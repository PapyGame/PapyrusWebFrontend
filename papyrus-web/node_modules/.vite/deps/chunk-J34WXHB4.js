import {
  require_shim
} from "./chunk-VJSPU622.js";
import {
  State,
  interpret
} from "./chunk-SRTTMZV5.js";
import {
  require_react
} from "./chunk-QCWLDGW7.js";
import {
  __commonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// ../node_modules/use-subscription/cjs/use-subscription.development.js
var require_use_subscription_development = __commonJS({
  "../node_modules/use-subscription/cjs/use-subscription.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var shim = require_shim();
        function useSubscription2(_ref) {
          var getCurrentValue = _ref.getCurrentValue, subscribe = _ref.subscribe;
          return shim.useSyncExternalStore(subscribe, getCurrentValue);
        }
        exports.useSubscription = useSubscription2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// ../node_modules/use-subscription/index.js
var require_use_subscription = __commonJS({
  "../node_modules/use-subscription/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_subscription_development();
    }
  }
});

// ../node_modules/xstate/lib/_virtual/_tslib.js
var require_tslib = __commonJS({
  "../node_modules/xstate/lib/_virtual/_tslib.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__assign = function() {
      exports.__assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return exports.__assign.apply(this, arguments);
    };
    function __rest2(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    }
    function __values2(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read7(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    }
    function __spreadArray3(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    }
    exports.__read = __read7;
    exports.__rest = __rest2;
    exports.__spreadArray = __spreadArray3;
    exports.__values = __values2;
  }
});

// ../node_modules/xstate/lib/types.js
var require_types = __commonJS({
  "../node_modules/xstate/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ActionTypes = void 0;
    (function(ActionTypes) {
      ActionTypes["Start"] = "xstate.start";
      ActionTypes["Stop"] = "xstate.stop";
      ActionTypes["Raise"] = "xstate.raise";
      ActionTypes["Send"] = "xstate.send";
      ActionTypes["Cancel"] = "xstate.cancel";
      ActionTypes["NullEvent"] = "";
      ActionTypes["Assign"] = "xstate.assign";
      ActionTypes["After"] = "xstate.after";
      ActionTypes["DoneState"] = "done.state";
      ActionTypes["DoneInvoke"] = "done.invoke";
      ActionTypes["Log"] = "xstate.log";
      ActionTypes["Init"] = "xstate.init";
      ActionTypes["Invoke"] = "xstate.invoke";
      ActionTypes["ErrorExecution"] = "error.execution";
      ActionTypes["ErrorCommunication"] = "error.communication";
      ActionTypes["ErrorPlatform"] = "error.platform";
      ActionTypes["ErrorCustom"] = "xstate.error";
      ActionTypes["Update"] = "xstate.update";
      ActionTypes["Pure"] = "xstate.pure";
      ActionTypes["Choose"] = "xstate.choose";
    })(exports.ActionTypes || (exports.ActionTypes = {}));
    exports.SpecialTargets = void 0;
    (function(SpecialTargets) {
      SpecialTargets["Parent"] = "#_parent";
      SpecialTargets["Internal"] = "#_internal";
    })(exports.SpecialTargets || (exports.SpecialTargets = {}));
  }
});

// ../node_modules/xstate/lib/actionTypes.js
var require_actionTypes = __commonJS({
  "../node_modules/xstate/lib/actionTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var types = require_types();
    var start = types.ActionTypes.Start;
    var stop = types.ActionTypes.Stop;
    var raise = types.ActionTypes.Raise;
    var send = types.ActionTypes.Send;
    var cancel = types.ActionTypes.Cancel;
    var nullEvent = types.ActionTypes.NullEvent;
    var assign = types.ActionTypes.Assign;
    var after = types.ActionTypes.After;
    var doneState = types.ActionTypes.DoneState;
    var log = types.ActionTypes.Log;
    var init = types.ActionTypes.Init;
    var invoke = types.ActionTypes.Invoke;
    var errorExecution = types.ActionTypes.ErrorExecution;
    var errorPlatform = types.ActionTypes.ErrorPlatform;
    var error = types.ActionTypes.ErrorCustom;
    var update = types.ActionTypes.Update;
    var choose = types.ActionTypes.Choose;
    var pure = types.ActionTypes.Pure;
    exports.after = after;
    exports.assign = assign;
    exports.cancel = cancel;
    exports.choose = choose;
    exports.doneState = doneState;
    exports.error = error;
    exports.errorExecution = errorExecution;
    exports.errorPlatform = errorPlatform;
    exports.init = init;
    exports.invoke = invoke;
    exports.log = log;
    exports.nullEvent = nullEvent;
    exports.pure = pure;
    exports.raise = raise;
    exports.send = send;
    exports.start = start;
    exports.stop = stop;
    exports.update = update;
  }
});

// ../node_modules/xstate/lib/constants.js
var require_constants = __commonJS({
  "../node_modules/xstate/lib/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var STATE_DELIMITER = ".";
    var EMPTY_ACTIVITY_MAP = {};
    var DEFAULT_GUARD_TYPE = "xstate.guard";
    var TARGETLESS_KEY = "";
    exports.DEFAULT_GUARD_TYPE = DEFAULT_GUARD_TYPE;
    exports.EMPTY_ACTIVITY_MAP = EMPTY_ACTIVITY_MAP;
    exports.STATE_DELIMITER = STATE_DELIMITER;
    exports.TARGETLESS_KEY = TARGETLESS_KEY;
  }
});

// ../node_modules/xstate/lib/environment.js
var require_environment = __commonJS({
  "../node_modules/xstate/lib/environment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var IS_PRODUCTION = false;
    exports.IS_PRODUCTION = IS_PRODUCTION;
  }
});

// ../node_modules/xstate/lib/utils.js
var require_utils = __commonJS({
  "../node_modules/xstate/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _tslib = require_tslib();
    var constants = require_constants();
    var environment = require_environment();
    var _a;
    function keys(value) {
      return Object.keys(value);
    }
    function matchesState(parentStateId, childStateId, delimiter) {
      if (delimiter === void 0) {
        delimiter = constants.STATE_DELIMITER;
      }
      var parentStateValue = toStateValue(parentStateId, delimiter);
      var childStateValue = toStateValue(childStateId, delimiter);
      if (isString(childStateValue)) {
        if (isString(parentStateValue)) {
          return childStateValue === parentStateValue;
        }
        return false;
      }
      if (isString(parentStateValue)) {
        return parentStateValue in childStateValue;
      }
      return Object.keys(parentStateValue).every(function(key) {
        if (!(key in childStateValue)) {
          return false;
        }
        return matchesState(parentStateValue[key], childStateValue[key]);
      });
    }
    function getEventType(event) {
      try {
        return isString(event) || typeof event === "number" ? "".concat(event) : event.type;
      } catch (e) {
        throw new Error("Events must be strings or objects with a string event.type property.");
      }
    }
    function getActionType(action) {
      try {
        return isString(action) || typeof action === "number" ? "".concat(action) : isFunction(action) ? action.name : action.type;
      } catch (e) {
        throw new Error("Actions must be strings or objects with a string action.type property.");
      }
    }
    function toStatePath(stateId, delimiter) {
      try {
        if (isArray(stateId)) {
          return stateId;
        }
        return stateId.toString().split(delimiter);
      } catch (e) {
        throw new Error("'".concat(stateId, "' is not a valid state path."));
      }
    }
    function isStateLike(state) {
      return typeof state === "object" && "value" in state && "context" in state && "event" in state && "_event" in state;
    }
    function toStateValue(stateValue, delimiter) {
      if (isStateLike(stateValue)) {
        return stateValue.value;
      }
      if (isArray(stateValue)) {
        return pathToStateValue(stateValue);
      }
      if (typeof stateValue !== "string") {
        return stateValue;
      }
      var statePath = toStatePath(stateValue, delimiter);
      return pathToStateValue(statePath);
    }
    function pathToStateValue(statePath) {
      if (statePath.length === 1) {
        return statePath[0];
      }
      var value = {};
      var marker = value;
      for (var i = 0; i < statePath.length - 1; i++) {
        if (i === statePath.length - 2) {
          marker[statePath[i]] = statePath[i + 1];
        } else {
          marker[statePath[i]] = {};
          marker = marker[statePath[i]];
        }
      }
      return value;
    }
    function mapValues(collection, iteratee) {
      var result = {};
      var collectionKeys = Object.keys(collection);
      for (var i = 0; i < collectionKeys.length; i++) {
        var key = collectionKeys[i];
        result[key] = iteratee(collection[key], key, collection, i);
      }
      return result;
    }
    function mapFilterValues(collection, iteratee, predicate) {
      var e_1, _a2;
      var result = {};
      try {
        for (var _b = _tslib.__values(Object.keys(collection)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var key = _c.value;
          var item = collection[key];
          if (!predicate(item)) {
            continue;
          }
          result[key] = iteratee(item, key, collection);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return result;
    }
    var path = function(props) {
      return function(object) {
        var e_2, _a2;
        var result = object;
        try {
          for (var props_1 = _tslib.__values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
            var prop = props_1_1.value;
            result = result[prop];
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (props_1_1 && !props_1_1.done && (_a2 = props_1.return))
              _a2.call(props_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
        return result;
      };
    };
    function nestedPath(props, accessorProp) {
      return function(object) {
        var e_3, _a2;
        var result = object;
        try {
          for (var props_2 = _tslib.__values(props), props_2_1 = props_2.next(); !props_2_1.done; props_2_1 = props_2.next()) {
            var prop = props_2_1.value;
            result = result[accessorProp][prop];
          }
        } catch (e_3_1) {
          e_3 = {
            error: e_3_1
          };
        } finally {
          try {
            if (props_2_1 && !props_2_1.done && (_a2 = props_2.return))
              _a2.call(props_2);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        return result;
      };
    }
    function toStatePaths(stateValue) {
      if (!stateValue) {
        return [[]];
      }
      if (isString(stateValue)) {
        return [[stateValue]];
      }
      var result = flatten(Object.keys(stateValue).map(function(key) {
        var subStateValue = stateValue[key];
        if (typeof subStateValue !== "string" && (!subStateValue || !Object.keys(subStateValue).length)) {
          return [[key]];
        }
        return toStatePaths(stateValue[key]).map(function(subPath) {
          return [key].concat(subPath);
        });
      }));
      return result;
    }
    function pathsToStateValue(paths) {
      var e_4, _a2;
      var result = {};
      if (paths && paths.length === 1 && paths[0].length === 1) {
        return paths[0][0];
      }
      try {
        for (var paths_1 = _tslib.__values(paths), paths_1_1 = paths_1.next(); !paths_1_1.done; paths_1_1 = paths_1.next()) {
          var currentPath = paths_1_1.value;
          var marker = result;
          for (var i = 0; i < currentPath.length; i++) {
            var subPath = currentPath[i];
            if (i === currentPath.length - 2) {
              marker[subPath] = currentPath[i + 1];
              break;
            }
            marker[subPath] = marker[subPath] || {};
            marker = marker[subPath];
          }
        }
      } catch (e_4_1) {
        e_4 = {
          error: e_4_1
        };
      } finally {
        try {
          if (paths_1_1 && !paths_1_1.done && (_a2 = paths_1.return))
            _a2.call(paths_1);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
      return result;
    }
    function flatten(array) {
      var _a2;
      return (_a2 = []).concat.apply(_a2, _tslib.__spreadArray([], _tslib.__read(array), false));
    }
    function toArrayStrict(value) {
      if (isArray(value)) {
        return value;
      }
      return [value];
    }
    function toArray(value) {
      if (value === void 0) {
        return [];
      }
      return toArrayStrict(value);
    }
    function mapContext(mapper, context, _event) {
      var e_5, _a2;
      if (isFunction(mapper)) {
        return mapper(context, _event.data);
      }
      var result = {};
      try {
        for (var _b = _tslib.__values(Object.keys(mapper)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var key = _c.value;
          var subMapper = mapper[key];
          if (isFunction(subMapper)) {
            result[key] = subMapper(context, _event.data);
          } else {
            result[key] = subMapper;
          }
        }
      } catch (e_5_1) {
        e_5 = {
          error: e_5_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_5)
            throw e_5.error;
        }
      }
      return result;
    }
    function isBuiltInEvent(eventType) {
      return /^(done|error)\./.test(eventType);
    }
    function isPromiseLike(value) {
      if (value instanceof Promise) {
        return true;
      }
      if (value !== null && (isFunction(value) || typeof value === "object") && isFunction(value.then)) {
        return true;
      }
      return false;
    }
    function isBehavior(value) {
      return value !== null && typeof value === "object" && "transition" in value && typeof value.transition === "function";
    }
    function partition2(items, predicate) {
      var e_6, _a2;
      var _b = _tslib.__read([[], []], 2), truthy = _b[0], falsy = _b[1];
      try {
        for (var items_1 = _tslib.__values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
          var item = items_1_1.value;
          if (predicate(item)) {
            truthy.push(item);
          } else {
            falsy.push(item);
          }
        }
      } catch (e_6_1) {
        e_6 = {
          error: e_6_1
        };
      } finally {
        try {
          if (items_1_1 && !items_1_1.done && (_a2 = items_1.return))
            _a2.call(items_1);
        } finally {
          if (e_6)
            throw e_6.error;
        }
      }
      return [truthy, falsy];
    }
    function updateHistoryStates(hist, stateValue) {
      return mapValues(hist.states, function(subHist, key) {
        if (!subHist) {
          return void 0;
        }
        var subStateValue = (isString(stateValue) ? void 0 : stateValue[key]) || (subHist ? subHist.current : void 0);
        if (!subStateValue) {
          return void 0;
        }
        return {
          current: subStateValue,
          states: updateHistoryStates(subHist, subStateValue)
        };
      });
    }
    function updateHistoryValue(hist, stateValue) {
      return {
        current: stateValue,
        states: updateHistoryStates(hist, stateValue)
      };
    }
    function updateContext(context, _event, assignActions, state) {
      if (!environment.IS_PRODUCTION) {
        exports.warn(!!context, "Attempting to update undefined context");
      }
      var updatedContext = context ? assignActions.reduce(function(acc, assignAction) {
        var e_7, _a2;
        var assignment = assignAction.assignment;
        var meta = {
          state,
          action: assignAction,
          _event
        };
        var partialUpdate = {};
        if (isFunction(assignment)) {
          partialUpdate = assignment(acc, _event.data, meta);
        } else {
          try {
            for (var _b = _tslib.__values(Object.keys(assignment)), _c = _b.next(); !_c.done; _c = _b.next()) {
              var key = _c.value;
              var propAssignment = assignment[key];
              partialUpdate[key] = isFunction(propAssignment) ? propAssignment(acc, _event.data, meta) : propAssignment;
            }
          } catch (e_7_1) {
            e_7 = {
              error: e_7_1
            };
          } finally {
            try {
              if (_c && !_c.done && (_a2 = _b.return))
                _a2.call(_b);
            } finally {
              if (e_7)
                throw e_7.error;
            }
          }
        }
        return Object.assign({}, acc, partialUpdate);
      }, context) : context;
      return updatedContext;
    }
    exports.warn = function() {
    };
    if (!environment.IS_PRODUCTION) {
      exports.warn = function(condition, message) {
        var error = condition instanceof Error ? condition : void 0;
        if (!error && condition) {
          return;
        }
        if (console !== void 0) {
          var args = ["Warning: ".concat(message)];
          if (error) {
            args.push(error);
          }
          console.warn.apply(console, args);
        }
      };
    }
    function isArray(value) {
      return Array.isArray(value);
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isString(value) {
      return typeof value === "string";
    }
    function toGuard(condition, guardMap) {
      if (!condition) {
        return void 0;
      }
      if (isString(condition)) {
        return {
          type: constants.DEFAULT_GUARD_TYPE,
          name: condition,
          predicate: guardMap ? guardMap[condition] : void 0
        };
      }
      if (isFunction(condition)) {
        return {
          type: constants.DEFAULT_GUARD_TYPE,
          name: condition.name,
          predicate: condition
        };
      }
      return condition;
    }
    function isObservable(value) {
      try {
        return "subscribe" in value && isFunction(value.subscribe);
      } catch (e) {
        return false;
      }
    }
    var symbolObservable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
    var interopSymbols = (_a = {}, _a[symbolObservable] = function() {
      return this;
    }, _a[Symbol.observable] = function() {
      return this;
    }, _a);
    function isMachine(value) {
      return !!value && "__xstatenode" in value;
    }
    function isActor(value) {
      return !!value && typeof value.send === "function";
    }
    var uniqueId = function() {
      var currentId = 0;
      return function() {
        currentId++;
        return currentId.toString(16);
      };
    }();
    function toEventObject(event, payload) {
      if (isString(event) || typeof event === "number") {
        return _tslib.__assign({
          type: event
        }, payload);
      }
      return event;
    }
    function toSCXMLEvent(event, scxmlEvent) {
      if (!isString(event) && "$$type" in event && event.$$type === "scxml") {
        return event;
      }
      var eventObject = toEventObject(event);
      return _tslib.__assign({
        name: eventObject.type,
        data: eventObject,
        $$type: "scxml",
        type: "external"
      }, scxmlEvent);
    }
    function toTransitionConfigArray(event, configLike) {
      var transitions = toArrayStrict(configLike).map(function(transitionLike) {
        if (typeof transitionLike === "undefined" || typeof transitionLike === "string" || isMachine(transitionLike)) {
          return {
            target: transitionLike,
            event
          };
        }
        return _tslib.__assign(_tslib.__assign({}, transitionLike), {
          event
        });
      });
      return transitions;
    }
    function normalizeTarget(target) {
      if (target === void 0 || target === constants.TARGETLESS_KEY) {
        return void 0;
      }
      return toArray(target);
    }
    function reportUnhandledExceptionOnInvocation(originalError, currentError, id) {
      if (!environment.IS_PRODUCTION) {
        var originalStackTrace = originalError.stack ? " Stacktrace was '".concat(originalError.stack, "'") : "";
        if (originalError === currentError) {
          console.error("Missing onError handler for invocation '".concat(id, "', error was '").concat(originalError, "'.").concat(originalStackTrace));
        } else {
          var stackTrace = currentError.stack ? " Stacktrace was '".concat(currentError.stack, "'") : "";
          console.error("Missing onError handler and/or unhandled exception/promise rejection for invocation '".concat(id, "'. ") + "Original error: '".concat(originalError, "'. ").concat(originalStackTrace, " Current error is '").concat(currentError, "'.").concat(stackTrace));
        }
      }
    }
    function evaluateGuard(machine, guard, context, _event, state) {
      var guards = machine.options.guards;
      var guardMeta = {
        state,
        cond: guard,
        _event
      };
      if (guard.type === constants.DEFAULT_GUARD_TYPE) {
        return ((guards === null || guards === void 0 ? void 0 : guards[guard.name]) || guard.predicate)(context, _event.data, guardMeta);
      }
      var condFn = guards === null || guards === void 0 ? void 0 : guards[guard.type];
      if (!condFn) {
        throw new Error("Guard '".concat(guard.type, "' is not implemented on machine '").concat(machine.id, "'."));
      }
      return condFn(context, _event.data, guardMeta);
    }
    function toInvokeSource(src) {
      if (typeof src === "string") {
        return {
          type: src
        };
      }
      return src;
    }
    function toObserver2(nextHandler, errorHandler, completionHandler) {
      if (typeof nextHandler === "object") {
        return nextHandler;
      }
      var noop2 = function() {
        return void 0;
      };
      return {
        next: nextHandler,
        error: errorHandler || noop2,
        complete: completionHandler || noop2
      };
    }
    function createInvokeId(stateNodeId, index2) {
      return "".concat(stateNodeId, ":invocation[").concat(index2, "]");
    }
    exports.createInvokeId = createInvokeId;
    exports.evaluateGuard = evaluateGuard;
    exports.flatten = flatten;
    exports.getActionType = getActionType;
    exports.getEventType = getEventType;
    exports.interopSymbols = interopSymbols;
    exports.isActor = isActor;
    exports.isArray = isArray;
    exports.isBehavior = isBehavior;
    exports.isBuiltInEvent = isBuiltInEvent;
    exports.isFunction = isFunction;
    exports.isMachine = isMachine;
    exports.isObservable = isObservable;
    exports.isPromiseLike = isPromiseLike;
    exports.isStateLike = isStateLike;
    exports.isString = isString;
    exports.keys = keys;
    exports.mapContext = mapContext;
    exports.mapFilterValues = mapFilterValues;
    exports.mapValues = mapValues;
    exports.matchesState = matchesState;
    exports.nestedPath = nestedPath;
    exports.normalizeTarget = normalizeTarget;
    exports.partition = partition2;
    exports.path = path;
    exports.pathToStateValue = pathToStateValue;
    exports.pathsToStateValue = pathsToStateValue;
    exports.reportUnhandledExceptionOnInvocation = reportUnhandledExceptionOnInvocation;
    exports.symbolObservable = symbolObservable;
    exports.toArray = toArray;
    exports.toArrayStrict = toArrayStrict;
    exports.toEventObject = toEventObject;
    exports.toGuard = toGuard;
    exports.toInvokeSource = toInvokeSource;
    exports.toObserver = toObserver2;
    exports.toSCXMLEvent = toSCXMLEvent;
    exports.toStatePath = toStatePath;
    exports.toStatePaths = toStatePaths;
    exports.toStateValue = toStateValue;
    exports.toTransitionConfigArray = toTransitionConfigArray;
    exports.uniqueId = uniqueId;
    exports.updateContext = updateContext;
    exports.updateHistoryStates = updateHistoryStates;
    exports.updateHistoryValue = updateHistoryValue;
  }
});

// ../node_modules/xstate/lib/actions.js
var require_actions = __commonJS({
  "../node_modules/xstate/lib/actions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _tslib = require_tslib();
    var types = require_types();
    var actionTypes = require_actionTypes();
    var utils = require_utils();
    var environment = require_environment();
    var initEvent = utils.toSCXMLEvent({
      type: actionTypes.init
    });
    function getActionFunction(actionType, actionFunctionMap) {
      return actionFunctionMap ? actionFunctionMap[actionType] || void 0 : void 0;
    }
    function toActionObject(action, actionFunctionMap) {
      var actionObject;
      if (utils.isString(action) || typeof action === "number") {
        var exec = getActionFunction(action, actionFunctionMap);
        if (utils.isFunction(exec)) {
          actionObject = {
            type: action,
            exec
          };
        } else if (exec) {
          actionObject = exec;
        } else {
          actionObject = {
            type: action,
            exec: void 0
          };
        }
      } else if (utils.isFunction(action)) {
        actionObject = {
          // Convert action to string if unnamed
          type: action.name || action.toString(),
          exec: action
        };
      } else {
        var exec = getActionFunction(action.type, actionFunctionMap);
        if (utils.isFunction(exec)) {
          actionObject = _tslib.__assign(_tslib.__assign({}, action), {
            exec
          });
        } else if (exec) {
          var actionType = exec.type || action.type;
          actionObject = _tslib.__assign(_tslib.__assign(_tslib.__assign({}, exec), action), {
            type: actionType
          });
        } else {
          actionObject = action;
        }
      }
      return actionObject;
    }
    var toActionObjects = function(action, actionFunctionMap) {
      if (!action) {
        return [];
      }
      var actions = utils.isArray(action) ? action : [action];
      return actions.map(function(subAction) {
        return toActionObject(subAction, actionFunctionMap);
      });
    };
    function toActivityDefinition(action) {
      var actionObject = toActionObject(action);
      return _tslib.__assign(_tslib.__assign({
        id: utils.isString(action) ? action : actionObject.id
      }, actionObject), {
        type: actionObject.type
      });
    }
    function raise(event) {
      if (!utils.isString(event)) {
        return send(event, {
          to: types.SpecialTargets.Internal
        });
      }
      return {
        type: actionTypes.raise,
        event
      };
    }
    function resolveRaise(action) {
      return {
        type: actionTypes.raise,
        _event: utils.toSCXMLEvent(action.event)
      };
    }
    function send(event, options) {
      return {
        to: options ? options.to : void 0,
        type: actionTypes.send,
        event: utils.isFunction(event) ? event : utils.toEventObject(event),
        delay: options ? options.delay : void 0,
        id: options && options.id !== void 0 ? options.id : utils.isFunction(event) ? event.name : utils.getEventType(event)
      };
    }
    function resolveSend(action, ctx, _event, delaysMap) {
      var meta = {
        _event
      };
      var resolvedEvent = utils.toSCXMLEvent(utils.isFunction(action.event) ? action.event(ctx, _event.data, meta) : action.event);
      var resolvedDelay;
      if (utils.isString(action.delay)) {
        var configDelay = delaysMap && delaysMap[action.delay];
        resolvedDelay = utils.isFunction(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;
      } else {
        resolvedDelay = utils.isFunction(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;
      }
      var resolvedTarget = utils.isFunction(action.to) ? action.to(ctx, _event.data, meta) : action.to;
      return _tslib.__assign(_tslib.__assign({}, action), {
        to: resolvedTarget,
        _event: resolvedEvent,
        event: resolvedEvent.data,
        delay: resolvedDelay
      });
    }
    function sendParent(event, options) {
      return send(event, _tslib.__assign(_tslib.__assign({}, options), {
        to: types.SpecialTargets.Parent
      }));
    }
    function sendTo(actor, event, options) {
      return send(event, _tslib.__assign(_tslib.__assign({}, options), {
        to: actor
      }));
    }
    function sendUpdate() {
      return sendParent(actionTypes.update);
    }
    function respond(event, options) {
      return send(event, _tslib.__assign(_tslib.__assign({}, options), {
        to: function(_, __, _a) {
          var _event = _a._event;
          return _event.origin;
        }
      }));
    }
    var defaultLogExpr = function(context, event) {
      return {
        context,
        event
      };
    };
    function log(expr, label) {
      if (expr === void 0) {
        expr = defaultLogExpr;
      }
      return {
        type: actionTypes.log,
        label,
        expr
      };
    }
    var resolveLog = function(action, ctx, _event) {
      return _tslib.__assign(_tslib.__assign({}, action), {
        value: utils.isString(action.expr) ? action.expr : action.expr(ctx, _event.data, {
          _event
        })
      });
    };
    var cancel = function(sendId) {
      return {
        type: actionTypes.cancel,
        sendId
      };
    };
    function start(activity) {
      var activityDef = toActivityDefinition(activity);
      return {
        type: types.ActionTypes.Start,
        activity: activityDef,
        exec: void 0
      };
    }
    function stop(actorRef) {
      var activity = utils.isFunction(actorRef) ? actorRef : toActivityDefinition(actorRef);
      return {
        type: types.ActionTypes.Stop,
        activity,
        exec: void 0
      };
    }
    function resolveStop(action, context, _event) {
      var actorRefOrString = utils.isFunction(action.activity) ? action.activity(context, _event.data) : action.activity;
      var resolvedActorRef = typeof actorRefOrString === "string" ? {
        id: actorRefOrString
      } : actorRefOrString;
      var actionObject = {
        type: types.ActionTypes.Stop,
        activity: resolvedActorRef
      };
      return actionObject;
    }
    var assign = function(assignment) {
      return {
        type: actionTypes.assign,
        assignment
      };
    };
    function isActionObject(action) {
      return typeof action === "object" && "type" in action;
    }
    function after(delayRef, id) {
      var idSuffix = id ? "#".concat(id) : "";
      return "".concat(types.ActionTypes.After, "(").concat(delayRef, ")").concat(idSuffix);
    }
    function done(id, data) {
      var type = "".concat(types.ActionTypes.DoneState, ".").concat(id);
      var eventObject = {
        type,
        data
      };
      eventObject.toString = function() {
        return type;
      };
      return eventObject;
    }
    function doneInvoke(id, data) {
      var type = "".concat(types.ActionTypes.DoneInvoke, ".").concat(id);
      var eventObject = {
        type,
        data
      };
      eventObject.toString = function() {
        return type;
      };
      return eventObject;
    }
    function error(id, data) {
      var type = "".concat(types.ActionTypes.ErrorPlatform, ".").concat(id);
      var eventObject = {
        type,
        data
      };
      eventObject.toString = function() {
        return type;
      };
      return eventObject;
    }
    function pure(getActions) {
      return {
        type: types.ActionTypes.Pure,
        get: getActions
      };
    }
    function forwardTo(target, options) {
      return send(function(_, event) {
        return event;
      }, _tslib.__assign(_tslib.__assign({}, options), {
        to: target
      }));
    }
    function escalate(errorData, options) {
      return sendParent(function(context, event, meta) {
        return {
          type: actionTypes.error,
          data: utils.isFunction(errorData) ? errorData(context, event, meta) : errorData
        };
      }, _tslib.__assign(_tslib.__assign({}, options), {
        to: types.SpecialTargets.Parent
      }));
    }
    function choose(conds) {
      return {
        type: types.ActionTypes.Choose,
        conds
      };
    }
    function resolveActions(machine, currentState, currentContext, _event, actions, preserveActionOrder) {
      if (preserveActionOrder === void 0) {
        preserveActionOrder = false;
      }
      var _a = _tslib.__read(preserveActionOrder ? [[], actions] : utils.partition(actions, function(action) {
        return action.type === actionTypes.assign;
      }), 2), assignActions = _a[0], otherActions = _a[1];
      var updatedContext = assignActions.length ? utils.updateContext(currentContext, _event, assignActions, currentState) : currentContext;
      var preservedContexts = preserveActionOrder ? [currentContext] : void 0;
      var resolvedActions = utils.flatten(otherActions.map(function(actionObject) {
        var _a2;
        switch (actionObject.type) {
          case actionTypes.raise:
            return resolveRaise(actionObject);
          case actionTypes.send:
            var sendAction = resolveSend(actionObject, updatedContext, _event, machine.options.delays);
            if (!environment.IS_PRODUCTION) {
              utils.warn(
                !utils.isString(actionObject.delay) || typeof sendAction.delay === "number",
                // tslint:disable-next-line:max-line-length
                "No delay reference for delay expression '".concat(actionObject.delay, "' was found on machine '").concat(machine.id, "'")
              );
            }
            return sendAction;
          case actionTypes.log:
            return resolveLog(actionObject, updatedContext, _event);
          case actionTypes.choose: {
            var chooseAction = actionObject;
            var matchedActions = (_a2 = chooseAction.conds.find(function(condition) {
              var guard = utils.toGuard(condition.cond, machine.options.guards);
              return !guard || utils.evaluateGuard(machine, guard, updatedContext, _event, currentState);
            })) === null || _a2 === void 0 ? void 0 : _a2.actions;
            if (!matchedActions) {
              return [];
            }
            var _b = _tslib.__read(resolveActions(machine, currentState, updatedContext, _event, toActionObjects(utils.toArray(matchedActions), machine.options.actions), preserveActionOrder), 2), resolvedActionsFromChoose = _b[0], resolvedContextFromChoose = _b[1];
            updatedContext = resolvedContextFromChoose;
            preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);
            return resolvedActionsFromChoose;
          }
          case actionTypes.pure: {
            var matchedActions = actionObject.get(updatedContext, _event.data);
            if (!matchedActions) {
              return [];
            }
            var _c = _tslib.__read(resolveActions(machine, currentState, updatedContext, _event, toActionObjects(utils.toArray(matchedActions), machine.options.actions), preserveActionOrder), 2), resolvedActionsFromPure = _c[0], resolvedContext = _c[1];
            updatedContext = resolvedContext;
            preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);
            return resolvedActionsFromPure;
          }
          case actionTypes.stop: {
            return resolveStop(actionObject, updatedContext, _event);
          }
          case actionTypes.assign: {
            updatedContext = utils.updateContext(updatedContext, _event, [actionObject], currentState);
            preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);
            break;
          }
          default:
            var resolvedActionObject = toActionObject(actionObject, machine.options.actions);
            var exec_1 = resolvedActionObject.exec;
            if (exec_1 && preservedContexts) {
              var contextIndex_1 = preservedContexts.length - 1;
              resolvedActionObject = _tslib.__assign(_tslib.__assign({}, resolvedActionObject), {
                exec: function(_ctx) {
                  var args = [];
                  for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                  }
                  exec_1.apply(void 0, _tslib.__spreadArray([preservedContexts[contextIndex_1]], _tslib.__read(args), false));
                }
              });
            }
            return resolvedActionObject;
        }
      }).filter(function(a) {
        return !!a;
      }));
      return [resolvedActions, updatedContext];
    }
    exports.actionTypes = actionTypes;
    exports.after = after;
    exports.assign = assign;
    exports.cancel = cancel;
    exports.choose = choose;
    exports.done = done;
    exports.doneInvoke = doneInvoke;
    exports.error = error;
    exports.escalate = escalate;
    exports.forwardTo = forwardTo;
    exports.getActionFunction = getActionFunction;
    exports.initEvent = initEvent;
    exports.isActionObject = isActionObject;
    exports.log = log;
    exports.pure = pure;
    exports.raise = raise;
    exports.resolveActions = resolveActions;
    exports.resolveLog = resolveLog;
    exports.resolveRaise = resolveRaise;
    exports.resolveSend = resolveSend;
    exports.resolveStop = resolveStop;
    exports.respond = respond;
    exports.send = send;
    exports.sendParent = sendParent;
    exports.sendTo = sendTo;
    exports.sendUpdate = sendUpdate;
    exports.start = start;
    exports.stop = stop;
    exports.toActionObject = toActionObject;
    exports.toActionObjects = toActionObjects;
    exports.toActivityDefinition = toActivityDefinition;
  }
});

// ../node_modules/xstate/lib/serviceScope.js
var require_serviceScope = __commonJS({
  "../node_modules/xstate/lib/serviceScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var serviceStack = [];
    var provide = function(service, fn) {
      serviceStack.push(service);
      var result = fn(service);
      serviceStack.pop();
      return result;
    };
    var consume = function(fn) {
      return fn(serviceStack[serviceStack.length - 1]);
    };
    exports.consume = consume;
    exports.provide = provide;
  }
});

// ../node_modules/xstate/lib/Actor.js
var require_Actor = __commonJS({
  "../node_modules/xstate/lib/Actor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _tslib = require_tslib();
    var utils = require_utils();
    var serviceScope = require_serviceScope();
    function createNullActor(id) {
      var _a;
      return _a = {
        id,
        send: function() {
          return void 0;
        },
        subscribe: function() {
          return {
            unsubscribe: function() {
              return void 0;
            }
          };
        },
        getSnapshot: function() {
          return void 0;
        },
        toJSON: function() {
          return {
            id
          };
        }
      }, _a[utils.symbolObservable] = function() {
        return this;
      }, _a;
    }
    function createInvocableActor(invokeDefinition, machine, context, _event) {
      var _a;
      var invokeSrc = utils.toInvokeSource(invokeDefinition.src);
      var serviceCreator = (_a = machine === null || machine === void 0 ? void 0 : machine.options.services) === null || _a === void 0 ? void 0 : _a[invokeSrc.type];
      var resolvedData = invokeDefinition.data ? utils.mapContext(invokeDefinition.data, context, _event) : void 0;
      var tempActor = serviceCreator ? createDeferredActor(serviceCreator, invokeDefinition.id, resolvedData) : createNullActor(invokeDefinition.id);
      tempActor.meta = invokeDefinition;
      return tempActor;
    }
    function createDeferredActor(entity, id, data) {
      var tempActor = createNullActor(id);
      tempActor.deferred = true;
      if (utils.isMachine(entity)) {
        var initialState_1 = tempActor.state = serviceScope.provide(void 0, function() {
          return (data ? entity.withContext(data) : entity).initialState;
        });
        tempActor.getSnapshot = function() {
          return initialState_1;
        };
      }
      return tempActor;
    }
    function isActor(item) {
      try {
        return typeof item.send === "function";
      } catch (e) {
        return false;
      }
    }
    function isSpawnedActor(item) {
      return isActor(item) && "id" in item;
    }
    function toActorRef(actorRefLike) {
      var _a;
      return _tslib.__assign((_a = {
        subscribe: function() {
          return {
            unsubscribe: function() {
              return void 0;
            }
          };
        },
        id: "anonymous",
        getSnapshot: function() {
          return void 0;
        }
      }, _a[utils.symbolObservable] = function() {
        return this;
      }, _a), actorRefLike);
    }
    exports.createDeferredActor = createDeferredActor;
    exports.createInvocableActor = createInvocableActor;
    exports.createNullActor = createNullActor;
    exports.isActor = isActor;
    exports.isSpawnedActor = isSpawnedActor;
    exports.toActorRef = toActorRef;
  }
});

// ../node_modules/xstate/lib/behaviors.js
var require_behaviors = __commonJS({
  "../node_modules/xstate/lib/behaviors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var actions = require_actions();
    var Actor = require_Actor();
    var utils = require_utils();
    function fromReducer(transition, initialState) {
      return {
        transition,
        initialState
      };
    }
    function fromPromise(promiseFn) {
      var initialState = {
        error: void 0,
        data: void 0,
        status: "pending"
      };
      return {
        transition: function(state, event, _a) {
          var parent = _a.parent, id = _a.id, observers = _a.observers;
          switch (event.type) {
            case "fulfill":
              parent === null || parent === void 0 ? void 0 : parent.send(actions.doneInvoke(id, event.data));
              return {
                error: void 0,
                data: event.data,
                status: "fulfilled"
              };
            case "reject":
              parent === null || parent === void 0 ? void 0 : parent.send(actions.error(id, event.error));
              observers.forEach(function(observer) {
                observer.error(event.error);
              });
              return {
                error: event.error,
                data: void 0,
                status: "rejected"
              };
            default:
              return state;
          }
        },
        initialState,
        start: function(_a) {
          var self = _a.self;
          promiseFn().then(function(data) {
            self.send({
              type: "fulfill",
              data
            });
          }, function(reason) {
            self.send({
              type: "reject",
              error: reason
            });
          });
          return initialState;
        }
      };
    }
    function spawnBehavior2(behavior, options) {
      if (options === void 0) {
        options = {};
      }
      var state = behavior.initialState;
      var observers = /* @__PURE__ */ new Set();
      var mailbox = [];
      var flushing = false;
      var flush = function() {
        if (flushing) {
          return;
        }
        flushing = true;
        while (mailbox.length > 0) {
          var event_1 = mailbox.shift();
          state = behavior.transition(state, event_1, actorCtx);
          observers.forEach(function(observer) {
            return observer.next(state);
          });
        }
        flushing = false;
      };
      var actor = Actor.toActorRef({
        id: options.id,
        send: function(event) {
          mailbox.push(event);
          flush();
        },
        getSnapshot: function() {
          return state;
        },
        subscribe: function(next, handleError, complete) {
          var observer = utils.toObserver(next, handleError, complete);
          observers.add(observer);
          observer.next(state);
          return {
            unsubscribe: function() {
              observers.delete(observer);
            }
          };
        }
      });
      var actorCtx = {
        parent: options.parent,
        self: actor,
        id: options.id || "anonymous",
        observers
      };
      state = behavior.start ? behavior.start(actorCtx) : state;
      return actor;
    }
    exports.fromPromise = fromPromise;
    exports.fromReducer = fromReducer;
    exports.spawnBehavior = spawnBehavior2;
  }
});

// ../node_modules/@xstate/react/es/useMachine.js
var import_react4 = __toESM(require_react());

// ../node_modules/@xstate/react/es/types.js
var ReactEffectType;
(function(ReactEffectType2) {
  ReactEffectType2[ReactEffectType2["Effect"] = 1] = "Effect";
  ReactEffectType2[ReactEffectType2["LayoutEffect"] = 2] = "LayoutEffect";
})(ReactEffectType || (ReactEffectType = {}));

// ../node_modules/@xstate/react/es/useInterpret.js
var import_react3 = __toESM(require_react());

// ../node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js
var import_react = __toESM(require_react());
var index = import_react.useLayoutEffect;
var use_isomorphic_layout_effect_browser_esm_default = index;

// ../node_modules/@xstate/react/es/useConstant.js
var React = __toESM(require_react());
function useConstant(fn) {
  var ref = React.useRef();
  if (!ref.current) {
    ref.current = { v: fn() };
  }
  return ref.current.v;
}

// ../node_modules/@xstate/react/es/useReactEffectActions.js
var import_react2 = __toESM(require_react());

// ../node_modules/@xstate/react/es/utils.js
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __values = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function partition(items, predicate) {
  var e_1, _a;
  var _b = __read([[], []], 2), truthy = _b[0], falsy = _b[1];
  try {
    for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
      var item = items_1_1.value;
      if (predicate(item)) {
        truthy.push(item);
      } else {
        falsy.push(item);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (items_1_1 && !items_1_1.done && (_a = items_1.return))
        _a.call(items_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return [truthy, falsy];
}

// ../node_modules/@xstate/react/es/useReactEffectActions.js
var __read2 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function executeEffect(action, state) {
  var exec = action.exec;
  var originalExec = exec(state.context, state._event.data, {
    action,
    state,
    _event: state._event
  });
  originalExec();
}
function useReactEffectActions(service) {
  var effectActionsRef = (0, import_react2.useRef)([]);
  var layoutEffectActionsRef = (0, import_react2.useRef)([]);
  use_isomorphic_layout_effect_browser_esm_default(function() {
    var sub = service.subscribe(function(currentState) {
      var _a, _b;
      if (currentState.actions.length) {
        var reactEffectActions = currentState.actions.filter(function(action) {
          return typeof action.exec === "function" && "__effect" in action.exec;
        });
        var _c = __read2(partition(reactEffectActions, function(action) {
          return action.exec.__effect === ReactEffectType.Effect;
        }), 2), effectActions = _c[0], layoutEffectActions = _c[1];
        (_a = effectActionsRef.current).push.apply(_a, __spreadArray([], __read2(effectActions.map(function(effectAction) {
          return [effectAction, currentState];
        })), false));
        (_b = layoutEffectActionsRef.current).push.apply(_b, __spreadArray([], __read2(layoutEffectActions.map(function(layoutEffectAction) {
          return [layoutEffectAction, currentState];
        })), false));
      }
    });
    return function() {
      sub.unsubscribe();
    };
  }, []);
  use_isomorphic_layout_effect_browser_esm_default(function() {
    while (layoutEffectActionsRef.current.length) {
      var _a = __read2(layoutEffectActionsRef.current.shift(), 2), layoutEffectAction = _a[0], effectState = _a[1];
      executeEffect(layoutEffectAction, effectState);
    }
  });
  (0, import_react2.useEffect)(function() {
    while (effectActionsRef.current.length) {
      var _a = __read2(effectActionsRef.current.shift(), 2), effectAction = _a[0], effectState = _a[1];
      executeEffect(effectAction, effectState);
    }
  });
}

// ../node_modules/@xstate/react/es/useInterpret.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var __read3 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function toObserver(nextHandler, errorHandler, completionHandler) {
  if (typeof nextHandler === "object") {
    return nextHandler;
  }
  var noop2 = function() {
    return void 0;
  };
  return {
    next: nextHandler,
    error: errorHandler || noop2,
    complete: completionHandler || noop2
  };
}
function useInterpret(getMachine, options, observerOrListener) {
  if (options === void 0) {
    options = {};
  }
  var machine = useConstant(function() {
    return typeof getMachine === "function" ? getMachine() : getMachine;
  });
  if (typeof getMachine !== "function") {
    var _a = __read3((0, import_react3.useState)(machine), 1), initialMachine = _a[0];
    if (getMachine !== initialMachine) {
      console.warn("Machine given to `useMachine` has changed between renders. This is not supported and might lead to unexpected results.\nPlease make sure that you pass the same Machine as argument each time.");
    }
  }
  var context = options.context, guards = options.guards, actions = options.actions, activities = options.activities, services = options.services, delays = options.delays, rehydratedState = options.state, interpreterOptions = __rest(options, ["context", "guards", "actions", "activities", "services", "delays", "state"]);
  var service = useConstant(function() {
    var machineConfig = {
      context,
      guards,
      actions,
      activities,
      services,
      delays
    };
    var machineWithConfig = machine.withConfig(machineConfig, function() {
      return __assign(__assign({}, machine.context), context);
    });
    return interpret(machineWithConfig, __assign({ deferEvents: true }, interpreterOptions));
  });
  use_isomorphic_layout_effect_browser_esm_default(function() {
    var sub;
    if (observerOrListener) {
      sub = service.subscribe(toObserver(observerOrListener));
    }
    return function() {
      sub === null || sub === void 0 ? void 0 : sub.unsubscribe();
    };
  }, [observerOrListener]);
  use_isomorphic_layout_effect_browser_esm_default(function() {
    service.start(rehydratedState ? State.create(rehydratedState) : void 0);
    return function() {
      service.stop();
    };
  }, []);
  use_isomorphic_layout_effect_browser_esm_default(function() {
    Object.assign(service.machine.options.actions, actions);
    Object.assign(service.machine.options.guards, guards);
    Object.assign(service.machine.options.activities, activities);
    Object.assign(service.machine.options.services, services);
    Object.assign(service.machine.options.delays, delays);
  }, [actions, guards, activities, services, delays]);
  useReactEffectActions(service);
  return service;
}

// ../node_modules/@xstate/react/es/useMachine.js
var __read4 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray2 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function createReactActionFunction(exec, tag) {
  var effectExec = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return function() {
      return exec.apply(void 0, __spreadArray2([], __read4(args), false));
    };
  };
  Object.defineProperties(effectExec, {
    name: { value: "effect:".concat(exec.name) },
    __effect: { value: tag }
  });
  return effectExec;
}
function asEffect(exec) {
  return createReactActionFunction(exec, ReactEffectType.Effect);
}
function asLayoutEffect(exec) {
  return createReactActionFunction(exec, ReactEffectType.LayoutEffect);
}
function useMachine(getMachine, options) {
  if (options === void 0) {
    options = {};
  }
  var listener = (0, import_react4.useCallback)(function(nextState) {
    var initialStateChanged = nextState.changed === void 0 && Object.keys(nextState.children).length;
    if (nextState.changed || initialStateChanged) {
      setState(nextState);
    }
  }, []);
  var service = useInterpret(getMachine, options, listener);
  var _a = __read4((0, import_react4.useState)(function() {
    var initialState = service.machine.initialState;
    return options.state ? State.create(options.state) : initialState;
  }), 2), state = _a[0], setState = _a[1];
  return [state, service.send, service];
}

// ../node_modules/@xstate/react/es/useActor.js
var import_react5 = __toESM(require_react());
var __read5 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function isActorWithState(actorRef) {
  return "state" in actorRef;
}
function isDeferredActor(actorRef) {
  return "deferred" in actorRef;
}
var noop = function() {
};
function defaultGetSnapshot(actorRef) {
  return "getSnapshot" in actorRef ? actorRef.getSnapshot() : isActorWithState(actorRef) ? actorRef.state : void 0;
}
function useActor(actorRef, getSnapshot) {
  if (getSnapshot === void 0) {
    getSnapshot = defaultGetSnapshot;
  }
  var actorRefRef = (0, import_react5.useRef)(actorRef);
  var deferredEventsRef = (0, import_react5.useRef)([]);
  var _a = __read5((0, import_react5.useState)(function() {
    return getSnapshot(actorRef);
  }), 2), current = _a[0], setCurrent = _a[1];
  var send = useConstant(function() {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var event = args[0];
      if (args.length > 1) {
        console.warn("Unexpected payload: ".concat(JSON.stringify(args[1]), ". Only a single event object can be sent to actor send() functions."));
      }
      var currentActorRef = actorRefRef.current;
      if (isDeferredActor(currentActorRef) && currentActorRef.deferred) {
        deferredEventsRef.current.push(event);
      } else {
        currentActorRef.send(event);
      }
    };
  });
  use_isomorphic_layout_effect_browser_esm_default(function() {
    actorRefRef.current = actorRef;
    setCurrent(getSnapshot(actorRef));
    var subscription = actorRef.subscribe({
      next: function(emitted) {
        return setCurrent(emitted);
      },
      error: noop,
      complete: noop
    });
    while (deferredEventsRef.current.length > 0) {
      var deferredEvent = deferredEventsRef.current.shift();
      actorRef.send(deferredEvent);
    }
    return function() {
      subscription.unsubscribe();
    };
  }, [actorRef]);
  return [current, send];
}

// ../node_modules/@xstate/react/es/useService.js
var __read6 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function getServiceSnapshot(service) {
  return ("status" in service ? service.status : service._status) !== 0 ? service.state : service.machine.initialState;
}
function useService(service) {
  if (!("machine" in service)) {
    throw new Error("Attempted to use an actor-like object instead of a service in the useService() hook. Please use the useActor() hook instead.");
  }
  var _a = __read6(useActor(service), 1), state = _a[0];
  return [state, service.send];
}

// ../node_modules/@xstate/react/es/useSelector.js
var import_react6 = __toESM(require_react());
var import_use_subscription = __toESM(require_use_subscription());
function isService(actor) {
  return "state" in actor && "machine" in actor;
}
var defaultCompare = function(a, b) {
  return a === b;
};
var defaultGetSnapshot2 = function(a) {
  return isService(a) ? getServiceSnapshot(a) : isActorWithState(a) ? a.state : void 0;
};
function useSelector(actor, selector, compare, getSnapshot) {
  if (compare === void 0) {
    compare = defaultCompare;
  }
  if (getSnapshot === void 0) {
    getSnapshot = defaultGetSnapshot2;
  }
  var latestSelectorRef = (0, import_react6.useRef)(selector);
  var subscription = (0, import_react6.useMemo)(function() {
    var snapshot = getSnapshot(actor);
    var current = selector(snapshot);
    var notifySubscriber;
    return {
      getSnapshot: function() {
        return snapshot;
      },
      getCurrentValue: function() {
        return current;
      },
      setCurrentValue: function(newCurrent) {
        current = newCurrent;
        notifySubscriber === null || notifySubscriber === void 0 ? void 0 : notifySubscriber();
      },
      subscribe: function(callback) {
        notifySubscriber = callback;
        var sub = actor.subscribe(function(emitted) {
          snapshot = emitted;
          var next = latestSelectorRef.current(emitted);
          if (!compare(current, next)) {
            current = next;
            callback();
          }
        });
        return function() {
          sub.unsubscribe();
        };
      }
    };
  }, [actor]);
  var currentSelected = (0, import_use_subscription.useSubscription)(subscription);
  var currentChanged = false;
  if (latestSelectorRef.current !== selector) {
    var selected = selector(subscription.getSnapshot());
    if (!compare(currentSelected, selected)) {
      currentChanged = true;
      currentSelected = selected;
    }
  }
  use_isomorphic_layout_effect_browser_esm_default(function() {
    latestSelectorRef.current = selector;
    if (currentChanged) {
      subscription.setCurrentValue(currentSelected);
    }
  });
  return currentSelected;
}

// ../node_modules/@xstate/react/es/useSpawn.js
var import_behaviors = __toESM(require_behaviors());
function useSpawn(behavior) {
  var actorRef = useConstant(function() {
    return (0, import_behaviors.spawnBehavior)(behavior);
  });
  return actorRef;
}

export {
  useInterpret,
  asEffect,
  asLayoutEffect,
  useMachine,
  useActor,
  useService,
  useSelector,
  useSpawn
};
/*! Bundled license information:

use-subscription/cjs/use-subscription.development.js:
  (**
   * @license React
   * use-subscription.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

xstate/lib/_virtual/_tslib.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=chunk-J34WXHB4.js.map
