import {
  Avatar_default,
  Fab_default,
  ListSubheader_default,
  Zoom_default
} from "./chunk-TDY4KRIT.js";
import {
  Chip_default
} from "./chunk-M64WZJX4.js";
import {
  Collapse_default
} from "./chunk-7EABD3G6.js";
import {
  Tabs_default
} from "./chunk-LJHHLN5M.js";
import {
  Popper_default,
  Tooltip_default
} from "./chunk-B6AM2NKK.js";
import {
  Typography_default
} from "./chunk-OSUJ7GDT.js";
import {
  IconButton_default
} from "./chunk-TSYRDUXI.js";
import {
  ButtonBase_default
} from "./chunk-PQJMVEX4.js";
import {
  init_utils
} from "./chunk-VFPNJJT6.js";
import {
  useId
} from "./chunk-CVF63FI4.js";
import {
  isMuiElement
} from "./chunk-YJVCL377.js";
import {
  useControlled
} from "./chunk-QFTOHLK2.js";
import {
  createSvgIcon
} from "./chunk-4JITSZEO.js";
import {
  useTheme
} from "./chunk-JE5XHEFL.js";
import {
  useIsFocusVisible
} from "./chunk-CCPUFXAI.js";
import {
  useEventCallback
} from "./chunk-3SY2X4VC.js";
import {
  setRef,
  useForkRef
} from "./chunk-VAAWV47Q.js";
import {
  capitalize
} from "./chunk-TZNDNIQK.js";
import {
  Paper_default
} from "./chunk-QYGHSHYC.js";
import {
  withStyles_default
} from "./chunk-YGDE4KKL.js";
import {
  alpha,
  darken,
  duration,
  emphasize,
  lighten
} from "./chunk-D3SGUVA5.js";
import {
  _defineProperty,
  _objectWithoutProperties,
  _slicedToArray,
  _typeof,
  chainPropTypes,
  init_defineProperty,
  init_esm,
  init_objectWithoutProperties,
  init_slicedToArray,
  init_typeof,
  require_react_is
} from "./chunk-WQUDTCFH.js";
import {
  clsx_m_default,
  init_clsx_m
} from "./chunk-OBJPNOCR.js";
import {
  _extends,
  init_extends,
  require_prop_types
} from "./chunk-PYVGESTF.js";
import {
  require_react
} from "./chunk-QCWLDGW7.js";
import {
  __toESM
} from "./chunk-AUZ3RYOM.js";

// ../node_modules/@material-ui/lab/esm/Alert/Alert.js
init_objectWithoutProperties();
init_extends();
var React6 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
init_clsx_m();

// ../node_modules/@material-ui/lab/esm/internal/svg-icons/SuccessOutlined.js
var React = __toESM(require_react());
init_utils();
var SuccessOutlined_default = createSvgIcon(React.createElement("path", {
  d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"
}), "SuccessOutlined");

// ../node_modules/@material-ui/lab/esm/internal/svg-icons/ReportProblemOutlined.js
var React2 = __toESM(require_react());
init_utils();
var ReportProblemOutlined_default = createSvgIcon(React2.createElement("path", {
  d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"
}), "ReportProblemOutlined");

// ../node_modules/@material-ui/lab/esm/internal/svg-icons/ErrorOutline.js
var React3 = __toESM(require_react());
init_utils();
var ErrorOutline_default = createSvgIcon(React3.createElement("path", {
  d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}), "ErrorOutline");

// ../node_modules/@material-ui/lab/esm/internal/svg-icons/InfoOutlined.js
var React4 = __toESM(require_react());
init_utils();
var InfoOutlined_default = createSvgIcon(React4.createElement("path", {
  d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"
}), "InfoOutlined");

// ../node_modules/@material-ui/lab/esm/internal/svg-icons/Close.js
var React5 = __toESM(require_react());
init_utils();
var Close_default = createSvgIcon(React5.createElement("path", {
  d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");

// ../node_modules/@material-ui/lab/esm/Alert/Alert.js
init_utils();
var styles = function styles2(theme) {
  var getColor = theme.palette.type === "light" ? darken : lighten;
  var getBackgroundColor = theme.palette.type === "light" ? lighten : darken;
  return {
    /* Styles applied to the root element. */
    root: _extends({}, theme.typography.body2, {
      borderRadius: theme.shape.borderRadius,
      backgroundColor: "transparent",
      display: "flex",
      padding: "6px 16px"
    }),
    /* Styles applied to the root element if `variant="standard"` and `color="success"`. */
    standardSuccess: {
      color: getColor(theme.palette.success.main, 0.6),
      backgroundColor: getBackgroundColor(theme.palette.success.main, 0.9),
      "& $icon": {
        color: theme.palette.success.main
      }
    },
    /* Styles applied to the root element if `variant="standard"` and `color="info"`. */
    standardInfo: {
      color: getColor(theme.palette.info.main, 0.6),
      backgroundColor: getBackgroundColor(theme.palette.info.main, 0.9),
      "& $icon": {
        color: theme.palette.info.main
      }
    },
    /* Styles applied to the root element if `variant="standard"` and `color="warning"`. */
    standardWarning: {
      color: getColor(theme.palette.warning.main, 0.6),
      backgroundColor: getBackgroundColor(theme.palette.warning.main, 0.9),
      "& $icon": {
        color: theme.palette.warning.main
      }
    },
    /* Styles applied to the root element if `variant="standard"` and `color="error"`. */
    standardError: {
      color: getColor(theme.palette.error.main, 0.6),
      backgroundColor: getBackgroundColor(theme.palette.error.main, 0.9),
      "& $icon": {
        color: theme.palette.error.main
      }
    },
    /* Styles applied to the root element if `variant="outlined"` and `color="success"`. */
    outlinedSuccess: {
      color: getColor(theme.palette.success.main, 0.6),
      border: "1px solid ".concat(theme.palette.success.main),
      "& $icon": {
        color: theme.palette.success.main
      }
    },
    /* Styles applied to the root element if `variant="outlined"` and `color="info"`. */
    outlinedInfo: {
      color: getColor(theme.palette.info.main, 0.6),
      border: "1px solid ".concat(theme.palette.info.main),
      "& $icon": {
        color: theme.palette.info.main
      }
    },
    /* Styles applied to the root element if `variant="outlined"` and `color="warning"`. */
    outlinedWarning: {
      color: getColor(theme.palette.warning.main, 0.6),
      border: "1px solid ".concat(theme.palette.warning.main),
      "& $icon": {
        color: theme.palette.warning.main
      }
    },
    /* Styles applied to the root element if `variant="outlined"` and `color="error"`. */
    outlinedError: {
      color: getColor(theme.palette.error.main, 0.6),
      border: "1px solid ".concat(theme.palette.error.main),
      "& $icon": {
        color: theme.palette.error.main
      }
    },
    /* Styles applied to the root element if `variant="filled"` and `color="success"`. */
    filledSuccess: {
      color: "#fff",
      fontWeight: theme.typography.fontWeightMedium,
      backgroundColor: theme.palette.success.main
    },
    /* Styles applied to the root element if `variant="filled"` and `color="info"`. */
    filledInfo: {
      color: "#fff",
      fontWeight: theme.typography.fontWeightMedium,
      backgroundColor: theme.palette.info.main
    },
    /* Styles applied to the root element if `variant="filled"` and `color="warning"`. */
    filledWarning: {
      color: "#fff",
      fontWeight: theme.typography.fontWeightMedium,
      backgroundColor: theme.palette.warning.main
    },
    /* Styles applied to the root element if `variant="filled"` and `color="error"`. */
    filledError: {
      color: "#fff",
      fontWeight: theme.typography.fontWeightMedium,
      backgroundColor: theme.palette.error.main
    },
    /* Styles applied to the icon wrapper element. */
    icon: {
      marginRight: 12,
      padding: "7px 0",
      display: "flex",
      fontSize: 22,
      opacity: 0.9
    },
    /* Styles applied to the message wrapper element. */
    message: {
      padding: "8px 0"
    },
    /* Styles applied to the action wrapper element if `action` is provided. */
    action: {
      display: "flex",
      alignItems: "center",
      marginLeft: "auto",
      paddingLeft: 16,
      marginRight: -8
    }
  };
};
var defaultIconMapping = {
  success: React6.createElement(SuccessOutlined_default, {
    fontSize: "inherit"
  }),
  warning: React6.createElement(ReportProblemOutlined_default, {
    fontSize: "inherit"
  }),
  error: React6.createElement(ErrorOutline_default, {
    fontSize: "inherit"
  }),
  info: React6.createElement(InfoOutlined_default, {
    fontSize: "inherit"
  })
};
var _ref = React6.createElement(Close_default, {
  fontSize: "small"
});
var Alert = React6.forwardRef(function Alert2(props, ref) {
  var action = props.action, children = props.children, classes = props.classes, className = props.className, _props$closeText = props.closeText, closeText = _props$closeText === void 0 ? "Close" : _props$closeText, color = props.color, icon = props.icon, _props$iconMapping = props.iconMapping, iconMapping = _props$iconMapping === void 0 ? defaultIconMapping : _props$iconMapping, onClose = props.onClose, _props$role = props.role, role = _props$role === void 0 ? "alert" : _props$role, _props$severity = props.severity, severity = _props$severity === void 0 ? "success" : _props$severity, _props$variant = props.variant, variant = _props$variant === void 0 ? "standard" : _props$variant, other = _objectWithoutProperties(props, ["action", "children", "classes", "className", "closeText", "color", "icon", "iconMapping", "onClose", "role", "severity", "variant"]);
  return React6.createElement(Paper_default, _extends({
    role,
    square: true,
    elevation: 0,
    className: clsx_m_default(classes.root, classes["".concat(variant).concat(capitalize(color || severity))], className),
    ref
  }, other), icon !== false ? React6.createElement("div", {
    className: classes.icon
  }, icon || iconMapping[severity] || defaultIconMapping[severity]) : null, React6.createElement("div", {
    className: classes.message
  }, children), action != null ? React6.createElement("div", {
    className: classes.action
  }, action) : null, action == null && onClose ? React6.createElement("div", {
    className: classes.action
  }, React6.createElement(IconButton_default, {
    size: "small",
    "aria-label": closeText,
    title: closeText,
    color: "inherit",
    onClick: onClose
  }, _ref)) : null);
});
true ? Alert.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The action to display. It renders after the message, at the end of the alert.
   */
  action: import_prop_types.default.node,
  /**
   * The content of the component.
   */
  children: import_prop_types.default.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types.default.object,
  /**
   * @ignore
   */
  className: import_prop_types.default.string,
  /**
   * Override the default label for the *close popup* icon button.
   *
   * For localization purposes, you can use the provided [translations](/guides/localization/).
   */
  closeText: import_prop_types.default.string,
  /**
   * The main color for the alert. Unless provided, the value is taken from the `severity` prop.
   */
  color: import_prop_types.default.oneOf(["error", "info", "success", "warning"]),
  /**
   * Override the icon displayed before the children.
   * Unless provided, the icon is mapped to the value of the `severity` prop.
   */
  icon: import_prop_types.default.node,
  /**
   * The component maps the `severity` prop to a range of different icons,
   * for instance success to `<SuccessOutlined>`.
   * If you wish to change this mapping, you can provide your own.
   * Alternatively, you can use the `icon` prop to override the icon displayed.
   */
  iconMapping: import_prop_types.default.shape({
    error: import_prop_types.default.node,
    info: import_prop_types.default.node,
    success: import_prop_types.default.node,
    warning: import_prop_types.default.node
  }),
  /**
   * Callback fired when the component requests to be closed.
   * When provided and no `action` prop is set, a close icon button is displayed that triggers the callback when clicked.
   *
   * @param {object} event The event source of the callback.
   */
  onClose: import_prop_types.default.func,
  /**
   * The ARIA role attribute of the element.
   */
  role: import_prop_types.default.string,
  /**
   * The severity of the alert. This defines the color and icon used.
   */
  severity: import_prop_types.default.oneOf(["error", "info", "success", "warning"]),
  /**
   * The variant to use.
   */
  variant: import_prop_types.default.oneOf(["filled", "outlined", "standard"])
} : void 0;
var Alert_default = withStyles_default(styles, {
  name: "MuiAlert"
})(Alert);

// ../node_modules/@material-ui/lab/esm/AlertTitle/AlertTitle.js
init_extends();
init_objectWithoutProperties();
var React7 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());
init_clsx_m();
var styles3 = function styles4(theme) {
  return {
    /* Styles applied to the root element. */
    root: {
      fontWeight: theme.typography.fontWeightMedium,
      marginTop: -2
    }
  };
};
var AlertTitle = React7.forwardRef(function AlertTitle2(props, ref) {
  var classes = props.classes, className = props.className, other = _objectWithoutProperties(props, ["classes", "className"]);
  return React7.createElement(Typography_default, _extends({
    gutterBottom: true,
    component: "div",
    ref,
    className: clsx_m_default(classes.root, className)
  }, other));
});
true ? AlertTitle.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: import_prop_types2.default.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types2.default.object,
  /**
   * @ignore
   */
  className: import_prop_types2.default.string
} : void 0;
var AlertTitle_default = withStyles_default(styles3, {
  name: "MuiAlertTitle"
})(AlertTitle);

// ../node_modules/@material-ui/lab/esm/Autocomplete/Autocomplete.js
init_objectWithoutProperties();
init_defineProperty();
init_extends();
var React10 = __toESM(require_react());
var import_prop_types3 = __toESM(require_prop_types());
init_clsx_m();

// ../node_modules/@material-ui/lab/esm/internal/svg-icons/ArrowDropDown.js
var React8 = __toESM(require_react());
init_utils();
var ArrowDropDown_default = createSvgIcon(React8.createElement("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown");

// ../node_modules/@material-ui/lab/esm/useAutocomplete/useAutocomplete.js
init_extends();
init_slicedToArray();
init_typeof();
var React9 = __toESM(require_react());
init_utils();
function stripDiacritics(string2) {
  return typeof string2.normalize !== "undefined" ? string2.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : string2;
}
function createFilterOptions() {
  var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _config$ignoreAccents = config.ignoreAccents, ignoreAccents = _config$ignoreAccents === void 0 ? true : _config$ignoreAccents, _config$ignoreCase = config.ignoreCase, ignoreCase = _config$ignoreCase === void 0 ? true : _config$ignoreCase, limit = config.limit, _config$matchFrom = config.matchFrom, matchFrom = _config$matchFrom === void 0 ? "any" : _config$matchFrom, stringify = config.stringify, _config$trim = config.trim, trim = _config$trim === void 0 ? false : _config$trim;
  return function(options, _ref3) {
    var inputValue = _ref3.inputValue, getOptionLabel = _ref3.getOptionLabel;
    var input = trim ? inputValue.trim() : inputValue;
    if (ignoreCase) {
      input = input.toLowerCase();
    }
    if (ignoreAccents) {
      input = stripDiacritics(input);
    }
    var filteredOptions = options.filter(function(option) {
      var candidate = (stringify || getOptionLabel)(option);
      if (ignoreCase) {
        candidate = candidate.toLowerCase();
      }
      if (ignoreAccents) {
        candidate = stripDiacritics(candidate);
      }
      return matchFrom === "start" ? candidate.indexOf(input) === 0 : candidate.indexOf(input) > -1;
    });
    return typeof limit === "number" ? filteredOptions.slice(0, limit) : filteredOptions;
  };
}
function findIndex(array, comp) {
  for (var i = 0; i < array.length; i += 1) {
    if (comp(array[i])) {
      return i;
    }
  }
  return -1;
}
var defaultFilterOptions = createFilterOptions();
var pageSize = 5;
function useAutocomplete(props) {
  var _props$autoComplete = props.autoComplete, autoComplete = _props$autoComplete === void 0 ? false : _props$autoComplete, _props$autoHighlight = props.autoHighlight, autoHighlight = _props$autoHighlight === void 0 ? false : _props$autoHighlight, _props$autoSelect = props.autoSelect, autoSelect = _props$autoSelect === void 0 ? false : _props$autoSelect, _props$blurOnSelect = props.blurOnSelect, blurOnSelect = _props$blurOnSelect === void 0 ? false : _props$blurOnSelect, _props$clearOnBlur = props.clearOnBlur, clearOnBlur = _props$clearOnBlur === void 0 ? !props.freeSolo : _props$clearOnBlur, _props$clearOnEscape = props.clearOnEscape, clearOnEscape = _props$clearOnEscape === void 0 ? false : _props$clearOnEscape, _props$componentName = props.componentName, componentName = _props$componentName === void 0 ? "useAutocomplete" : _props$componentName, _props$debug = props.debug, debug = _props$debug === void 0 ? false : _props$debug, _props$defaultValue = props.defaultValue, defaultValue = _props$defaultValue === void 0 ? props.multiple ? [] : null : _props$defaultValue, _props$disableClearab = props.disableClearable, disableClearable = _props$disableClearab === void 0 ? false : _props$disableClearab, _props$disableCloseOn = props.disableCloseOnSelect, disableCloseOnSelect = _props$disableCloseOn === void 0 ? false : _props$disableCloseOn, _props$disabledItemsF = props.disabledItemsFocusable, disabledItemsFocusable = _props$disabledItemsF === void 0 ? false : _props$disabledItemsF, _props$disableListWra = props.disableListWrap, disableListWrap = _props$disableListWra === void 0 ? false : _props$disableListWra, _props$filterOptions = props.filterOptions, filterOptions = _props$filterOptions === void 0 ? defaultFilterOptions : _props$filterOptions, _props$filterSelected = props.filterSelectedOptions, filterSelectedOptions = _props$filterSelected === void 0 ? false : _props$filterSelected, _props$freeSolo = props.freeSolo, freeSolo = _props$freeSolo === void 0 ? false : _props$freeSolo, getOptionDisabled = props.getOptionDisabled, _props$getOptionLabel = props.getOptionLabel, getOptionLabelProp = _props$getOptionLabel === void 0 ? function(option) {
    return option;
  } : _props$getOptionLabel, _props$getOptionSelec = props.getOptionSelected, getOptionSelected = _props$getOptionSelec === void 0 ? function(option, value2) {
    return option === value2;
  } : _props$getOptionSelec, groupBy = props.groupBy, _props$handleHomeEndK = props.handleHomeEndKeys, handleHomeEndKeys = _props$handleHomeEndK === void 0 ? !props.freeSolo : _props$handleHomeEndK, idProp = props.id, _props$includeInputIn = props.includeInputInList, includeInputInList = _props$includeInputIn === void 0 ? false : _props$includeInputIn, inputValueProp = props.inputValue, _props$multiple = props.multiple, multiple = _props$multiple === void 0 ? false : _props$multiple, onChange = props.onChange, onClose = props.onClose, onHighlightChange = props.onHighlightChange, onInputChange = props.onInputChange, onOpen = props.onOpen, openProp = props.open, _props$openOnFocus = props.openOnFocus, openOnFocus = _props$openOnFocus === void 0 ? false : _props$openOnFocus, options = props.options, _props$selectOnFocus = props.selectOnFocus, selectOnFocus = _props$selectOnFocus === void 0 ? !props.freeSolo : _props$selectOnFocus, valueProp = props.value;
  var id = useId(idProp);
  var getOptionLabel = getOptionLabelProp;
  if (true) {
    getOptionLabel = function getOptionLabel2(option) {
      var optionLabel = getOptionLabelProp(option);
      if (typeof optionLabel !== "string") {
        var erroneousReturn = optionLabel === void 0 ? "undefined" : "".concat(_typeof(optionLabel), " (").concat(optionLabel, ")");
        console.error("Material-UI: The `getOptionLabel` method of ".concat(componentName, " returned ").concat(erroneousReturn, " instead of a string for ").concat(JSON.stringify(option), "."));
      }
      return optionLabel;
    };
  }
  var ignoreFocus = React9.useRef(false);
  var firstFocus = React9.useRef(true);
  var inputRef = React9.useRef(null);
  var listboxRef = React9.useRef(null);
  var _React$useState = React9.useState(null), anchorEl = _React$useState[0], setAnchorEl = _React$useState[1];
  var _React$useState2 = React9.useState(-1), focusedTag = _React$useState2[0], setFocusedTag = _React$useState2[1];
  var defaultHighlighted = autoHighlight ? 0 : -1;
  var highlightedIndexRef = React9.useRef(defaultHighlighted);
  var _useControlled = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: componentName
  }), _useControlled2 = _slicedToArray(_useControlled, 2), value = _useControlled2[0], setValue = _useControlled2[1];
  var _useControlled3 = useControlled({
    controlled: inputValueProp,
    default: "",
    name: componentName,
    state: "inputValue"
  }), _useControlled4 = _slicedToArray(_useControlled3, 2), inputValue = _useControlled4[0], setInputValue = _useControlled4[1];
  var _React$useState3 = React9.useState(false), focused = _React$useState3[0], setFocused = _React$useState3[1];
  var resetInputValue = useEventCallback(function(event, newValue) {
    var newInputValue;
    if (multiple) {
      newInputValue = "";
    } else if (newValue == null) {
      newInputValue = "";
    } else {
      var optionLabel = getOptionLabel(newValue);
      newInputValue = typeof optionLabel === "string" ? optionLabel : "";
    }
    if (inputValue === newInputValue) {
      return;
    }
    setInputValue(newInputValue);
    if (onInputChange) {
      onInputChange(event, newInputValue, "reset");
    }
  });
  React9.useEffect(function() {
    resetInputValue(null, value);
  }, [value, resetInputValue]);
  var _useControlled5 = useControlled({
    controlled: openProp,
    default: false,
    name: componentName,
    state: "open"
  }), _useControlled6 = _slicedToArray(_useControlled5, 2), open = _useControlled6[0], setOpenState = _useControlled6[1];
  var inputValueIsSelectedValue = !multiple && value != null && inputValue === getOptionLabel(value);
  var popupOpen = open;
  var filteredOptions = popupOpen ? filterOptions(
    options.filter(function(option) {
      if (filterSelectedOptions && (multiple ? value : [value]).some(function(value2) {
        return value2 !== null && getOptionSelected(option, value2);
      })) {
        return false;
      }
      return true;
    }),
    // we use the empty string to manipulate `filterOptions` to not filter any options
    // i.e. the filter predicate always returns true
    {
      inputValue: inputValueIsSelectedValue ? "" : inputValue,
      getOptionLabel
    }
  ) : [];
  if (true) {
    if (value !== null && !freeSolo && options.length > 0) {
      var missingValue = (multiple ? value : [value]).filter(function(value2) {
        return !options.some(function(option) {
          return getOptionSelected(option, value2);
        });
      });
      if (missingValue.length > 0) {
        console.warn(["Material-UI: The value provided to ".concat(componentName, " is invalid."), "None of the options match with `".concat(missingValue.length > 1 ? JSON.stringify(missingValue) : JSON.stringify(missingValue[0]), "`."), "You can use the `getOptionSelected` prop to customize the equality test."].join("\n"));
      }
    }
  }
  var focusTag = useEventCallback(function(tagToFocus) {
    if (tagToFocus === -1) {
      inputRef.current.focus();
    } else {
      anchorEl.querySelector('[data-tag-index="'.concat(tagToFocus, '"]')).focus();
    }
  });
  React9.useEffect(function() {
    if (multiple && focusedTag > value.length - 1) {
      setFocusedTag(-1);
      focusTag(-1);
    }
  }, [value, multiple, focusedTag, focusTag]);
  function validOptionIndex(index, direction) {
    if (!listboxRef.current || index === -1) {
      return -1;
    }
    var nextFocus = index;
    while (true) {
      if (direction === "next" && nextFocus === filteredOptions.length || direction === "previous" && nextFocus === -1) {
        return -1;
      }
      var option = listboxRef.current.querySelector('[data-option-index="'.concat(nextFocus, '"]'));
      var nextFocusDisabled = disabledItemsFocusable ? false : option && (option.disabled || option.getAttribute("aria-disabled") === "true");
      if (option && !option.hasAttribute("tabindex") || nextFocusDisabled) {
        nextFocus += direction === "next" ? 1 : -1;
      } else {
        return nextFocus;
      }
    }
  }
  var setHighlightedIndex = useEventCallback(function(_ref23) {
    var event = _ref23.event, index = _ref23.index, _ref2$reason = _ref23.reason, reason = _ref2$reason === void 0 ? "auto" : _ref2$reason;
    highlightedIndexRef.current = index;
    if (index === -1) {
      inputRef.current.removeAttribute("aria-activedescendant");
    } else {
      inputRef.current.setAttribute("aria-activedescendant", "".concat(id, "-option-").concat(index));
    }
    if (onHighlightChange) {
      onHighlightChange(event, index === -1 ? null : filteredOptions[index], reason);
    }
    if (!listboxRef.current) {
      return;
    }
    var prev = listboxRef.current.querySelector("[data-focus]");
    if (prev) {
      prev.removeAttribute("data-focus");
    }
    var listboxNode = listboxRef.current.parentElement.querySelector('[role="listbox"]');
    if (!listboxNode) {
      return;
    }
    if (index === -1) {
      listboxNode.scrollTop = 0;
      return;
    }
    var option = listboxRef.current.querySelector('[data-option-index="'.concat(index, '"]'));
    if (!option) {
      return;
    }
    option.setAttribute("data-focus", "true");
    if (listboxNode.scrollHeight > listboxNode.clientHeight && reason !== "mouse") {
      var element2 = option;
      var scrollBottom = listboxNode.clientHeight + listboxNode.scrollTop;
      var elementBottom = element2.offsetTop + element2.offsetHeight;
      if (elementBottom > scrollBottom) {
        listboxNode.scrollTop = elementBottom - listboxNode.clientHeight;
      } else if (element2.offsetTop - element2.offsetHeight * (groupBy ? 1.3 : 0) < listboxNode.scrollTop) {
        listboxNode.scrollTop = element2.offsetTop - element2.offsetHeight * (groupBy ? 1.3 : 0);
      }
    }
  });
  var changeHighlightedIndex = useEventCallback(function(_ref3) {
    var event = _ref3.event, diff = _ref3.diff, _ref3$direction = _ref3.direction, direction = _ref3$direction === void 0 ? "next" : _ref3$direction, _ref3$reason = _ref3.reason, reason = _ref3$reason === void 0 ? "auto" : _ref3$reason;
    if (!popupOpen) {
      return;
    }
    var getNextIndex = function getNextIndex2() {
      var maxIndex = filteredOptions.length - 1;
      if (diff === "reset") {
        return defaultHighlighted;
      }
      if (diff === "start") {
        return 0;
      }
      if (diff === "end") {
        return maxIndex;
      }
      var newIndex = highlightedIndexRef.current + diff;
      if (newIndex < 0) {
        if (newIndex === -1 && includeInputInList) {
          return -1;
        }
        if (disableListWrap && highlightedIndexRef.current !== -1 || Math.abs(diff) > 1) {
          return 0;
        }
        return maxIndex;
      }
      if (newIndex > maxIndex) {
        if (newIndex === maxIndex + 1 && includeInputInList) {
          return -1;
        }
        if (disableListWrap || Math.abs(diff) > 1) {
          return maxIndex;
        }
        return 0;
      }
      return newIndex;
    };
    var nextIndex = validOptionIndex(getNextIndex(), direction);
    setHighlightedIndex({
      index: nextIndex,
      reason,
      event
    });
    if (autoComplete && diff !== "reset") {
      if (nextIndex === -1) {
        inputRef.current.value = inputValue;
      } else {
        var option = getOptionLabel(filteredOptions[nextIndex]);
        inputRef.current.value = option;
        var index = option.toLowerCase().indexOf(inputValue.toLowerCase());
        if (index === 0 && inputValue.length > 0) {
          inputRef.current.setSelectionRange(inputValue.length, option.length);
        }
      }
    }
  });
  var syncHighlightedIndex = React9.useCallback(function() {
    if (!popupOpen) {
      return;
    }
    var valueItem = multiple ? value[0] : value;
    if (filteredOptions.length === 0 || valueItem == null) {
      changeHighlightedIndex({
        diff: "reset"
      });
      return;
    }
    if (!listboxRef.current) {
      return;
    }
    if (!filterSelectedOptions && valueItem != null) {
      var currentOption = filteredOptions[highlightedIndexRef.current];
      if (multiple && currentOption && findIndex(value, function(val) {
        return getOptionSelected(currentOption, val);
      }) !== -1) {
        return;
      }
      var itemIndex = findIndex(filteredOptions, function(optionItem) {
        return getOptionSelected(optionItem, valueItem);
      });
      if (itemIndex === -1) {
        changeHighlightedIndex({
          diff: "reset"
        });
      } else {
        setHighlightedIndex({
          index: itemIndex
        });
      }
      return;
    }
    if (highlightedIndexRef.current >= filteredOptions.length - 1) {
      setHighlightedIndex({
        index: filteredOptions.length - 1
      });
      return;
    }
    setHighlightedIndex({
      index: highlightedIndexRef.current
    });
  }, [
    // Only sync the highlighted index when the option switch between empty and not
    // eslint-disable-next-line react-hooks/exhaustive-deps
    filteredOptions.length === 0,
    // Don't sync the highlighted index with the value when multiple
    // eslint-disable-next-line react-hooks/exhaustive-deps
    multiple ? false : value,
    filterSelectedOptions,
    changeHighlightedIndex,
    setHighlightedIndex,
    popupOpen,
    inputValue,
    multiple
  ]);
  var handleListboxRef = useEventCallback(function(node2) {
    setRef(listboxRef, node2);
    if (!node2) {
      return;
    }
    syncHighlightedIndex();
  });
  React9.useEffect(function() {
    syncHighlightedIndex();
  }, [syncHighlightedIndex]);
  var handleOpen = function handleOpen2(event) {
    if (open) {
      return;
    }
    setOpenState(true);
    if (onOpen) {
      onOpen(event);
    }
  };
  var handleClose = function handleClose2(event, reason) {
    if (!open) {
      return;
    }
    setOpenState(false);
    if (onClose) {
      onClose(event, reason);
    }
  };
  var handleValue = function handleValue2(event, newValue, reason, details) {
    if (value === newValue) {
      return;
    }
    if (onChange) {
      onChange(event, newValue, reason, details);
    }
    setValue(newValue);
  };
  var isTouch = React9.useRef(false);
  var selectNewValue = function selectNewValue2(event, option) {
    var reasonProp = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "select-option";
    var origin = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "options";
    var reason = reasonProp;
    var newValue = option;
    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];
      if (true) {
        var matches = newValue.filter(function(val) {
          return getOptionSelected(option, val);
        });
        if (matches.length > 1) {
          console.error(["Material-UI: The `getOptionSelected` method of ".concat(componentName, " do not handle the arguments correctly."), "The component expects a single value to match a given option but found ".concat(matches.length, " matches.")].join("\n"));
        }
      }
      var itemIndex = findIndex(newValue, function(valueItem) {
        return getOptionSelected(option, valueItem);
      });
      if (itemIndex === -1) {
        newValue.push(option);
      } else if (origin !== "freeSolo") {
        newValue.splice(itemIndex, 1);
        reason = "remove-option";
      }
    }
    resetInputValue(event, newValue);
    handleValue(event, newValue, reason, {
      option
    });
    if (!disableCloseOnSelect) {
      handleClose(event, reason);
    }
    if (blurOnSelect === true || blurOnSelect === "touch" && isTouch.current || blurOnSelect === "mouse" && !isTouch.current) {
      inputRef.current.blur();
    }
  };
  function validTagIndex(index, direction) {
    if (index === -1) {
      return -1;
    }
    var nextFocus = index;
    while (true) {
      if (direction === "next" && nextFocus === value.length || direction === "previous" && nextFocus === -1) {
        return -1;
      }
      var option = anchorEl.querySelector('[data-tag-index="'.concat(nextFocus, '"]'));
      if (option && (!option.hasAttribute("tabindex") || option.disabled || option.getAttribute("aria-disabled") === "true")) {
        nextFocus += direction === "next" ? 1 : -1;
      } else {
        return nextFocus;
      }
    }
  }
  var handleFocusTag = function handleFocusTag2(event, direction) {
    if (!multiple) {
      return;
    }
    handleClose(event, "toggleInput");
    var nextTag = focusedTag;
    if (focusedTag === -1) {
      if (inputValue === "" && direction === "previous") {
        nextTag = value.length - 1;
      }
    } else {
      nextTag += direction === "next" ? 1 : -1;
      if (nextTag < 0) {
        nextTag = 0;
      }
      if (nextTag === value.length) {
        nextTag = -1;
      }
    }
    nextTag = validTagIndex(nextTag, direction);
    setFocusedTag(nextTag);
    focusTag(nextTag);
  };
  var handleClear = function handleClear2(event) {
    ignoreFocus.current = true;
    setInputValue("");
    if (onInputChange) {
      onInputChange(event, "", "clear");
    }
    handleValue(event, multiple ? [] : null, "clear");
  };
  var handleKeyDown = function handleKeyDown2(other) {
    return function(event) {
      if (focusedTag !== -1 && ["ArrowLeft", "ArrowRight"].indexOf(event.key) === -1) {
        setFocusedTag(-1);
        focusTag(-1);
      }
      switch (event.key) {
        case "Home":
          if (popupOpen && handleHomeEndKeys) {
            event.preventDefault();
            changeHighlightedIndex({
              diff: "start",
              direction: "next",
              reason: "keyboard",
              event
            });
          }
          break;
        case "End":
          if (popupOpen && handleHomeEndKeys) {
            event.preventDefault();
            changeHighlightedIndex({
              diff: "end",
              direction: "previous",
              reason: "keyboard",
              event
            });
          }
          break;
        case "PageUp":
          event.preventDefault();
          changeHighlightedIndex({
            diff: -pageSize,
            direction: "previous",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "PageDown":
          event.preventDefault();
          changeHighlightedIndex({
            diff: pageSize,
            direction: "next",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowDown":
          event.preventDefault();
          changeHighlightedIndex({
            diff: 1,
            direction: "next",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowUp":
          event.preventDefault();
          changeHighlightedIndex({
            diff: -1,
            direction: "previous",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowLeft":
          handleFocusTag(event, "previous");
          break;
        case "ArrowRight":
          handleFocusTag(event, "next");
          break;
        case "Enter":
          if (event.which === 229) {
            break;
          }
          if (highlightedIndexRef.current !== -1 && popupOpen) {
            var option = filteredOptions[highlightedIndexRef.current];
            var disabled = getOptionDisabled ? getOptionDisabled(option) : false;
            event.preventDefault();
            if (disabled) {
              return;
            }
            selectNewValue(event, option, "select-option");
            if (autoComplete) {
              inputRef.current.setSelectionRange(inputRef.current.value.length, inputRef.current.value.length);
            }
          } else if (freeSolo && inputValue !== "" && inputValueIsSelectedValue === false) {
            if (multiple) {
              event.preventDefault();
            }
            selectNewValue(event, inputValue, "create-option", "freeSolo");
          }
          break;
        case "Escape":
          if (popupOpen) {
            event.preventDefault();
            event.stopPropagation();
            handleClose(event, "escape");
          } else if (clearOnEscape && (inputValue !== "" || multiple && value.length > 0)) {
            event.preventDefault();
            event.stopPropagation();
            handleClear(event);
          }
          break;
        case "Backspace":
          if (multiple && inputValue === "" && value.length > 0) {
            var index = focusedTag === -1 ? value.length - 1 : focusedTag;
            var newValue = value.slice();
            newValue.splice(index, 1);
            handleValue(event, newValue, "remove-option", {
              option: value[index]
            });
          }
          break;
        default:
      }
      if (other.onKeyDown) {
        other.onKeyDown(event);
      }
    };
  };
  var handleFocus = function handleFocus2(event) {
    setFocused(true);
    if (openOnFocus && !ignoreFocus.current) {
      handleOpen(event);
    }
  };
  var handleBlur = function handleBlur2(event) {
    if (listboxRef.current !== null && document.activeElement === listboxRef.current.parentElement) {
      inputRef.current.focus();
      return;
    }
    setFocused(false);
    firstFocus.current = true;
    ignoreFocus.current = false;
    if (debug && inputValue !== "") {
      return;
    }
    if (autoSelect && highlightedIndexRef.current !== -1 && popupOpen) {
      selectNewValue(event, filteredOptions[highlightedIndexRef.current], "blur");
    } else if (autoSelect && freeSolo && inputValue !== "") {
      selectNewValue(event, inputValue, "blur", "freeSolo");
    } else if (clearOnBlur) {
      resetInputValue(event, value);
    }
    handleClose(event, "blur");
  };
  var handleInputChange = function handleInputChange2(event) {
    var newValue = event.target.value;
    if (inputValue !== newValue) {
      setInputValue(newValue);
      if (onInputChange) {
        onInputChange(event, newValue, "input");
      }
    }
    if (newValue === "") {
      if (!disableClearable && !multiple) {
        handleValue(event, null, "clear");
      }
    } else {
      handleOpen(event);
    }
  };
  var handleOptionMouseOver = function handleOptionMouseOver2(event) {
    setHighlightedIndex({
      event,
      index: Number(event.currentTarget.getAttribute("data-option-index")),
      reason: "mouse"
    });
  };
  var handleOptionTouchStart = function handleOptionTouchStart2() {
    isTouch.current = true;
  };
  var handleOptionClick = function handleOptionClick2(event) {
    var index = Number(event.currentTarget.getAttribute("data-option-index"));
    selectNewValue(event, filteredOptions[index], "select-option");
    isTouch.current = false;
  };
  var handleTagDelete = function handleTagDelete2(index) {
    return function(event) {
      var newValue = value.slice();
      newValue.splice(index, 1);
      handleValue(event, newValue, "remove-option", {
        option: value[index]
      });
    };
  };
  var handlePopupIndicator = function handlePopupIndicator2(event) {
    if (open) {
      handleClose(event, "toggleInput");
    } else {
      handleOpen(event);
    }
  };
  var handleMouseDown = function handleMouseDown2(event) {
    if (event.target.getAttribute("id") !== id) {
      event.preventDefault();
    }
  };
  var handleClick = function handleClick2() {
    inputRef.current.focus();
    if (selectOnFocus && firstFocus.current && inputRef.current.selectionEnd - inputRef.current.selectionStart === 0) {
      inputRef.current.select();
    }
    firstFocus.current = false;
  };
  var handleInputMouseDown = function handleInputMouseDown2(event) {
    if (inputValue === "" || !open) {
      handlePopupIndicator(event);
    }
  };
  var dirty = freeSolo && inputValue.length > 0;
  dirty = dirty || (multiple ? value.length > 0 : value !== null);
  var groupedOptions = filteredOptions;
  if (groupBy) {
    var indexBy = /* @__PURE__ */ new Map();
    var warn = false;
    groupedOptions = filteredOptions.reduce(function(acc, option, index) {
      var group = groupBy(option);
      if (acc.length > 0 && acc[acc.length - 1].group === group) {
        acc[acc.length - 1].options.push(option);
      } else {
        if (true) {
          if (indexBy.get(group) && !warn) {
            console.warn("Material-UI: The options provided combined with the `groupBy` method of ".concat(componentName, " returns duplicated headers."), "You can solve the issue by sorting the options with the output of `groupBy`.");
            warn = true;
          }
          indexBy.set(group, true);
        }
        acc.push({
          key: index,
          index,
          group,
          options: [option]
        });
      }
      return acc;
    }, []);
  }
  return {
    getRootProps: function getRootProps() {
      var other = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return _extends({
        "aria-owns": popupOpen ? "".concat(id, "-popup") : null,
        role: "combobox",
        "aria-expanded": popupOpen
      }, other, {
        onKeyDown: handleKeyDown(other),
        onMouseDown: handleMouseDown,
        onClick: handleClick
      });
    },
    getInputLabelProps: function getInputLabelProps() {
      return {
        id: "".concat(id, "-label"),
        htmlFor: id
      };
    },
    getInputProps: function getInputProps() {
      return {
        id,
        value: inputValue,
        onBlur: handleBlur,
        onFocus: handleFocus,
        onChange: handleInputChange,
        onMouseDown: handleInputMouseDown,
        // if open then this is handled imperativeley so don't let react override
        // only have an opinion about this when closed
        "aria-activedescendant": popupOpen ? "" : null,
        "aria-autocomplete": autoComplete ? "both" : "list",
        "aria-controls": popupOpen ? "".concat(id, "-popup") : null,
        // Disable browser's suggestion that might overlap with the popup.
        // Handle autocomplete but not autofill.
        autoComplete: "off",
        ref: inputRef,
        autoCapitalize: "none",
        spellCheck: "false"
      };
    },
    getClearProps: function getClearProps() {
      return {
        tabIndex: -1,
        onClick: handleClear
      };
    },
    getPopupIndicatorProps: function getPopupIndicatorProps() {
      return {
        tabIndex: -1,
        onClick: handlePopupIndicator
      };
    },
    getTagProps: function getTagProps(_ref4) {
      var index = _ref4.index;
      return {
        key: index,
        "data-tag-index": index,
        tabIndex: -1,
        onDelete: handleTagDelete(index)
      };
    },
    getListboxProps: function getListboxProps() {
      return {
        role: "listbox",
        id: "".concat(id, "-popup"),
        "aria-labelledby": "".concat(id, "-label"),
        ref: handleListboxRef,
        onMouseDown: function onMouseDown(event) {
          event.preventDefault();
        }
      };
    },
    getOptionProps: function getOptionProps(_ref5) {
      var index = _ref5.index, option = _ref5.option;
      var selected = (multiple ? value : [value]).some(function(value2) {
        return value2 != null && getOptionSelected(option, value2);
      });
      var disabled = getOptionDisabled ? getOptionDisabled(option) : false;
      return {
        key: index,
        tabIndex: -1,
        role: "option",
        id: "".concat(id, "-option-").concat(index),
        onMouseOver: handleOptionMouseOver,
        onClick: handleOptionClick,
        onTouchStart: handleOptionTouchStart,
        "data-option-index": index,
        "aria-disabled": disabled,
        "aria-selected": selected
      };
    },
    id,
    inputValue,
    value,
    dirty,
    popupOpen,
    focused: focused || focusedTag !== -1,
    anchorEl,
    setAnchorEl,
    focusedTag,
    groupedOptions
  };
}

// ../node_modules/@material-ui/lab/esm/Autocomplete/Autocomplete.js
var styles5 = function styles6(theme) {
  var _option;
  return {
    /* Styles applied to the root element. */
    root: {
      "&$focused $clearIndicatorDirty": {
        visibility: "visible"
      },
      /* Avoid double tap issue on iOS */
      "@media (pointer: fine)": {
        "&:hover $clearIndicatorDirty": {
          visibility: "visible"
        }
      }
    },
    /* Styles applied to the root element if `fullWidth={true}`. */
    fullWidth: {
      width: "100%"
    },
    /* Pseudo-class applied to the root element if focused. */
    focused: {},
    /* Styles applied to the tag elements, e.g. the chips. */
    tag: {
      margin: 3,
      maxWidth: "calc(100% - 6px)"
    },
    /* Styles applied to the tag elements, e.g. the chips if `size="small"`. */
    tagSizeSmall: {
      margin: 2,
      maxWidth: "calc(100% - 4px)"
    },
    /* Styles applied when the popup icon is rendered. */
    hasPopupIcon: {},
    /* Styles applied when the clear icon is rendered. */
    hasClearIcon: {},
    /* Styles applied to the Input element. */
    inputRoot: {
      flexWrap: "wrap",
      "$hasPopupIcon &, $hasClearIcon &": {
        paddingRight: 26 + 4
      },
      "$hasPopupIcon$hasClearIcon &": {
        paddingRight: 52 + 4
      },
      "& $input": {
        width: 0,
        minWidth: 30
      },
      '&[class*="MuiInput-root"]': {
        paddingBottom: 1,
        "& $input": {
          padding: 4
        },
        "& $input:first-child": {
          padding: "6px 0"
        }
      },
      '&[class*="MuiInput-root"][class*="MuiInput-marginDense"]': {
        "& $input": {
          padding: "4px 4px 5px"
        },
        "& $input:first-child": {
          padding: "3px 0 6px"
        }
      },
      '&[class*="MuiOutlinedInput-root"]': {
        padding: 9,
        "$hasPopupIcon &, $hasClearIcon &": {
          paddingRight: 26 + 4 + 9
        },
        "$hasPopupIcon$hasClearIcon &": {
          paddingRight: 52 + 4 + 9
        },
        "& $input": {
          padding: "9.5px 4px"
        },
        "& $input:first-child": {
          paddingLeft: 6
        },
        "& $endAdornment": {
          right: 9
        }
      },
      '&[class*="MuiOutlinedInput-root"][class*="MuiOutlinedInput-marginDense"]': {
        padding: 6,
        "& $input": {
          padding: "4.5px 4px"
        }
      },
      '&[class*="MuiFilledInput-root"]': {
        paddingTop: 19,
        paddingLeft: 8,
        "$hasPopupIcon &, $hasClearIcon &": {
          paddingRight: 26 + 4 + 9
        },
        "$hasPopupIcon$hasClearIcon &": {
          paddingRight: 52 + 4 + 9
        },
        "& $input": {
          padding: "9px 4px"
        },
        "& $endAdornment": {
          right: 9
        }
      },
      '&[class*="MuiFilledInput-root"][class*="MuiFilledInput-marginDense"]': {
        paddingBottom: 1,
        "& $input": {
          padding: "4.5px 4px"
        }
      }
    },
    /* Styles applied to the input element. */
    input: {
      flexGrow: 1,
      textOverflow: "ellipsis",
      opacity: 0
    },
    /* Styles applied to the input element if tag focused. */
    inputFocused: {
      opacity: 1
    },
    /* Styles applied to the endAdornment element. */
    endAdornment: {
      // We use a position absolute to support wrapping tags.
      position: "absolute",
      right: 0,
      top: "calc(50% - 14px)"
      // Center vertically
    },
    /* Styles applied to the clear indicator. */
    clearIndicator: {
      marginRight: -2,
      padding: 4,
      visibility: "hidden"
    },
    /* Styles applied to the clear indicator if the input is dirty. */
    clearIndicatorDirty: {},
    /* Styles applied to the popup indicator. */
    popupIndicator: {
      padding: 2,
      marginRight: -2
    },
    /* Styles applied to the popup indicator if the popup is open. */
    popupIndicatorOpen: {
      transform: "rotate(180deg)"
    },
    /* Styles applied to the popper element. */
    popper: {
      zIndex: theme.zIndex.modal
    },
    /* Styles applied to the popper element if `disablePortal={true}`. */
    popperDisablePortal: {
      position: "absolute"
    },
    /* Styles applied to the `Paper` component. */
    paper: _extends({}, theme.typography.body1, {
      overflow: "hidden",
      margin: "4px 0"
    }),
    /* Styles applied to the `listbox` component. */
    listbox: {
      listStyle: "none",
      margin: 0,
      padding: "8px 0",
      maxHeight: "40vh",
      overflow: "auto"
    },
    /* Styles applied to the loading wrapper. */
    loading: {
      color: theme.palette.text.secondary,
      padding: "14px 16px"
    },
    /* Styles applied to the no option wrapper. */
    noOptions: {
      color: theme.palette.text.secondary,
      padding: "14px 16px"
    },
    /* Styles applied to the option elements. */
    option: (_option = {
      minHeight: 48,
      display: "flex",
      justifyContent: "flex-start",
      alignItems: "center",
      cursor: "pointer",
      paddingTop: 6,
      boxSizing: "border-box",
      outline: "0",
      WebkitTapHighlightColor: "transparent",
      paddingBottom: 6,
      paddingLeft: 16,
      paddingRight: 16
    }, _defineProperty(_option, theme.breakpoints.up("sm"), {
      minHeight: "auto"
    }), _defineProperty(_option, '&[aria-selected="true"]', {
      backgroundColor: theme.palette.action.selected
    }), _defineProperty(_option, '&[data-focus="true"]', {
      backgroundColor: theme.palette.action.hover
    }), _defineProperty(_option, "&:active", {
      backgroundColor: theme.palette.action.selected
    }), _defineProperty(_option, '&[aria-disabled="true"]', {
      opacity: theme.palette.action.disabledOpacity,
      pointerEvents: "none"
    }), _option),
    /* Styles applied to the group's label elements. */
    groupLabel: {
      backgroundColor: theme.palette.background.paper,
      top: -8
    },
    /* Styles applied to the group's ul elements. */
    groupUl: {
      padding: 0,
      "& $option": {
        paddingLeft: 24
      }
    }
  };
};
function DisablePortal(props) {
  var anchorEl = props.anchorEl, open = props.open, other = _objectWithoutProperties(props, ["anchorEl", "open"]);
  return React10.createElement("div", other);
}
var _ref2 = React10.createElement(Close_default, {
  fontSize: "small"
});
var _ref22 = React10.createElement(ArrowDropDown_default, null);
var Autocomplete = React10.forwardRef(function Autocomplete2(props, ref) {
  var _props$autoComplete = props.autoComplete, autoComplete = _props$autoComplete === void 0 ? false : _props$autoComplete, _props$autoHighlight = props.autoHighlight, autoHighlight = _props$autoHighlight === void 0 ? false : _props$autoHighlight, _props$autoSelect = props.autoSelect, autoSelect = _props$autoSelect === void 0 ? false : _props$autoSelect, _props$blurOnSelect = props.blurOnSelect, blurOnSelect = _props$blurOnSelect === void 0 ? false : _props$blurOnSelect, ChipProps = props.ChipProps, classes = props.classes, className = props.className, _props$clearOnBlur = props.clearOnBlur, clearOnBlur = _props$clearOnBlur === void 0 ? !props.freeSolo : _props$clearOnBlur, _props$clearOnEscape = props.clearOnEscape, clearOnEscape = _props$clearOnEscape === void 0 ? false : _props$clearOnEscape, _props$clearText = props.clearText, clearText = _props$clearText === void 0 ? "Clear" : _props$clearText, _props$closeIcon = props.closeIcon, closeIcon = _props$closeIcon === void 0 ? _ref2 : _props$closeIcon, _props$closeText = props.closeText, closeText = _props$closeText === void 0 ? "Close" : _props$closeText, _props$debug = props.debug, debug = _props$debug === void 0 ? false : _props$debug, _props$defaultValue = props.defaultValue, defaultValue = _props$defaultValue === void 0 ? props.multiple ? [] : null : _props$defaultValue, _props$disableClearab = props.disableClearable, disableClearable = _props$disableClearab === void 0 ? false : _props$disableClearab, _props$disableCloseOn = props.disableCloseOnSelect, disableCloseOnSelect = _props$disableCloseOn === void 0 ? false : _props$disableCloseOn, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, _props$disabledItemsF = props.disabledItemsFocusable, disabledItemsFocusable = _props$disabledItemsF === void 0 ? false : _props$disabledItemsF, _props$disableListWra = props.disableListWrap, disableListWrap = _props$disableListWra === void 0 ? false : _props$disableListWra, _props$disablePortal = props.disablePortal, disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal, filterOptions = props.filterOptions, _props$filterSelected = props.filterSelectedOptions, filterSelectedOptions = _props$filterSelected === void 0 ? false : _props$filterSelected, _props$forcePopupIcon = props.forcePopupIcon, forcePopupIcon = _props$forcePopupIcon === void 0 ? "auto" : _props$forcePopupIcon, _props$freeSolo = props.freeSolo, freeSolo = _props$freeSolo === void 0 ? false : _props$freeSolo, _props$fullWidth = props.fullWidth, fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth, _props$getLimitTagsTe = props.getLimitTagsText, getLimitTagsText = _props$getLimitTagsTe === void 0 ? function(more2) {
    return "+".concat(more2);
  } : _props$getLimitTagsTe, getOptionDisabled = props.getOptionDisabled, _props$getOptionLabel = props.getOptionLabel, getOptionLabel = _props$getOptionLabel === void 0 ? function(x) {
    return x;
  } : _props$getOptionLabel, getOptionSelected = props.getOptionSelected, groupBy = props.groupBy, _props$handleHomeEndK = props.handleHomeEndKeys, handleHomeEndKeys = _props$handleHomeEndK === void 0 ? !props.freeSolo : _props$handleHomeEndK, idProp = props.id, _props$includeInputIn = props.includeInputInList, includeInputInList = _props$includeInputIn === void 0 ? false : _props$includeInputIn, inputValueProp = props.inputValue, _props$limitTags = props.limitTags, limitTags = _props$limitTags === void 0 ? -1 : _props$limitTags, _props$ListboxCompone = props.ListboxComponent, ListboxComponent = _props$ListboxCompone === void 0 ? "ul" : _props$ListboxCompone, ListboxProps = props.ListboxProps, _props$loading = props.loading, loading = _props$loading === void 0 ? false : _props$loading, _props$loadingText = props.loadingText, loadingText = _props$loadingText === void 0 ? "Loading…" : _props$loadingText, _props$multiple = props.multiple, multiple = _props$multiple === void 0 ? false : _props$multiple, _props$noOptionsText = props.noOptionsText, noOptionsText = _props$noOptionsText === void 0 ? "No options" : _props$noOptionsText, onChange = props.onChange, onClose = props.onClose, onHighlightChange = props.onHighlightChange, onInputChange = props.onInputChange, onOpen = props.onOpen, open = props.open, _props$openOnFocus = props.openOnFocus, openOnFocus = _props$openOnFocus === void 0 ? false : _props$openOnFocus, _props$openText = props.openText, openText = _props$openText === void 0 ? "Open" : _props$openText, options = props.options, _props$PaperComponent = props.PaperComponent, PaperComponent = _props$PaperComponent === void 0 ? Paper_default : _props$PaperComponent, _props$PopperComponen = props.PopperComponent, PopperComponentProp = _props$PopperComponen === void 0 ? Popper_default : _props$PopperComponen, _props$popupIcon = props.popupIcon, popupIcon = _props$popupIcon === void 0 ? _ref22 : _props$popupIcon, renderGroupProp = props.renderGroup, renderInput = props.renderInput, renderOptionProp = props.renderOption, renderTags = props.renderTags, _props$selectOnFocus = props.selectOnFocus, selectOnFocus = _props$selectOnFocus === void 0 ? !props.freeSolo : _props$selectOnFocus, _props$size = props.size, size = _props$size === void 0 ? "medium" : _props$size, valueProp = props.value, other = _objectWithoutProperties(props, ["autoComplete", "autoHighlight", "autoSelect", "blurOnSelect", "ChipProps", "classes", "className", "clearOnBlur", "clearOnEscape", "clearText", "closeIcon", "closeText", "debug", "defaultValue", "disableClearable", "disableCloseOnSelect", "disabled", "disabledItemsFocusable", "disableListWrap", "disablePortal", "filterOptions", "filterSelectedOptions", "forcePopupIcon", "freeSolo", "fullWidth", "getLimitTagsText", "getOptionDisabled", "getOptionLabel", "getOptionSelected", "groupBy", "handleHomeEndKeys", "id", "includeInputInList", "inputValue", "limitTags", "ListboxComponent", "ListboxProps", "loading", "loadingText", "multiple", "noOptionsText", "onChange", "onClose", "onHighlightChange", "onInputChange", "onOpen", "open", "openOnFocus", "openText", "options", "PaperComponent", "PopperComponent", "popupIcon", "renderGroup", "renderInput", "renderOption", "renderTags", "selectOnFocus", "size", "value"]);
  var PopperComponent = disablePortal ? DisablePortal : PopperComponentProp;
  var _useAutocomplete = useAutocomplete(_extends({}, props, {
    componentName: "Autocomplete"
  })), getRootProps = _useAutocomplete.getRootProps, getInputProps = _useAutocomplete.getInputProps, getInputLabelProps = _useAutocomplete.getInputLabelProps, getPopupIndicatorProps = _useAutocomplete.getPopupIndicatorProps, getClearProps = _useAutocomplete.getClearProps, getTagProps = _useAutocomplete.getTagProps, getListboxProps = _useAutocomplete.getListboxProps, getOptionProps = _useAutocomplete.getOptionProps, value = _useAutocomplete.value, dirty = _useAutocomplete.dirty, id = _useAutocomplete.id, popupOpen = _useAutocomplete.popupOpen, focused = _useAutocomplete.focused, focusedTag = _useAutocomplete.focusedTag, anchorEl = _useAutocomplete.anchorEl, setAnchorEl = _useAutocomplete.setAnchorEl, inputValue = _useAutocomplete.inputValue, groupedOptions = _useAutocomplete.groupedOptions;
  var startAdornment;
  if (multiple && value.length > 0) {
    var getCustomizedTagProps = function getCustomizedTagProps2(params) {
      return _extends({
        className: clsx_m_default(classes.tag, size === "small" && classes.tagSizeSmall),
        disabled
      }, getTagProps(params));
    };
    if (renderTags) {
      startAdornment = renderTags(value, getCustomizedTagProps);
    } else {
      startAdornment = value.map(function(option, index) {
        return React10.createElement(Chip_default, _extends({
          label: getOptionLabel(option),
          size
        }, getCustomizedTagProps({
          index
        }), ChipProps));
      });
    }
  }
  if (limitTags > -1 && Array.isArray(startAdornment)) {
    var more = startAdornment.length - limitTags;
    if (!focused && more > 0) {
      startAdornment = startAdornment.splice(0, limitTags);
      startAdornment.push(React10.createElement("span", {
        className: classes.tag,
        key: startAdornment.length
      }, getLimitTagsText(more)));
    }
  }
  var defaultRenderGroup = function defaultRenderGroup2(params) {
    return React10.createElement("li", {
      key: params.key
    }, React10.createElement(ListSubheader_default, {
      className: classes.groupLabel,
      component: "div"
    }, params.group), React10.createElement("ul", {
      className: classes.groupUl
    }, params.children));
  };
  var renderGroup = renderGroupProp || defaultRenderGroup;
  var renderOption = renderOptionProp || getOptionLabel;
  var renderListOption = function renderListOption2(option, index) {
    var optionProps = getOptionProps({
      option,
      index
    });
    return React10.createElement("li", _extends({}, optionProps, {
      className: classes.option
    }), renderOption(option, {
      selected: optionProps["aria-selected"],
      inputValue
    }));
  };
  var hasClearIcon = !disableClearable && !disabled;
  var hasPopupIcon = (!freeSolo || forcePopupIcon === true) && forcePopupIcon !== false;
  return React10.createElement(React10.Fragment, null, React10.createElement("div", _extends({
    ref,
    className: clsx_m_default(classes.root, className, focused && classes.focused, fullWidth && classes.fullWidth, hasClearIcon && classes.hasClearIcon, hasPopupIcon && classes.hasPopupIcon)
  }, getRootProps(other)), renderInput({
    id,
    disabled,
    fullWidth: true,
    size: size === "small" ? "small" : void 0,
    InputLabelProps: getInputLabelProps(),
    InputProps: {
      ref: setAnchorEl,
      className: classes.inputRoot,
      startAdornment,
      endAdornment: React10.createElement("div", {
        className: classes.endAdornment
      }, hasClearIcon ? React10.createElement(IconButton_default, _extends({}, getClearProps(), {
        "aria-label": clearText,
        title: clearText,
        className: clsx_m_default(classes.clearIndicator, dirty && classes.clearIndicatorDirty)
      }), closeIcon) : null, hasPopupIcon ? React10.createElement(IconButton_default, _extends({}, getPopupIndicatorProps(), {
        disabled,
        "aria-label": popupOpen ? closeText : openText,
        title: popupOpen ? closeText : openText,
        className: clsx_m_default(classes.popupIndicator, popupOpen && classes.popupIndicatorOpen)
      }), popupIcon) : null)
    },
    inputProps: _extends({
      className: clsx_m_default(classes.input, focusedTag === -1 && classes.inputFocused),
      disabled
    }, getInputProps())
  })), popupOpen && anchorEl ? React10.createElement(PopperComponent, {
    className: clsx_m_default(classes.popper, disablePortal && classes.popperDisablePortal),
    style: {
      width: anchorEl ? anchorEl.clientWidth : null
    },
    role: "presentation",
    anchorEl,
    open: true
  }, React10.createElement(PaperComponent, {
    className: classes.paper
  }, loading && groupedOptions.length === 0 ? React10.createElement("div", {
    className: classes.loading
  }, loadingText) : null, groupedOptions.length === 0 && !freeSolo && !loading ? React10.createElement("div", {
    className: classes.noOptions
  }, noOptionsText) : null, groupedOptions.length > 0 ? React10.createElement(ListboxComponent, _extends({
    className: classes.listbox
  }, getListboxProps(), ListboxProps), groupedOptions.map(function(option, index) {
    if (groupBy) {
      return renderGroup({
        key: option.key,
        group: option.group,
        children: option.options.map(function(option2, index2) {
          return renderListOption(option2, option.index + index2);
        })
      });
    }
    return renderListOption(option, index);
  })) : null)) : null);
});
true ? Autocomplete.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the portion of the selected suggestion that has not been typed by the user,
   * known as the completion string, appears inline after the input cursor in the textbox.
   * The inline completion string is visually highlighted and has a selected state.
   */
  autoComplete: import_prop_types3.default.bool,
  /**
   * If `true`, the first option is automatically highlighted.
   */
  autoHighlight: import_prop_types3.default.bool,
  /**
   * If `true`, the selected option becomes the value of the input
   * when the Autocomplete loses focus unless the user chooses
   * a different option or changes the character string in the input.
   */
  autoSelect: import_prop_types3.default.bool,
  /**
   * Control if the input should be blurred when an option is selected:
   *
   * - `false` the input is not blurred.
   * - `true` the input is always blurred.
   * - `touch` the input is blurred after a touch event.
   * - `mouse` the input is blurred after a mouse event.
   */
  blurOnSelect: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf(["mouse", "touch"]), import_prop_types3.default.bool]),
  /**
   * Props applied to the [`Chip`](/api/chip/) element.
   */
  ChipProps: import_prop_types3.default.object,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types3.default.object,
  /**
   * @ignore
   */
  className: import_prop_types3.default.string,
  /**
   * If `true`, the input's text will be cleared on blur if no value is selected.
   *
   * Set to `true` if you want to help the user enter a new value.
   * Set to `false` if you want to help the user resume his search.
   */
  clearOnBlur: import_prop_types3.default.bool,
  /**
   * If `true`, clear all values when the user presses escape and the popup is closed.
   */
  clearOnEscape: import_prop_types3.default.bool,
  /**
   * Override the default text for the *clear* icon button.
   *
   * For localization purposes, you can use the provided [translations](/guides/localization/).
   */
  clearText: import_prop_types3.default.string,
  /**
   * The icon to display in place of the default close icon.
   */
  closeIcon: import_prop_types3.default.node,
  /**
   * Override the default text for the *close popup* icon button.
   *
   * For localization purposes, you can use the provided [translations](/guides/localization/).
   */
  closeText: import_prop_types3.default.string,
  /**
   * If `true`, the popup will ignore the blur event if the input is filled.
   * You can inspect the popup markup with your browser tools.
   * Consider this option when you need to customize the component.
   */
  debug: import_prop_types3.default.bool,
  /**
   * The default input value. Use when the component is not controlled.
   */
  defaultValue: import_prop_types3.default.any,
  /**
   * If `true`, the input can't be cleared.
   */
  disableClearable: import_prop_types3.default.bool,
  /**
   * If `true`, the popup won't close when a value is selected.
   */
  disableCloseOnSelect: import_prop_types3.default.bool,
  /**
   * If `true`, the input will be disabled.
   */
  disabled: import_prop_types3.default.bool,
  /**
   * If `true`, will allow focus on disabled items.
   */
  disabledItemsFocusable: import_prop_types3.default.bool,
  /**
   * If `true`, the list box in the popup will not wrap focus.
   */
  disableListWrap: import_prop_types3.default.bool,
  /**
   * Disable the portal behavior.
   * The children stay within it's parent DOM hierarchy.
   */
  disablePortal: import_prop_types3.default.bool,
  /**
   * A filter function that determines the options that are eligible.
   *
   * @param {T[]} options The options to render.
   * @param {object} state The state of the component.
   * @returns {T[]}
   */
  filterOptions: import_prop_types3.default.func,
  /**
   * If `true`, hide the selected options from the list box.
   */
  filterSelectedOptions: import_prop_types3.default.bool,
  /**
   * Force the visibility display of the popup icon.
   */
  forcePopupIcon: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf(["auto"]), import_prop_types3.default.bool]),
  /**
   * If `true`, the Autocomplete is free solo, meaning that the user input is not bound to provided options.
   */
  freeSolo: import_prop_types3.default.bool,
  /**
   * If `true`, the input will take up the full width of its container.
   */
  fullWidth: import_prop_types3.default.bool,
  /**
   * The label to display when the tags are truncated (`limitTags`).
   *
   * @param {number} more The number of truncated tags.
   * @returns {ReactNode}
   */
  getLimitTagsText: import_prop_types3.default.func,
  /**
   * Used to determine the disabled state for a given option.
   *
   * @param {T} option The option to test.
   * @returns {boolean}
   */
  getOptionDisabled: import_prop_types3.default.func,
  /**
   * Used to determine the string value for a given option.
   * It's used to fill the input (and the list box options if `renderOption` is not provided).
   *
   * @param {T} option
   * @returns {string}
   */
  getOptionLabel: import_prop_types3.default.func,
  /**
   * Used to determine if an option is selected, considering the current value.
   * Uses strict equality by default.
   *
   * @param {T} option The option to test.
   * @param {T} value The value to test against.
   * @returns {boolean}
   */
  getOptionSelected: import_prop_types3.default.func,
  /**
   * If provided, the options will be grouped under the returned string.
   * The groupBy value is also used as the text for group headings when `renderGroup` is not provided.
   *
   * @param {T} options The options to group.
   * @returns {string}
   */
  groupBy: import_prop_types3.default.func,
  /**
   * If `true`, the component handles the "Home" and "End" keys when the popup is open.
   * It should move focus to the first option and last option, respectively.
   */
  handleHomeEndKeys: import_prop_types3.default.bool,
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types3.default.string,
  /**
   * If `true`, the highlight can move to the input.
   */
  includeInputInList: import_prop_types3.default.bool,
  /**
   * The input value.
   */
  inputValue: import_prop_types3.default.string,
  /**
   * The maximum number of tags that will be visible when not focused.
   * Set `-1` to disable the limit.
   */
  limitTags: import_prop_types3.default.number,
  /**
   * The component used to render the listbox.
   */
  ListboxComponent: import_prop_types3.default.elementType,
  /**
   * Props applied to the Listbox element.
   */
  ListboxProps: import_prop_types3.default.object,
  /**
   * If `true`, the component is in a loading state.
   */
  loading: import_prop_types3.default.bool,
  /**
   * Text to display when in a loading state.
   *
   * For localization purposes, you can use the provided [translations](/guides/localization/).
   */
  loadingText: import_prop_types3.default.node,
  /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   */
  multiple: import_prop_types3.default.bool,
  /**
   * Text to display when there are no options.
   *
   * For localization purposes, you can use the provided [translations](/guides/localization/).
   */
  noOptionsText: import_prop_types3.default.node,
  /**
   * Callback fired when the value changes.
   *
   * @param {object} event The event source of the callback.
   * @param {T|T[]} value The new value of the component.
   * @param {string} reason One of "create-option", "select-option", "remove-option", "blur" or "clear".
   */
  onChange: import_prop_types3.default.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"toggleInput"`, `"escape"`, `"select-option"`, `"blur"`.
   */
  onClose: import_prop_types3.default.func,
  /**
   * Callback fired when the highlight option changes.
   *
   * @param {object} event The event source of the callback.
   * @param {T} option The highlighted option.
   * @param {string} reason Can be: `"keyboard"`, `"auto"`, `"mouse"`.
   */
  onHighlightChange: import_prop_types3.default.func,
  /**
   * Callback fired when the input value changes.
   *
   * @param {object} event The event source of the callback.
   * @param {string} value The new value of the text input.
   * @param {string} reason Can be: `"input"` (user input), `"reset"` (programmatic change), `"clear"`.
   */
  onInputChange: import_prop_types3.default.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: import_prop_types3.default.func,
  /**
   * Control the popup` open state.
   */
  open: import_prop_types3.default.bool,
  /**
   * If `true`, the popup will open on input focus.
   */
  openOnFocus: import_prop_types3.default.bool,
  /**
   * Override the default text for the *open popup* icon button.
   *
   * For localization purposes, you can use the provided [translations](/guides/localization/).
   */
  openText: import_prop_types3.default.string,
  /**
   * Array of options.
   */
  options: import_prop_types3.default.array.isRequired,
  /**
   * The component used to render the body of the popup.
   */
  PaperComponent: import_prop_types3.default.elementType,
  /**
   * The component used to position the popup.
   */
  PopperComponent: import_prop_types3.default.elementType,
  /**
   * The icon to display in place of the default popup icon.
   */
  popupIcon: import_prop_types3.default.node,
  /**
   * Render the group.
   *
   * @param {any} option The group to render.
   * @returns {ReactNode}
   */
  renderGroup: import_prop_types3.default.func,
  /**
   * Render the input.
   *
   * @param {object} params
   * @returns {ReactNode}
   */
  renderInput: import_prop_types3.default.func.isRequired,
  /**
   * Render the option, use `getOptionLabel` by default.
   *
   * @param {T} option The option to render.
   * @param {object} state The state of the component.
   * @returns {ReactNode}
   */
  renderOption: import_prop_types3.default.func,
  /**
   * Render the selected value.
   *
   * @param {T[]} value The `value` provided to the component.
   * @param {function} getTagProps A tag props getter.
   * @returns {ReactNode}
   */
  renderTags: import_prop_types3.default.func,
  /**
   * If `true`, the input's text will be selected on focus.
   * It helps the user clear the selected value.
   */
  selectOnFocus: import_prop_types3.default.bool,
  /**
   * The size of the autocomplete.
   */
  size: import_prop_types3.default.oneOf(["medium", "small"]),
  /**
   * The value of the autocomplete.
   *
   * The value must have reference equality with the option in order to be selected.
   * You can customize the equality behavior with the `getOptionSelected` prop.
   */
  value: import_prop_types3.default.any
} : void 0;
var Autocomplete_default = withStyles_default(styles5, {
  name: "MuiAutocomplete"
})(Autocomplete);

// ../node_modules/@material-ui/lab/esm/AvatarGroup/AvatarGroup.js
init_extends();
init_objectWithoutProperties();
var React11 = __toESM(require_react());
var import_prop_types4 = __toESM(require_prop_types());
var import_react_is = __toESM(require_react_is());
init_clsx_m();
init_esm();
var SPACINGS = {
  small: -16,
  medium: null
};
var styles7 = function styles8(theme) {
  return {
    /* Styles applied to the root element. */
    root: {
      display: "flex"
    },
    /* Styles applied to the avatar elements. */
    avatar: {
      border: "2px solid ".concat(theme.palette.background.default),
      marginLeft: -8,
      "&:first-child": {
        marginLeft: 0
      }
    }
  };
};
var AvatarGroup = React11.forwardRef(function AvatarGroup2(props, ref) {
  var childrenProp = props.children, classes = props.classes, className = props.className, _props$max = props.max, max = _props$max === void 0 ? 5 : _props$max, _props$spacing = props.spacing, spacing = _props$spacing === void 0 ? "medium" : _props$spacing, other = _objectWithoutProperties(props, ["children", "classes", "className", "max", "spacing"]);
  var clampedMax = max < 2 ? 2 : max;
  var children = React11.Children.toArray(childrenProp).filter(function(child) {
    if (true) {
      if ((0, import_react_is.isFragment)(child)) {
        console.error(["Material-UI: The AvatarGroup component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join("\n"));
      }
    }
    return React11.isValidElement(child);
  });
  var extraAvatars = children.length > clampedMax ? children.length - clampedMax + 1 : 0;
  var marginLeft = spacing && SPACINGS[spacing] !== void 0 ? SPACINGS[spacing] : -spacing;
  return React11.createElement("div", _extends({
    className: clsx_m_default(classes.root, className),
    ref
  }, other), children.slice(0, children.length - extraAvatars).map(function(child, index) {
    return React11.cloneElement(child, {
      className: clsx_m_default(child.props.className, classes.avatar),
      style: _extends({
        zIndex: children.length - index,
        marginLeft: index === 0 ? void 0 : marginLeft
      }, child.props.style)
    });
  }), extraAvatars ? React11.createElement(Avatar_default, {
    className: classes.avatar,
    style: {
      zIndex: 0,
      marginLeft
    }
  }, "+", extraAvatars) : null);
});
true ? AvatarGroup.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The avatars to stack.
   */
  children: import_prop_types4.default.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types4.default.object,
  /**
   * @ignore
   */
  className: import_prop_types4.default.string,
  /**
   * Max avatars to show before +x.
   */
  max: chainPropTypes(import_prop_types4.default.number, function(props) {
    if (props.max < 2) {
      throw new Error(["Material-UI: The prop `max` should be equal to 2 or above.", "A value below is clamped to 2."].join("\n"));
    }
  }),
  /**
   * Spacing between avatars.
   */
  spacing: import_prop_types4.default.oneOfType([import_prop_types4.default.oneOf(["medium", "small"]), import_prop_types4.default.number])
} : void 0;
var AvatarGroup_default = withStyles_default(styles7, {
  name: "MuiAvatarGroup"
})(AvatarGroup);

// ../node_modules/@material-ui/lab/esm/Rating/Rating.js
init_extends();
init_slicedToArray();
init_objectWithoutProperties();
var React13 = __toESM(require_react());
var import_prop_types5 = __toESM(require_prop_types());
init_clsx_m();
init_esm();
init_utils();

// ../node_modules/@material-ui/lab/esm/internal/svg-icons/Star.js
var React12 = __toESM(require_react());
init_utils();
var Star_default = createSvgIcon(React12.createElement("path", {
  d: "M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"
}), "Star");

// ../node_modules/@material-ui/lab/esm/Rating/Rating.js
function clamp(value, min, max) {
  if (value < min) {
    return min;
  }
  if (value > max) {
    return max;
  }
  return value;
}
function getDecimalPrecision(num) {
  var decimalPart = num.toString().split(".")[1];
  return decimalPart ? decimalPart.length : 0;
}
function roundValueToPrecision(value, precision) {
  if (value == null) {
    return value;
  }
  var nearest = Math.round(value / precision) * precision;
  return Number(nearest.toFixed(getDecimalPrecision(precision)));
}
var styles9 = function styles10(theme) {
  return {
    /* Styles applied to the root element. */
    root: {
      display: "inline-flex",
      position: "relative",
      fontSize: theme.typography.pxToRem(24),
      color: "#ffb400",
      cursor: "pointer",
      textAlign: "left",
      WebkitTapHighlightColor: "transparent",
      "&$disabled": {
        opacity: 0.5,
        pointerEvents: "none"
      },
      "&$focusVisible $iconActive": {
        outline: "1px solid #999"
      }
    },
    /* Styles applied to the root element if `size="small"`. */
    sizeSmall: {
      fontSize: theme.typography.pxToRem(18)
    },
    /* Styles applied to the root element if `size="large"`. */
    sizeLarge: {
      fontSize: theme.typography.pxToRem(30)
    },
    /* Styles applied to the root element if `readOnly={true}`. */
    readOnly: {
      pointerEvents: "none"
    },
    /* Pseudo-class applied to the root element if `disabled={true}`. */
    disabled: {},
    /* Pseudo-class applied to the root element if keyboard focused. */
    focusVisible: {},
    /* Visually hide an element. */
    visuallyhidden: {
      border: 0,
      clip: "rect(0 0 0 0)",
      height: 1,
      margin: -1,
      color: "#000",
      overflow: "hidden",
      padding: 0,
      position: "absolute",
      top: 20,
      width: 1
    },
    /* Styles applied to the pristine label. */
    pristine: {
      "input:focus + &": {
        top: 0,
        bottom: 0,
        position: "absolute",
        outline: "1px solid #999",
        width: "100%"
      }
    },
    /* Styles applied to the label elements. */
    label: {
      cursor: "inherit"
    },
    /* Styles applied to the icon wrapping elements. */
    icon: {
      display: "flex",
      transition: theme.transitions.create("transform", {
        duration: theme.transitions.duration.shortest
      }),
      // Fix mouseLeave issue.
      // https://github.com/facebook/react/issues/4492
      pointerEvents: "none"
    },
    /* Styles applied to the icon wrapping elements when empty. */
    iconEmpty: {
      color: theme.palette.action.disabled
    },
    /* Styles applied to the icon wrapping elements when filled. */
    iconFilled: {},
    /* Styles applied to the icon wrapping elements when hover. */
    iconHover: {},
    /* Styles applied to the icon wrapping elements when focus. */
    iconFocus: {},
    /* Styles applied to the icon wrapping elements when active. */
    iconActive: {
      transform: "scale(1.2)"
    },
    /* Styles applied to the icon wrapping elements when decimals are necessary. */
    decimal: {
      position: "relative"
    }
  };
};
function IconContainer(props) {
  var value = props.value, other = _objectWithoutProperties(props, ["value"]);
  return React13.createElement("span", other);
}
true ? IconContainer.propTypes = {
  value: import_prop_types5.default.number.isRequired
} : void 0;
var defaultIcon = React13.createElement(Star_default, {
  fontSize: "inherit"
});
function defaultLabelText(value) {
  return "".concat(value, " Star").concat(value !== 1 ? "s" : "");
}
var Rating = React13.forwardRef(function Rating2(props, ref) {
  var classes = props.classes, className = props.className, _props$defaultValue = props.defaultValue, defaultValue = _props$defaultValue === void 0 ? null : _props$defaultValue, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, emptyIcon = props.emptyIcon, _props$emptyLabelText = props.emptyLabelText, emptyLabelText = _props$emptyLabelText === void 0 ? "Empty" : _props$emptyLabelText, _props$getLabelText = props.getLabelText, getLabelText = _props$getLabelText === void 0 ? defaultLabelText : _props$getLabelText, _props$icon = props.icon, icon = _props$icon === void 0 ? defaultIcon : _props$icon, _props$IconContainerC = props.IconContainerComponent, IconContainerComponent = _props$IconContainerC === void 0 ? IconContainer : _props$IconContainerC, _props$max = props.max, max = _props$max === void 0 ? 5 : _props$max, nameProp = props.name, onChange = props.onChange, onChangeActive = props.onChangeActive, onMouseLeave = props.onMouseLeave, onMouseMove = props.onMouseMove, _props$precision = props.precision, precision = _props$precision === void 0 ? 1 : _props$precision, _props$readOnly = props.readOnly, readOnly = _props$readOnly === void 0 ? false : _props$readOnly, _props$size = props.size, size = _props$size === void 0 ? "medium" : _props$size, valueProp = props.value, other = _objectWithoutProperties(props, ["classes", "className", "defaultValue", "disabled", "emptyIcon", "emptyLabelText", "getLabelText", "icon", "IconContainerComponent", "max", "name", "onChange", "onChangeActive", "onMouseLeave", "onMouseMove", "precision", "readOnly", "size", "value"]);
  var name = useId(nameProp);
  var _useControlled = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "Rating"
  }), _useControlled2 = _slicedToArray(_useControlled, 2), valueDerived = _useControlled2[0], setValueState = _useControlled2[1];
  var valueRounded = roundValueToPrecision(valueDerived, precision);
  var theme = useTheme();
  var _React$useState = React13.useState({
    hover: -1,
    focus: -1
  }), _React$useState$ = _React$useState[0], hover = _React$useState$.hover, focus = _React$useState$.focus, setState = _React$useState[1];
  var value = valueRounded;
  if (hover !== -1) {
    value = hover;
  }
  if (focus !== -1) {
    value = focus;
  }
  var _useIsFocusVisible = useIsFocusVisible(), isFocusVisible = _useIsFocusVisible.isFocusVisible, onBlurVisible = _useIsFocusVisible.onBlurVisible, focusVisibleRef = _useIsFocusVisible.ref;
  var _React$useState2 = React13.useState(false), focusVisible = _React$useState2[0], setFocusVisible = _React$useState2[1];
  var rootRef = React13.useRef();
  var handleFocusRef = useForkRef(focusVisibleRef, rootRef);
  var handleRef = useForkRef(handleFocusRef, ref);
  var handleMouseMove = function handleMouseMove2(event) {
    if (onMouseMove) {
      onMouseMove(event);
    }
    var rootNode = rootRef.current;
    var _rootNode$getBounding = rootNode.getBoundingClientRect(), right = _rootNode$getBounding.right, left = _rootNode$getBounding.left;
    var _rootNode$firstChild$ = rootNode.firstChild.getBoundingClientRect(), width = _rootNode$firstChild$.width;
    var percent;
    if (theme.direction === "rtl") {
      percent = (right - event.clientX) / (width * max);
    } else {
      percent = (event.clientX - left) / (width * max);
    }
    var newHover = roundValueToPrecision(max * percent + precision / 2, precision);
    newHover = clamp(newHover, precision, max);
    setState(function(prev) {
      return prev.hover === newHover && prev.focus === newHover ? prev : {
        hover: newHover,
        focus: newHover
      };
    });
    setFocusVisible(false);
    if (onChangeActive && hover !== newHover) {
      onChangeActive(event, newHover);
    }
  };
  var handleMouseLeave = function handleMouseLeave2(event) {
    if (onMouseLeave) {
      onMouseLeave(event);
    }
    var newHover = -1;
    setState({
      hover: newHover,
      focus: newHover
    });
    if (onChangeActive && hover !== newHover) {
      onChangeActive(event, newHover);
    }
  };
  var handleChange = function handleChange2(event) {
    var newValue = parseFloat(event.target.value);
    setValueState(newValue);
    if (onChange) {
      onChange(event, newValue);
    }
  };
  var handleClear = function handleClear2(event) {
    if (event.clientX === 0 && event.clientY === 0) {
      return;
    }
    setState({
      hover: -1,
      focus: -1
    });
    setValueState(null);
    if (onChange && parseFloat(event.target.value) === valueRounded) {
      onChange(event, null);
    }
  };
  var handleFocus = function handleFocus2(event) {
    if (isFocusVisible(event)) {
      setFocusVisible(true);
    }
    var newFocus = parseFloat(event.target.value);
    setState(function(prev) {
      return {
        hover: prev.hover,
        focus: newFocus
      };
    });
    if (onChangeActive && focus !== newFocus) {
      onChangeActive(event, newFocus);
    }
  };
  var handleBlur = function handleBlur2(event) {
    if (hover !== -1) {
      return;
    }
    if (focusVisible !== false) {
      setFocusVisible(false);
      onBlurVisible();
    }
    var newFocus = -1;
    setState(function(prev) {
      return {
        hover: prev.hover,
        focus: newFocus
      };
    });
    if (onChangeActive && focus !== newFocus) {
      onChangeActive(event, newFocus);
    }
  };
  var item = function item2(state, labelProps) {
    var id = "".concat(name, "-").concat(String(state.value).replace(".", "-"));
    var container = React13.createElement(IconContainerComponent, {
      value: state.value,
      className: clsx_m_default(classes.icon, state.filled ? classes.iconFilled : classes.iconEmpty, state.hover && classes.iconHover, state.focus && classes.iconFocus, state.active && classes.iconActive)
    }, emptyIcon && !state.filled ? emptyIcon : icon);
    if (readOnly) {
      return React13.createElement("span", _extends({
        key: state.value
      }, labelProps), container);
    }
    return React13.createElement(React13.Fragment, {
      key: state.value
    }, React13.createElement("label", _extends({
      className: classes.label,
      htmlFor: id
    }, labelProps), container, React13.createElement("span", {
      className: classes.visuallyhidden
    }, getLabelText(state.value))), React13.createElement("input", {
      onFocus: handleFocus,
      onBlur: handleBlur,
      onChange: handleChange,
      onClick: handleClear,
      disabled,
      value: state.value,
      id,
      type: "radio",
      name,
      checked: state.checked,
      className: classes.visuallyhidden
    }));
  };
  return React13.createElement("span", _extends({
    ref: handleRef,
    onMouseMove: handleMouseMove,
    onMouseLeave: handleMouseLeave,
    className: clsx_m_default(classes.root, className, size !== "medium" && classes["size".concat(capitalize(size))], disabled && classes.disabled, focusVisible && classes.focusVisible, readOnly && classes.readOnly),
    role: readOnly ? "img" : null,
    "aria-label": readOnly ? getLabelText(value) : null
  }, other), Array.from(new Array(max)).map(function(_, index) {
    var itemValue = index + 1;
    if (precision < 1) {
      var items = Array.from(new Array(1 / precision));
      return React13.createElement("span", {
        key: itemValue,
        className: clsx_m_default(classes.decimal, itemValue === Math.ceil(value) && (hover !== -1 || focus !== -1) && classes.iconActive)
      }, items.map(function($, indexDecimal) {
        var itemDecimalValue = roundValueToPrecision(itemValue - 1 + (indexDecimal + 1) * precision, precision);
        return item({
          value: itemDecimalValue,
          filled: itemDecimalValue <= value,
          hover: itemDecimalValue <= hover,
          focus: itemDecimalValue <= focus,
          checked: itemDecimalValue === valueRounded
        }, {
          style: items.length - 1 === indexDecimal ? {} : {
            width: itemDecimalValue === value ? "".concat((indexDecimal + 1) * precision * 100, "%") : "0%",
            overflow: "hidden",
            zIndex: 1,
            position: "absolute"
          }
        });
      }));
    }
    return item({
      value: itemValue,
      active: itemValue === value && (hover !== -1 || focus !== -1),
      filled: itemValue <= value,
      hover: itemValue <= hover,
      focus: itemValue <= focus,
      checked: itemValue === valueRounded
    });
  }), !readOnly && !disabled && valueRounded == null && React13.createElement(React13.Fragment, null, React13.createElement("input", {
    value: "",
    id: "".concat(name, "-empty"),
    type: "radio",
    name,
    defaultChecked: true,
    className: classes.visuallyhidden
  }), React13.createElement("label", {
    className: classes.pristine,
    htmlFor: "".concat(name, "-empty")
  }, React13.createElement("span", {
    className: classes.visuallyhidden
  }, emptyLabelText))));
});
true ? Rating.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types5.default.object,
  /**
   * @ignore
   */
  className: import_prop_types5.default.string,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: import_prop_types5.default.number,
  /**
   * If `true`, the rating will be disabled.
   */
  disabled: import_prop_types5.default.bool,
  /**
   * The icon to display when empty.
   */
  emptyIcon: import_prop_types5.default.node,
  /**
   * The label read when the rating input is empty.
   */
  emptyLabelText: import_prop_types5.default.node,
  /**
   * Accepts a function which returns a string value that provides a user-friendly name for the current value of the rating.
   *
   * For localization purposes, you can use the provided [translations](/guides/localization/).
   *
   * @param {number} value The rating label's value to format.
   * @returns {string}
   */
  getLabelText: import_prop_types5.default.func,
  /**
   * The icon to display.
   */
  icon: import_prop_types5.default.node,
  /**
   * The component containing the icon.
   */
  IconContainerComponent: import_prop_types5.default.elementType,
  /**
   * Maximum rating.
   */
  max: import_prop_types5.default.number,
  /**
   * The name attribute of the radio `input` elements.
   * If `readOnly` is false, the prop is required,
   * this input name`should be unique within the parent form.
   */
  name: chainPropTypes(import_prop_types5.default.string, function(props) {
    if (!props.readOnly && !props.name) {
      return new Error(["Material-UI: The prop `name` is required (when `readOnly` is false).", "Additionally, the input name should be unique within the parent form."].join("\n"));
    }
    return null;
  }),
  /**
   * Callback fired when the value changes.
   *
   * @param {object} event The event source of the callback.
   * @param {number} value The new value.
   */
  onChange: import_prop_types5.default.func,
  /**
   * Callback function that is fired when the hover state changes.
   *
   * @param {object} event The event source of the callback.
   * @param {number} value The new value.
   */
  onChangeActive: import_prop_types5.default.func,
  /**
   * @ignore
   */
  onMouseLeave: import_prop_types5.default.func,
  /**
   * @ignore
   */
  onMouseMove: import_prop_types5.default.func,
  /**
   * The minimum increment value change allowed.
   */
  precision: chainPropTypes(import_prop_types5.default.number, function(props) {
    if (props.precision < 0.1) {
      return new Error(["Material-UI: The prop `precision` should be above 0.1.", "A value below this limit has an imperceptible impact."].join("\n"));
    }
    return null;
  }),
  /**
   * Removes all hover effects and pointer events.
   */
  readOnly: import_prop_types5.default.bool,
  /**
   * The size of the rating.
   */
  size: import_prop_types5.default.oneOf(["large", "medium", "small"]),
  /**
   * The rating value.
   */
  value: import_prop_types5.default.number
} : void 0;
var Rating_default = withStyles_default(styles9, {
  name: "MuiRating"
})(Rating);

// ../node_modules/@material-ui/lab/esm/Skeleton/Skeleton.js
init_extends();
init_objectWithoutProperties();
var React14 = __toESM(require_react());
init_clsx_m();
var import_prop_types6 = __toESM(require_prop_types());
var styles11 = function styles12(theme) {
  return {
    /* Styles applied to the root element. */
    root: {
      display: "block",
      // Create a "on paper" color with sufficient contrast retaining the color
      backgroundColor: alpha(theme.palette.text.primary, theme.palette.type === "light" ? 0.11 : 0.13),
      height: "1.2em"
    },
    /* Styles applied to the root element if `variant="text"`. */
    text: {
      marginTop: 0,
      marginBottom: 0,
      height: "auto",
      transformOrigin: "0 60%",
      transform: "scale(1, 0.60)",
      borderRadius: theme.shape.borderRadius,
      "&:empty:before": {
        content: '"\\00a0"'
      }
    },
    /* Styles applied to the root element if `variant="rect"`. */
    rect: {},
    /* Styles applied to the root element if `variant="circle"`. */
    circle: {
      borderRadius: "50%"
    },
    /* Styles applied to the root element if `animation="pulse"`. */
    pulse: {
      animation: "$pulse 1.5s ease-in-out 0.5s infinite"
    },
    "@keyframes pulse": {
      "0%": {
        opacity: 1
      },
      "50%": {
        opacity: 0.4
      },
      "100%": {
        opacity: 1
      }
    },
    /* Styles applied to the root element if `animation="wave"`. */
    wave: {
      position: "relative",
      overflow: "hidden",
      "&::after": {
        animation: "$wave 1.6s linear 0.5s infinite",
        background: "linear-gradient(90deg, transparent, ".concat(theme.palette.action.hover, ", transparent)"),
        content: '""',
        position: "absolute",
        transform: "translateX(-100%)",
        // Avoid flash during server-side hydration
        bottom: 0,
        left: 0,
        right: 0,
        top: 0
      }
    },
    "@keyframes wave": {
      "0%": {
        transform: "translateX(-100%)"
      },
      "60%": {
        // +0.5s of delay between each loop
        transform: "translateX(100%)"
      },
      "100%": {
        transform: "translateX(100%)"
      }
    },
    /* Styles applied when the component is passed children. */
    withChildren: {
      "& > *": {
        visibility: "hidden"
      }
    },
    /* Styles applied when the component is passed children and no width. */
    fitContent: {
      maxWidth: "fit-content"
    },
    /* Styles applied when the component is passed children and no height. */
    heightAuto: {
      height: "auto"
    }
  };
};
var Skeleton = React14.forwardRef(function Skeleton2(props, ref) {
  var _props$animation = props.animation, animation = _props$animation === void 0 ? "pulse" : _props$animation, classes = props.classes, className = props.className, _props$component = props.component, Component = _props$component === void 0 ? "span" : _props$component, height = props.height, _props$variant = props.variant, variant = _props$variant === void 0 ? "text" : _props$variant, width = props.width, other = _objectWithoutProperties(props, ["animation", "classes", "className", "component", "height", "variant", "width"]);
  var hasChildren = Boolean(other.children);
  return React14.createElement(Component, _extends({
    ref,
    className: clsx_m_default(classes.root, classes[variant], className, hasChildren && [classes.withChildren, !width && classes.fitContent, !height && classes.heightAuto], animation !== false && classes[animation])
  }, other, {
    style: _extends({
      width,
      height
    }, other.style)
  }));
});
true ? Skeleton.propTypes = {
  /**
   * The animation.
   * If `false` the animation effect is disabled.
   */
  animation: import_prop_types6.default.oneOf(["pulse", "wave", false]),
  /**
   * Optional children to infer width and height from.
   */
  children: import_prop_types6.default.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types6.default.object.isRequired,
  /**
   * @ignore
   */
  className: import_prop_types6.default.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: import_prop_types6.default.elementType,
  /**
   * Height of the skeleton.
   * Useful when you don't want to adapt the skeleton to a text element but for instance a card.
   */
  height: import_prop_types6.default.oneOfType([import_prop_types6.default.number, import_prop_types6.default.string]),
  /**
   * The type of content that will be rendered.
   */
  variant: import_prop_types6.default.oneOf(["text", "rect", "circle"]),
  /**
   * Width of the skeleton.
   * Useful when the skeleton is inside an inline element with no width of its own.
   */
  width: import_prop_types6.default.oneOfType([import_prop_types6.default.number, import_prop_types6.default.string])
} : void 0;
var Skeleton_default = withStyles_default(styles11, {
  name: "MuiSkeleton"
})(Skeleton);

// ../node_modules/@material-ui/lab/esm/SpeedDial/SpeedDial.js
init_extends();
init_objectWithoutProperties();
var React15 = __toESM(require_react());
var import_react_is2 = __toESM(require_react_is());
var import_prop_types7 = __toESM(require_prop_types());
init_clsx_m();
init_utils();
function getOrientation(direction) {
  if (direction === "up" || direction === "down") {
    return "vertical";
  }
  if (direction === "right" || direction === "left") {
    return "horizontal";
  }
  return void 0;
}
function clamp2(value, min, max) {
  if (value < min) {
    return min;
  }
  if (value > max) {
    return max;
  }
  return value;
}
var dialRadius = 32;
var spacingActions = 16;
var styles13 = function styles14(theme) {
  return {
    /* Styles applied to the root element. */
    root: {
      zIndex: theme.zIndex.speedDial,
      display: "flex",
      alignItems: "center",
      pointerEvents: "none"
    },
    /* Styles applied to the Fab component. */
    fab: {
      pointerEvents: "auto"
    },
    /* Styles applied to the root if direction="up" */
    directionUp: {
      flexDirection: "column-reverse",
      "& $actions": {
        flexDirection: "column-reverse",
        marginBottom: -dialRadius,
        paddingBottom: spacingActions + dialRadius
      }
    },
    /* Styles applied to the root if direction="down" */
    directionDown: {
      flexDirection: "column",
      "& $actions": {
        flexDirection: "column",
        marginTop: -dialRadius,
        paddingTop: spacingActions + dialRadius
      }
    },
    /* Styles applied to the root if direction="left" */
    directionLeft: {
      flexDirection: "row-reverse",
      "& $actions": {
        flexDirection: "row-reverse",
        marginRight: -dialRadius,
        paddingRight: spacingActions + dialRadius
      }
    },
    /* Styles applied to the root if direction="right" */
    directionRight: {
      flexDirection: "row",
      "& $actions": {
        flexDirection: "row",
        marginLeft: -dialRadius,
        paddingLeft: spacingActions + dialRadius
      }
    },
    /* Styles applied to the actions (`children` wrapper) element. */
    actions: {
      display: "flex",
      pointerEvents: "auto"
    },
    /* Styles applied to the actions (`children` wrapper) element if `open={false}`. */
    actionsClosed: {
      transition: "top 0s linear 0.2s",
      pointerEvents: "none"
    }
  };
};
var SpeedDial = React15.forwardRef(function SpeedDial2(props, ref) {
  var ariaLabel = props.ariaLabel, _props$FabProps = props.FabProps;
  _props$FabProps = _props$FabProps === void 0 ? {} : _props$FabProps;
  var origDialButtonRef = _props$FabProps.ref, FabProps = _objectWithoutProperties(_props$FabProps, ["ref"]), childrenProp = props.children, classes = props.classes, className = props.className, _props$direction = props.direction, direction = _props$direction === void 0 ? "up" : _props$direction, _props$hidden = props.hidden, hidden = _props$hidden === void 0 ? false : _props$hidden, icon = props.icon, onBlur = props.onBlur, onClose = props.onClose, onFocus = props.onFocus, onKeyDown = props.onKeyDown, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onOpen = props.onOpen, open = props.open, openIcon = props.openIcon, _props$TransitionComp = props.TransitionComponent, TransitionComponent = _props$TransitionComp === void 0 ? Zoom_default : _props$TransitionComp, _props$transitionDura = props.transitionDuration, transitionDuration = _props$transitionDura === void 0 ? {
    enter: duration.enteringScreen,
    exit: duration.leavingScreen
  } : _props$transitionDura, TransitionProps = props.TransitionProps, other = _objectWithoutProperties(props, ["ariaLabel", "FabProps", "children", "classes", "className", "direction", "hidden", "icon", "onBlur", "onClose", "onFocus", "onKeyDown", "onMouseEnter", "onMouseLeave", "onOpen", "open", "openIcon", "TransitionComponent", "transitionDuration", "TransitionProps"]);
  var eventTimer = React15.useRef();
  React15.useEffect(function() {
    return function() {
      clearTimeout(eventTimer.current);
    };
  }, []);
  var focusedAction = React15.useRef(0);
  var nextItemArrowKey = React15.useRef();
  var actions = React15.useRef([]);
  actions.current = [actions.current[0]];
  var handleOwnFabRef = React15.useCallback(function(fabFef) {
    actions.current[0] = fabFef;
  }, []);
  var handleFabRef = useForkRef(origDialButtonRef, handleOwnFabRef);
  var createHandleSpeedDialActionButtonRef = function createHandleSpeedDialActionButtonRef2(dialActionIndex, origButtonRef) {
    return function(buttonRef) {
      actions.current[dialActionIndex + 1] = buttonRef;
      if (origButtonRef) {
        origButtonRef(buttonRef);
      }
    };
  };
  var handleKeyDown = function handleKeyDown2(event) {
    if (onKeyDown) {
      onKeyDown(event);
    }
    var key = event.key.replace("Arrow", "").toLowerCase();
    var _nextItemArrowKey$cur = nextItemArrowKey.current, nextItemArrowKeyCurrent = _nextItemArrowKey$cur === void 0 ? key : _nextItemArrowKey$cur;
    if (event.key === "Escape") {
      if (onClose) {
        actions.current[0].focus();
        onClose(event, "escapeKeyDown");
      }
      return;
    }
    if (getOrientation(key) === getOrientation(nextItemArrowKeyCurrent) && getOrientation(key) !== void 0) {
      event.preventDefault();
      var actionStep = key === nextItemArrowKeyCurrent ? 1 : -1;
      var nextAction = clamp2(focusedAction.current + actionStep, 0, actions.current.length - 1);
      actions.current[nextAction].focus();
      focusedAction.current = nextAction;
      nextItemArrowKey.current = nextItemArrowKeyCurrent;
    }
  };
  React15.useEffect(function() {
    if (!open) {
      focusedAction.current = 0;
      nextItemArrowKey.current = void 0;
    }
  }, [open]);
  var handleClose = function handleClose2(event) {
    if (event.type === "mouseleave" && onMouseLeave) {
      onMouseLeave(event);
    }
    if (event.type === "blur" && onBlur) {
      onBlur(event);
    }
    clearTimeout(eventTimer.current);
    if (onClose) {
      if (event.type === "blur") {
        event.persist();
        eventTimer.current = setTimeout(function() {
          onClose(event, "blur");
        });
      } else {
        onClose(event, "mouseLeave");
      }
    }
  };
  var handleClick = function handleClick2(event) {
    if (FabProps.onClick) {
      FabProps.onClick(event);
    }
    clearTimeout(eventTimer.current);
    if (open) {
      if (onClose) {
        onClose(event, "toggle");
      }
    } else if (onOpen) {
      onOpen(event, "toggle");
    }
  };
  var handleOpen = function handleOpen2(event) {
    if (event.type === "mouseenter" && onMouseEnter) {
      onMouseEnter(event);
    }
    if (event.type === "focus" && onFocus) {
      onFocus(event);
    }
    clearTimeout(eventTimer.current);
    if (onOpen && !open) {
      event.persist();
      eventTimer.current = setTimeout(function() {
        var eventMap = {
          focus: "focus",
          mouseenter: "mouseEnter"
        };
        onOpen(event, eventMap[event.type]);
      });
    }
  };
  var id = ariaLabel.replace(/^[^a-z]+|[^\w:.-]+/gi, "");
  var allItems = React15.Children.toArray(childrenProp).filter(function(child) {
    if (true) {
      if ((0, import_react_is2.isFragment)(child)) {
        console.error(["Material-UI: The SpeedDial component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join("\n"));
      }
    }
    return React15.isValidElement(child);
  });
  var children = allItems.map(function(child, index) {
    var _child$props$FabProps = child.props.FabProps;
    _child$props$FabProps = _child$props$FabProps === void 0 ? {} : _child$props$FabProps;
    var origButtonRef = _child$props$FabProps.ref, ChildFabProps = _objectWithoutProperties(_child$props$FabProps, ["ref"]);
    return React15.cloneElement(child, {
      FabProps: _extends({}, ChildFabProps, {
        ref: createHandleSpeedDialActionButtonRef(index, origButtonRef)
      }),
      delay: 30 * (open ? index : allItems.length - index),
      open,
      id: "".concat(id, "-action-").concat(index)
    });
  });
  return React15.createElement("div", _extends({
    className: clsx_m_default(classes.root, classes["direction".concat(capitalize(direction))], className),
    ref,
    role: "presentation",
    onKeyDown: handleKeyDown,
    onBlur: handleClose,
    onFocus: handleOpen,
    onMouseEnter: handleOpen,
    onMouseLeave: handleClose
  }, other), React15.createElement(TransitionComponent, _extends({
    in: !hidden,
    timeout: transitionDuration,
    unmountOnExit: true
  }, TransitionProps), React15.createElement(Fab_default, _extends({
    color: "primary",
    "aria-label": ariaLabel,
    "aria-haspopup": "true",
    "aria-expanded": open,
    "aria-controls": "".concat(id, "-actions")
  }, FabProps, {
    onClick: handleClick,
    className: clsx_m_default(classes.fab, FabProps.className),
    ref: handleFabRef
  }), React15.isValidElement(icon) && isMuiElement(icon, ["SpeedDialIcon"]) ? React15.cloneElement(icon, {
    open
  }) : icon)), React15.createElement("div", {
    id: "".concat(id, "-actions"),
    role: "menu",
    "aria-orientation": getOrientation(direction),
    className: clsx_m_default(classes.actions, !open && classes.actionsClosed)
  }, children));
});
true ? SpeedDial.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The aria-label of the button element.
   * Also used to provide the `id` for the `SpeedDial` element and its children.
   */
  ariaLabel: import_prop_types7.default.string.isRequired,
  /**
   * SpeedDialActions to display when the SpeedDial is `open`.
   */
  children: import_prop_types7.default.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types7.default.object,
  /**
   * @ignore
   */
  className: import_prop_types7.default.string,
  /**
   * The direction the actions open relative to the floating action button.
   */
  direction: import_prop_types7.default.oneOf(["down", "left", "right", "up"]),
  /**
   * Props applied to the [`Fab`](/api/fab/) element.
   */
  FabProps: import_prop_types7.default.object,
  /**
   * If `true`, the SpeedDial will be hidden.
   */
  hidden: import_prop_types7.default.bool,
  /**
   * The icon to display in the SpeedDial Fab. The `SpeedDialIcon` component
   * provides a default Icon with animation.
   */
  icon: import_prop_types7.default.node,
  /**
   * @ignore
   */
  onBlur: import_prop_types7.default.func,
  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"toggle"`, `"blur"`, `"mouseLeave"`, `"escapeKeyDown"`.
   */
  onClose: import_prop_types7.default.func,
  /**
   * @ignore
   */
  onFocus: import_prop_types7.default.func,
  /**
   * @ignore
   */
  onKeyDown: import_prop_types7.default.func,
  /**
   * @ignore
   */
  onMouseEnter: import_prop_types7.default.func,
  /**
   * @ignore
   */
  onMouseLeave: import_prop_types7.default.func,
  /**
   * Callback fired when the component requests to be open.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"toggle"`, `"focus"`, `"mouseEnter"`.
   */
  onOpen: import_prop_types7.default.func,
  /**
   * If `true`, the SpeedDial is open.
   */
  open: import_prop_types7.default.bool.isRequired,
  /**
   * The icon to display in the SpeedDial Fab when the SpeedDial is open.
   */
  openIcon: import_prop_types7.default.node,
  /**
   * The component used for the transition.
   * [Follow this guide](/components/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   */
  TransitionComponent: import_prop_types7.default.elementType,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   */
  transitionDuration: import_prop_types7.default.oneOfType([import_prop_types7.default.number, import_prop_types7.default.shape({
    appear: import_prop_types7.default.number,
    enter: import_prop_types7.default.number,
    exit: import_prop_types7.default.number
  })]),
  /**
   * Props applied to the [`Transition`](http://reactcommunity.org/react-transition-group/transition#Transition-props) element.
   */
  TransitionProps: import_prop_types7.default.object
} : void 0;
var SpeedDial_default = withStyles_default(styles13, {
  name: "MuiSpeedDial"
})(SpeedDial);

// ../node_modules/@material-ui/lab/esm/SpeedDialAction/SpeedDialAction.js
init_objectWithoutProperties();
init_extends();
var React16 = __toESM(require_react());
var import_prop_types8 = __toESM(require_prop_types());
init_clsx_m();
init_utils();
var styles15 = function styles16(theme) {
  return {
    /* Styles applied to the Fab component. */
    fab: {
      margin: 8,
      color: theme.palette.text.secondary,
      backgroundColor: theme.palette.background.paper,
      "&:hover": {
        backgroundColor: emphasize(theme.palette.background.paper, 0.15)
      },
      transition: "".concat(theme.transitions.create("transform", {
        duration: theme.transitions.duration.shorter
      }), ", opacity 0.8s"),
      opacity: 1
    },
    /* Styles applied to the Fab component if `open={false}`. */
    fabClosed: {
      opacity: 0,
      transform: "scale(0)"
    },
    /* Styles applied to the root element if `tooltipOpen={true}`. */
    staticTooltip: {
      position: "relative",
      display: "flex",
      "& $staticTooltipLabel": {
        transition: theme.transitions.create(["transform", "opacity"], {
          duration: theme.transitions.duration.shorter
        }),
        opacity: 1
      }
    },
    /* Styles applied to the root element if `tooltipOpen={true}` and `open={false}`. */
    staticTooltipClosed: {
      "& $staticTooltipLabel": {
        opacity: 0,
        transform: "scale(0.5)"
      }
    },
    /* Styles applied to the static tooltip label if `tooltipOpen={true}`. */
    staticTooltipLabel: _extends({
      position: "absolute"
    }, theme.typography.body1, {
      backgroundColor: theme.palette.background.paper,
      borderRadius: theme.shape.borderRadius,
      boxShadow: theme.shadows[1],
      color: theme.palette.text.secondary,
      padding: "4px 16px",
      wordBreak: "keep-all"
    }),
    /* Styles applied to the root if `tooltipOpen={true}` and `tooltipPlacement="left"`` */
    tooltipPlacementLeft: {
      alignItems: "center",
      "& $staticTooltipLabel": {
        transformOrigin: "100% 50%",
        right: "100%",
        marginRight: 8
      }
    },
    /* Styles applied to the root if `tooltipOpen={true}` and `tooltipPlacement="right"`` */
    tooltipPlacementRight: {
      alignItems: "center",
      "& $staticTooltipLabel": {
        transformOrigin: "0% 50%",
        left: "100%",
        marginLeft: 8
      }
    }
  };
};
var SpeedDialAction = React16.forwardRef(function SpeedDialAction2(props, ref) {
  var classes = props.classes, className = props.className, _props$delay = props.delay, delay = _props$delay === void 0 ? 0 : _props$delay, _props$FabProps = props.FabProps, FabProps = _props$FabProps === void 0 ? {} : _props$FabProps, icon = props.icon, id = props.id, open = props.open, TooltipClasses = props.TooltipClasses, _props$tooltipOpen = props.tooltipOpen, tooltipOpenProp = _props$tooltipOpen === void 0 ? false : _props$tooltipOpen, _props$tooltipPlaceme = props.tooltipPlacement, tooltipPlacement = _props$tooltipPlaceme === void 0 ? "left" : _props$tooltipPlaceme, tooltipTitle = props.tooltipTitle, other = _objectWithoutProperties(props, ["classes", "className", "delay", "FabProps", "icon", "id", "open", "TooltipClasses", "tooltipOpen", "tooltipPlacement", "tooltipTitle"]);
  var _React$useState = React16.useState(tooltipOpenProp), tooltipOpen = _React$useState[0], setTooltipOpen = _React$useState[1];
  var handleTooltipClose = function handleTooltipClose2() {
    setTooltipOpen(false);
  };
  var handleTooltipOpen = function handleTooltipOpen2() {
    setTooltipOpen(true);
  };
  var transitionStyle = {
    transitionDelay: "".concat(delay, "ms")
  };
  var fab = React16.createElement(Fab_default, _extends({
    size: "small",
    className: clsx_m_default(classes.fab, className, !open && classes.fabClosed),
    tabIndex: -1,
    role: "menuitem",
    "aria-describedby": "".concat(id, "-label")
  }, FabProps, {
    style: _extends({}, transitionStyle, FabProps.style)
  }), icon);
  if (tooltipOpenProp) {
    return React16.createElement("span", _extends({
      id,
      ref,
      className: clsx_m_default(classes.staticTooltip, classes["tooltipPlacement".concat(capitalize(tooltipPlacement))], !open && classes.staticTooltipClosed)
    }, other), React16.createElement("span", {
      style: transitionStyle,
      id: "".concat(id, "-label"),
      className: classes.staticTooltipLabel
    }, tooltipTitle), fab);
  }
  return React16.createElement(Tooltip_default, _extends({
    id,
    ref,
    title: tooltipTitle,
    placement: tooltipPlacement,
    onClose: handleTooltipClose,
    onOpen: handleTooltipOpen,
    open: open && tooltipOpen,
    classes: TooltipClasses
  }, other), fab);
});
true ? SpeedDialAction.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types8.default.object,
  /**
   * @ignore
   */
  className: import_prop_types8.default.string,
  /**
   * Adds a transition delay, to allow a series of SpeedDialActions to be animated.
   */
  delay: import_prop_types8.default.number,
  /**
   * Props applied to the [`Fab`](/api/fab/) component.
   */
  FabProps: import_prop_types8.default.object,
  /**
   * The Icon to display in the SpeedDial Fab.
   */
  icon: import_prop_types8.default.node,
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types8.default.string,
  /**
   * If `true`, the tooltip is shown.
   */
  open: import_prop_types8.default.bool,
  /**
   * `classes` prop applied to the [`Tooltip`](/api/tooltip/) element.
   */
  TooltipClasses: import_prop_types8.default.object,
  /**
   * Make the tooltip always visible when the SpeedDial is open.
   */
  tooltipOpen: import_prop_types8.default.bool,
  /**
   * Placement of the tooltip.
   */
  tooltipPlacement: import_prop_types8.default.oneOf(["bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Label to display in the tooltip.
   */
  tooltipTitle: import_prop_types8.default.node
} : void 0;
var SpeedDialAction_default = withStyles_default(styles15, {
  name: "MuiSpeedDialAction"
})(SpeedDialAction);

// ../node_modules/@material-ui/lab/esm/SpeedDialIcon/SpeedDialIcon.js
init_extends();
init_objectWithoutProperties();
var React18 = __toESM(require_react());
var import_prop_types9 = __toESM(require_prop_types());
init_clsx_m();

// ../node_modules/@material-ui/lab/esm/internal/svg-icons/Add.js
var React17 = __toESM(require_react());
init_utils();
var Add_default = createSvgIcon(React17.createElement("path", {
  d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"
}), "Add");

// ../node_modules/@material-ui/lab/esm/SpeedDialIcon/SpeedDialIcon.js
var styles17 = function styles18(theme) {
  return {
    /* Styles applied to the root element. */
    root: {
      height: 24
    },
    /* Styles applied to the icon component. */
    icon: {
      transition: theme.transitions.create(["transform", "opacity"], {
        duration: theme.transitions.duration.short
      })
    },
    /* Styles applied to the icon component if `open={true}`. */
    iconOpen: {
      transform: "rotate(45deg)"
    },
    /* Styles applied to the icon when and `openIcon` is provided and if `open={true}`. */
    iconWithOpenIconOpen: {
      opacity: 0
    },
    /* Styles applied to the `openIcon` if provided. */
    openIcon: {
      position: "absolute",
      transition: theme.transitions.create(["transform", "opacity"], {
        duration: theme.transitions.duration.short
      }),
      opacity: 0,
      transform: "rotate(-45deg)"
    },
    /* Styles applied to the `openIcon` if provided and if `open={true}`. */
    openIconOpen: {
      transform: "rotate(0deg)",
      opacity: 1
    }
  };
};
var SpeedDialIcon = React18.forwardRef(function SpeedDialIcon2(props, ref) {
  var className = props.className, classes = props.classes, iconProp = props.icon, open = props.open, openIconProp = props.openIcon, other = _objectWithoutProperties(props, ["className", "classes", "icon", "open", "openIcon"]);
  var iconClassName = clsx_m_default(classes.icon, open && [classes.iconOpen, openIconProp && classes.iconWithOpenIconOpen]);
  var openIconClassName = clsx_m_default(classes.openIcon, open && classes.openIconOpen);
  function formatIcon(icon, newClassName) {
    if (React18.isValidElement(icon)) {
      return React18.cloneElement(icon, {
        className: newClassName
      });
    }
    return icon;
  }
  return React18.createElement("span", _extends({
    className: clsx_m_default(classes.root, className),
    ref
  }, other), openIconProp ? formatIcon(openIconProp, openIconClassName) : null, iconProp ? formatIcon(iconProp, iconClassName) : React18.createElement(Add_default, {
    className: iconClassName
  }));
});
true ? SpeedDialIcon.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types9.default.object,
  /**
   * @ignore
   */
  className: import_prop_types9.default.string,
  /**
   * The icon to display in the SpeedDial Floating Action Button.
   */
  icon: import_prop_types9.default.node,
  /**
   * @ignore
   * If `true`, the SpeedDial is open.
   */
  open: import_prop_types9.default.bool,
  /**
   * The icon to display in the SpeedDial Floating Action Button when the SpeedDial is open.
   */
  openIcon: import_prop_types9.default.node
} : void 0;
SpeedDialIcon.muiName = "SpeedDialIcon";
var SpeedDialIcon_default = withStyles_default(styles17, {
  name: "MuiSpeedDialIcon"
})(SpeedDialIcon);

// ../node_modules/@material-ui/lab/esm/TabContext/TabContext.js
var React19 = __toESM(require_react());
var PropTypes10 = __toESM(require_prop_types());
var Context = React19.createContext(null);
if (true) {
  Context.displayName = "TabContext";
}
function useUniquePrefix() {
  var _React$useState = React19.useState(null), id = _React$useState[0], setId = _React$useState[1];
  React19.useEffect(function() {
    setId("mui-p-".concat(Math.round(Math.random() * 1e5)));
  }, []);
  return id;
}
function TabContext(props) {
  var children = props.children, value = props.value;
  var idPrefix = useUniquePrefix();
  var context = React19.useMemo(function() {
    return {
      idPrefix,
      value
    };
  }, [idPrefix, value]);
  return React19.createElement(Context.Provider, {
    value: context
  }, children);
}
true ? TabContext.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: PropTypes10.node,
  /**
   * The value of the currently selected `Tab`.
   */
  value: PropTypes10.string.isRequired
} : void 0;
function useTabContext() {
  return React19.useContext(Context);
}
function getPanelId(context, value) {
  var idPrefix = context.idPrefix;
  if (idPrefix === null) {
    return null;
  }
  return "".concat(context.idPrefix, "-P-").concat(value);
}
function getTabId(context, value) {
  var idPrefix = context.idPrefix;
  if (idPrefix === null) {
    return null;
  }
  return "".concat(context.idPrefix, "-T-").concat(value);
}

// ../node_modules/@material-ui/lab/esm/TabList/TabList.js
init_extends();
init_objectWithoutProperties();
var React20 = __toESM(require_react());
var PropTypes11 = __toESM(require_prop_types());
var TabList = React20.forwardRef(function TabList2(props, ref) {
  var childrenProp = props.children, other = _objectWithoutProperties(props, ["children"]);
  var context = useTabContext();
  if (context === null) {
    throw new TypeError("No TabContext provided");
  }
  var children = React20.Children.map(childrenProp, function(child) {
    return React20.cloneElement(child, {
      // SOMEDAY: `Tabs` will set those themselves
      "aria-controls": getPanelId(context, child.props.value),
      id: getTabId(context, child.props.value)
    });
  });
  return React20.createElement(Tabs_default, _extends({}, other, {
    ref,
    value: context.value
  }), children);
});
true ? TabList.propTypes = {
  children: PropTypes11.arrayOf(PropTypes11.element)
} : void 0;
var TabList_default = TabList;

// ../node_modules/@material-ui/lab/esm/TabPanel/TabPanel.js
init_extends();
init_objectWithoutProperties();
var React21 = __toESM(require_react());
var import_prop_types10 = __toESM(require_prop_types());
init_clsx_m();
var styles19 = function styles20(theme) {
  return {
    /* Styles applied to the root element. */
    root: {
      padding: theme.spacing(3)
    }
  };
};
var TabPanel = React21.forwardRef(function TabPanel2(props, ref) {
  var children = props.children, className = props.className, classes = props.classes, value = props.value, other = _objectWithoutProperties(props, ["children", "className", "classes", "value"]);
  var context = useTabContext();
  if (context === null) {
    throw new TypeError("No TabContext provided");
  }
  var id = getPanelId(context, value);
  var tabId = getTabId(context, value);
  return React21.createElement("div", _extends({
    "aria-labelledby": tabId,
    className: clsx_m_default(classes.root, className),
    hidden: value !== context.value,
    id,
    ref,
    role: "tabpanel"
  }, other), value === context.value && children);
});
true ? TabPanel.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: import_prop_types10.default.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types10.default.object,
  /**
   * @ignore
   */
  className: import_prop_types10.default.string,
  /**
   * The `value` of the corresponding `Tab`. Must use the index of the `Tab` when
   * no `value` was passed to `Tab`.
   */
  value: import_prop_types10.default.string.isRequired
} : void 0;
var TabPanel_default = withStyles_default(styles19, {
  name: "MuiTabPanel"
})(TabPanel);

// ../node_modules/@material-ui/lab/esm/Timeline/Timeline.js
init_extends();
init_objectWithoutProperties();
var React23 = __toESM(require_react());
var import_prop_types11 = __toESM(require_prop_types());
init_clsx_m();
init_utils();

// ../node_modules/@material-ui/lab/esm/Timeline/TimelineContext.js
var React22 = __toESM(require_react());
var TimelineContext = React22.createContext({});
if (true) {
  TimelineContext.displayName = "TimelineContext";
}
var TimelineContext_default = TimelineContext;

// ../node_modules/@material-ui/lab/esm/Timeline/Timeline.js
var styles21 = function styles22() {
  return {
    /* Styles applied to the root element. */
    root: {
      display: "flex",
      flexDirection: "column",
      padding: "6px 16px",
      flexGrow: 1
    },
    /* Styles applied to the root element if `align="left"`. */
    alignLeft: {},
    /* Styles applied to the root element if `align="right"`. */
    alignRight: {},
    /* Styles applied to the root element if `align="alternate"`. */
    alignAlternate: {}
  };
};
var Timeline = React23.forwardRef(function Timeline2(props, ref) {
  var _props$align = props.align, align = _props$align === void 0 ? "left" : _props$align, classes = props.classes, className = props.className, other = _objectWithoutProperties(props, ["align", "classes", "className"]);
  return React23.createElement(TimelineContext_default.Provider, {
    value: {
      align
    }
  }, React23.createElement("ul", _extends({
    className: clsx_m_default(classes.root, classes["align".concat(capitalize(align))], className),
    ref
  }, other)));
});
true ? Timeline.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The position where the timeline's content should appear.
   */
  align: import_prop_types11.default.oneOf(["alternate", "left", "right"]),
  /**
   * The content of the component.
   */
  children: import_prop_types11.default.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types11.default.object,
  /**
   * @ignore
   */
  className: import_prop_types11.default.string
} : void 0;
var Timeline_default = withStyles_default(styles21, {
  name: "MuiTimeline"
})(Timeline);

// ../node_modules/@material-ui/lab/esm/TimelineConnector/TimelineConnector.js
init_extends();
init_objectWithoutProperties();
var React24 = __toESM(require_react());
var import_prop_types12 = __toESM(require_prop_types());
init_clsx_m();
var styles23 = function styles24(theme) {
  return {
    /* Styles applied to the root element. */
    root: {
      width: 2,
      backgroundColor: theme.palette.grey[400],
      flexGrow: 1
    }
  };
};
var TimelineConnector = React24.forwardRef(function TimelineConnector2(props, ref) {
  var classes = props.classes, className = props.className, other = _objectWithoutProperties(props, ["classes", "className"]);
  return React24.createElement("span", _extends({
    className: clsx_m_default(classes.root, className),
    ref
  }, other));
});
true ? TimelineConnector.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: import_prop_types12.default.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types12.default.object,
  /**
   * @ignore
   */
  className: import_prop_types12.default.string
} : void 0;
var TimelineConnector_default = withStyles_default(styles23, {
  name: "MuiTimelineConnector"
})(TimelineConnector);

// ../node_modules/@material-ui/lab/esm/TimelineContent/TimelineContent.js
init_extends();
init_objectWithoutProperties();
var React26 = __toESM(require_react());
var import_prop_types13 = __toESM(require_prop_types());
init_clsx_m();
init_utils();

// ../node_modules/@material-ui/lab/esm/TimelineItem/TimelineItemContext.js
var React25 = __toESM(require_react());
var TimelineItemContext = React25.createContext({});
if (true) {
  TimelineItemContext.displayName = "TimelineItemContext";
}
var TimelineItemContext_default = TimelineItemContext;

// ../node_modules/@material-ui/lab/esm/TimelineContent/TimelineContent.js
var styles25 = function styles26() {
  return {
    /* Styles applied to the root element. */
    root: {
      flex: 1,
      padding: "6px 16px"
    },
    /* Styles applied to the root element if `align="right"`. */
    alignRight: {
      textAlign: "right"
    }
  };
};
var TimelineContent = React26.forwardRef(function TimelineContent2(props, ref) {
  var classes = props.classes, className = props.className, other = _objectWithoutProperties(props, ["classes", "className"]);
  var _React$useContext = React26.useContext(TimelineContext_default), _React$useContext$ali = _React$useContext.align, align = _React$useContext$ali === void 0 ? "left" : _React$useContext$ali;
  var _React$useContext2 = React26.useContext(TimelineItemContext_default), _React$useContext2$cl = _React$useContext2.classes, contextClasses = _React$useContext2$cl === void 0 ? {} : _React$useContext2$cl;
  return React26.createElement("div", _extends({
    className: clsx_m_default(classes.root, contextClasses.content, classes["align".concat(capitalize(align))], className),
    ref
  }, other));
});
true ? TimelineContent.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: import_prop_types13.default.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types13.default.object,
  /**
   * @ignore
   */
  className: import_prop_types13.default.string
} : void 0;
var TimelineContent_default = withStyles_default(styles25, {
  name: "MuiTimelineContent"
})(TimelineContent);

// ../node_modules/@material-ui/lab/esm/TimelineDot/TimelineDot.js
init_extends();
init_objectWithoutProperties();
var React27 = __toESM(require_react());
var import_prop_types14 = __toESM(require_prop_types());
init_clsx_m();
init_utils();
var styles27 = function styles28(theme) {
  return {
    /* Styles applied to the root element. */
    root: {
      display: "flex",
      alignSelf: "baseline",
      borderStyle: "solid",
      borderWidth: 2,
      padding: 4,
      borderRadius: "50%",
      boxShadow: theme.shadows[2],
      marginTop: 8,
      marginBottom: 8
    },
    /* Styles applied to the root element if `color="grey"` and `variant="default"`. */
    defaultGrey: {
      borderColor: "transparent",
      color: theme.palette.grey[50],
      backgroundColor: theme.palette.grey[400]
    },
    /* Styles applied to the root element if `color="grey"` and `variant="outlined"`. */
    outlinedGrey: {
      boxShadow: "none",
      color: theme.palette.grey.contrastText,
      borderColor: theme.palette.grey[400],
      backgroundColor: "transparent"
    },
    /* Styles applied to the root element if `color="primary"` and `variant="default"`. */
    defaultPrimary: {
      borderColor: "transparent",
      color: theme.palette.primary.contrastText,
      backgroundColor: theme.palette.primary.main
    },
    /* Styles applied to the root element if `color="primary"` and `variant="outlined"`. */
    outlinedPrimary: {
      boxShadow: "none",
      backgroundColor: "transparent",
      borderColor: theme.palette.primary.main
    },
    /* Styles applied to the root element if `color="secondary"` and `variant="default"`. */
    defaultSecondary: {
      borderColor: "transparent",
      color: theme.palette.secondary.contrastText,
      backgroundColor: theme.palette.secondary.main
    },
    /* Styles applied to the root element if `color="secondary"` and `variant="outlined"`. */
    outlinedSecondary: {
      boxShadow: "none",
      backgroundColor: "transparent",
      borderColor: theme.palette.secondary.main
    }
  };
};
var TimelineDot = React27.forwardRef(function TimelineDot2(props, ref) {
  var classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? "grey" : _props$color, _props$variant = props.variant, variant = _props$variant === void 0 ? "default" : _props$variant, other = _objectWithoutProperties(props, ["classes", "className", "color", "variant"]);
  return React27.createElement("span", _extends({
    className: clsx_m_default(classes.root, className, color !== "inherit" && classes["".concat(variant).concat(capitalize(color))]),
    ref
  }, other));
});
true ? TimelineDot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: import_prop_types14.default.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types14.default.object,
  /**
   * @ignore
   */
  className: import_prop_types14.default.string,
  /**
   * The dot can have a different colors.
   */
  color: import_prop_types14.default.oneOf(["grey", "inherit", "primary", "secondary"]),
  /**
   * The dot can appear filled or outlined.
   */
  variant: import_prop_types14.default.oneOf(["default", "outlined"])
} : void 0;
var TimelineDot_default = withStyles_default(styles27, {
  name: "MuiTimelineDot"
})(TimelineDot);

// ../node_modules/@material-ui/lab/esm/TimelineItem/TimelineItem.js
init_extends();
init_objectWithoutProperties();
var React28 = __toESM(require_react());
var import_prop_types15 = __toESM(require_prop_types());
init_clsx_m();
init_utils();
var styles29 = function styles30() {
  return {
    /* Styles applied to the root element. */
    root: {
      listStyle: "none",
      display: "flex",
      position: "relative",
      minHeight: 70
    },
    /* Styles applied to the root element if `align="left"`. */
    alignLeft: {},
    /* Styles applied to the root element if `align="right"`. */
    alignRight: {
      flexDirection: "row-reverse"
    },
    /* Styles applied to the root element if `align="alternate"`. */
    alignAlternate: {
      "&:nth-child(even)": {
        flexDirection: "row-reverse",
        "& $content": {
          textAlign: "right"
        },
        "& $oppositeContent": {
          textAlign: "left"
        }
      }
    },
    /* Styles applied to the root element if no there isn't TimelineOppositeContent provided. */
    missingOppositeContent: {
      "&:before": {
        content: '""',
        flex: 1,
        padding: "6px 16px"
      }
    },
    /* Styles applied to the timeline content node. */
    content: {},
    /* Styles applied to the timeline opposite content node. */
    oppositeContent: {}
  };
};
var TimelineItem = React28.forwardRef(function TimelineItem2(props, ref) {
  var classes = props.classes, className = props.className, other = _objectWithoutProperties(props, ["classes", "className"]);
  var _React$useContext = React28.useContext(TimelineContext_default), _React$useContext$ali = _React$useContext.align, align = _React$useContext$ali === void 0 ? "left" : _React$useContext$ali;
  var hasOppositeContent = false;
  React28.Children.forEach(props.children, function(child) {
    if (isMuiElement(child, ["TimelineOppositeContent"])) {
      hasOppositeContent = true;
    }
  });
  return React28.createElement(TimelineItemContext_default.Provider, {
    value: {
      classes: {
        content: classes.content,
        oppositeContent: classes.oppositeContent
      }
    }
  }, React28.createElement("li", _extends({
    className: clsx_m_default(classes.root, classes["align".concat(capitalize(align))], className, !hasOppositeContent && classes.missingOppositeContent),
    ref
  }, other)));
});
true ? TimelineItem.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: import_prop_types15.default.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types15.default.object,
  /**
   * @ignore
   */
  className: import_prop_types15.default.string
} : void 0;
var TimelineItem_default = withStyles_default(styles29, {
  name: "MuiTimelineItem"
})(TimelineItem);

// ../node_modules/@material-ui/lab/esm/TimelineOppositeContent/TimelineOppositeContent.js
init_extends();
init_objectWithoutProperties();
var React29 = __toESM(require_react());
var import_prop_types16 = __toESM(require_prop_types());
init_clsx_m();
init_utils();
var styles31 = function styles32() {
  return {
    /* Styles applied to the root element. */
    root: {
      padding: "6px 16px",
      marginRight: "auto",
      textAlign: "right",
      flex: 1
    },
    /* Styles applied to the root element if `align="right"`. */
    alignRight: {
      textAlign: "left"
    }
  };
};
var TimelineOppositeContent = React29.forwardRef(function TimelineOppositeContent2(props, ref) {
  var classes = props.classes, className = props.className, other = _objectWithoutProperties(props, ["classes", "className"]);
  var _React$useContext = React29.useContext(TimelineContext_default), _React$useContext$ali = _React$useContext.align, align = _React$useContext$ali === void 0 ? "left" : _React$useContext$ali;
  var _React$useContext2 = React29.useContext(TimelineItemContext_default), _React$useContext2$cl = _React$useContext2.classes, contextClasses = _React$useContext2$cl === void 0 ? {} : _React$useContext2$cl;
  return React29.createElement("div", _extends({
    className: clsx_m_default(classes.root, contextClasses.oppositeContent, classes["align".concat(capitalize(align))], className),
    ref
  }, other));
});
true ? TimelineOppositeContent.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: import_prop_types16.default.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types16.default.object,
  /**
   * @ignore
   */
  className: import_prop_types16.default.string
} : void 0;
TimelineOppositeContent.muiName = "TimelineOppositeContent";
var TimelineOppositeContent_default = withStyles_default(styles31, {
  name: "MuiTimelineOppositeContent"
})(TimelineOppositeContent);

// ../node_modules/@material-ui/lab/esm/TimelineSeparator/TimelineSeparator.js
init_extends();
init_objectWithoutProperties();
var React30 = __toESM(require_react());
var import_prop_types17 = __toESM(require_prop_types());
init_clsx_m();
var styles33 = function styles34() {
  return {
    /* Styles applied to the root element. */
    root: {
      display: "flex",
      flexDirection: "column",
      flex: 0,
      alignItems: "center"
    }
  };
};
var TimelineSeparator = React30.forwardRef(function TimelineSeparator2(props, ref) {
  var classes = props.classes, className = props.className, other = _objectWithoutProperties(props, ["classes", "className"]);
  return React30.createElement("div", _extends({
    className: clsx_m_default(classes.root, className),
    ref
  }, other));
});
true ? TimelineSeparator.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: import_prop_types17.default.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types17.default.object,
  /**
   * @ignore
   */
  className: import_prop_types17.default.string
} : void 0;
var TimelineSeparator_default = withStyles_default(styles33, {
  name: "MuiTimelineSeparator"
})(TimelineSeparator);

// ../node_modules/@material-ui/lab/esm/ToggleButton/ToggleButton.js
init_objectWithoutProperties();
init_extends();
var React31 = __toESM(require_react());
var import_prop_types18 = __toESM(require_prop_types());
init_clsx_m();
init_utils();
var styles35 = function styles36(theme) {
  return {
    /* Styles applied to the root element. */
    root: _extends({}, theme.typography.button, {
      boxSizing: "border-box",
      borderRadius: theme.shape.borderRadius,
      padding: 11,
      border: "1px solid ".concat(alpha(theme.palette.action.active, 0.12)),
      color: alpha(theme.palette.action.active, 0.38),
      "&$selected": {
        color: theme.palette.action.active,
        backgroundColor: alpha(theme.palette.action.active, 0.12),
        "&:hover": {
          backgroundColor: alpha(theme.palette.action.active, 0.15)
        },
        "& + &": {
          borderLeft: 0,
          marginLeft: 0
        }
      },
      "&$disabled": {
        color: alpha(theme.palette.action.disabled, 0.12)
      },
      "&:hover": {
        textDecoration: "none",
        // Reset on mouse devices
        backgroundColor: alpha(theme.palette.text.primary, 0.05),
        "@media (hover: none)": {
          backgroundColor: "transparent"
        },
        "&$disabled": {
          backgroundColor: "transparent"
        }
      }
    }),
    /* Pseudo-class applied to the root element if `disabled={true}`. */
    disabled: {},
    /* Pseudo-class applied to the root element if `selected={true}`. */
    selected: {},
    /* Styles applied to the `label` wrapper element. */
    label: {
      width: "100%",
      // Ensure the correct width for iOS Safari
      display: "inherit",
      alignItems: "inherit",
      justifyContent: "inherit"
    },
    /* Styles applied to the root element if `size="small"`. */
    sizeSmall: {
      padding: 7,
      fontSize: theme.typography.pxToRem(13)
    },
    /* Styles applied to the root element if `size="large"`. */
    sizeLarge: {
      padding: 15,
      fontSize: theme.typography.pxToRem(15)
    }
  };
};
var ToggleButton = React31.forwardRef(function ToggleButton2(props, ref) {
  var children = props.children, classes = props.classes, className = props.className, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, _props$disableFocusRi = props.disableFocusRipple, disableFocusRipple = _props$disableFocusRi === void 0 ? false : _props$disableFocusRi, onChange = props.onChange, onClick = props.onClick, selected = props.selected, _props$size = props.size, size = _props$size === void 0 ? "medium" : _props$size, value = props.value, other = _objectWithoutProperties(props, ["children", "classes", "className", "disabled", "disableFocusRipple", "onChange", "onClick", "selected", "size", "value"]);
  var handleChange = function handleChange2(event) {
    if (onClick) {
      onClick(event, value);
      if (event.isDefaultPrevented()) {
        return;
      }
    }
    if (onChange) {
      onChange(event, value);
    }
  };
  return React31.createElement(ButtonBase_default, _extends({
    className: clsx_m_default(classes.root, className, disabled && classes.disabled, selected && classes.selected, size !== "medium" && classes["size".concat(capitalize(size))]),
    disabled,
    focusRipple: !disableFocusRipple,
    ref,
    onClick: handleChange,
    onChange,
    value,
    "aria-pressed": selected
  }, other), React31.createElement("span", {
    className: classes.label
  }, children));
});
true ? ToggleButton.propTypes = {
  /**
   * The content of the button.
   */
  children: import_prop_types18.default.node.isRequired,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types18.default.object.isRequired,
  /**
   * @ignore
   */
  className: import_prop_types18.default.string,
  /**
   * If `true`, the button will be disabled.
   */
  disabled: import_prop_types18.default.bool,
  /**
   * If `true`, the  keyboard focus ripple will be disabled.
   */
  disableFocusRipple: import_prop_types18.default.bool,
  /**
   * If `true`, the ripple effect will be disabled.
   */
  disableRipple: import_prop_types18.default.bool,
  /**
   * @ignore
   */
  onChange: import_prop_types18.default.func,
  /**
   * @ignore
   */
  onClick: import_prop_types18.default.func,
  /**
   * If `true`, the button will be rendered in an active state.
   */
  selected: import_prop_types18.default.bool,
  /**
   * @ignore
   */
  size: import_prop_types18.default.oneOf(["small", "medium", "large"]),
  /**
   * The value to associate with the button when selected in a
   * ToggleButtonGroup.
   */
  value: import_prop_types18.default.any.isRequired
} : void 0;
var ToggleButton_default = withStyles_default(styles35, {
  name: "MuiToggleButton"
})(ToggleButton);

// ../node_modules/@material-ui/lab/esm/ToggleButtonGroup/ToggleButtonGroup.js
init_extends();
init_objectWithoutProperties();
var React32 = __toESM(require_react());
var import_react_is3 = __toESM(require_react_is());
var import_prop_types19 = __toESM(require_prop_types());
init_clsx_m();

// ../node_modules/@material-ui/lab/esm/ToggleButtonGroup/isValueSelected.js
function isValueSelected(value, candidate) {
  if (candidate === void 0 || value === void 0) {
    return false;
  }
  if (Array.isArray(candidate)) {
    return candidate.indexOf(value) >= 0;
  }
  return value === candidate;
}

// ../node_modules/@material-ui/lab/esm/ToggleButtonGroup/ToggleButtonGroup.js
init_utils();
var styles37 = function styles38(theme) {
  return {
    /* Styles applied to the root element. */
    root: {
      display: "inline-flex",
      borderRadius: theme.shape.borderRadius
    },
    /* Styles applied to the root element if `orientation="vertical"`. */
    vertical: {
      flexDirection: "column"
    },
    /* Styles applied to the children. */
    grouped: {},
    /* Styles applied to the children if `orientation="horizontal"`. */
    groupedHorizontal: {
      "&:not(:first-child)": {
        marginLeft: -1,
        borderLeft: "1px solid transparent",
        borderTopLeftRadius: 0,
        borderBottomLeftRadius: 0
      },
      "&:not(:last-child)": {
        borderTopRightRadius: 0,
        borderBottomRightRadius: 0
      }
    },
    /* Styles applied to the children if `orientation="vertical"`. */
    groupedVertical: {
      "&:not(:first-child)": {
        marginTop: -1,
        borderTop: "1px solid transparent",
        borderTopLeftRadius: 0,
        borderTopRightRadius: 0
      },
      "&:not(:last-child)": {
        borderBottomLeftRadius: 0,
        borderBottomRightRadius: 0
      }
    }
  };
};
var ToggleButtonGroup = React32.forwardRef(function ToggleButton3(props, ref) {
  var children = props.children, classes = props.classes, className = props.className, _props$exclusive = props.exclusive, exclusive = _props$exclusive === void 0 ? false : _props$exclusive, onChange = props.onChange, _props$orientation = props.orientation, orientation = _props$orientation === void 0 ? "horizontal" : _props$orientation, _props$size = props.size, size = _props$size === void 0 ? "medium" : _props$size, value = props.value, other = _objectWithoutProperties(props, ["children", "classes", "className", "exclusive", "onChange", "orientation", "size", "value"]);
  var handleChange = function handleChange2(event, buttonValue) {
    if (!onChange) {
      return;
    }
    var index = value && value.indexOf(buttonValue);
    var newValue;
    if (value && index >= 0) {
      newValue = value.slice();
      newValue.splice(index, 1);
    } else {
      newValue = value ? value.concat(buttonValue) : [buttonValue];
    }
    onChange(event, newValue);
  };
  var handleExclusiveChange = function handleExclusiveChange2(event, buttonValue) {
    if (!onChange) {
      return;
    }
    onChange(event, value === buttonValue ? null : buttonValue);
  };
  return React32.createElement("div", _extends({
    role: "group",
    className: clsx_m_default(classes.root, className, orientation === "vertical" && classes.vertical),
    ref
  }, other), React32.Children.map(children, function(child) {
    if (!React32.isValidElement(child)) {
      return null;
    }
    if (true) {
      if ((0, import_react_is3.isFragment)(child)) {
        console.error(["Material-UI: The ToggleButtonGroup component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join("\n"));
      }
    }
    return React32.cloneElement(child, {
      className: clsx_m_default(classes.grouped, classes["grouped".concat(capitalize(orientation))], child.props.className),
      onChange: exclusive ? handleExclusiveChange : handleChange,
      selected: child.props.selected === void 0 ? isValueSelected(child.props.value, value) : child.props.selected,
      size: child.props.size || size
    });
  }));
});
true ? ToggleButtonGroup.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the button.
   */
  children: import_prop_types19.default.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types19.default.object,
  /**
   * @ignore
   */
  className: import_prop_types19.default.string,
  /**
   * If `true`, only allow one of the child ToggleButton values to be selected.
   */
  exclusive: import_prop_types19.default.bool,
  /**
   * Callback fired when the value changes.
   *
   * @param {object} event The event source of the callback.
   * @param {any} value of the selected buttons. When `exclusive` is true
   * this is a single value; when false an array of selected values. If no value
   * is selected and `exclusive` is true the value is null; when false an empty array.
   */
  onChange: import_prop_types19.default.func,
  /**
   * The group orientation (layout flow direction).
   */
  orientation: import_prop_types19.default.oneOf(["horizontal", "vertical"]),
  /**
   * The size of the buttons.
   */
  size: import_prop_types19.default.oneOf(["large", "medium", "small"]),
  /**
   * The currently selected value within the group or an array of selected
   * values when `exclusive` is false.
   *
   * The value must have reference equality with the option in order to be selected.
   */
  value: import_prop_types19.default.any
} : void 0;
var ToggleButtonGroup_default = withStyles_default(styles37, {
  name: "MuiToggleButtonGroup"
})(ToggleButtonGroup);

// ../node_modules/@material-ui/lab/esm/TreeItem/TreeItem.js
init_extends();
init_objectWithoutProperties();
var React34 = __toESM(require_react());
init_clsx_m();
var import_prop_types20 = __toESM(require_prop_types());
init_utils();

// ../node_modules/@material-ui/lab/esm/TreeView/TreeViewContext.js
var React33 = __toESM(require_react());
var TreeViewContext = React33.createContext({});
if (true) {
  TreeViewContext.displayName = "TreeViewContext";
}
var TreeViewContext_default = TreeViewContext;

// ../node_modules/@material-ui/lab/esm/TreeItem/TreeItem.js
var styles39 = function styles40(theme) {
  return {
    /* Styles applied to the root element. */
    root: {
      listStyle: "none",
      margin: 0,
      padding: 0,
      outline: 0,
      WebkitTapHighlightColor: "transparent",
      "&:focus > $content $label": {
        backgroundColor: theme.palette.action.hover
      },
      "&$selected > $content $label": {
        backgroundColor: alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity)
      },
      "&$selected > $content $label:hover, &$selected:focus > $content $label": {
        backgroundColor: alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    },
    /* Pseudo-class applied to the root element when expanded. */
    expanded: {},
    /* Pseudo-class applied to the root element when selected. */
    selected: {},
    /* Styles applied to the `role="group"` element. */
    group: {
      margin: 0,
      padding: 0,
      marginLeft: 17
    },
    /* Styles applied to the tree node content. */
    content: {
      width: "100%",
      display: "flex",
      alignItems: "center",
      cursor: "pointer"
    },
    /* Styles applied to the tree node icon and collapse/expand icon. */
    iconContainer: {
      marginRight: 4,
      width: 15,
      display: "flex",
      flexShrink: 0,
      justifyContent: "center",
      "& svg": {
        fontSize: 18
      }
    },
    /* Styles applied to the label element. */
    label: {
      width: "100%",
      paddingLeft: 4,
      position: "relative",
      "&:hover": {
        backgroundColor: theme.palette.action.hover,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  };
};
var isPrintableCharacter = function isPrintableCharacter2(str) {
  return str && str.length === 1 && str.match(/\S/);
};
var TreeItem = React34.forwardRef(function TreeItem2(props, ref) {
  var children = props.children, classes = props.classes, className = props.className, collapseIcon = props.collapseIcon, endIcon = props.endIcon, expandIcon = props.expandIcon, iconProp = props.icon, label = props.label, nodeId = props.nodeId, onClick = props.onClick, onLabelClick = props.onLabelClick, onIconClick = props.onIconClick, onFocus = props.onFocus, onKeyDown = props.onKeyDown, onMouseDown = props.onMouseDown, _props$TransitionComp = props.TransitionComponent, TransitionComponent = _props$TransitionComp === void 0 ? Collapse_default : _props$TransitionComp, TransitionProps = props.TransitionProps, other = _objectWithoutProperties(props, ["children", "classes", "className", "collapseIcon", "endIcon", "expandIcon", "icon", "label", "nodeId", "onClick", "onLabelClick", "onIconClick", "onFocus", "onKeyDown", "onMouseDown", "TransitionComponent", "TransitionProps"]);
  var _React$useContext = React34.useContext(TreeViewContext_default), contextIcons = _React$useContext.icons, focus = _React$useContext.focus, focusFirstNode = _React$useContext.focusFirstNode, focusLastNode = _React$useContext.focusLastNode, focusNextNode = _React$useContext.focusNextNode, focusPreviousNode = _React$useContext.focusPreviousNode, focusByFirstCharacter = _React$useContext.focusByFirstCharacter, selectNode = _React$useContext.selectNode, selectRange = _React$useContext.selectRange, selectNextNode = _React$useContext.selectNextNode, selectPreviousNode = _React$useContext.selectPreviousNode, rangeSelectToFirst = _React$useContext.rangeSelectToFirst, rangeSelectToLast = _React$useContext.rangeSelectToLast, selectAllNodes = _React$useContext.selectAllNodes, expandAllSiblings = _React$useContext.expandAllSiblings, toggleExpansion = _React$useContext.toggleExpansion, isExpanded = _React$useContext.isExpanded, isFocused = _React$useContext.isFocused, isSelected = _React$useContext.isSelected, isTabbable = _React$useContext.isTabbable, multiSelect = _React$useContext.multiSelect, getParent = _React$useContext.getParent, mapFirstChar = _React$useContext.mapFirstChar, addNodeToNodeMap = _React$useContext.addNodeToNodeMap, removeNodeFromNodeMap = _React$useContext.removeNodeFromNodeMap;
  var nodeRef = React34.useRef(null);
  var contentRef = React34.useRef(null);
  var handleRef = useForkRef(nodeRef, ref);
  var icon = iconProp;
  var expandable = Boolean(Array.isArray(children) ? children.length : children);
  var expanded = isExpanded ? isExpanded(nodeId) : false;
  var focused = isFocused ? isFocused(nodeId) : false;
  var tabbable = isTabbable ? isTabbable(nodeId) : false;
  var selected = isSelected ? isSelected(nodeId) : false;
  var icons = contextIcons || {};
  var theme = useTheme();
  if (!icon) {
    if (expandable) {
      if (!expanded) {
        icon = expandIcon || icons.defaultExpandIcon;
      } else {
        icon = collapseIcon || icons.defaultCollapseIcon;
      }
      if (!icon) {
        icon = icons.defaultParentIcon;
      }
    } else {
      icon = endIcon || icons.defaultEndIcon;
    }
  }
  var handleClick = function handleClick2(event) {
    if (!focused) {
      focus(nodeId);
    }
    var multiple = multiSelect && (event.shiftKey || event.ctrlKey || event.metaKey);
    if (expandable && !event.defaultPrevented && !(multiple && isExpanded(nodeId))) {
      toggleExpansion(event, nodeId);
    }
    if (multiple) {
      if (event.shiftKey) {
        selectRange(event, {
          end: nodeId
        });
      } else {
        selectNode(event, nodeId, true);
      }
    } else {
      selectNode(event, nodeId);
    }
    if (onClick) {
      onClick(event);
    }
  };
  var handleMouseDown = function handleMouseDown2(event) {
    if (event.shiftKey || event.ctrlKey || event.metaKey) {
      event.preventDefault();
    }
    if (onMouseDown) {
      onMouseDown(event);
    }
  };
  var handleNextArrow = function handleNextArrow2(event) {
    if (expandable) {
      if (expanded) {
        focusNextNode(nodeId);
      } else {
        toggleExpansion(event);
      }
    }
    return true;
  };
  var handlePreviousArrow = function handlePreviousArrow2(event) {
    if (expanded) {
      toggleExpansion(event, nodeId);
      return true;
    }
    var parent = getParent(nodeId);
    if (parent) {
      focus(parent);
      return true;
    }
    return false;
  };
  var handleKeyDown = function handleKeyDown2(event) {
    var flag = false;
    var key = event.key;
    if (event.altKey || event.currentTarget !== event.target) {
      return;
    }
    var ctrlPressed = event.ctrlKey || event.metaKey;
    switch (key) {
      case " ":
        if (nodeRef.current === event.currentTarget) {
          if (multiSelect && event.shiftKey) {
            flag = selectRange(event, {
              end: nodeId
            });
          } else if (multiSelect) {
            flag = selectNode(event, nodeId, true);
          } else {
            flag = selectNode(event, nodeId);
          }
        }
        event.stopPropagation();
        break;
      case "Enter":
        if (nodeRef.current === event.currentTarget && expandable) {
          toggleExpansion(event);
          flag = true;
        }
        event.stopPropagation();
        break;
      case "ArrowDown":
        if (multiSelect && event.shiftKey) {
          selectNextNode(event, nodeId);
        }
        focusNextNode(nodeId);
        flag = true;
        break;
      case "ArrowUp":
        if (multiSelect && event.shiftKey) {
          selectPreviousNode(event, nodeId);
        }
        focusPreviousNode(nodeId);
        flag = true;
        break;
      case "ArrowRight":
        if (theme.direction === "rtl") {
          flag = handlePreviousArrow(event);
        } else {
          flag = handleNextArrow(event);
        }
        break;
      case "ArrowLeft":
        if (theme.direction === "rtl") {
          flag = handleNextArrow(event);
        } else {
          flag = handlePreviousArrow(event);
        }
        break;
      case "Home":
        if (multiSelect && ctrlPressed && event.shiftKey) {
          rangeSelectToFirst(event, nodeId);
        }
        focusFirstNode();
        flag = true;
        break;
      case "End":
        if (multiSelect && ctrlPressed && event.shiftKey) {
          rangeSelectToLast(event, nodeId);
        }
        focusLastNode();
        flag = true;
        break;
      default:
        if (key === "*") {
          expandAllSiblings(event, nodeId);
          flag = true;
        } else if (multiSelect && ctrlPressed && key.toLowerCase() === "a") {
          flag = selectAllNodes(event);
        } else if (!ctrlPressed && !event.shiftKey && isPrintableCharacter(key)) {
          focusByFirstCharacter(nodeId, key);
          flag = true;
        }
    }
    if (flag) {
      event.preventDefault();
      event.stopPropagation();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  var handleFocus = function handleFocus2(event) {
    if (!focused && event.currentTarget === event.target) {
      focus(nodeId);
    }
    if (onFocus) {
      onFocus(event);
    }
  };
  React34.useEffect(function() {
    if (addNodeToNodeMap) {
      var childIds = [];
      React34.Children.forEach(children, function(child) {
        if (React34.isValidElement(child) && child.props.nodeId) {
          childIds.push(child.props.nodeId);
        }
      });
      addNodeToNodeMap(nodeId, childIds);
    }
  }, [children, nodeId, addNodeToNodeMap]);
  React34.useEffect(function() {
    if (removeNodeFromNodeMap) {
      return function() {
        removeNodeFromNodeMap(nodeId);
      };
    }
    return void 0;
  }, [nodeId, removeNodeFromNodeMap]);
  React34.useEffect(function() {
    if (mapFirstChar && label) {
      mapFirstChar(nodeId, contentRef.current.textContent.substring(0, 1).toLowerCase());
    }
  }, [mapFirstChar, nodeId, label]);
  React34.useEffect(function() {
    if (focused) {
      nodeRef.current.focus();
    }
  }, [focused]);
  var ariaSelected;
  if (multiSelect) {
    ariaSelected = selected;
  } else if (selected) {
    ariaSelected = true;
  }
  return React34.createElement("li", _extends({
    className: clsx_m_default(classes.root, className, expanded && classes.expanded, selected && classes.selected),
    role: "treeitem",
    onKeyDown: handleKeyDown,
    onFocus: handleFocus,
    "aria-expanded": expandable ? expanded : null,
    "aria-selected": ariaSelected,
    ref: handleRef,
    tabIndex: tabbable ? 0 : -1
  }, other), React34.createElement("div", {
    className: classes.content,
    onClick: handleClick,
    onMouseDown: handleMouseDown,
    ref: contentRef
  }, React34.createElement("div", {
    onClick: onIconClick,
    className: classes.iconContainer
  }, icon), React34.createElement(Typography_default, {
    onClick: onLabelClick,
    component: "div",
    className: classes.label
  }, label)), children && React34.createElement(TransitionComponent, _extends({
    unmountOnExit: true,
    className: classes.group,
    in: expanded,
    component: "ul",
    role: "group"
  }, TransitionProps), children));
});
true ? TreeItem.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: import_prop_types20.default.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types20.default.object,
  /**
   * @ignore
   */
  className: import_prop_types20.default.string,
  /**
   * The icon used to collapse the node.
   */
  collapseIcon: import_prop_types20.default.node,
  /**
   * The icon displayed next to a end node.
   */
  endIcon: import_prop_types20.default.node,
  /**
   * The icon used to expand the node.
   */
  expandIcon: import_prop_types20.default.node,
  /**
   * The icon to display next to the tree node's label.
   */
  icon: import_prop_types20.default.node,
  /**
   * The tree node label.
   */
  label: import_prop_types20.default.node,
  /**
   * The id of the node.
   */
  nodeId: import_prop_types20.default.string.isRequired,
  /**
   * @ignore
   */
  onClick: import_prop_types20.default.func,
  /**
   * @ignore
   */
  onFocus: import_prop_types20.default.func,
  /**
   * `onClick` handler for the icon container. Call `event.preventDefault()` to prevent `onNodeToggle` from being called.
   */
  onIconClick: import_prop_types20.default.func,
  /**
   * @ignore
   */
  onKeyDown: import_prop_types20.default.func,
  /**
   * `onClick` handler for the label container. Call `event.preventDefault()` to prevent `onNodeToggle` from being called.
   */
  onLabelClick: import_prop_types20.default.func,
  /**
   * @ignore
   */
  onMouseDown: import_prop_types20.default.func,
  /**
   * The component used for the transition.
   * [Follow this guide](/components/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   */
  TransitionComponent: import_prop_types20.default.elementType,
  /**
   * Props applied to the [`Transition`](http://reactcommunity.org/react-transition-group/transition#Transition-props) element.
   */
  TransitionProps: import_prop_types20.default.object
} : void 0;
var TreeItem_default = withStyles_default(styles39, {
  name: "MuiTreeItem"
})(TreeItem);

// ../node_modules/@material-ui/lab/esm/TreeView/TreeView.js
init_extends();
init_slicedToArray();
init_objectWithoutProperties();
var React35 = __toESM(require_react());
init_clsx_m();
var import_prop_types21 = __toESM(require_prop_types());
init_utils();
var styles41 = {
  /* Styles applied to the root element. */
  root: {
    padding: 0,
    margin: 0,
    listStyle: "none"
  }
};
function arrayDiff(arr1, arr2) {
  if (arr1.length !== arr2.length)
    return true;
  for (var i = 0; i < arr1.length; i += 1) {
    if (arr1[i] !== arr2[i])
      return true;
  }
  return false;
}
var findNextFirstChar = function findNextFirstChar2(firstChars, startIndex, char) {
  for (var i = startIndex; i < firstChars.length; i += 1) {
    if (char === firstChars[i]) {
      return i;
    }
  }
  return -1;
};
var defaultExpandedDefault = [];
var defaultSelectedDefault = [];
var TreeView = React35.forwardRef(function TreeView2(props, ref) {
  var children = props.children, classes = props.classes, className = props.className, defaultCollapseIcon = props.defaultCollapseIcon, defaultEndIcon = props.defaultEndIcon, _props$defaultExpande = props.defaultExpanded, defaultExpanded = _props$defaultExpande === void 0 ? defaultExpandedDefault : _props$defaultExpande, defaultExpandIcon = props.defaultExpandIcon, defaultParentIcon = props.defaultParentIcon, _props$defaultSelecte = props.defaultSelected, defaultSelected = _props$defaultSelecte === void 0 ? defaultSelectedDefault : _props$defaultSelecte, _props$disableSelecti = props.disableSelection, disableSelection = _props$disableSelecti === void 0 ? false : _props$disableSelecti, _props$multiSelect = props.multiSelect, multiSelect = _props$multiSelect === void 0 ? false : _props$multiSelect, expandedProp = props.expanded, onNodeSelect = props.onNodeSelect, onNodeToggle = props.onNodeToggle, selectedProp = props.selected, other = _objectWithoutProperties(props, ["children", "classes", "className", "defaultCollapseIcon", "defaultEndIcon", "defaultExpanded", "defaultExpandIcon", "defaultParentIcon", "defaultSelected", "disableSelection", "multiSelect", "expanded", "onNodeSelect", "onNodeToggle", "selected"]);
  var _React$useState = React35.useState(null), tabbable = _React$useState[0], setTabbable = _React$useState[1];
  var _React$useState2 = React35.useState(null), focusedNodeId = _React$useState2[0], setFocusedNodeId = _React$useState2[1];
  var nodeMap = React35.useRef({});
  var firstCharMap = React35.useRef({});
  var visibleNodes = React35.useRef([]);
  var _useControlled = useControlled({
    controlled: expandedProp,
    default: defaultExpanded,
    name: "TreeView",
    state: "expanded"
  }), _useControlled2 = _slicedToArray(_useControlled, 2), expanded = _useControlled2[0], setExpandedState = _useControlled2[1];
  var _useControlled3 = useControlled({
    controlled: selectedProp,
    default: defaultSelected,
    name: "TreeView",
    state: "selected"
  }), _useControlled4 = _slicedToArray(_useControlled3, 2), selected = _useControlled4[0], setSelectedState = _useControlled4[1];
  var isExpanded = React35.useCallback(function(id) {
    return Array.isArray(expanded) ? expanded.indexOf(id) !== -1 : false;
  }, [expanded]);
  var isSelected = React35.useCallback(function(id) {
    return Array.isArray(selected) ? selected.indexOf(id) !== -1 : selected === id;
  }, [selected]);
  var isTabbable = function isTabbable2(id) {
    return tabbable === id;
  };
  var isFocused = function isFocused2(id) {
    return focusedNodeId === id;
  };
  var getNextNode = function getNextNode2(id) {
    var nodeIndex = visibleNodes.current.indexOf(id);
    if (nodeIndex !== -1 && nodeIndex + 1 < visibleNodes.current.length) {
      return visibleNodes.current[nodeIndex + 1];
    }
    return null;
  };
  var getPreviousNode = function getPreviousNode2(id) {
    var nodeIndex = visibleNodes.current.indexOf(id);
    if (nodeIndex !== -1 && nodeIndex - 1 >= 0) {
      return visibleNodes.current[nodeIndex - 1];
    }
    return null;
  };
  var getLastNode = function getLastNode2() {
    return visibleNodes.current[visibleNodes.current.length - 1];
  };
  var getFirstNode = function getFirstNode2() {
    return visibleNodes.current[0];
  };
  var getParent = function getParent2(id) {
    return nodeMap.current[id].parent;
  };
  var getNodesInRange = function getNodesInRange2(a, b) {
    var aIndex = visibleNodes.current.indexOf(a);
    var bIndex = visibleNodes.current.indexOf(b);
    var start = Math.min(aIndex, bIndex);
    var end = Math.max(aIndex, bIndex);
    return visibleNodes.current.slice(start, end + 1);
  };
  var focus = function focus2(id) {
    if (id) {
      setTabbable(id);
      setFocusedNodeId(id);
    }
  };
  var focusNextNode = function focusNextNode2(id) {
    return focus(getNextNode(id));
  };
  var focusPreviousNode = function focusPreviousNode2(id) {
    return focus(getPreviousNode(id));
  };
  var focusFirstNode = function focusFirstNode2() {
    return focus(getFirstNode());
  };
  var focusLastNode = function focusLastNode2() {
    return focus(getLastNode());
  };
  var focusByFirstCharacter = function focusByFirstCharacter2(id, char) {
    var start;
    var index;
    var lowercaseChar = char.toLowerCase();
    var firstCharIds = [];
    var firstChars = [];
    Object.keys(firstCharMap.current).forEach(function(nodeId) {
      var firstChar = firstCharMap.current[nodeId];
      var map = nodeMap.current[nodeId];
      var visible = map.parent ? isExpanded(map.parent) : true;
      if (visible) {
        firstCharIds.push(nodeId);
        firstChars.push(firstChar);
      }
    });
    start = firstCharIds.indexOf(id) + 1;
    if (start === nodeMap.current.length) {
      start = 0;
    }
    index = findNextFirstChar(firstChars, start, lowercaseChar);
    if (index === -1) {
      index = findNextFirstChar(firstChars, 0, lowercaseChar);
    }
    if (index > -1) {
      focus(firstCharIds[index]);
    }
  };
  var toggleExpansion = function toggleExpansion2(event) {
    var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : focusedNodeId;
    var newExpanded;
    if (expanded.indexOf(value) !== -1) {
      newExpanded = expanded.filter(function(id) {
        return id !== value;
      });
      setTabbable(function(oldTabbable) {
        var map = nodeMap.current[oldTabbable];
        if (oldTabbable && (map && map.parent ? map.parent.id : null) === value) {
          return value;
        }
        return oldTabbable;
      });
    } else {
      newExpanded = [value].concat(expanded);
    }
    if (onNodeToggle) {
      onNodeToggle(event, newExpanded);
    }
    setExpandedState(newExpanded);
  };
  var expandAllSiblings = function expandAllSiblings2(event, id) {
    var map = nodeMap.current[id];
    var parent = nodeMap.current[map.parent];
    var diff;
    if (parent) {
      diff = parent.children.filter(function(child) {
        return !isExpanded(child);
      });
    } else {
      var topLevelNodes = nodeMap.current[-1].children;
      diff = topLevelNodes.filter(function(node2) {
        return !isExpanded(node2);
      });
    }
    var newExpanded = expanded.concat(diff);
    if (diff.length > 0) {
      setExpandedState(newExpanded);
      if (onNodeToggle) {
        onNodeToggle(event, newExpanded);
      }
    }
  };
  var lastSelectedNode = React35.useRef(null);
  var lastSelectionWasRange = React35.useRef(false);
  var currentRangeSelection = React35.useRef([]);
  var handleRangeArrowSelect = function handleRangeArrowSelect2(event, nodes) {
    var base = selected;
    var start = nodes.start, next = nodes.next, current = nodes.current;
    if (!next || !current) {
      return;
    }
    if (currentRangeSelection.current.indexOf(current) === -1) {
      currentRangeSelection.current = [];
    }
    if (lastSelectionWasRange.current) {
      if (currentRangeSelection.current.indexOf(next) !== -1) {
        base = base.filter(function(id) {
          return id === start || id !== current;
        });
        currentRangeSelection.current = currentRangeSelection.current.filter(function(id) {
          return id === start || id !== current;
        });
      } else {
        base.push(next);
        currentRangeSelection.current.push(next);
      }
    } else {
      base.push(next);
      currentRangeSelection.current.push(current, next);
    }
    if (onNodeSelect) {
      onNodeSelect(event, base);
    }
    setSelectedState(base);
  };
  var handleRangeSelect = function handleRangeSelect2(event, nodes) {
    var base = selected;
    var start = nodes.start, end = nodes.end;
    if (lastSelectionWasRange.current) {
      base = selected.filter(function(id) {
        return currentRangeSelection.current.indexOf(id) === -1;
      });
    }
    var range = getNodesInRange(start, end);
    currentRangeSelection.current = range;
    var newSelected = base.concat(range);
    newSelected = newSelected.filter(function(id, i) {
      return newSelected.indexOf(id) === i;
    });
    if (onNodeSelect) {
      onNodeSelect(event, newSelected);
    }
    setSelectedState(newSelected);
  };
  var handleMultipleSelect = function handleMultipleSelect2(event, value) {
    var newSelected = [];
    if (selected.indexOf(value) !== -1) {
      newSelected = selected.filter(function(id) {
        return id !== value;
      });
    } else {
      newSelected = [value].concat(selected);
    }
    if (onNodeSelect) {
      onNodeSelect(event, newSelected);
    }
    setSelectedState(newSelected);
  };
  var handleSingleSelect = function handleSingleSelect2(event, value) {
    var newSelected = multiSelect ? [value] : value;
    if (onNodeSelect) {
      onNodeSelect(event, newSelected);
    }
    setSelectedState(newSelected);
  };
  var selectNode = function selectNode2(event, id) {
    var multiple = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (id) {
      if (multiple) {
        handleMultipleSelect(event, id);
      } else {
        handleSingleSelect(event, id);
      }
      lastSelectedNode.current = id;
      lastSelectionWasRange.current = false;
      currentRangeSelection.current = [];
      return true;
    }
    return false;
  };
  var selectRange = function selectRange2(event, nodes) {
    var stacked = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var _nodes$start = nodes.start, start = _nodes$start === void 0 ? lastSelectedNode.current : _nodes$start, end = nodes.end, current = nodes.current;
    if (stacked) {
      handleRangeArrowSelect(event, {
        start,
        next: end,
        current
      });
    } else {
      handleRangeSelect(event, {
        start,
        end
      });
    }
    lastSelectionWasRange.current = true;
    return true;
  };
  var rangeSelectToFirst = function rangeSelectToFirst2(event, id) {
    if (!lastSelectedNode.current) {
      lastSelectedNode.current = id;
    }
    var start = lastSelectionWasRange.current ? lastSelectedNode.current : id;
    return selectRange(event, {
      start,
      end: getFirstNode()
    });
  };
  var rangeSelectToLast = function rangeSelectToLast2(event, id) {
    if (!lastSelectedNode.current) {
      lastSelectedNode.current = id;
    }
    var start = lastSelectionWasRange.current ? lastSelectedNode.current : id;
    return selectRange(event, {
      start,
      end: getLastNode()
    });
  };
  var selectNextNode = function selectNextNode2(event, id) {
    return selectRange(event, {
      end: getNextNode(id),
      current: id
    }, true);
  };
  var selectPreviousNode = function selectPreviousNode2(event, id) {
    return selectRange(event, {
      end: getPreviousNode(id),
      current: id
    }, true);
  };
  var selectAllNodes = function selectAllNodes2(event) {
    return selectRange(event, {
      start: getFirstNode(),
      end: getLastNode()
    });
  };
  var addNodeToNodeMap = function addNodeToNodeMap2(id, childrenIds) {
    var currentMap = nodeMap.current[id];
    nodeMap.current[id] = _extends({}, currentMap, {
      children: childrenIds,
      id
    });
    childrenIds.forEach(function(childId) {
      var currentChildMap = nodeMap.current[childId];
      nodeMap.current[childId] = _extends({}, currentChildMap, {
        parent: id,
        id: childId
      });
    });
  };
  var getNodesToRemove = React35.useCallback(function(id) {
    var map = nodeMap.current[id];
    var nodes = [];
    if (map) {
      nodes.push(id);
      if (map.children) {
        nodes.concat(map.children);
        map.children.forEach(function(node2) {
          nodes.concat(getNodesToRemove(node2));
        });
      }
    }
    return nodes;
  }, []);
  var cleanUpFirstCharMap = React35.useCallback(function(nodes) {
    var newMap = _extends({}, firstCharMap.current);
    nodes.forEach(function(node2) {
      if (newMap[node2]) {
        delete newMap[node2];
      }
    });
    firstCharMap.current = newMap;
  }, []);
  var removeNodeFromNodeMap = React35.useCallback(function(id) {
    var nodes = getNodesToRemove(id);
    cleanUpFirstCharMap(nodes);
    var newMap = _extends({}, nodeMap.current);
    nodes.forEach(function(node2) {
      var map = newMap[node2];
      if (map) {
        if (map.parent) {
          var parentMap = newMap[map.parent];
          if (parentMap && parentMap.children) {
            var parentChildren = parentMap.children.filter(function(c) {
              return c !== node2;
            });
            newMap[map.parent] = _extends({}, parentMap, {
              children: parentChildren
            });
          }
        }
        delete newMap[node2];
      }
    });
    nodeMap.current = newMap;
    setFocusedNodeId(function(oldFocusedNodeId) {
      if (oldFocusedNodeId === id) {
        return null;
      }
      return oldFocusedNodeId;
    });
  }, [getNodesToRemove, cleanUpFirstCharMap]);
  var mapFirstChar = function mapFirstChar2(id, firstChar) {
    firstCharMap.current[id] = firstChar;
  };
  var prevChildIds = React35.useRef([]);
  var _React$useState3 = React35.useState(false), childrenCalculated = _React$useState3[0], setChildrenCalculated = _React$useState3[1];
  React35.useEffect(function() {
    var childIds = [];
    React35.Children.forEach(children, function(child) {
      if (React35.isValidElement(child) && child.props.nodeId) {
        childIds.push(child.props.nodeId);
      }
    });
    if (arrayDiff(prevChildIds.current, childIds)) {
      nodeMap.current[-1] = {
        parent: null,
        children: childIds
      };
      childIds.forEach(function(id, index) {
        if (index === 0) {
          setTabbable(id);
        }
      });
      visibleNodes.current = nodeMap.current[-1].children;
      prevChildIds.current = childIds;
      setChildrenCalculated(true);
    }
  }, [children]);
  React35.useEffect(function() {
    var buildVisible = function buildVisible2(nodes) {
      var list = [];
      for (var i = 0; i < nodes.length; i += 1) {
        var item = nodes[i];
        list.push(item);
        var childs = nodeMap.current[item].children;
        if (isExpanded(item) && childs) {
          list = list.concat(buildVisible2(childs));
        }
      }
      return list;
    };
    if (childrenCalculated) {
      visibleNodes.current = buildVisible(nodeMap.current[-1].children);
    }
  }, [expanded, childrenCalculated, isExpanded, children]);
  var noopSelection = function noopSelection2() {
    return false;
  };
  return React35.createElement(TreeViewContext_default.Provider, {
    value: {
      icons: {
        defaultCollapseIcon,
        defaultExpandIcon,
        defaultParentIcon,
        defaultEndIcon
      },
      focus,
      focusFirstNode,
      focusLastNode,
      focusNextNode,
      focusPreviousNode,
      focusByFirstCharacter,
      expandAllSiblings,
      toggleExpansion,
      isExpanded,
      isFocused,
      isSelected,
      selectNode: disableSelection ? noopSelection : selectNode,
      selectRange: disableSelection ? noopSelection : selectRange,
      selectNextNode: disableSelection ? noopSelection : selectNextNode,
      selectPreviousNode: disableSelection ? noopSelection : selectPreviousNode,
      rangeSelectToFirst: disableSelection ? noopSelection : rangeSelectToFirst,
      rangeSelectToLast: disableSelection ? noopSelection : rangeSelectToLast,
      selectAllNodes: disableSelection ? noopSelection : selectAllNodes,
      isTabbable,
      multiSelect,
      getParent,
      mapFirstChar,
      addNodeToNodeMap,
      removeNodeFromNodeMap
    }
  }, React35.createElement("ul", _extends({
    role: "tree",
    "aria-multiselectable": multiSelect,
    className: clsx_m_default(classes.root, className),
    ref
  }, other), children));
});
true ? TreeView.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: import_prop_types21.default.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: import_prop_types21.default.object,
  /**
   * @ignore
   */
  className: import_prop_types21.default.string,
  /**
   * The default icon used to collapse the node.
   */
  defaultCollapseIcon: import_prop_types21.default.node,
  /**
   * The default icon displayed next to a end node. This is applied to all
   * tree nodes and can be overridden by the TreeItem `icon` prop.
   */
  defaultEndIcon: import_prop_types21.default.node,
  /**
   * Expanded node ids. (Uncontrolled)
   */
  defaultExpanded: import_prop_types21.default.arrayOf(import_prop_types21.default.string),
  /**
   * The default icon used to expand the node.
   */
  defaultExpandIcon: import_prop_types21.default.node,
  /**
   * The default icon displayed next to a parent node. This is applied to all
   * parent nodes and can be overridden by the TreeItem `icon` prop.
   */
  defaultParentIcon: import_prop_types21.default.node,
  /**
   * Selected node ids. (Uncontrolled)
   * When `multiSelect` is true this takes an array of strings; when false (default) a string.
   */
  defaultSelected: import_prop_types21.default.oneOfType([import_prop_types21.default.arrayOf(import_prop_types21.default.string), import_prop_types21.default.string]),
  /**
   * If `true` selection is disabled.
   */
  disableSelection: import_prop_types21.default.bool,
  /**
   * Expanded node ids. (Controlled)
   */
  expanded: import_prop_types21.default.arrayOf(import_prop_types21.default.string),
  /**
   * If true `ctrl` and `shift` will trigger multiselect.
   */
  multiSelect: import_prop_types21.default.bool,
  /**
   * Callback fired when tree items are selected/unselected.
   *
   * @param {object} event The event source of the callback
   * @param {(array|string)} value of the selected nodes. When `multiSelect` is true
   * this is an array of strings; when false (default) a string.
   */
  onNodeSelect: import_prop_types21.default.func,
  /**
   * Callback fired when tree items are expanded/collapsed.
   *
   * @param {object} event The event source of the callback.
   * @param {array} nodeIds The ids of the expanded nodes.
   */
  onNodeToggle: import_prop_types21.default.func,
  /**
   * Selected node ids. (Controlled)
   * When `multiSelect` is true this takes an array of strings; when false (default) a string.
   */
  selected: import_prop_types21.default.oneOfType([import_prop_types21.default.arrayOf(import_prop_types21.default.string), import_prop_types21.default.string])
} : void 0;
var TreeView_default = withStyles_default(styles41, {
  name: "MuiTreeView"
})(TreeView);

export {
  ToggleButton_default,
  ToggleButtonGroup_default,
  Alert_default,
  AlertTitle_default,
  createFilterOptions,
  useAutocomplete,
  Autocomplete_default,
  AvatarGroup_default,
  Rating_default,
  Skeleton_default,
  SpeedDial_default,
  SpeedDialAction_default,
  SpeedDialIcon_default,
  TabContext,
  useTabContext,
  getPanelId,
  getTabId,
  TabList_default,
  TabPanel_default,
  Timeline_default,
  TimelineConnector_default,
  TimelineContent_default,
  TimelineDot_default,
  TimelineItem_default,
  TimelineOppositeContent_default,
  TimelineSeparator_default,
  TreeItem_default,
  TreeView_default
};
/*! Bundled license information:

@material-ui/lab/esm/index.js:
  (** @license Material-UI v4.0.0-alpha.61
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=chunk-LU4ZSRGR.js.map
