{
  "version": 3,
  "sources": ["../../../../node_modules/lexical/Lexical.dev.js", "../../../../node_modules/lexical/Lexical.js", "../../../../node_modules/@lexical/react/LexicalComposerContext.dev.js", "../../../../node_modules/@lexical/react/LexicalComposerContext.js", "../../../../node_modules/@lexical/react/LexicalComposer.dev.js", "../../../../node_modules/@lexical/react/LexicalComposer.js", "../../../../node_modules/@lexical/react/LexicalErrorBoundary.dev.js", "../../../../node_modules/@lexical/react/LexicalErrorBoundary.js", "../../../../node_modules/@lexical/react/useLexicalNodeSelection.dev.js", "../../../../node_modules/@lexical/react/useLexicalNodeSelection.js", "../../../../node_modules/@lexical/selection/LexicalSelection.dev.js", "../../../../node_modules/@lexical/selection/LexicalSelection.js", "../../../../node_modules/@lexical/utils/LexicalUtils.dev.js", "../../../../node_modules/@lexical/utils/LexicalUtils.js", "../../../../node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js", "../../../../node_modules/@lexical/react/LexicalHorizontalRuleNode.js", "../../../../node_modules/prismjs/prism.js", "../../../../node_modules/prismjs/components/prism-clike.js", "../../../../node_modules/prismjs/components/prism-javascript.js", "../../../../node_modules/prismjs/components/prism-markup.js", "../../../../node_modules/prismjs/components/prism-markdown.js", "../../../../node_modules/prismjs/components/prism-c.js", "../../../../node_modules/prismjs/components/prism-css.js", "../../../../node_modules/prismjs/components/prism-objectivec.js", "../../../../node_modules/prismjs/components/prism-sql.js", "../../../../node_modules/prismjs/components/prism-python.js", "../../../../node_modules/prismjs/components/prism-rust.js", "../../../../node_modules/prismjs/components/prism-swift.js", "../../../../node_modules/prismjs/components/prism-typescript.js", "../../../../node_modules/prismjs/components/prism-java.js", "../../../../node_modules/prismjs/components/prism-cpp.js", "../../../../node_modules/@lexical/code/LexicalCode.dev.js", "../../../../node_modules/@lexical/code/LexicalCode.js", "../../../../node_modules/@lexical/list/LexicalList.dev.js", "../../../../node_modules/@lexical/list/LexicalList.js", "../../../../node_modules/@lexical/html/LexicalHtml.dev.js", "../../../../node_modules/@lexical/html/LexicalHtml.js", "../../../../node_modules/@lexical/clipboard/LexicalClipboard.dev.js", "../../../../node_modules/@lexical/clipboard/LexicalClipboard.js", "../../../../node_modules/@lexical/rich-text/LexicalRichText.dev.js", "../../../../node_modules/@lexical/rich-text/LexicalRichText.js", "../../../../node_modules/@lexical/link/LexicalLink.dev.js", "../../../../node_modules/@lexical/link/LexicalLink.js", "../../../../node_modules/@lexical/markdown/LexicalMarkdown.dev.js", "../../../../node_modules/@lexical/markdown/LexicalMarkdown.js", "../../../../node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js", "../../../../node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.js", "../../../../node_modules/@lexical/react/useLexicalEditable.dev.js", "../../../../node_modules/@lexical/react/useLexicalEditable.js", "../../../../node_modules/@lexical/text/LexicalText.dev.js", "../../../../node_modules/@lexical/text/LexicalText.js", "../../../../node_modules/@lexical/dragon/LexicalDragon.dev.js", "../../../../node_modules/@lexical/dragon/LexicalDragon.js", "../../../../node_modules/@lexical/react/LexicalRichTextPlugin.dev.js", "../../../../node_modules/@lexical/react/LexicalRichTextPlugin.js", "../../../../node_modules/@lexical/react/LexicalTabIndentationPlugin.dev.js", "../../../../node_modules/@lexical/react/LexicalTabIndentationPlugin.js", "../../../../node_modules/@material-ui/icons/Code.js", "../../../../node_modules/@material-ui/icons/FormatBold.js", "../../../../node_modules/@material-ui/icons/FormatItalic.js", "../../../../node_modules/@material-ui/icons/FormatListNumbered.js", "../../../../node_modules/@material-ui/icons/StrikethroughS.js", "../../../../node_modules/@material-ui/icons/Subject.js", "../../../../node_modules/@material-ui/icons/Title.js", "../../../../node_modules/@eclipse-sirius/sirius-components-forms/dist/sirius-components-forms.es.js", "../../../../node_modules/@eclipse-sirius/sirius-components-charts/dist/sirius-components-charts.es.js", "../../../../node_modules/d3-array/src/ascending.js", "../../../../node_modules/d3-array/src/descending.js", "../../../../node_modules/d3-array/src/bisector.js", "../../../../node_modules/d3-array/src/number.js", "../../../../node_modules/d3-array/src/bisect.js", "../../../../node_modules/d3-array/src/blur.js", "../../../../node_modules/d3-array/src/fsum.js", "../../../../node_modules/internmap/src/index.js", "../../../../node_modules/d3-array/src/array.js", "../../../../node_modules/d3-array/src/ticks.js", "../../../../node_modules/d3-array/src/max.js", "../../../../node_modules/d3-array/src/merge.js", "../../../../node_modules/d3-array/src/range.js", "../../../../node_modules/d3-array/src/shuffle.js", "../../../../node_modules/d3-array/src/map.js", "../../../../node_modules/d3-axis/src/identity.js", "../../../../node_modules/d3-axis/src/axis.js", "../../../../node_modules/d3-brush/src/brush.js", "../../../../node_modules/d3-chord/src/math.js", "../../../../node_modules/d3-path/src/path.js", "../../../../node_modules/d3-chord/src/array.js", "../../../../node_modules/d3-contour/src/array.js", "../../../../node_modules/robust-predicates/esm/util.js", "../../../../node_modules/robust-predicates/esm/orient2d.js", "../../../../node_modules/robust-predicates/esm/orient3d.js", "../../../../node_modules/robust-predicates/esm/incircle.js", "../../../../node_modules/robust-predicates/esm/insphere.js", "../../../../node_modules/delaunator/index.js", "../../../../node_modules/d3-delaunay/src/delaunay.js", "../../../../node_modules/d3-dsv/src/dsv.js", "../../../../node_modules/d3-dsv/src/csv.js", "../../../../node_modules/d3-dsv/src/tsv.js", "../../../../node_modules/d3-dsv/src/autoType.js", "../../../../node_modules/d3-fetch/src/text.js", "../../../../node_modules/d3-fetch/src/dsv.js", "../../../../node_modules/d3-fetch/src/xml.js", "../../../../node_modules/d3-quadtree/src/add.js", "../../../../node_modules/d3-quadtree/src/cover.js", "../../../../node_modules/d3-quadtree/src/data.js", "../../../../node_modules/d3-quadtree/src/extent.js", "../../../../node_modules/d3-quadtree/src/quad.js", "../../../../node_modules/d3-quadtree/src/find.js", "../../../../node_modules/d3-quadtree/src/remove.js", "../../../../node_modules/d3-quadtree/src/root.js", "../../../../node_modules/d3-quadtree/src/size.js", "../../../../node_modules/d3-quadtree/src/visit.js", "../../../../node_modules/d3-quadtree/src/visitAfter.js", "../../../../node_modules/d3-quadtree/src/x.js", "../../../../node_modules/d3-quadtree/src/y.js", "../../../../node_modules/d3-quadtree/src/quadtree.js", "../../../../node_modules/d3-force/src/simulation.js", "../../../../node_modules/d3-format/src/formatDecimal.js", "../../../../node_modules/d3-format/src/exponent.js", "../../../../node_modules/d3-format/src/formatGroup.js", "../../../../node_modules/d3-format/src/formatNumerals.js", "../../../../node_modules/d3-format/src/formatSpecifier.js", "../../../../node_modules/d3-format/src/formatTrim.js", "../../../../node_modules/d3-format/src/formatPrefixAuto.js", "../../../../node_modules/d3-format/src/formatRounded.js", "../../../../node_modules/d3-format/src/formatTypes.js", "../../../../node_modules/d3-format/src/identity.js", "../../../../node_modules/d3-format/src/locale.js", "../../../../node_modules/d3-format/src/defaultLocale.js", "../../../../node_modules/d3-format/src/precisionFixed.js", "../../../../node_modules/d3-format/src/precisionPrefix.js", "../../../../node_modules/d3-format/src/precisionRound.js", "../../../../node_modules/d3-geo/src/math.js", "../../../../node_modules/d3-geo/src/noop.js", "../../../../node_modules/d3-geo/src/area.js", "../../../../node_modules/d3-geo/src/cartesian.js", "../../../../node_modules/d3-geo/src/rotation.js", "../../../../node_modules/d3-geo/src/clip/buffer.js", "../../../../node_modules/d3-geo/src/pointEqual.js", "../../../../node_modules/d3-geo/src/clip/rejoin.js", "../../../../node_modules/d3-geo/src/polygonContains.js", "../../../../node_modules/d3-geo/src/clip/index.js", "../../../../node_modules/d3-geo/src/clip/antimeridian.js", "../../../../node_modules/d3-geo/src/clip/rectangle.js", "../../../../node_modules/d3-geo/src/path/area.js", "../../../../node_modules/d3-geo/src/path/bounds.js", "../../../../node_modules/d3-geo/src/path/context.js", "../../../../node_modules/d3-geo/src/path/measure.js", "../../../../node_modules/d3-geo/src/transform.js", "../../../../node_modules/d3-geo/src/projection/resample.js", "../../../../node_modules/d3-geo/src/projection/index.js", "../../../../node_modules/d3-geo/src/projection/azimuthal.js", "../../../../node_modules/d3-geo/src/projection/azimuthalEqualArea.js", "../../../../node_modules/d3-geo/src/projection/azimuthalEquidistant.js", "../../../../node_modules/d3-geo/src/projection/mercator.js", "../../../../node_modules/d3-geo/src/projection/equirectangular.js", "../../../../node_modules/d3-geo/src/projection/equalEarth.js", "../../../../node_modules/d3-geo/src/projection/gnomonic.js", "../../../../node_modules/d3-geo/src/projection/naturalEarth1.js", "../../../../node_modules/d3-geo/src/projection/orthographic.js", "../../../../node_modules/d3-geo/src/projection/stereographic.js", "../../../../node_modules/d3-geo/src/projection/transverseMercator.js", "../../../../node_modules/d3-hierarchy/src/hierarchy/count.js", "../../../../node_modules/d3-hierarchy/src/hierarchy/each.js", "../../../../node_modules/d3-hierarchy/src/hierarchy/eachBefore.js", "../../../../node_modules/d3-hierarchy/src/hierarchy/eachAfter.js", "../../../../node_modules/d3-hierarchy/src/hierarchy/find.js", "../../../../node_modules/d3-hierarchy/src/hierarchy/sum.js", "../../../../node_modules/d3-hierarchy/src/hierarchy/sort.js", "../../../../node_modules/d3-hierarchy/src/hierarchy/path.js", "../../../../node_modules/d3-hierarchy/src/hierarchy/ancestors.js", "../../../../node_modules/d3-hierarchy/src/hierarchy/descendants.js", "../../../../node_modules/d3-hierarchy/src/hierarchy/leaves.js", "../../../../node_modules/d3-hierarchy/src/hierarchy/links.js", "../../../../node_modules/d3-hierarchy/src/hierarchy/iterator.js", "../../../../node_modules/d3-hierarchy/src/hierarchy/index.js", "../../../../node_modules/d3-hierarchy/src/treemap/dice.js", "../../../../node_modules/d3-hierarchy/src/tree.js", "../../../../node_modules/d3-hierarchy/src/treemap/slice.js", "../../../../node_modules/d3-hierarchy/src/treemap/squarify.js", "../../../../node_modules/d3-hierarchy/src/treemap/resquarify.js", "../../../../node_modules/d3-random/src/defaultSource.js", "../../../../node_modules/d3-random/src/uniform.js", "../../../../node_modules/d3-random/src/int.js", "../../../../node_modules/d3-random/src/normal.js", "../../../../node_modules/d3-random/src/logNormal.js", "../../../../node_modules/d3-random/src/irwinHall.js", "../../../../node_modules/d3-random/src/bates.js", "../../../../node_modules/d3-random/src/exponential.js", "../../../../node_modules/d3-random/src/pareto.js", "../../../../node_modules/d3-random/src/bernoulli.js", "../../../../node_modules/d3-random/src/geometric.js", "../../../../node_modules/d3-random/src/gamma.js", "../../../../node_modules/d3-random/src/beta.js", "../../../../node_modules/d3-random/src/binomial.js", "../../../../node_modules/d3-random/src/weibull.js", "../../../../node_modules/d3-random/src/cauchy.js", "../../../../node_modules/d3-random/src/logistic.js", "../../../../node_modules/d3-random/src/poisson.js", "../../../../node_modules/d3-random/src/lcg.js", "../../../../node_modules/d3-scale/src/init.js", "../../../../node_modules/d3-scale/src/ordinal.js", "../../../../node_modules/d3-scale/src/band.js", "../../../../node_modules/d3-scale/src/constant.js", "../../../../node_modules/d3-scale/src/number.js", "../../../../node_modules/d3-scale/src/continuous.js", "../../../../node_modules/d3-scale/src/tickFormat.js", "../../../../node_modules/d3-scale/src/linear.js", "../../../../node_modules/d3-time/src/interval.js", "../../../../node_modules/d3-time/src/millisecond.js", "../../../../node_modules/d3-time/src/duration.js", "../../../../node_modules/d3-time/src/second.js", "../../../../node_modules/d3-time/src/minute.js", "../../../../node_modules/d3-time/src/hour.js", "../../../../node_modules/d3-time/src/day.js", "../../../../node_modules/d3-time/src/week.js", "../../../../node_modules/d3-time/src/month.js", "../../../../node_modules/d3-time/src/year.js", "../../../../node_modules/d3-time/src/ticks.js", "../../../../node_modules/d3-time-format/src/locale.js", "../../../../node_modules/d3-time-format/src/defaultLocale.js", "../../../../node_modules/d3-time-format/src/isoFormat.js", "../../../../node_modules/d3-time-format/src/isoParse.js", "../../../../node_modules/d3-scale-chromatic/src/colors.js", "../../../../node_modules/d3-scale-chromatic/src/categorical/category10.js", "../../../../node_modules/d3-scale-chromatic/src/categorical/Accent.js", "../../../../node_modules/d3-scale-chromatic/src/categorical/Dark2.js", "../../../../node_modules/d3-scale-chromatic/src/categorical/Paired.js", "../../../../node_modules/d3-scale-chromatic/src/categorical/Pastel1.js", "../../../../node_modules/d3-scale-chromatic/src/categorical/Pastel2.js", "../../../../node_modules/d3-scale-chromatic/src/categorical/Set1.js", "../../../../node_modules/d3-scale-chromatic/src/categorical/Set2.js", "../../../../node_modules/d3-scale-chromatic/src/categorical/Set3.js", "../../../../node_modules/d3-scale-chromatic/src/categorical/Tableau10.js", "../../../../node_modules/d3-scale-chromatic/src/ramp.js", "../../../../node_modules/d3-scale-chromatic/src/diverging/BrBG.js", "../../../../node_modules/d3-scale-chromatic/src/diverging/PRGn.js", "../../../../node_modules/d3-scale-chromatic/src/diverging/PiYG.js", "../../../../node_modules/d3-scale-chromatic/src/diverging/PuOr.js", "../../../../node_modules/d3-scale-chromatic/src/diverging/RdBu.js", "../../../../node_modules/d3-scale-chromatic/src/diverging/RdGy.js", "../../../../node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js", "../../../../node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js", "../../../../node_modules/d3-scale-chromatic/src/diverging/Spectral.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-single/Blues.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-single/Greens.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-single/Greys.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-single/Purples.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-single/Reds.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js", "../../../../node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js", "../../../../node_modules/d3-shape/src/constant.js", "../../../../node_modules/d3-shape/src/math.js", "../../../../node_modules/d3-shape/src/path.js", "../../../../node_modules/d3-shape/src/arc.js", "../../../../node_modules/d3-shape/src/array.js", "../../../../node_modules/d3-shape/src/curve/linear.js", "../../../../node_modules/d3-shape/src/descending.js", "../../../../node_modules/d3-shape/src/identity.js", "../../../../node_modules/d3-shape/src/pie.js", "../../../../node_modules/d3-shape/src/curve/radial.js", "../../../../node_modules/d3-shape/src/symbol/asterisk.js", "../../../../node_modules/d3-shape/src/symbol/diamond.js", "../../../../node_modules/d3-shape/src/symbol/star.js", "../../../../node_modules/d3-shape/src/symbol/triangle.js", "../../../../node_modules/d3-shape/src/symbol/triangle2.js", "../../../../node_modules/d3-shape/src/symbol/wye.js", "../../../../node_modules/d3-shape/src/noop.js", "../../../../node_modules/d3-shape/src/curve/basis.js", "../../../../node_modules/d3-shape/src/curve/basisClosed.js", "../../../../node_modules/d3-shape/src/curve/basisOpen.js", "../../../../node_modules/d3-shape/src/curve/bundle.js", "../../../../node_modules/d3-shape/src/curve/cardinal.js", "../../../../node_modules/d3-shape/src/curve/cardinalClosed.js", "../../../../node_modules/d3-shape/src/curve/cardinalOpen.js", "../../../../node_modules/d3-shape/src/curve/catmullRom.js", "../../../../node_modules/d3-shape/src/curve/catmullRomClosed.js", "../../../../node_modules/d3-shape/src/curve/catmullRomOpen.js", "../../../../node_modules/d3-shape/src/curve/linearClosed.js", "../../../../node_modules/d3-shape/src/curve/monotone.js", "../../../../node_modules/d3-shape/src/curve/natural.js", "../../../../node_modules/d3-shape/src/curve/step.js"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createCommand(type) {\n  return {\n    type\n  } ;\n}\nconst SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');\nconst CLICK_COMMAND = createCommand('CLICK_COMMAND');\nconst DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');\nconst INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');\nconst INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');\nconst CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\nconst PASTE_COMMAND = createCommand('PASTE_COMMAND');\nconst REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');\nconst DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');\nconst DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');\nconst FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');\nconst UNDO_COMMAND = createCommand('UNDO_COMMAND');\nconst REDO_COMMAND = createCommand('REDO_COMMAND');\nconst KEY_DOWN_COMMAND = createCommand('KEYDOWN_COMMAND');\nconst KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');\nconst MOVE_TO_END = createCommand('MOVE_TO_END');\nconst KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');\nconst MOVE_TO_START = createCommand('MOVE_TO_START');\nconst KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');\nconst KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');\nconst KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');\nconst KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');\nconst KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');\nconst KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');\nconst KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');\nconst KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');\nconst INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');\nconst OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');\nconst DROP_COMMAND = createCommand('DROP_COMMAND');\nconst FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');\nconst DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');\nconst DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');\nconst DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');\nconst COPY_COMMAND = createCommand('COPY_COMMAND');\nconst CUT_COMMAND = createCommand('CUT_COMMAND');\nconst CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');\nconst CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');\nconst CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');\nconst CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');\nconst FOCUS_COMMAND = createCommand('FOCUS_COMMAND');\nconst BLUR_COMMAND = createCommand('BLUR_COMMAND');\nconst KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// DOM\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3;\n\n// Reconciling\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2;\n\n// Text node modes\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2;\n// IS_INERT = 3\n\n// Text node formatting\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6;\nconst IS_HIGHLIGHT = 1 << 7;\nconst IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT;\n\n// Text node details\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1;\n\n// Element node formatting\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4;\nconst IS_ALIGN_START = 5;\nconst IS_ALIGN_END = 6;\n\n// Reconciliation\nconst NON_BREAKING_SPACE = '\\u00A0';\nconst ZERO_WIDTH_SPACE = '\\u200b';\n\n// For iOS/Safari we use a non breaking space, otherwise the cursor appears\n// overlapping the composed text.\nconst COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;\nconst DOUBLE_LINE_BREAK = '\\n\\n';\n\n// For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\nconst COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF';\n\n// eslint-disable-next-line no-misleading-character-class\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']');\n// eslint-disable-next-line no-misleading-character-class\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  code: IS_CODE,\n  highlight: IS_HIGHLIGHT,\n  italic: IS_ITALIC,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE\n};\nconst DETAIL_TYPE_TO_DETAIL = {\n  directionless: IS_DIRECTIONLESS,\n  unmergeable: IS_UNMERGEABLE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  end: IS_ALIGN_END,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT,\n  start: IS_ALIGN_START\n};\nconst ELEMENT_FORMAT_TO_TYPE = {\n  [IS_ALIGN_CENTER]: 'center',\n  [IS_ALIGN_END]: 'end',\n  [IS_ALIGN_JUSTIFY]: 'justify',\n  [IS_ALIGN_LEFT]: 'left',\n  [IS_ALIGN_RIGHT]: 'right',\n  [IS_ALIGN_START]: 'start'\n};\nconst TEXT_MODE_TO_TYPE = {\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\nconst TEXT_TYPE_TO_MODE = {\n  [IS_NORMAL]: 'normal',\n  [IS_SEGMENTED]: 'segmented',\n  [IS_TOKEN]: 'token'\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// The time between a text entry event and the mutation observer firing.\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\nfunction getIsProcesssingMutations() {\n  return isProcessingMutations;\n}\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\nfunction initTextEntryListener(editor) {\n  if (lastTextEntryTimeStamp === 0) {\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\n  }\n}\nfunction isManagedLineBreak(dom, target, editor) {\n  return (\n    // @ts-expect-error: internal field\n    target.__lexicalLineBreak === dom ||\n    // @ts-ignore We intentionally add this to the Node.\n    dom[`__lexicalKey_${editor._key}`] !== undefined\n  );\n}\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\nfunction handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection(editor._window);\n  let anchorOffset = null;\n  let focusOffset = null;\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n  const text = target.nodeValue;\n  if (text !== null) {\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n  }\n}\nfunction shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {\n  if ($isRangeSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {\n      return false;\n    }\n  }\n  return targetDOM.nodeType === DOM_TEXT_TYPE && targetNode.isAttached();\n}\nfunction $flushMutations$1(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n  try {\n    updateEditor(editor, () => {\n      const selection = $getSelection() || getLastSelection(editor);\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement();\n      // We use the current editor state, as that reflects what is\n      // actually \"on screen\".\n      const currentEditorState = editor._editorState;\n      const blockCursorElement = editor._blockCursorElement;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);\n        if (targetNode === null && targetDOM !== rootElement || $isDecoratorNode(targetNode)) {\n          continue;\n        }\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (shouldFlushTextMutations && $isTextNode(targetNode) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {\n            handleTextMutation(\n            // nodeType === DOM_TEXT_TYPE is a Text DOM node\n            targetDOM, targetNode, editor);\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true;\n          // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n          const addedDOMs = mutation.addedNodes;\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && (addedDOM.nodeName !== 'BR' || !isManagedLineBreak(addedDOM, parentDOM, editor))) {\n              if (IS_FIREFOX) {\n                const possibleText = addedDOM.innerText || addedDOM.nodeValue;\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n              if (removedDOM.nodeName === 'BR' && isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n            if (removedDOMsLength !== unremovedBRs) {\n              if (targetDOM === rootElement) {\n                targetNode = internalGetRoot(currentEditorState);\n              }\n              badDOMTargets.set(targetDOM, targetNode);\n            }\n          }\n        }\n      }\n\n      // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n      if (badDOMTargets.size > 0) {\n        for (const [targetDOM, targetNode] of badDOMTargets) {\n          if ($isElementNode(targetNode)) {\n            const childKeys = targetNode.getChildrenKeys();\n            let currentDOM = targetDOM.firstChild;\n            for (let s = 0; s < childKeys.length; s++) {\n              const key = childKeys[s];\n              const correctDOM = editor.getElementByKey(key);\n              if (correctDOM === null) {\n                continue;\n              }\n              if (currentDOM == null) {\n                targetDOM.appendChild(correctDOM);\n                currentDOM = correctDOM;\n              } else if (currentDOM !== correctDOM) {\n                targetDOM.replaceChild(correctDOM, currentDOM);\n              }\n              currentDOM = currentDOM.nextSibling;\n            }\n          } else if ($isTextNode(targetNode)) {\n            targetNode.markDirty();\n          }\n        }\n      }\n\n      // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n      const records = observer.takeRecords();\n\n      // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        }\n\n        // Clear any of those removal mutations\n        observer.takeRecords();\n      }\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          selection.dirty = true;\n          $setSelection(selection);\n        }\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\nfunction flushRootMutations(editor) {\n  const observer = editor._observer;\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    $flushMutations$1(editor, mutations, observer);\n  }\n}\nfunction initMutationObserver(editor) {\n  initTextEntryListener(editor);\n  editor._observer = new MutationObserver((mutations, observer) => {\n    $flushMutations$1(editor, mutations, observer);\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet keyCounter = 1;\nfunction generateRandomKey() {\n  return '' + keyCounter++;\n}\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n  return registeredNode;\n}\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\nfunction $isSelectionCapturedInDecorator(node) {\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\n}\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n  if (activeElement === null) {\n    return false;\n  }\n  const nodeName = activeElement.nodeName;\n  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' &&\n  // @ts-ignore iternal field\n  activeElement.__lexicalEditor == null);\n}\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) &&\n    // Ignore if selection is within nested editor\n    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (error) {\n    return false;\n  }\n}\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    // @ts-expect-error: internal field\n    const editor = currentNode.__lexicalEditor;\n    if (editor != null) {\n      return editor;\n    }\n    currentNode = getParentElement(currentNode);\n  }\n  return null;\n}\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n  return null;\n}\nfunction $isTokenOrSegmented(node) {\n  return node.isToken() || node.isSegmented();\n}\nfunction isDOMNodeLexicalTextNode(node) {\n  return node.nodeType === DOM_TEXT_TYPE;\n}\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (isDOMNodeLexicalTextNode(node)) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  const isStateFlagPresent = format & activeFormat;\n  if (isStateFlagPresent && (alignWithFormat === null || (alignWithFormat & activeFormat) === 0)) {\n    // Remove the state flag.\n    return format ^ activeFormat;\n  }\n  if (alignWithFormat === null || alignWithFormat & activeFormat) {\n    // Add the state flag.\n    return format | activeFormat;\n  }\n  return format;\n}\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\nfunction $setNodeKey(node, existingKey) {\n  if (existingKey != null) {\n    node.__key = existingKey;\n    return;\n  }\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n  editorState._nodeMap.set(key, node);\n  // TODO Split this function into leaf/element\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n  editor._cloneNotNeeded.add(key);\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n    const node = nodeMap.get(nextParentKey);\n    if (node === undefined) {\n      break;\n    }\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling();\n    // TODO: this function duplicates a bunch of operations, can be simplified.\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n      writableNode.__prev = null;\n    }\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n      writableNode.__next = null;\n    }\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n}\n\n// Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\n    editor._dirtyLeaves.add(key);\n  }\n}\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\nfunction $getCompositionKey() {\n  if (isCurrentlyReadOnlyMode()) {\n    return null;\n  }\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n  const node = editorState._nodeMap.get(key);\n  if (node === undefined) {\n    return null;\n  }\n  return node;\n}\nfunction getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor();\n  // @ts-ignore We intentionally add this to the Node.\n  const key = dom[`__lexicalKey_${editor._key}`];\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n  return null;\n}\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n  while (dom != null) {\n    const node = getNodeFromDOMNode(dom, editorState);\n    if (node !== null) {\n      return node;\n    }\n    dom = getParentElement(dom);\n  }\n  return null;\n}\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(() => $getRoot().getTextContent());\n}\nfunction markAllNodesAsDirty(editor, type) {\n  // Mark all existing text nodes as dirty\n  updateEditor(editor, () => {\n    const editorState = getActiveEditorState();\n    if (editorState.isEmpty()) {\n      return;\n    }\n    if (type === 'root') {\n      $getRoot().markDirty();\n      return;\n    }\n    const nodeMap = editorState._nodeMap;\n    for (const [, node] of nodeMap) {\n      node.markDirty();\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: 'history-merge'\n  } : undefined);\n}\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get('root');\n}\nfunction $setSelection(selection) {\n  errorOnReadOnly();\n  const editorState = getActiveEditorState();\n  if (selection !== null) {\n    {\n      if (Object.isFrozen(selection)) {\n        {\n          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);\n        }\n      }\n    }\n    selection.dirty = true;\n    selection._cachedNodes = null;\n  }\n  editorState._selection = selection;\n}\nfunction $flushMutations() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  flushRootMutations(editor);\n}\nfunction getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOM(dom, editor);\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n    return null;\n  }\n  return $getNodeByKey(nodeKey);\n}\nfunction getTextNodeOffset(node, moveSelectionToEnd) {\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\n}\nfunction getNodeKeyFromDOM(\n// Note that node here refers to a DOM Node, not an Lexical Node\ndom, editor) {\n  let node = dom;\n  while (node != null) {\n    // @ts-ignore We intentionally add this to the Node.\n    const key = node[`__lexicalKey_${editor._key}`];\n    if (key !== undefined) {\n      return key;\n    }\n    node = getParentElement(node);\n  }\n  return null;\n}\nfunction doesContainGrapheme(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n  return editorsToPropagate;\n}\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n}\nfunction getAnchorTextFromDOM(anchorNode) {\n  if (anchorNode.nodeType === DOM_TEXT_TYPE) {\n    return anchorNode.nodeValue;\n  }\n  return null;\n}\nfunction $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection(editor._window);\n  if (domSelection === null) {\n    return;\n  }\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n  if (anchorNode !== null) {\n    let textContent = getAnchorTextFromDOM(anchorNode);\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n    if (textContent !== null && $isTextNode(node)) {\n      if (node.canContainTabs()) {\n        const hasTabCharacter = textContent.includes('\\t');\n\n        // At present, this condition is primarily used for code highlights when\n        // grouped together in lines (divs). If a code highlight includes a tab,\n        // the newly typed character may be missing from the DOM's textContent.\n\n        // Let's take an example. If a LinedCodeNode looked roughly like this:\n        // <code><div><codeHighlight /><codeHighlight /></div></code>,\n        // the following could occur when using tabs:\n\n        // a. /tconst --type--> 'd' at offset 1 --get--> /tconst\n        //    - Missing 'd'\n        // b. /tconst --type--> 'd' at offset 3 --get--> /tcondst\n        //    --type--> 'd' at offset 3 --get--> /tcondst\n        //    - Missing second 'd'\n\n        // In these cases, we can fix the problem by manually inserting the\n        // newly typed character where we know it should have been.\n\n        if (data && data.length > 0 && hasTabCharacter) {\n          const selectionOffset = data.length;\n          const insertionOffset = anchorOffset + selectionOffset - 1;\n          const beforeInsertion = textContent.slice(0, insertionOffset);\n          const afterInsertion = textContent.slice(insertionOffset, textContent.length);\n          textContent = `${beforeInsertion}${data}${afterInsertion}`;\n          anchorOffset += selectionOffset;\n          focusOffset += selectionOffset;\n        }\n      }\n\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\n      if (textContent === COMPOSITION_SUFFIX && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n      if (textContent !== null) {\n        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);\n      }\n    }\n  }\n}\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n    const prevTextContent = node.getTextContent();\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n        return;\n      }\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n      const compositionKey = $getCompositionKey();\n      const nodeKey = node.getKey();\n      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing ||\n      // Check if character was added at the start, and we need\n      // to clear this input from occurring as that action wasn't\n      // permitted.\n      parent !== null && $isRangeSelection(prevSelection) && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0) {\n        node.markDirty();\n        return;\n      }\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        node.setTextContent(normalizedTextContent);\n        return;\n      }\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n      node.setTextContent(normalizedTextContent);\n    }\n  }\n}\nfunction $previousSiblingDoesNotAcceptText(node) {\n  const previousSibling = node.getPreviousSibling();\n  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();\n}\n\n// This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\n// in the case of a LinkNode, boundaries are not writable.\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = node.isToken();\n  if (offset === 0) {\n    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() || isToken || $previousSiblingDoesNotAcceptText(node);\n  } else if (offset === node.getTextContentSize()) {\n    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() || isToken;\n  } else {\n    return false;\n  }\n}\nfunction isTab(keyCode, altKey, ctrlKey, metaKey) {\n  return keyCode === 9 && !altKey && !ctrlKey && !metaKey;\n}\nfunction isBold(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 66 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isItalic(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 73 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isUnderline(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 85 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isParagraph(keyCode, shiftKey) {\n  return isReturn(keyCode) && !shiftKey;\n}\nfunction isLineBreak(keyCode, shiftKey) {\n  return isReturn(keyCode) && shiftKey;\n}\n\n// Inserts a new line after the selection\n\nfunction isOpenLineBreak(keyCode, ctrlKey) {\n  // 79 = KeyO\n  return IS_APPLE && ctrlKey && keyCode === 79;\n}\nfunction isDeleteWordBackward(keyCode, altKey, ctrlKey) {\n  return isBackspace(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteWordForward(keyCode, altKey, ctrlKey) {\n  return isDelete(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteLineBackward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isBackspace(keyCode);\n}\nfunction isDeleteLineForward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isDelete(keyCode);\n}\nfunction isDeleteBackward(keyCode, altKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    if (altKey || metaKey) {\n      return false;\n    }\n    return isBackspace(keyCode) || keyCode === 72 && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isBackspace(keyCode);\n}\nfunction isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  if (IS_APPLE) {\n    if (shiftKey || altKey || metaKey) {\n      return false;\n    }\n    return isDelete(keyCode) || keyCode === 68 && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isDelete(keyCode);\n}\nfunction isUndo(keyCode, shiftKey, metaKey, ctrlKey) {\n  return keyCode === 90 && !shiftKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isRedo(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return keyCode === 90 && metaKey && shiftKey;\n  }\n  return keyCode === 89 && ctrlKey || keyCode === 90 && ctrlKey && shiftKey;\n}\nfunction isCopy(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (keyCode === 67) {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isCut(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (keyCode === 88) {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isArrowLeft(keyCode) {\n  return keyCode === 37;\n}\nfunction isArrowRight(keyCode) {\n  return keyCode === 39;\n}\nfunction isArrowUp(keyCode) {\n  return keyCode === 38;\n}\nfunction isArrowDown(keyCode) {\n  return keyCode === 40;\n}\nfunction isMoveBackward(keyCode, ctrlKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveForward(keyCode, ctrlKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveUp(keyCode, ctrlKey, metaKey) {\n  return isArrowUp(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isMoveDown(keyCode, ctrlKey, metaKey) {\n  return isArrowDown(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isModifier(ctrlKey, shiftKey, altKey, metaKey) {\n  return ctrlKey || shiftKey || altKey || metaKey;\n}\nfunction isSpace(keyCode) {\n  return keyCode === 32;\n}\nfunction controlOrMeta(metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n  return ctrlKey;\n}\nfunction isReturn(keyCode) {\n  return keyCode === 13;\n}\nfunction isBackspace(keyCode) {\n  return keyCode === 8;\n}\nfunction isEscape(keyCode) {\n  return keyCode === 27;\n}\nfunction isDelete(keyCode) {\n  return keyCode === 46;\n}\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  const classNames = classNamesTheme[classNameThemeType];\n  // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n  if (typeof classNames === 'string') {\n    const classNamesArr = classNames.split(' ');\n    classNamesTheme[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n  return classNames;\n}\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n  const prevMutation = mutatedNodesByType.get(nodeKey);\n  // If the node has already been \"destroyed\", yet we are\n  // re-making it, then this means a move likely happened.\n  // We should change the mutation to be that of \"updated\"\n  // instead.\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\n  if (prevMutation === undefined || isMove) {\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\n  }\n}\nfunction $nodesOfType(klass) {\n  const editorState = getActiveEditorState();\n  const readOnly = editorState._readOnly;\n  const klassType = klass.getType();\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && (readOnly || node.isAttached())) {\n      nodesOfType.push(node);\n    }\n  }\n  return nodesOfType;\n}\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\nfunction $getAdjacentNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n      return possibleNode;\n    }\n  }\n  return null;\n}\nfunction isFirefoxClipboardEvents(editor) {\n  const event = getWindow(editor).event;\n  const inputType = event && event.inputType;\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\n}\nfunction dispatchCommand(editor, command, payload) {\n  return triggerCommandListeners(editor, command, payload);\n}\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\nfunction getParentElement(node) {\n  const parentElement = node.assignedSlot || node.parentElement;\n  return parentElement !== null && parentElement.nodeType === 11 ? parentElement.host : parentElement;\n}\nfunction scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {\n  const doc = rootElement.ownerDocument;\n  const defaultView = doc.defaultView;\n  if (defaultView === null) {\n    return;\n  }\n  let {\n    top: currentTop,\n    bottom: currentBottom\n  } = selectionRect;\n  let targetTop = 0;\n  let targetBottom = 0;\n  let element = rootElement;\n  while (element !== null) {\n    const isBodyElement = element === doc.body;\n    if (isBodyElement) {\n      targetTop = 0;\n      targetBottom = getWindow(editor).innerHeight;\n    } else {\n      const targetRect = element.getBoundingClientRect();\n      targetTop = targetRect.top;\n      targetBottom = targetRect.bottom;\n    }\n    let diff = 0;\n    if (currentTop < targetTop) {\n      diff = -(targetTop - currentTop);\n    } else if (currentBottom > targetBottom) {\n      diff = currentBottom - targetBottom;\n    }\n    if (diff !== 0) {\n      if (isBodyElement) {\n        // Only handles scrolling of Y axis\n        defaultView.scrollBy(0, diff);\n      } else {\n        const scrollTop = element.scrollTop;\n        element.scrollTop += diff;\n        const yOffset = element.scrollTop - scrollTop;\n        currentTop -= yOffset;\n        currentBottom -= yOffset;\n      }\n    }\n    if (isBodyElement) {\n      break;\n    }\n    element = getParentElement(element);\n  }\n}\nfunction $addUpdateTag(tag) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._updateTags.add(tag);\n}\nfunction $maybeMoveChildrenSelectionToParent(parentNode, offset = 0) {\n  if (offset !== 0) {\n    {\n      throw Error(`TODO`);\n    }\n  }\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\n    return selection;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if ($hasAncestor(anchorNode, parentNode)) {\n    anchor.set(parentNode.__key, 0, 'element');\n  }\n  if ($hasAncestor(focusNode, parentNode)) {\n    focus.set(parentNode.__key, 0, 'element');\n  }\n  return selection;\n}\nfunction $hasAncestor(child, targetNode) {\n  let parent = child.getParent();\n  while (parent !== null) {\n    if (parent.is(targetNode)) {\n      return true;\n    }\n    parent = parent.getParent();\n  }\n  return false;\n}\nfunction getDefaultView(domElem) {\n  const ownerDoc = domElem.ownerDocument;\n  return ownerDoc && ownerDoc.defaultView || null;\n}\nfunction getWindow(editor) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    {\n      throw Error(`window object not found`);\n    }\n  }\n  return windowObj;\n}\nfunction $isInlineElementOrDecoratorNode(node) {\n  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();\n}\nfunction $getNearestRootOrShadowRoot(node) {\n  let parent = node.getParentOrThrow();\n  while (parent !== null) {\n    if ($isRootOrShadowRoot(parent)) {\n      return parent;\n    }\n    parent = parent.getParentOrThrow();\n  }\n  return parent;\n}\nfunction $isRootOrShadowRoot(node) {\n  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();\n}\nfunction $copyNode(node) {\n  // @ts-ignore\n  const copy = node.constructor.clone(node);\n  $setNodeKey(copy, null);\n  return copy;\n}\nfunction $applyNodeReplacement(node) {\n  const editor = getActiveEditor();\n  const nodeType = node.constructor.getType();\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.`);\n    }\n  }\n  const replaceFunc = registeredNode.replace;\n  if (replaceFunc !== null) {\n    const replacementNode = replaceFunc(node);\n    if (!(replacementNode instanceof node.constructor)) {\n      {\n        throw Error(`$initializeNode failed. Ensure replacement node is a subclass of the original node.`);\n      }\n    }\n    return replacementNode;\n  }\n  return node;\n}\nfunction errorOnInsertTextNodeOnRoot(node, insertNode) {\n  const parentNode = node.getParent();\n  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {\n    {\n      throw Error(`Only element or decorator nodes can be inserted in to the root node`);\n    }\n  }\n}\nfunction createBlockCursorElement(editorConfig) {\n  const theme = editorConfig.theme;\n  const element = document.createElement('div');\n  element.contentEditable = 'false';\n  element.setAttribute('data-lexical-cursor', 'true');\n  let blockCursorTheme = theme.blockCursor;\n  if (blockCursorTheme !== undefined) {\n    if (typeof blockCursorTheme === 'string') {\n      const classNamesArr = blockCursorTheme.split(' ');\n      // @ts-expect-error: intentional\n      blockCursorTheme = theme.blockCursor = classNamesArr;\n    }\n    if (blockCursorTheme !== undefined) {\n      element.classList.add(...blockCursorTheme);\n    }\n  }\n  return element;\n}\nfunction needsBlockCursor(node) {\n  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();\n}\nfunction removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {\n  rootElement.style.removeProperty('caret-color');\n  editor._blockCursorElement = null;\n  const parentElement = blockCursorElement.parentElement;\n  if (parentElement !== null) {\n    parentElement.removeChild(blockCursorElement);\n  }\n}\nfunction updateDOMBlockCursorElement(editor, rootElement, nextSelection) {\n  let blockCursorElement = editor._blockCursorElement;\n  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {\n    const anchor = nextSelection.anchor;\n    const elementNode = anchor.getNode();\n    const offset = anchor.offset;\n    const elementNodeSize = elementNode.getChildrenSize();\n    let isBlockCursor = false;\n    let insertBeforeElement = null;\n    if (offset === elementNodeSize) {\n      const child = elementNode.getChildAtIndex(offset - 1);\n      if (needsBlockCursor(child)) {\n        isBlockCursor = true;\n      }\n    } else {\n      const child = elementNode.getChildAtIndex(offset);\n      if (needsBlockCursor(child)) {\n        const sibling = child.getPreviousSibling();\n        if (sibling === null || needsBlockCursor(sibling)) {\n          isBlockCursor = true;\n          insertBeforeElement = editor.getElementByKey(child.__key);\n        }\n      }\n    }\n    if (isBlockCursor) {\n      const elementDOM = editor.getElementByKey(elementNode.__key);\n      if (blockCursorElement === null) {\n        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);\n      }\n      rootElement.style.caretColor = 'transparent';\n      if (insertBeforeElement === null) {\n        elementDOM.appendChild(blockCursorElement);\n      } else {\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\n      }\n      return;\n    }\n  }\n  // Remove cursor\n  if (blockCursorElement !== null) {\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n  }\n}\nfunction getDOMSelection(targetWindow) {\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n  if (startNode == null) {\n    startNode = node;\n  }\n  if (!!$isRootOrShadowRoot(node)) {\n    throw Error(`Can not call $splitNode() on root element`);\n  }\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = $isRootOrShadowRoot(parent);\n    // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);\n    if (isParentRoot) {\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n      delete decorators[key];\n    }\n  }\n}\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, dirtyNodes) {\n  let child = node.getFirstChild();\n  while (child !== null) {\n    const childKey = child.__key;\n    if (child !== undefined && child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, dirtyNodes);\n      }\n\n      // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n      nodeMap.delete(childKey);\n    }\n    child = child.isAttached() ? child.getNextSibling() : null;\n  }\n}\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap;\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n      nodeMap.delete(nodeKey);\n    }\n  }\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, dirtyElements);\n        }\n\n        // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n        nodeMap.delete(nodeKey);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);\n}\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  }\n\n  // Backward\n  let previousNode;\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Forward\n  let nextNode;\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\nfunction $normalizeSelection(selection) {\n  $normalizePoint(selection.anchor);\n  $normalizePoint(selection.focus);\n  return selection;\n}\nfunction $normalizePoint(point) {\n  while (point.type === 'element') {\n    const node = point.getNode();\n    const offset = point.offset;\n    let nextNode;\n    let nextOffsetAtEnd;\n    if (offset === node.getChildrenSize()) {\n      nextNode = node.getChildAtIndex(offset - 1);\n      nextOffsetAtEnd = true;\n    } else {\n      nextNode = node.getChildAtIndex(offset);\n      nextOffsetAtEnd = false;\n    }\n    if ($isTextNode(nextNode)) {\n      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text');\n      break;\n    } else if (!$isElementNode(nextNode)) {\n      break;\n    }\n    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element');\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet subTreeTextContent = '';\nlet subTreeDirectionedTextContent = '';\nlet editorTextContent = '';\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeTextDirection = null;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n    if (dom.parentNode === parentDOM) {\n      parentDOM.removeChild(dom);\n    }\n  }\n\n  // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n  if ($isElementNode(node)) {\n    const children = createChildrenArray(node, activePrevNodeMap);\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\n  }\n}\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty('text-align', value);\n}\nconst DEFAULT_INDENT_VALUE = '20px';\nfunction setElementIndent(dom, indent) {\n  const indentClassName = activeEditorConfig.theme.indent;\n  if (typeof indentClassName === 'string') {\n    const elementHasClassName = dom.classList.contains(indentClassName);\n    if (indent > 0 && !elementHasClassName) {\n      dom.classList.add(indentClassName);\n    } else if (indent < 1 && elementHasClassName) {\n      dom.classList.remove(indentClassName);\n    }\n  }\n  const indentationBaseValue = getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') || DEFAULT_INDENT_VALUE;\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`);\n}\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  } else if (format === IS_ALIGN_START) {\n    setTextAlign(domStyle, 'start');\n  } else if (format === IS_ALIGN_END) {\n    setTextAlign(domStyle, 'end');\n  }\n}\nfunction createNode(key, parentDOM, insertDOM) {\n  const node = activeNextNodeMap.get(key);\n  if (node === undefined) {\n    {\n      throw Error(`createNode: node does not exist in nodeMap`);\n    }\n  }\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1);\n\n  // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n    const childrenSize = node.__size;\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n    if (childrenSize !== 0) {\n      const endIndex = childrenSize - 1;\n      const children = createChildrenArray(node, activeNextNodeMap);\n      createChildrenWithDirection(children, endIndex, node, dom);\n    }\n    const format = node.__format;\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n    if (!node.isInline()) {\n      reconcileElementTerminatingLineBreak(null, node, dom);\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n      // Decorators are always non editable\n      dom.contentEditable = 'false';\n    } else if ($isTextNode(node)) {\n      if (!node.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (parentDOM !== null) {\n    if (insertDOM != null) {\n      parentDOM.insertBefore(dom, insertDOM);\n    } else {\n      // @ts-expect-error: internal field\n      const possibleLineBreak = parentDOM.__lexicalLineBreak;\n      if (possibleLineBreak != null) {\n        parentDOM.insertBefore(dom, possibleLineBreak);\n      } else {\n        parentDOM.appendChild(dom);\n      }\n    }\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\n  return dom;\n}\nfunction createChildrenWithDirection(children, endIndex, element, dom) {\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  createChildren(children, element, 0, endIndex, dom, null);\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\n}\nfunction createChildren(children, element, _startIndex, endIndex, dom, insertDOM) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    createNode(children[startIndex], dom, insertDOM);\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  // @ts-expect-error: internal field\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction isLastChildLineBreakOrDecorator(childKey, nodeMap) {\n  const node = nodeMap.get(childKey);\n  return $isLineBreakNode(node) || $isDecoratorNode(node) && node.isInline();\n}\n\n// If we end an element with a LineBreakNode, then we need to add an additional <br>\nfunction reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {\n  const prevLineBreak = prevElement !== null && (prevElement.__size === 0 || isLastChildLineBreakOrDecorator(prevElement.__last, activePrevNodeMap));\n  const nextLineBreak = nextElement.__size === 0 || isLastChildLineBreakOrDecorator(nextElement.__last, activeNextNodeMap);\n  if (prevLineBreak) {\n    if (!nextLineBreak) {\n      // @ts-expect-error: internal field\n      const element = dom.__lexicalLineBreak;\n      if (element != null) {\n        dom.removeChild(element);\n      }\n\n      // @ts-expect-error: internal field\n      dom.__lexicalLineBreak = null;\n    }\n  } else if (nextLineBreak) {\n    const element = document.createElement('br');\n    // @ts-expect-error: internal field\n    dom.__lexicalLineBreak = element;\n    dom.appendChild(element);\n  }\n}\nfunction reconcileBlockDirection(element, dom) {\n  const previousSubTreeDirectionTextContent =\n  // @ts-expect-error: internal field\n  dom.__lexicalDirTextContent;\n  // @ts-expect-error: internal field\n  const previousDirection = dom.__lexicalDir;\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\n    if (direction !== previousDirection) {\n      const classList = dom.classList;\n      const theme = activeEditorConfig.theme;\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined;\n\n      // Remove the old theme classes if they exist\n      if (previousDirectionTheme !== undefined) {\n        if (typeof previousDirectionTheme === 'string') {\n          const classNamesArr = previousDirectionTheme.split(' ');\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\n        }\n\n        // @ts-ignore: intentional\n        classList.remove(...previousDirectionTheme);\n      }\n      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {\n        // Remove direction\n        dom.removeAttribute('dir');\n      } else {\n        // Apply the new theme classes if they exist\n        if (nextDirectionTheme !== undefined) {\n          if (typeof nextDirectionTheme === 'string') {\n            const classNamesArr = nextDirectionTheme.split(' ');\n            // @ts-expect-error: intentional\n            nextDirectionTheme = theme[direction] = classNamesArr;\n          }\n          if (nextDirectionTheme !== undefined) {\n            classList.add(...nextDirectionTheme);\n          }\n        }\n\n        // Update direction\n        dom.dir = direction;\n      }\n      if (!activeEditorStateReadOnly) {\n        const writableNode = element.getWritable();\n        writableNode.__dir = direction;\n      }\n    }\n    activeTextDirection = direction;\n    // @ts-expect-error: internal field\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent;\n    // @ts-expect-error: internal field\n    dom.__lexicalDir = direction;\n  }\n}\nfunction reconcileChildrenWithDirection(prevElement, nextElement, dom) {\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  reconcileChildren(prevElement, nextElement, dom);\n  reconcileBlockDirection(nextElement, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\n}\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n  while (nodeKey !== null) {\n    const node = nodeMap.get(nodeKey);\n    if (node === undefined) {\n      {\n        throw Error(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n  return children;\n}\nfunction reconcileChildren(prevElement, nextElement, dom) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  const prevChildrenSize = prevElement.__size;\n  const nextChildrenSize = nextElement.__size;\n  subTreeTextContent = '';\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\n    const prevFirstChildKey = prevElement.__first;\n    const nextFrstChildKey = nextElement.__first;\n    if (prevFirstChildKey === nextFrstChildKey) {\n      reconcileNode(prevFirstChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\n      const replacementDOM = createNode(nextFrstChildKey, null, null);\n      dom.replaceChild(replacementDOM, lastDOM);\n      destroyNode(prevFirstChildKey, null);\n    }\n  } else {\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\n    if (prevChildrenSize === 0) {\n      if (nextChildrenSize !== 0) {\n        createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, dom, null);\n      }\n    } else if (nextChildrenSize === 0) {\n      if (prevChildrenSize !== 0) {\n        // @ts-expect-error: internal field\n        const lexicalLineBreak = dom.__lexicalLineBreak;\n        const canUseFastPath = lexicalLineBreak == null;\n        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);\n        if (canUseFastPath) {\n          // Fast path for removing DOM nodes\n          dom.textContent = '';\n        }\n      }\n    } else {\n      reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, dom);\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n\n  // @ts-expect-error: internal field\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key);\n\n  // If the node key points to the same instance in both states\n  // and isn't dirty, we just update the text content cache\n  // and return the existing DOM Node.\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      // @ts-expect-error: internal field\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      }\n\n      // @ts-expect-error: internal field\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\n      if (previousSubTreeDirectionTextContent !== undefined) {\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n    return dom;\n  }\n  // If the node key doesn't point to the same instance in both maps,\n  // it means it were cloned. If they're also dirty, we mark them as mutated.\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\n  }\n\n  // Update node. If it returns true, we need to unmount and re-create the node\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = createNode(key, null, null);\n    if (parentDOM === null) {\n      {\n        throw Error(`reconcileNode: parentDOM is null`);\n      }\n    }\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n    const nextFormat = nextNode.__format;\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n    if (isDirty) {\n      reconcileChildrenWithDirection(prevNode, nextNode, dom);\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\n      }\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = nextNode.getTextContent();\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\n      // Handle text content, for LTR, LTR cases.\n      subTreeDirectionedTextContent += text;\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    nextNode = nextNode.getWritable();\n    nextNode.__cachedText = editorTextContent;\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n  return dom;\n}\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n  pendingDecorators[key] = decorator;\n}\nfunction getFirstChild(element) {\n  return element.firstChild;\n}\nfunction getNextSibling(element) {\n  let nextSibling = element.nextSibling;\n  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {\n    nextSibling = nextSibling.nextSibling;\n  }\n  return nextSibling;\n}\nfunction reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = getFirstChild(dom);\n  let prevIndex = 0;\n  let nextIndex = 0;\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, dom);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        createNode(nextKey, dom, siblingDOM);\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n        } else {\n          if (siblingDOM != null) {\n            dom.insertBefore(childDOM, siblingDOM);\n          } else {\n            dom.appendChild(childDOM);\n          }\n          reconcileNode(nextKey, dom);\n        }\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n  }\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, dom, insertDOM);\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);\n  }\n}\nfunction reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  // We cache text content to make retrieval more efficient.\n  // The cache must be rebuilt during reconciliation to account for any changes.\n  subTreeTextContent = '';\n  editorTextContent = '';\n  subTreeDirectionedTextContent = '';\n  // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeTextDirection = null;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);\n  // We keep track of mutated nodes so we can trigger mutation\n  // listeners later in the update cycle.\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  reconcileNode('root', null);\n  // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // @ts-ignore\n  activeEditor$1 = undefined;\n  // @ts-ignore\n  activeEditorNodes = undefined;\n  // @ts-ignore\n  activeDirtyElements = undefined;\n  // @ts-ignore\n  activeDirtyLeaves = undefined;\n  // @ts-ignore\n  activePrevNodeMap = undefined;\n  // @ts-ignore\n  activeNextNodeMap = undefined;\n  // @ts-ignore\n  activeEditorConfig = undefined;\n  // @ts-ignore\n  activePrevKeyToDOMMap = undefined;\n  // @ts-ignore\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap;\n  // @ts-ignore We intentionally add this to the Node.\n  dom['__lexicalKey_' + editor._key] = key;\n  keyToDOMMap.set(key, dom);\n}\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];\nif (CAN_USE_BEFORE_INPUT) {\n  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);\n}\nlet lastKeyDownTimeStamp = 0;\nlet lastKeyCode = 0;\nlet lastBeforeInputInsertTextTimeStamp = 0;\nlet unprocessedBeforeInputData = null;\nlet rootElementsRegistered = 0;\nlet isSelectionChangeFromDOMUpdate = false;\nlet isSelectionChangeFromMouseDown = false;\nlet isInsertLineBreak = false;\nlet isFirefoxEndingComposition = false;\nlet collapsedSelectionFormat = [0, '', 0, 'root', 0];\n\n// This function is used to determine if Lexical should attempt to override\n// the default browser behavior for insertion of text and use its own internal\n// heuristics. This is an extremely important function, and makes much of Lexical\n// work as intended between different browsers and across word, line and character\n// boundary/formats. It also is important for text replacement, node schemas and\n// composition mechanics.\nfunction $shouldPreventDefaultAndInsertText(selection, text, timeStamp, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const editor = getActiveEditor();\n  const domSelection = getDOMSelection(editor._window);\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\n  const textLength = text.length;\n  return anchorKey !== focus.key ||\n  // If we're working with a non-text node.\n  !$isTextNode(anchorNode) ||\n  // If we are replacing a range with a single character or grapheme, and not composing.\n  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT ||\n  // We check to see if there has been\n  // a recent beforeinput event for \"textInput\". If there has been one in the last\n  // 50ms then we proceed as normal. However, if there is not, then this is likely\n  // a dangling `input` event caused by execCommand('insertText').\n  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() ||\n  // Any non standard text node.\n  $isTokenOrSegmented(anchorNode) ||\n  // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  anchorNode.isDirty() && textLength > 1 ||\n  // If the DOM selection element is not the same as the backing node during beforeinput.\n  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) ||\n  // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style ||\n  // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\nfunction shouldSkipSelectionChange(domNode, offset) {\n  return domNode !== null && domNode.nodeValue !== null && domNode.nodeType === DOM_TEXT_TYPE && offset !== 0 && offset !== domNode.nodeValue.length;\n}\nfunction onSelectionChange(domSelection, editor, isActive) {\n  const {\n    anchorNode: anchorDOM,\n    anchorOffset,\n    focusNode: focusDOM,\n    focusOffset\n  } = domSelection;\n  if (isSelectionChangeFromDOMUpdate) {\n    isSelectionChangeFromDOMUpdate = false;\n\n    // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {\n      return;\n    }\n  }\n  updateEditor(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return;\n    }\n    const selection = $getSelection();\n\n    // Update the selection format\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {\n          selection.dirty = true;\n        }\n\n        // If we have marked a collapsed selection format, and we're\n        // within the given time range  then attempt to use that format\n        // instead of getting the format from the anchor node.\n        const windowEvent = getWindow(editor).event;\n        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\n          selection.format = lastFormat;\n          selection.style = lastStyle;\n        } else {\n          if (anchor.type === 'text') {\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          } else if (anchor.type === 'element') {\n            selection.format = 0;\n            selection.style = '';\n          }\n        }\n      } else {\n        let combinedFormat = IS_ALL_FORMATTING;\n        let hasTextNodes = false;\n        const nodes = selection.getNodes();\n        const nodesLength = nodes.length;\n        for (let i = 0; i < nodesLength; i++) {\n          const node = nodes[i];\n          if ($isTextNode(node)) {\n            // TODO: what about style?\n            hasTextNodes = true;\n            combinedFormat &= node.getFormat();\n            if (combinedFormat === 0) {\n              break;\n            }\n          }\n        }\n        selection.format = hasTextNodes ? combinedFormat : 0;\n      }\n    }\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\n  });\n}\n\n// This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\nfunction onClick(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const domSelection = getDOMSelection(editor._window);\n    const lastSelection = $getPreviousSelection();\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      if (domSelection && anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {\n        domSelection.removeAllRanges();\n        selection.dirty = true;\n      }\n    }\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\nfunction onPointerDown(event, editor) {\n  // TODO implement text drag & drop\n  const target = event.target;\n  const pointerType = event.pointerType;\n  if (target instanceof Node && pointerType !== 'touch') {\n    updateEditor(editor, () => {\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\n      // selected content is lost.\n      if (!$isSelectionCapturedInDecorator(target)) {\n        isSelectionChangeFromMouseDown = true;\n      }\n    });\n  }\n}\nfunction $applyTargetRange(selection, event) {\n  if (event.getTargetRanges) {\n    const targetRange = event.getTargetRanges()[0];\n    if (targetRange) {\n      selection.applyDOMRange(targetRange);\n    }\n  }\n}\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();\n}\nfunction isPossiblyAndroidKeyPress(timeStamp) {\n  return lastKeyCode === 229 && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;\n}\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType;\n\n  // We let the browser do its own thing for composition.\n  if (inputType === 'deleteCompositionText' ||\n  // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    return;\n  }\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if (inputType === 'deleteContentBackward') {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n        $setSelection(prevSelection.clone());\n      }\n      if ($isRangeSelection(selection)) {\n        // Used for handling backspace in Android.\n        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && selection.anchor.key === selection.focus.key) {\n          $setCompositionKey(null);\n          lastKeyDownTimeStamp = 0;\n          // Fixes an Android bug where selection flickers when backspacing\n          setTimeout(() => {\n            updateEditor(editor, () => {\n              $setCompositionKey(null);\n            });\n          }, ANDROID_COMPOSITION_LATENCY);\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            anchorNode.markDirty();\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          }\n        } else {\n          event.preventDefault();\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n        }\n        return;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n    const data = event.data;\n\n    // This represents the case when two beforeinput events are triggered at the same time (without a\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\n    // a combination of autocorrection + autocapitalization.\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\n    // but this would kill the massive performance win from the most common typing event.\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\n    // content, a job that would usually be the input event's responsibility.\n    if (unprocessedBeforeInputData !== null) {\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\n    }\n    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode())) {\n      $applyTargetRange(selection, event);\n    }\n    unprocessedBeforeInputData = null;\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, data, event.timeStamp, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      } else {\n        unprocessedBeforeInputData = data;\n      }\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\n      return;\n    }\n\n    // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n    event.preventDefault();\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText':\n        {\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertFromComposition':\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertLineBreak':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          break;\n        }\n      case 'insertParagraph':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n\n          // Some browsers do not provide the type \"insertLineBreak\".\n          // So instead, we need to infer it from the keyboard event.\n          if (isInsertLineBreak) {\n            isInsertLineBreak = false;\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          } else {\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n          }\n          break;\n        }\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation':\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n      case 'deleteByComposition':\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND, undefined);\n          }\n          break;\n        }\n      case 'deleteByDrag':\n      case 'deleteByCut':\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, undefined);\n          break;\n        }\n      case 'deleteContent':\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n      case 'deleteWordBackward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n      case 'deleteWordForward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n      case 'formatStrikeThrough':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n          break;\n        }\n      case 'formatBold':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n          break;\n        }\n      case 'formatItalic':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n          break;\n        }\n      case 'formatUnderline':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n          break;\n        }\n      case 'historyUndo':\n        {\n          dispatchCommand(editor, UNDO_COMMAND, undefined);\n          break;\n        }\n      case 'historyRedo':\n        {\n          dispatchCommand(editor, REDO_COMMAND, undefined);\n          break;\n        }\n      // NO-OP\n    }\n  });\n}\n\nfunction onInput(event, editor) {\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const data = event.data;\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, data, event.timeStamp, false)) {\n      // Given we're over-riding the default behavior, we will need\n      // to ensure to disable composition before dispatching the\n      // insertText command for when changing the sequence for FF.\n      if (isFirefoxEndingComposition) {\n        onCompositionEndImpl(editor, data);\n        isFirefoxEndingComposition = false;\n      }\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection === null) {\n        return;\n      }\n      const offset = anchor.offset;\n      // If the content is the same as inserted, then don't dispatch an insertion.\n      // Given onInput doesn't take the current selection (it uses the previous)\n      // we can compare that against what the DOM currently says.\n      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, offset) + data + anchorNode.getTextContent().slice(offset + selection.focus.offset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      }\n      const textLength = data.length;\n\n      // Another hack for FF, as it's possible that the IME is still\n      // open, even though compositionend has already fired (sigh).\n      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {\n        selection.anchor.offset -= textLength;\n      }\n\n      // This ensures consistency on Android.\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      const characterData = data !== null ? data : undefined;\n      $updateSelectedTextFromDOM(false, editor, characterData);\n\n      // onInput always fires after onCompositionEnd for FF.\n      if (isFirefoxEndingComposition) {\n        onCompositionEndImpl(editor, data || undefined);\n        isFirefoxEndingComposition = false;\n      }\n    }\n\n    // Also flush any other mutations that might have occurred\n    // since the change.\n    $flushMutations();\n  });\n  unprocessedBeforeInputData = null;\n}\nfunction onCompositionStart(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      const node = selection.anchor.getNode();\n      $setCompositionKey(anchor.key);\n      if (\n      // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic. We can't do this for Safari,\n      // as the keydown fires after composition start.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY ||\n      // FF has issues around composing multibyte characters, so we also\n      // need to invoke the empty space heuristic below.\n      anchor.type === 'element' || !selection.isCollapsed() || node.getFormat() !== selection.format || node.getStyle() !== selection.style) {\n        // We insert a zero width character, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);\n      }\n    }\n  });\n}\nfunction onCompositionEndImpl(editor, data) {\n  const compositionKey = editor._compositionKey;\n  $setCompositionKey(null);\n\n  // Handle termination of composition.\n  if (compositionKey !== null && data != null) {\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\n    // So check for the empty case.\n    if (data === '') {\n      const node = $getNodeByKey(compositionKey);\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {\n        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n      }\n      return;\n    }\n\n    // Composition can sometimes be that of a new line. In which case, we need to\n    // handle that accordingly.\n    if (data[data.length - 1] === '\\n') {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        // If the last character is a line break, we also need to insert\n        // a line break.\n        const focus = selection.focus;\n        selection.anchor.set(focus.key, focus.offset, focus.type);\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n        return;\n      }\n    }\n  }\n  $updateSelectedTextFromDOM(true, editor, data);\n}\nfunction onCompositionEnd(event, editor) {\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\n  // fire onInput before onCompositionEnd. To ensure the sequence works\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\n  // defer handling of onCompositionEnd in Firefox till we have processed\n  // the logic in onInput.\n  if (IS_FIREFOX) {\n    isFirefoxEndingComposition = true;\n  } else {\n    updateEditor(editor, () => {\n      onCompositionEndImpl(editor, event.data);\n    });\n  }\n}\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n  lastKeyCode = event.keyCode;\n  if (editor.isComposing()) {\n    return;\n  }\n  const {\n    keyCode,\n    shiftKey,\n    ctrlKey,\n    metaKey,\n    altKey\n  } = event;\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\n    return;\n  }\n  if (isMoveForward(keyCode, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_END, event);\n  } else if (isMoveBackward(keyCode, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_START, event);\n  } else if (isMoveUp(keyCode, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(keyCode, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(keyCode, shiftKey)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isSpace(keyCode)) {\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\n  } else if (isOpenLineBreak(keyCode, ctrlKey)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(keyCode, shiftKey)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(keyCode, altKey, metaKey, ctrlKey)) {\n    if (isBackspace(keyCode)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(keyCode)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    if (isDelete(keyCode)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(keyCode, altKey, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\n  } else if (isRedo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND, undefined);\n  } else {\n    const prevSelection = editor._editorState._selection;\n    if ($isNodeSelection(prevSelection)) {\n      if (isCopy(keyCode, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, COPY_COMMAND, event);\n      } else if (isCut(keyCode, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, CUT_COMMAND, event);\n      }\n    }\n  }\n  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\nfunction getRootElementRemoveHandles(rootElement) {\n  // @ts-expect-error: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n  if (eventHandles === undefined) {\n    eventHandles = [];\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n  return eventHandles;\n}\n\n// Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\nconst activeNestedEditorsMap = new Map();\nfunction onDocumentSelectionChange(event) {\n  const target = event.target;\n  const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;\n  const domSelection = getDOMSelection(targetWindow);\n  if (domSelection === null) {\n    return;\n  }\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\n  if (nextActiveEditor === null) {\n    return;\n  }\n  if (isSelectionChangeFromMouseDown) {\n    isSelectionChangeFromMouseDown = false;\n    updateEditor(nextActiveEditor, () => {\n      const lastSelection = $getPreviousSelection();\n      const domAnchorNode = domSelection.anchorNode;\n      if (domAnchorNode === null) {\n        return;\n      }\n      const nodeType = domAnchorNode.nodeType;\n      // If the user is attempting to click selection back onto text, then\n      // we should attempt create a range selection.\n      // When we click on an empty paragraph node or the end of a paragraph that ends\n      // with an image/poll, the nodeType will be ELEMENT_NODE\n      if (nodeType !== DOM_ELEMENT_TYPE && nodeType !== DOM_TEXT_TYPE) {\n        return;\n      }\n      const newSelection = internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor);\n      $setSelection(newSelection);\n    });\n  }\n\n  // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(domSelection, prevActiveEditor, false);\n  }\n  onSelectionChange(domSelection, nextActiveEditor, true);\n\n  // If newly selected editor is nested, then add it to the map, clean map otherwise\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\nfunction stopLexicalPropagation(event) {\n  // We attach a special property to ensure the same event doesn't re-fire\n  // for parent editors.\n  // @ts-ignore\n  event._lexicalHandled = true;\n}\nfunction hasStoppedLexicalPropagation(event) {\n  // @ts-ignore\n  const stopped = event._lexicalHandled === true;\n  return stopped;\n}\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  if (rootElementsRegistered === 0) {\n    const doc = rootElement.ownerDocument;\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  rootElementsRegistered++;\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === 'function' ? event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable()) {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable()) {\n        switch (eventName) {\n          case 'cut':\n            return dispatchCommand(editor, CUT_COMMAND, event);\n          case 'copy':\n            return dispatchCommand(editor, COPY_COMMAND, event);\n          case 'paste':\n            return dispatchCommand(editor, PASTE_COMMAND, event);\n          case 'dragstart':\n            return dispatchCommand(editor, DRAGSTART_COMMAND, event);\n          case 'dragover':\n            return dispatchCommand(editor, DRAGOVER_COMMAND, event);\n          case 'dragend':\n            return dispatchCommand(editor, DRAGEND_COMMAND, event);\n          case 'focus':\n            return dispatchCommand(editor, FOCUS_COMMAND, event);\n          case 'blur':\n            {\n              return dispatchCommand(editor, BLUR_COMMAND, event);\n            }\n          case 'drop':\n            return dispatchCommand(editor, DROP_COMMAND, event);\n        }\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\nfunction removeRootElementEvents(rootElement) {\n  if (rootElementsRegistered !== 0) {\n    rootElementsRegistered--;\n\n    // We only want to have a single global selectionchange event handler, shared\n    // between all editor instances.\n    if (rootElementsRegistered === 0) {\n      const doc = rootElement.ownerDocument;\n      doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n    }\n  }\n\n  // @ts-expect-error: internal field\n  const editor = rootElement.__lexicalEditor;\n  if (editor !== null && editor !== undefined) {\n    cleanActiveNestedEditorsMap(editor);\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEditor = null;\n  }\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  }\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEventHandles = [];\n}\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\nfunction markSelectionChangeFromDOMUpdate() {\n  isSelectionChangeFromDOMUpdate = true;\n}\nfunction markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass Point {\n  constructor(key, offset, type) {\n    this._selection = null;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n  isBefore(b) {\n    let aNode = this.getNode();\n    let bNode = b.getNode();\n    const aOffset = this.offset;\n    const bOffset = b.offset;\n    if ($isElementNode(aNode)) {\n      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);\n      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;\n    }\n    if ($isElementNode(bNode)) {\n      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);\n      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;\n    }\n    if (aNode === bNode) {\n      return aOffset < bOffset;\n    }\n    return aNode.isBefore(bNode);\n  }\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n    if (node === null) {\n      {\n        throw Error(`Point.getNode: node not found`);\n      }\n    }\n    return node;\n  }\n  set(key, offset, type) {\n    const selection = this._selection;\n    const oldKey = this.key;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n      if (selection !== null) {\n        selection._cachedNodes = null;\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction $createPoint(key, offset, type) {\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\nfunction selectPointOnNode(point, node) {\n  let key = node.__key;\n  let offset = point.offset;\n  let type = 'element';\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  } else if (!$isElementNode(node)) {\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling)) {\n      key = nextSibling.__key;\n      offset = 0;\n      type = 'text';\n    } else {\n      const parentNode = node.getParent();\n      if (parentNode) {\n        key = parentNode.__key;\n        offset = node.getIndexWithinParent() + 1;\n      }\n    }\n  }\n  point.set(key, offset, type);\n}\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else {\n    selectPointOnNode(point, node);\n  }\n}\nfunction $transferStartingElementPointToTextPoint(start, end, format, style) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n  textNode.setFormat(format);\n  textNode.setStyle(style);\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target);\n  }\n  // Transfer the element point to a text point.\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n  start.set(textNode.__key, 0, 'text');\n}\nfunction $setPointValues(point, key, offset, type) {\n  point.key = key;\n  point.offset = offset;\n  point.type = type;\n}\nclass NodeSelection {\n  constructor(objects) {\n    this.dirty = false;\n    this._nodes = objects;\n    this._cachedNodes = null;\n  }\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n  add(key) {\n    this.dirty = true;\n    this._nodes.add(key);\n    this._cachedNodes = null;\n  }\n  delete(key) {\n    this.dirty = true;\n    this._nodes.delete(key);\n    this._cachedNodes = null;\n  }\n  clear() {\n    this.dirty = true;\n    this._nodes.clear();\n    this._cachedNodes = null;\n  }\n  has(key) {\n    return this._nodes.has(key);\n  }\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes, selectStart) {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\n    let selectionAtEnd;\n    // Insert nodes\n    if ($isTextNode(lastSelectedNode)) {\n      selectionAtEnd = lastSelectedNode.select();\n    } else {\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\n    }\n    selectionAtEnd.insertNodes(nodes, selectStart);\n    // Remove selected nodes\n    for (let i = 0; i < selectedNodesLength; i++) {\n      selectedNodes[i].remove();\n    }\n    return true;\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const objects = this._nodes;\n    const nodes = [];\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n}\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\nclass GridSelection {\n  constructor(gridKey, anchor, focus) {\n    this.gridKey = gridKey;\n    this.anchor = anchor;\n    this.focus = focus;\n    this.dirty = false;\n    this._cachedNodes = null;\n    anchor._selection = this;\n    focus._selection = this;\n  }\n  is(selection) {\n    if (!DEPRECATED_$isGridSelection(selection)) {\n      return false;\n    }\n    return this.gridKey === selection.gridKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(gridKey, anchorCellKey, focusCellKey) {\n    this.dirty = true;\n    this.gridKey = gridKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new GridSelection(this.gridKey, this.anchor, this.focus);\n  }\n  isCollapsed() {\n    return false;\n  }\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCharacterOffsets() {\n    return getCharacterOffsets(this);\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes, selectStart) {\n    const focusNode = this.focus.getNode();\n    const selection = $normalizeSelection(focusNode.select(0, focusNode.getChildrenSize()));\n    return selection.insertNodes(nodes, selectStart);\n  }\n  getShape() {\n    const anchorCellNode = $getNodeByKey(this.anchor.key);\n    if (!(anchorCellNode !== null)) {\n      throw Error(`getNodes: expected to find AnchorNode`);\n    }\n    const anchorCellNodeIndex = anchorCellNode.getIndexWithinParent();\n    const anchorCelRoweIndex = anchorCellNode.getParentOrThrow().getIndexWithinParent();\n    const focusCellNode = $getNodeByKey(this.focus.key);\n    if (!(focusCellNode !== null)) {\n      throw Error(`getNodes: expected to find FocusNode`);\n    }\n    const focusCellNodeIndex = focusCellNode.getIndexWithinParent();\n    const focusCellRowIndex = focusCellNode.getParentOrThrow().getIndexWithinParent();\n    const startX = Math.min(anchorCellNodeIndex, focusCellNodeIndex);\n    const stopX = Math.max(anchorCellNodeIndex, focusCellNodeIndex);\n    const startY = Math.min(anchorCelRoweIndex, focusCellRowIndex);\n    const stopY = Math.max(anchorCelRoweIndex, focusCellRowIndex);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const nodesSet = new Set();\n    const {\n      fromX,\n      fromY,\n      toX,\n      toY\n    } = this.getShape();\n    const gridNode = $getNodeByKey(this.gridKey);\n    if (!DEPRECATED_$isGridNode(gridNode)) {\n      {\n        throw Error(`getNodes: expected to find GridNode`);\n      }\n    }\n    nodesSet.add(gridNode);\n    const gridRowNodes = gridNode.getChildren();\n    for (let r = fromY; r <= toY; r++) {\n      const gridRowNode = gridRowNodes[r];\n      nodesSet.add(gridRowNode);\n      if (!DEPRECATED_$isGridRowNode(gridRowNode)) {\n        {\n          throw Error(`getNodes: expected to find GridRowNode`);\n        }\n      }\n      const gridCellNodes = gridRowNode.getChildren();\n      for (let c = fromX; c <= toX; c++) {\n        const gridCellNode = gridCellNodes[c];\n        if (!DEPRECATED_$isGridCellNode(gridCellNode)) {\n          {\n            throw Error(`getNodes: expected to find GridCellNode`);\n          }\n        }\n        nodesSet.add(gridCellNode);\n        const children = gridCellNode.getChildren();\n        while (children.length > 0) {\n          const child = children.shift();\n          nodesSet.add(child);\n          if ($isElementNode(child)) {\n            children.unshift(...child.getChildren());\n          }\n        }\n      }\n    }\n    const nodes = Array.from(nodesSet);\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n}\nfunction DEPRECATED_$isGridSelection(x) {\n  return x instanceof GridSelection;\n}\nclass RangeSelection {\n  constructor(anchor, focus, format, style) {\n    this.anchor = anchor;\n    this.focus = focus;\n    this.dirty = false;\n    this.format = format;\n    this.style = style;\n    this._cachedNodes = null;\n    anchor._selection = this;\n    focus._selection = this;\n  }\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;\n  }\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = anchor.getNode();\n    let lastNode = focus.getNode();\n    if ($isElementNode(firstNode)) {\n      const firstNodeDescendant = firstNode.getDescendantByIndex(anchor.offset);\n      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;\n    }\n    if ($isElementNode(lastNode)) {\n      let lastNodeDescendant = lastNode.getDescendantByIndex(focus.offset);\n      // We don't want to over-select, as node selection infers the child before\n      // the last descendant, not including that descendant.\n      if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(focus.offset) === lastNodeDescendant) {\n        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();\n      }\n      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;\n    }\n    let nodes;\n    if (firstNode.is(lastNode)) {\n      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {\n        nodes = [];\n      } else {\n        nodes = [firstNode];\n      }\n    } else {\n      nodes = firstNode.getNodesBetween(lastNode);\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, 'text');\n    $setPointValues(this.focus, focusNode.__key, focusOffset, 'text');\n    this._cachedNodes = null;\n    this.dirty = true;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    if (nodes.length === 0) {\n      return '';\n    }\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = getCharacterOffsets(this);\n    let textContent = '';\n    let prevWasElement = true;\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n          if (node === firstNode) {\n            if (node === lastNode) {\n              if (anchor.type !== 'element' || focus.type !== 'element' || focus.offset === anchor.offset) {\n                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n              }\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n    return textContent;\n  }\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);\n    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);\n    this._cachedNodes = null;\n  }\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);\n    return selection;\n  }\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n  setStyle(style) {\n    this.style = style;\n    this.dirty = true;\n  }\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n  insertRawText(text) {\n    const parts = text.split(/\\r?\\n/);\n    if (parts.length === 1) {\n      this.insertText(text);\n    } else {\n      const nodes = [];\n      const length = parts.length;\n      for (let i = 0; i < length; i++) {\n        const part = parts[i];\n        if (part !== '') {\n          nodes.push($createTextNode(part));\n        }\n        if (i !== length - 1) {\n          nodes.push($createLineBreakNode());\n        }\n      }\n      this.insertNodes(nodes);\n    }\n  }\n  insertText(text) {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = this.isCollapsed() || anchor.isBefore(focus);\n    const format = this.format;\n    const style = this.style;\n    if (isBefore && anchor.type === 'element') {\n      $transferStartingElementPointToTextPoint(anchor, focus, format, style);\n    } else if (!isBefore && focus.type === 'element') {\n      $transferStartingElementPointToTextPoint(focus, anchor, format, style);\n    }\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const firstPoint = isBefore ? anchor : focus;\n    const endPoint = isBefore ? focus : anchor;\n    const startOffset = firstPoint.offset;\n    const endOffset = endPoint.offset;\n    let firstNode = selectedNodes[0];\n    if (!$isTextNode(firstNode)) {\n      {\n        throw Error(`insertText: first node is not a text node`);\n      }\n    }\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {\n      let nextSibling = firstNode.getNextSibling();\n      if (!$isTextNode(nextSibling) || $isTokenOrSegmented(nextSibling)) {\n        nextSibling = $createTextNode();\n        nextSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {\n      let prevSibling = firstNode.getPreviousSibling();\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n        prevSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n      prevSibling.select();\n      firstNode = prevSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      textNode.setFormat(format);\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== '') {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\n        this.insertText('');\n        normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n    if (selectedNodesLength === 1) {\n      if (firstNode.isToken()) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const firstNodeFormat = firstNode.getFormat();\n      const firstNodeStyle = firstNode.getStyle();\n      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n          firstNode.setStyle(style);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.setStyle(style);\n          textNode.select();\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode, false);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode, false);\n          }\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n          return;\n        }\n      }\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (this.anchor.type === 'text') {\n        if (firstNode.isComposing()) {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        } else {\n          this.format = firstNodeFormat;\n          this.style = firstNodeStyle;\n        }\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);\n\n      // We have to get the parent elements before the next section,\n      // as in that section we might mutate the lastNode.\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();\n      let lastElementChild = lastNode;\n\n      // If the last element is inline, we should instead look at getting\n      // the nodes of its parent, rather than itself. This behavior will\n      // then better match how text node insertions work. We will need to\n      // also update the last element's child accordingly as we do this.\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\n        // Keep traversing till we have a non-inline element parent.\n        do {\n          lastElementChild = lastElement;\n          lastElement = lastElement.getParentOrThrow();\n        } while (lastElement.isInline());\n      }\n\n      // Handle mutations to the last node.\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          }\n          lastNode = lastNode.spliceText(0, endOffset, '');\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      }\n\n      // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement);\n\n      // We choose a target to insert all nodes after. In the case of having\n      // and inline starting parent element with a starting node that has no\n      // siblings, we should insert after the starting parent element, otherwise\n      // we will incorrectly merge into the starting parent element.\n      // TODO: should we keep on traversing parents if we're inside another\n      // nested inline element?\n      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n        const lastNodeChild = lastNodeChildren[i];\n        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n          break;\n        }\n        if (lastNodeChild.isAttached()) {\n          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {\n            if (!firstAndLastElementsAreEqual) {\n              insertionTarget.insertAfter(lastNodeChild, false);\n            }\n          } else {\n            lastNodeChild.remove();\n          }\n        }\n      }\n      if (!firstAndLastElementsAreEqual) {\n        // Check if we have already moved out all the nodes of the\n        // last parent, and if so, traverse the parent tree and mark\n        // them all as being able to deleted too.\n        let parent = lastElement;\n        let lastRemovedParent = null;\n        while (parent !== null) {\n          const children = parent.getChildren();\n          const childrenLength = children.length;\n          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n            markedNodeKeysForKeep.delete(parent.__key);\n            lastRemovedParent = parent;\n          }\n          parent = parent.getParent();\n        }\n      }\n\n      // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n      if (!firstNode.isToken()) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      }\n\n      // Remove all selected nodes that haven't already been removed.\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n  removeText() {\n    this.insertText('');\n  }\n  formatText(formatType) {\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const selectedNodes = this.getNodes();\n    const selectedTextNodes = [];\n    for (const selectedNode of selectedNodes) {\n      if ($isTextNode(selectedNode)) {\n        selectedTextNodes.push(selectedNode);\n      }\n    }\n    const selectedTextNodesLength = selectedTextNodes.length;\n    if (selectedTextNodesLength === 0) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBackward = this.isBackward();\n    const startPoint = isBackward ? focus : anchor;\n    const endPoint = isBackward ? anchor : focus;\n    let firstIndex = 0;\n    let firstNode = selectedTextNodes[0];\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset;\n\n    // In case selection started at the end of text node use next text node\n    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {\n      firstIndex = 1;\n      firstNode = selectedTextNodes[1];\n      startOffset = 0;\n    }\n    if (firstNode == null) {\n      return;\n    }\n    const firstNextFormat = firstNode.getFormatFlags(formatType, null);\n    const lastIndex = selectedTextNodesLength - 1;\n    let lastNode = selectedTextNodes[lastIndex];\n    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize();\n\n    // Single node selected\n    if (firstNode.is(lastNode)) {\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n      // The entire node is selected, so just format it\n      if (startOffset === 0 && endOffset === firstNode.getTextContentSize()) {\n        firstNode.setFormat(firstNextFormat);\n      } else {\n        // Node is partially selected, so split it into two nodes\n        // add style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        replacement.setFormat(firstNextFormat);\n\n        // Update selection only if starts/ends on text node\n        if (startPoint.type === 'text') {\n          startPoint.set(replacement.__key, 0, 'text');\n        }\n        if (endPoint.type === 'text') {\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\n        }\n      }\n      this.format = firstNextFormat;\n      return;\n    }\n    // Multiple nodes selected\n    // The entire first node isn't selected, so split it\n    if (startOffset !== 0) {\n      [, firstNode] = firstNode.splitText(startOffset);\n      startOffset = 0;\n    }\n    firstNode.setFormat(firstNextFormat);\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);\n    // If the offset is 0, it means no actual characters are selected,\n    // so we skip formatting the last node altogether.\n    if (endOffset > 0) {\n      if (endOffset !== lastNode.getTextContentSize()) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      lastNode.setFormat(lastNextFormat);\n    }\n\n    // Process all text nodes in between\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\n      const textNode = selectedTextNodes[i];\n      if (!textNode.isToken()) {\n        const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\n        textNode.setFormat(nextFormat);\n      }\n    }\n\n    // Update selection only if starts/ends on text node\n    if (startPoint.type === 'text') {\n      startPoint.set(firstNode.__key, startOffset, 'text');\n    }\n    if (endPoint.type === 'text') {\n      endPoint.set(lastNode.__key, endOffset, 'text');\n    }\n    this.format = firstNextFormat | lastNextFormat;\n  }\n  insertNodes(nodes, selectStart) {\n    // If there is a range selected remove the text in it\n    if (!this.isCollapsed()) {\n      const selectionEnd = this.isBackward() ? this.anchor : this.focus;\n      const nextSibling = selectionEnd.getNode().getNextSibling();\n      const nextSiblingKey = nextSibling ? nextSibling.getKey() : null;\n      const prevSibling = selectionEnd.getNode().getPreviousSibling();\n      const prevSiblingKey = prevSibling ? prevSibling.getKey() : null;\n      this.removeText();\n\n      // If the selection has been moved to an adjacent inline element, create\n      // a temporary text node that we can insert the nodes after.\n      if (this.isCollapsed() && this.focus.type === 'element') {\n        let textNode;\n        if (this.focus.key === nextSiblingKey && this.focus.offset === 0) {\n          textNode = $createTextNode();\n          this.focus.getNode().insertBefore(textNode);\n        } else if (this.focus.key === prevSiblingKey && this.focus.offset === this.focus.getNode().getChildrenSize()) {\n          textNode = $createTextNode();\n          this.focus.getNode().insertAfter(textNode);\n        }\n        if (textNode) {\n          this.focus.set(textNode.__key, 0, 'text');\n          this.anchor.set(textNode.__key, 0, 'text');\n        }\n      }\n    }\n    const anchor = this.anchor;\n    const anchorOffset = anchor.offset;\n    const anchorNode = anchor.getNode();\n    let target = anchorNode;\n    if (anchor.type === 'element') {\n      const element = anchor.getNode();\n      const placementNode = element.getChildAtIndex(anchorOffset - 1);\n      if (placementNode === null) {\n        target = element;\n      } else {\n        target = placementNode;\n      }\n    }\n    const siblings = [];\n\n    // Get all remaining text node siblings in this element so we can\n    // append them after the last node we're inserting.\n    const nextSiblings = anchorNode.getNextSiblings();\n    const topLevelElement = $isRootOrShadowRoot(anchorNode) ? null : anchorNode.getTopLevelElementOrThrow();\n    if ($isTextNode(anchorNode)) {\n      const textContent = anchorNode.getTextContent();\n      const textContentLength = textContent.length;\n      if (anchorOffset === 0 && textContentLength !== 0) {\n        const prevSibling = anchorNode.getPreviousSibling();\n        if (prevSibling !== null) {\n          target = prevSibling;\n        } else {\n          target = anchorNode.getParentOrThrow();\n        }\n        siblings.push(anchorNode);\n      } else if (anchorOffset === textContentLength) {\n        target = anchorNode;\n      } else if (anchorNode.isToken()) {\n        // Do nothing if we're inside a token node\n        return false;\n      } else {\n        // If we started with a range selected grab the danglingText after the\n        // end of the selection and put it on our siblings array so we can\n        // append it after the last node we're inserting\n        let danglingText;\n        [target, danglingText] = anchorNode.splitText(anchorOffset);\n        siblings.push(danglingText);\n      }\n    }\n    const startingNode = target;\n    siblings.push(...nextSiblings);\n    const firstNode = nodes[0];\n    let didReplaceOrMerge = false;\n    let lastNode = null;\n\n    // Time to insert the nodes!\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (!$isRootOrShadowRoot(target) && !$isDecoratorNode(target) && $isElementNode(node) && !node.isInline()) {\n        // -----\n        // Heuristics for the replacement or merging of elements\n        // -----\n\n        // If we have an incoming element node as the first node, then we'll need\n        // see if we can merge any descendant leaf nodes into our existing target.\n        // We can do this by finding the first descendant in our node and then we can\n        // pluck it and its parent (siblings included) out and insert them directly\n        // into our target. We only do this for the first node, as we are only\n        // interested in merging with the anchor, which is our target.\n        //\n        // If we apply either the replacement or merging heuristics, we need to be\n        // careful that we're not trying to insert a non-element node into a root node,\n        // so we check if the target's parent after this logic is the root node and if\n        // so we trigger an invariant to ensure this problem is caught in development\n        // and fixed accordingly.\n\n        if (node.is(firstNode)) {\n          if ($isElementNode(target) && target.isEmpty() && target.canReplaceWith(node)) {\n            target.replace(node);\n            target = node;\n            didReplaceOrMerge = true;\n            continue;\n          }\n          // We may have a node tree where there are many levels, for example with\n          // lists and tables. So let's find the first descendant to try and merge\n          // with. So if we have the target:\n          //\n          // Paragraph (1)\n          //   Text (2)\n          //\n          // and we are trying to insert:\n          //\n          // ListNode (3)\n          //   ListItemNode (4)\n          //     Text (5)\n          //   ListItemNode (6)\n          //\n          // The result would be:\n          //\n          // Paragraph (1)\n          //   Text (2)\n          //   Text (5)\n          //\n\n          const firstDescendant = node.getFirstDescendant();\n          if ($isLeafNode(firstDescendant)) {\n            let element = firstDescendant.getParentOrThrow();\n            while (element.isInline()) {\n              element = element.getParentOrThrow();\n            }\n            const children = element.getChildren();\n            const childrenLength = children.length;\n            if ($isElementNode(target)) {\n              let firstChild = target.getFirstChild();\n              for (let s = 0; s < childrenLength; s++) {\n                const child = children[s];\n                if (firstChild === null) {\n                  target.append(child);\n                } else {\n                  firstChild.insertAfter(child);\n                }\n                firstChild = child;\n              }\n            } else {\n              for (let s = childrenLength - 1; s >= 0; s--) {\n                target.insertAfter(children[s]);\n              }\n              target = target.getParentOrThrow();\n            }\n            lastNode = children[childrenLength - 1];\n            element.remove();\n            didReplaceOrMerge = true;\n            if (element.is(node)) {\n              continue;\n            }\n          }\n        }\n        if ($isTextNode(target)) {\n          if (topLevelElement === null) {\n            {\n              throw Error(`insertNode: topLevelElement is root node`);\n            }\n          }\n          target = topLevelElement;\n        }\n      } else if (didReplaceOrMerge && !$isDecoratorNode(node) && $isRootOrShadowRoot(target.getParent())) {\n        {\n          throw Error(`insertNodes: cannot insert a non-element into a root node`);\n        }\n      }\n      didReplaceOrMerge = false;\n      if ($isElementNode(target) && !target.isInline()) {\n        lastNode = node;\n        if ($isDecoratorNode(node) && !node.isInline()) {\n          target = target.insertAfter(node, false);\n        } else if (!$isElementNode(node)) {\n          const firstChild = target.getFirstChild();\n          if (firstChild !== null) {\n            firstChild.insertBefore(node);\n          } else {\n            target.append(node);\n          }\n          target = node;\n        } else {\n          if (!node.canBeEmpty() && node.isEmpty()) {\n            continue;\n          }\n          if ($isRootNode(target)) {\n            const placementNode = target.getChildAtIndex(anchorOffset);\n            if (placementNode !== null) {\n              placementNode.insertBefore(node);\n            } else {\n              target.append(node);\n            }\n            target = node;\n          } else {\n            target = target.insertAfter(node, false);\n          }\n        }\n      } else if (!$isElementNode(node) || $isElementNode(node) && node.isInline() || $isDecoratorNode(target) && !target.isInline()) {\n        lastNode = node;\n        // when pasting top level node in the middle of paragraph\n        // we need to split paragraph instead of placing it inline\n        if ($isRangeSelection(this) && $isDecoratorNode(node) && ($isElementNode(target) || $isTextNode(target)) && !node.isInline()) {\n          let splitNode;\n          let splitOffset;\n          if ($isTextNode(target)) {\n            splitNode = target.getParentOrThrow();\n            const [textNode] = target.splitText(anchorOffset);\n            splitOffset = textNode.getIndexWithinParent() + 1;\n          } else {\n            splitNode = target;\n            splitOffset = anchorOffset;\n          }\n          const [, rightTree] = $splitNode(splitNode, splitOffset);\n          target = rightTree.insertBefore(node);\n        } else {\n          target = target.insertAfter(node, false);\n        }\n      } else {\n        const nextTarget = target.getParentOrThrow();\n        // if we're inserting an Element after a LineBreak, we want to move the target to the parent\n        // and remove the LineBreak so we don't have empty space.\n        if ($isLineBreakNode(target)) {\n          target.remove();\n        }\n        target = nextTarget;\n        // Re-try again with the target being the parent\n        i--;\n        continue;\n      }\n    }\n    if (selectStart) {\n      // Handle moving selection to start for all nodes\n      if ($isTextNode(startingNode)) {\n        startingNode.select();\n      } else {\n        const prevSibling = target.getPreviousSibling();\n        if ($isTextNode(prevSibling)) {\n          prevSibling.select();\n        } else {\n          const index = target.getIndexWithinParent();\n          target.getParentOrThrow().select(index, index);\n        }\n      }\n    }\n    if ($isElementNode(target)) {\n      // If the last node to be inserted was a text node,\n      // then we should attempt to move selection to that.\n      const lastChild = $isTextNode(lastNode) ? lastNode : $isElementNode(lastNode) && lastNode.isInline() ? lastNode.getLastDescendant() : target.getLastDescendant();\n      if (!selectStart) {\n        // Handle moving selection to end for elements\n        if (lastChild === null) {\n          target.select();\n        } else if ($isTextNode(lastChild)) {\n          if (lastChild.getTextContent() === '') {\n            lastChild.selectPrevious();\n          } else {\n            lastChild.select();\n          }\n        } else {\n          lastChild.selectNext();\n        }\n      }\n      if (siblings.length !== 0) {\n        const originalTarget = target;\n        for (let i = siblings.length - 1; i >= 0; i--) {\n          const sibling = siblings[i];\n          const prevParent = sibling.getParentOrThrow();\n          if ($isElementNode(target) && !$isBlockElementNode(sibling) && !($isDecoratorNode(sibling) && (\n          // Note: We are only looking for decorators that are inline and not isolated.\n          !sibling.isInline() || sibling.isIsolated()))) {\n            if (originalTarget === target) {\n              target.append(sibling);\n            } else {\n              target.insertBefore(sibling);\n            }\n            target = sibling;\n          } else if (!$isElementNode(target) && !$isBlockElementNode(sibling)) {\n            target.insertBefore(sibling);\n            target = sibling;\n          } else {\n            if ($isElementNode(sibling) && !sibling.canInsertAfter(target)) {\n              // @ts-ignore The clone method does exist on the constructor.\n              const prevParentClone = prevParent.constructor.clone(prevParent);\n              if (!$isElementNode(prevParentClone)) {\n                {\n                  throw Error(`insertNodes: cloned parent clone is not an element`);\n                }\n              }\n              prevParentClone.append(sibling);\n              target.insertAfter(prevParentClone);\n            } else {\n              target.insertAfter(sibling);\n            }\n          }\n          // Check if the prev parent is empty, as it might need\n          // removing.\n          if (prevParent.isEmpty() && !prevParent.canBeEmpty()) {\n            prevParent.remove();\n          }\n        }\n      }\n    } else if (!selectStart) {\n      // Handle moving selection to end for other nodes\n      if ($isTextNode(target)) {\n        target.select();\n      } else {\n        const element = target.getParentOrThrow();\n        const index = target.getIndexWithinParent() + 1;\n        element.select(index, index);\n      }\n    }\n    return true;\n  }\n  insertParagraph() {\n    if (!this.isCollapsed()) {\n      this.removeText();\n    }\n    const anchor = this.anchor;\n    const anchorOffset = anchor.offset;\n    let currentElement;\n    let nodesToMove = [];\n    let siblingsToMove = [];\n    if (anchor.type === 'text') {\n      const anchorNode = anchor.getNode();\n      nodesToMove = anchorNode.getNextSiblings().reverse();\n      currentElement = anchorNode.getParentOrThrow();\n      const isInline = currentElement.isInline();\n      const textContentLength = isInline ? currentElement.getTextContentSize() : anchorNode.getTextContentSize();\n      if (anchorOffset === 0) {\n        nodesToMove.push(anchorNode);\n      } else {\n        if (isInline) {\n          // For inline nodes, we want to move all the siblings to the new paragraph\n          // if selection is at the end, we just move the siblings. Otherwise, we also\n          // split the text node and add that and it's siblings below.\n          siblingsToMove = currentElement.getNextSiblings();\n        }\n        if (anchorOffset !== textContentLength) {\n          if (!isInline || anchorOffset !== anchorNode.getTextContentSize()) {\n            const [, splitNode] = anchorNode.splitText(anchorOffset);\n            nodesToMove.push(splitNode);\n          }\n        }\n      }\n    } else {\n      currentElement = anchor.getNode();\n      if ($isRootOrShadowRoot(currentElement)) {\n        const paragraph = $createParagraphNode();\n        const child = currentElement.getChildAtIndex(anchorOffset);\n        paragraph.select();\n        if (child !== null) {\n          child.insertBefore(paragraph, false);\n        } else {\n          currentElement.append(paragraph);\n        }\n        return;\n      }\n      nodesToMove = currentElement.getChildren().slice(anchorOffset).reverse();\n    }\n    const nodesToMoveLength = nodesToMove.length;\n    if (anchorOffset === 0 && nodesToMoveLength > 0 && currentElement.isInline()) {\n      const parent = currentElement.getParentOrThrow();\n      const newElement = parent.insertNewAfter(this, false);\n      if ($isElementNode(newElement)) {\n        const children = parent.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          newElement.append(children[i]);\n        }\n      }\n      return;\n    }\n    const newElement = currentElement.insertNewAfter(this, false);\n    if (newElement === null) {\n      // Handle as a line break insertion\n      this.insertLineBreak();\n    } else if ($isElementNode(newElement)) {\n      // If we're at the beginning of the current element, move the new element to be before the current element\n      const currentElementFirstChild = currentElement.getFirstChild();\n      const isBeginning = anchorOffset === 0 && (currentElement.is(anchor.getNode()) || currentElementFirstChild && currentElementFirstChild.is(anchor.getNode()));\n      if (isBeginning && nodesToMoveLength > 0) {\n        currentElement.insertBefore(newElement);\n        return;\n      }\n      let firstChild = null;\n      const siblingsToMoveLength = siblingsToMove.length;\n      const parent = newElement.getParentOrThrow();\n      // For inline elements, we append the siblings to the parent.\n      if (siblingsToMoveLength > 0) {\n        for (let i = 0; i < siblingsToMoveLength; i++) {\n          const siblingToMove = siblingsToMove[i];\n          parent.append(siblingToMove);\n        }\n      }\n      if (nodesToMoveLength !== 0) {\n        for (let i = 0; i < nodesToMoveLength; i++) {\n          const nodeToMove = nodesToMove[i];\n          if (firstChild === null) {\n            newElement.append(nodeToMove);\n          } else {\n            firstChild.insertBefore(nodeToMove);\n          }\n          firstChild = nodeToMove;\n        }\n      }\n      if (!newElement.canBeEmpty() && newElement.getChildrenSize() === 0) {\n        newElement.selectPrevious();\n        newElement.remove();\n      } else {\n        newElement.selectStart();\n      }\n    }\n  }\n  insertLineBreak(selectStart) {\n    const lineBreakNode = $createLineBreakNode();\n    const anchor = this.anchor;\n    if (anchor.type === 'element') {\n      const element = anchor.getNode();\n      if ($isRootNode(element)) {\n        this.insertParagraph();\n      }\n    }\n    if (selectStart) {\n      this.insertNodes([lineBreakNode], true);\n    } else {\n      if (this.insertNodes([lineBreakNode])) {\n        lineBreakNode.selectNext(0, 0);\n      }\n    }\n  }\n  getCharacterOffsets() {\n    return getCharacterOffsets(this);\n  }\n  extract() {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const [anchorOffset, focusOffset] = getCharacterOffsets(this);\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n      return [firstNode];\n    }\n    const isBefore = anchor.isBefore(focus);\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n    return selectedNodes;\n  }\n  modify(alter, isBackward, granularity) {\n    const focus = this.focus;\n    const anchor = this.anchor;\n    const collapse = alter === 'move';\n\n    // Handle the selection movement around decorators.\n    const possibleNode = $getAdjacentNode(focus, isBackward);\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n      // Make it possible to move selection from range selection to\n      // node selection on the node.\n      if (collapse && possibleNode.isKeyboardSelectable()) {\n        const nodeSelection = $createNodeSelection();\n        nodeSelection.add(possibleNode.__key);\n        $setSelection(nodeSelection);\n        return;\n      }\n      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();\n      if (!$isTextNode(sibling)) {\n        const parent = possibleNode.getParentOrThrow();\n        let offset;\n        let elementKey;\n        if ($isElementNode(sibling)) {\n          elementKey = sibling.__key;\n          offset = isBackward ? sibling.getChildrenSize() : 0;\n        } else {\n          offset = possibleNode.getIndexWithinParent();\n          elementKey = parent.__key;\n          if (!isBackward) {\n            offset++;\n          }\n        }\n        focus.set(elementKey, offset, 'element');\n        if (collapse) {\n          anchor.set(elementKey, offset, 'element');\n        }\n        return;\n      } else {\n        const siblingKey = sibling.__key;\n        const offset = isBackward ? sibling.getTextContent().length : 0;\n        focus.set(siblingKey, offset, 'text');\n        if (collapse) {\n          anchor.set(siblingKey, offset, 'text');\n        }\n        return;\n      }\n    }\n    const editor = getActiveEditor();\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return;\n    }\n    const blockCursorElement = editor._blockCursorElement;\n    const rootElement = editor._rootElement;\n    // Remove the block cursor element if it exists. This will ensure selection\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\n    // occur. :/\n    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n    }\n    // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity);\n    // Guard against no ranges\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0);\n      // Apply the DOM selection to our Lexical selection.\n      const anchorNode = this.anchor.getNode();\n      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);\n      this.applyDOMRange(range);\n      this.dirty = true;\n      if (!collapse) {\n        // Validate selection; make sure that the new extended selection respects shadow roots\n        const nodes = this.getNodes();\n        const validNodes = [];\n        let shrinkSelection = false;\n        for (let i = 0; i < nodes.length; i++) {\n          const nextNode = nodes[i];\n          if ($hasAncestor(nextNode, root)) {\n            validNodes.push(nextNode);\n          } else {\n            shrinkSelection = true;\n          }\n        }\n        if (shrinkSelection && validNodes.length > 0) {\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\n          // will return an empty array in this case\n          if (isBackward) {\n            const firstValidNode = validNodes[0];\n            if ($isElementNode(firstValidNode)) {\n              firstValidNode.selectStart();\n            } else {\n              firstValidNode.getParentOrThrow().selectStart();\n            }\n          } else {\n            const lastValidNode = validNodes[validNodes.length - 1];\n            if ($isElementNode(lastValidNode)) {\n              lastValidNode.selectEnd();\n            } else {\n              lastValidNode.getParentOrThrow().selectEnd();\n            }\n          }\n        }\n\n        // Because a range works on start and end, we might need to flip\n        // the anchor and focus points to match what the DOM has, not what\n        // the range has specifically.\n        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {\n          $swapPoints(this);\n        }\n      }\n    }\n  }\n  deleteCharacter(isBackward) {\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const focus = this.focus;\n      let anchorNode = anchor.getNode();\n      if (!isBackward && (\n      // Delete forward handle case\n      anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\n        const parent = anchorNode.getParent();\n        const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());\n        if ($isElementNode(nextSibling) && !nextSibling.canExtractContents()) {\n          return;\n        }\n      }\n      // Handle the deletion around decorators.\n      const possibleNode = $getAdjacentNode(focus, isBackward);\n      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n        // Make it possible to move selection from range selection to\n        // node selection on the node.\n        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {\n          anchorNode.remove();\n          const nodeSelection = $createNodeSelection();\n          nodeSelection.add(possibleNode.__key);\n          $setSelection(nodeSelection);\n        } else {\n          possibleNode.remove();\n        }\n        return;\n      }\n      this.modify('extend', isBackward, 'character');\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        const element = anchor.type === 'element' ? anchor.getNode() : anchor.getNode().getParentOrThrow();\n        if (element.collapseAtStart(this)) {\n          return;\n        }\n      }\n    }\n    const wasCollapsed = this.isCollapsed();\n    this.removeText();\n    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === 'element' && this.anchor.offset === 0) {\n      const anchorNode = this.anchor.getNode();\n      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {\n        anchorNode.collapseAtStart(this);\n      }\n    }\n  }\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      if (this.anchor.type === 'text') {\n        this.modify('extend', isBackward, 'lineboundary');\n      }\n\n      // If selection is extended to cover text edge then extend it one character more\n      // to delete its parent element. Otherwise text content will be deleted but empty\n      // parent node will remain\n      const endPoint = isBackward ? this.focus : this.anchor;\n      if (endPoint.offset === 0) {\n        this.modify('extend', isBackward, 'character');\n      }\n    }\n    this.removeText();\n  }\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      this.modify('extend', isBackward, 'word');\n    }\n    this.removeText();\n  }\n}\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\nfunction getCharacterOffset(point) {\n  const offset = point.offset;\n  if (point.type === 'text') {\n    return offset;\n  }\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\n}\nfunction getCharacterOffsets(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {\n    return [0, 0];\n  }\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  $setPointValues(anchor, focus.key, focus.offset, focus.type);\n  $setPointValues(focus, anchorKey, anchorOffset, anchorType);\n  selection._cachedNodes = null;\n}\nfunction moveNativeSelection(domSelection, alter, direction, granularity) {\n  // @ts-expect-error Selection.modify() method applies a change to the current selection or cursor position,\n  // but is still non-standard in some browsers.\n  domSelection.modify(alter, direction, granularity);\n}\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n      if (!doesContainGrapheme(text)) {\n        if (isBackward) {\n          focus.offset = characterOffset;\n        } else {\n          anchor.offset = characterOffset;\n        }\n      }\n    }\n  }\n}\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/(?=\\s)/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n      break;\n    }\n  }\n  const nextTextContent = split.join('').trim();\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\nfunction internalResolveSelectionPoint(dom, offset, lastPoint, editor) {\n  let resolvedOffset = offset;\n  let resolvedNode;\n  // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (dom.nodeType === DOM_ELEMENT_TYPE) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false;\n    // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length;\n    // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n    let childDOM = childNodes[resolvedOffset];\n    let hasBlockCursor = false;\n    if (childDOM === editor._blockCursorElement) {\n      childDOM = childNodes[resolvedOffset + 1];\n      hasBlockCursor = true;\n    } else if (editor._blockCursorElement !== null) {\n      resolvedOffset--;\n    }\n    resolvedNode = getNodeFromDOM(childDOM);\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n    } else {\n      let resolvedElement = getNodeFromDOM(dom);\n      // Ensure resolvedElement is actually a element.\n      if (resolvedElement === null) {\n        return null;\n      }\n      if ($isElementNode(resolvedElement)) {\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n          if (descendant === null) {\n            resolvedElement = child;\n            resolvedOffset = 0;\n          } else {\n            child = descendant;\n            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();\n          }\n        }\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);\n        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {\n          resolvedOffset++;\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent();\n        // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = getNodeFromDOM(dom);\n  }\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');\n}\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\n  const offset = point.offset;\n  const node = point.getNode();\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n    if (!isBackward) {\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getChildrenSize();\n        // @ts-expect-error: intentional\n        point.type = 'element';\n      } else if ($isTextNode(prevSibling)) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getTextContent().length;\n      }\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getPreviousSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = parentSibling.getTextContent().length;\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.key = nextSibling.__key;\n      point.offset = 0;\n      // @ts-expect-error: intentional\n      point.type = 'element';\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {\n      const parentSibling = parent.getNextSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = 0;\n      }\n    }\n  }\n}\nfunction normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus);\n\n    // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n    if (isCollapsed) {\n      focus.key = anchor.key;\n      focus.offset = anchor.offset;\n      focus.type = anchor.type;\n    }\n    const editor = getActiveEditor();\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);\n      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);\n    }\n  }\n}\nfunction internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n  const resolvedAnchorPoint = internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n  const resolvedFocusPoint = internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {\n    const anchorNode = getNodeFromDOM(anchorDOM);\n    const focusNode = getNodeFromDOM(focusDOM);\n    // Ensure if we're selecting the content of a decorator that we\n    // return null for this point, as it's not in the controlled scope\n    // of Lexical.\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\n      return null;\n    }\n  }\n\n  // Handle normalization of selection when it is at the boundaries.\n  normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n}\nfunction $isBlockElementNode(node) {\n  return $isElementNode(node) && !node.isInline();\n}\n\n// This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\nfunction internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, '');\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\nfunction $createRangeSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0, '');\n}\nfunction $createNodeSelection() {\n  return new NodeSelection(new Set());\n}\nfunction DEPRECATED_$createGridSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new GridSelection('root', anchor, focus);\n}\nfunction internalCreateSelection(editor) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection(editor._window);\n  if ($isNodeSelection(lastSelection) || DEPRECATED_$isGridSelection(lastSelection)) {\n    return lastSelection.clone();\n  }\n  return internalCreateRangeSelection(lastSelection, domSelection, editor);\n}\nfunction internalCreateRangeSelection(lastSelection, domSelection, editor) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    return null;\n  }\n  // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n\n  const windowEvent = windowObj.event;\n  const eventType = windowEvent ? windowEvent.type : undefined;\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection = !getIsProcesssingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return lastSelection.clone();\n    }\n  } else {\n    return lastSelection.clone();\n  }\n  // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n  const resolvedSelectionPoints = internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? '' : lastSelection.style);\n}\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n  const parentKey = parentNode.__key;\n  // Single node. We shift selection but never redimension it\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n    if (nodeOffset <= selectionOffset) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element');\n      // The new selection might point to text nodes, try to resolve them\n      $updateSelectionResolveTextNodes(selection);\n    }\n    return;\n  }\n  // Multiple nodes selected. We shift or redimension selection\n  const isBackward = selection.isBackward();\n  const firstPoint = isBackward ? focus : anchor;\n  const firstPointNode = firstPoint.getNode();\n  const lastPoint = isBackward ? anchor : focus;\n  const lastPointNode = lastPoint.getNode();\n  if (parentNode.is(firstPointNode)) {\n    const firstPointOffset = firstPoint.offset;\n    if (nodeOffset <= firstPointOffset) {\n      firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\n    }\n  }\n  if (parentNode.is(lastPointNode)) {\n    const lastPointOffset = lastPoint.offset;\n    if (nodeOffset <= lastPointOffset) {\n      lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\n    }\n  }\n  // The new selection might point to text nodes, try to resolve them\n  $updateSelectionResolveTextNodes(selection);\n}\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n    return;\n  }\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n    point.set(parent.__key, offset, 'element');\n  }\n}\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === 'text') {\n    point.key = key;\n    if (!isBefore) {\n      point.offset += textLength;\n    }\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.offset -= 1;\n  }\n}\nfunction updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement;\n\n  // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n  if (tags.has('collaboration') && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {\n    return;\n  }\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n    return;\n  }\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const nextStyle = nextSelection.style;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n  let anchorFormatOrStyleChanged = false;\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    const anchorNode = anchor.getNode();\n    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;\n  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === 'text') {\n    anchorFormatOrStyleChanged = true;\n  }\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  }\n\n  // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {\n    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());\n  }\n\n  // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode &&\n  // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === 'Range' && isCollapsed)) {\n    // If the root element does not have focus, ensure it has focus\n    if (activeElement === null || !rootElement.contains(activeElement)) {\n      rootElement.focus({\n        preventScroll: true\n      });\n    }\n    if (anchor.type !== 'element') {\n      return;\n    }\n  }\n\n  // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n  try {\n    // When updating more than 1000 nodes on Chrome, it's actually better to defer\n    // updating the selection till the next frame. This is because Chrome's\n    // Blink engine has hard limit on how many DOM nodes it can redraw in\n    // a single cycle, so keeping it to the next frame improves performance.\n    // The downside is that is makes the computation within Lexical more\n    // complex, as now, we've sync update the DOM, but selection no longer\n    // matches.\n    if (IS_CHROME && nodeCount > 1000) {\n      window.requestAnimationFrame(() => domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset));\n    } else {\n      domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n    }\n  } catch (error) {\n    // If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n  }\n  if (!tags.has('skip-scroll-into-view') && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {\n    const selectionTarget = nextSelection instanceof RangeSelection && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;\n    if (selectionTarget !== null) {\n      // @ts-ignore Text nodes do have getBoundingClientRect\n      const selectionRect = selectionTarget.getBoundingClientRect();\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\n    }\n  }\n  markSelectionChangeFromDOMUpdate();\n}\nfunction $insertNodes(nodes, selectStart) {\n  let selection = $getSelection();\n  if (selection === null) {\n    selection = $getRoot().selectEnd();\n  }\n  return selection.insertNodes(nodes, selectStart);\n}\nfunction $getTextContent() {\n  const selection = $getSelection();\n  if (selection === null) {\n    return '';\n  }\n  return selection.getTextContent();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\nconst observerOptions = {\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;\n}\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      throw Error(`Cannot use method in read-only mode.`);\n    }\n  }\n}\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().`);\n    }\n  }\n  return activeEditorState;\n}\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().`);\n    }\n  }\n  return activeEditor;\n}\nfunction internalGetActiveEditor() {\n  return activeEditor;\n}\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n  const transformsArrLength = transformsArr.length;\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined &&\n  // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\n\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n        dirtyLeaves.add(nodeKey);\n      }\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n\n      // We want to prioritize node transforms over element transforms\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    }\n\n    // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n      if (nodeKey !== 'root' && !intentionallyMarkedAsDirty) {\n        continue;\n      }\n      const node = nodeMap.get(nodeKey);\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n    }\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\nfunction $parseSerializedNode(serializedNode) {\n  const internalSerializedNode = serializedNode;\n  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);\n}\nfunction $parseSerializedNodeImpl(serializedNode, registeredNodes) {\n  const type = serializedNode.type;\n  const registeredNode = registeredNodes.get(type);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`parseEditorState: type \"${type}\" + not found`);\n    }\n  }\n  const nodeClass = registeredNode.klass;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);\n    }\n  }\n  const node = nodeClass.importJSON(serializedNode);\n  const children = serializedNode.children;\n  if ($isElementNode(node) && Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const serializedJSONChildNode = children[i];\n      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);\n      node.append(childNode);\n    }\n  }\n  return node;\n}\nfunction parseEditorState(serializedEditorState, editor, updateFn) {\n  const editorState = createEmptyEditorState();\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previousDirtyElements = editor._dirtyElements;\n  const previousDirtyLeaves = editor._dirtyLeaves;\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\n  const previousDirtyType = editor._dirtyType;\n  editor._dirtyElements = new Map();\n  editor._dirtyLeaves = new Set();\n  editor._cloneNotNeeded = new Set();\n  editor._dirtyType = 0;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n  try {\n    const registeredNodes = editor._nodes;\n    const serializedNode = serializedEditorState.root;\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\n    if (updateFn) {\n      updateFn();\n    }\n\n    // Make the editorState immutable\n    editorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\n    }\n  } finally {\n    editor._dirtyElements = previousDirtyElements;\n    editor._dirtyLeaves = previousDirtyLeaves;\n    editor._cloneNotNeeded = previousCloneNotNeeded;\n    editor._dirtyType = previousDirtyType;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n  return editorState;\n}\n\n// This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nfunction readEditorState(editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = null;\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap;\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  };\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  };\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\nfunction commitPendingUpdates(editor) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n  const shouldSkipDOM = editor._headless || rootElement === null;\n  if (pendingEditorState === null) {\n    return;\n  }\n\n  // ======\n  // Reconciliation has started.\n  // ======\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  const observer = editor._observer;\n  let mutatedNodes = null;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    isReadOnlyMode = false;\n    // We don't want updates to sync block the reconciliation.\n    editor._updating = true;\n    try {\n      const dirtyType = editor._dirtyType;\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      observer.disconnect();\n      mutatedNodes = reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } catch (error) {\n      // Report errors\n      if (error instanceof Error) {\n        editor._onError(error);\n      }\n\n      // Reset editor and restore incoming editor state to the DOM\n      if (!isAttemptingToRecoverFromReconcilerError) {\n        resetEditor(editor, null, rootElement, pendingEditorState);\n        initMutationObserver(editor);\n        editor._dirtyType = FULL_RECONCILE;\n        isAttemptingToRecoverFromReconcilerError = true;\n        commitPendingUpdates(editor);\n        isAttemptingToRecoverFromReconcilerError = false;\n      } else {\n        // To avoid a possible situation of infinite loops, lets throw\n        throw error;\n      }\n      return;\n    } finally {\n      observer.observe(rootElement, observerOptions);\n      editor._updating = previouslyUpdating;\n      activeEditorState = previousActiveEditorState;\n      isReadOnlyMode = previousReadOnlyMode;\n      activeEditor = previousActiveEditor;\n    }\n  }\n  if (!pendingEditorState._readOnly) {\n    pendingEditorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n      if ($isRangeSelection(pendingSelection)) {\n        Object.freeze(pendingSelection.anchor);\n        Object.freeze(pendingSelection.focus);\n      }\n      Object.freeze(pendingSelection);\n    }\n  }\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n  const deferred = editor._deferred;\n  const nodeCount = pendingEditorState._nodeMap.size;\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n  $garbageCollectDetachedDecorators(editor, pendingEditorState);\n\n  // ======\n  // Reconciliation has finished. Now update selection and trigger listeners.\n  // ======\n\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window);\n\n  // Attempt to update the DOM selection, including focusing of the root element,\n  // and scroll into view if needed.\n  if (editor._editable &&\n  // domSelection will be null in headless\n  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    try {\n      if (observer !== null) {\n        observer.disconnect();\n      }\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\n        const blockCursorElement = editor._blockCursorElement;\n        if (blockCursorElement !== null) {\n          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n        }\n        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement, nodeCount);\n      }\n      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);\n      if (observer !== null) {\n        observer.observe(rootElement, observerOptions);\n      }\n    } finally {\n      activeEditor = previousActiveEditor;\n      activeEditorState = previousActiveEditorState;\n    }\n  }\n  if (mutatedNodes !== null) {\n    triggerMutationListeners(editor, currentEditorState, pendingEditorState, mutatedNodes, tags, dirtyLeaves);\n  }\n  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  /**\n   * Capture pendingDecorators after garbage collecting detached decorators\n   */\n  const pendingDecorators = editor._pendingDecorators;\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  }\n  triggerTextContentListeners(editor, currentEditorState, pendingEditorState);\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    normalizedNodes,\n    prevEditorState: currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor, deferred);\n  triggerEnqueuedUpdates(editor);\n}\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\nfunction triggerMutationListeners(editor, currentEditorState, pendingEditorState, mutatedNodes, updateTags, dirtyLeaves) {\n  const listeners = Array.from(editor._listeners.mutation);\n  const listenersLength = listeners.length;\n  for (let i = 0; i < listenersLength; i++) {\n    const [listener, klass] = listeners[i];\n    const mutatedNodesByType = mutatedNodes.get(klass);\n    if (mutatedNodesByType !== undefined) {\n      listener(mutatedNodesByType, {\n        dirtyLeaves,\n        updateTags\n      });\n    }\n  }\n}\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n    for (let i = 0; i < listeners.length; i++) {\n      // @ts-ignore\n      listeners[i].apply(null, payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\nfunction triggerCommandListeners(editor, type, payload) {\n  if (editor._updating === false || activeEditor !== editor) {\n    let returnVal = false;\n    editor.update(() => {\n      returnVal = triggerCommandListeners(editor, type, payload);\n    });\n    return returnVal;\n  }\n  const editors = getEditorsToPropagate(editor);\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n      if (listenerInPriorityOrder !== undefined) {\n        const listenersSet = listenerInPriorityOrder[i];\n        if (listenersSet !== undefined) {\n          const listeners = Array.from(listenersSet);\n          const listenersLength = listeners.length;\n          for (let j = 0; j < listenersLength; j++) {\n            if (listeners[j](payload, editor) === true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n  if (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [updateFn, options] = queuedUpdate;\n      beginUpdate(editor, updateFn, options);\n    }\n  }\n}\nfunction triggerDeferredUpdateCallbacks(editor, deferred) {\n  editor._deferred = [];\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\nfunction processNestedUpdates(editor, initialSkipTransforms) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false;\n\n  // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n  while (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [nextUpdateFn, options] = queuedUpdate;\n      let onUpdate;\n      let tag;\n      if (options !== undefined) {\n        onUpdate = options.onUpdate;\n        tag = options.tag;\n        if (options.skipTransforms) {\n          skipTransforms = true;\n        }\n        if (onUpdate) {\n          editor._deferred.push(onUpdate);\n        }\n        if (tag) {\n          editor._updateTags.add(tag);\n        }\n      }\n      nextUpdateFn();\n    }\n  }\n  return skipTransforms;\n}\nfunction beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let tag;\n  let skipTransforms = false;\n  let discrete = false;\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    tag = options.tag;\n    if (tag != null) {\n      updateTags.add(tag);\n    }\n    skipTransforms = options.skipTransforms || false;\n    discrete = options.discrete || false;\n  }\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);\n    editorStateWasCloned = true;\n  }\n  pendingEditorState._flushSync = discrete;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n  try {\n    if (editorStateWasCloned) {\n      if (editor._headless) {\n        if (currentEditorState._selection != null) {\n          pendingEditorState._selection = currentEditorState._selection.clone();\n        }\n      } else {\n        pendingEditorState._selection = internalCreateSelection(editor);\n      }\n    }\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n      processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n    const endingCompositionKey = editor._compositionKey;\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n    const pendingSelection = pendingEditorState._selection;\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n\n    // Restore existing editor state to the DOM\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements.clear();\n    commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n  const windowObj = editor._window;\n  const windowEvent = windowObj !== null ? window.event : null;\n  const eventType = windowEvent != null ? windowEvent.type : null;\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor) || editor._blockCursorElement !== null && eventType === 'blur';\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    beginUpdate(editor, updateFn, options);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n  if (parent === null) {\n    return;\n  }\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\n  let selectionMoved = false;\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  }\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    // Doing this is O(n) so lets avoid it unless we need to do it\n    const index = nodeToRemove.getIndexWithinParent();\n    removeFromParent(nodeToRemove);\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  } else {\n    removeFromParent(nodeToRemove);\n  }\n  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    removeNode(parent, restoreSelection);\n  }\n  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\nclass LexicalNode {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n  static getType() {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n  }\n  static clone(_data) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n  constructor(key) {\n    // @ts-expect-error\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    this.__prev = null;\n    this.__next = null;\n    $setNodeKey(this, key);\n    {\n      if (this.__type !== 'root') {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type,\n        // @ts-expect-error\n        this.constructor);\n      }\n    }\n  }\n  // Getters and Traversers\n\n  getType() {\n    return this.__type;\n  }\n  isAttached() {\n    let nodeKey = this.__key;\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n      const node = $getNodeByKey(nodeKey);\n      if (node === null) {\n        break;\n      }\n      nodeKey = node.__parent;\n    }\n    return false;\n  }\n  isSelected(selection) {\n    const targetSelection = selection || $getSelection();\n    if (targetSelection == null) {\n      return false;\n    }\n    const isSelected = targetSelection.getNodes().some(n => n.__key === this.__key);\n    if ($isTextNode(this)) {\n      return isSelected;\n    }\n    // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n    if ($isRangeSelection(targetSelection) && targetSelection.anchor.type === 'element' && targetSelection.focus.type === 'element' && targetSelection.anchor.key === targetSelection.focus.key && targetSelection.anchor.offset === targetSelection.focus.offset) {\n      return false;\n    }\n    return isSelected;\n  }\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n  getIndexWithinParent() {\n    const parent = this.getParent();\n    if (parent === null) {\n      return -1;\n    }\n    let node = parent.getFirstChild();\n    let index = 0;\n    while (node !== null) {\n      if (this.is(node)) {\n        return index;\n      }\n      index++;\n      node = node.getNextSibling();\n    }\n    return -1;\n  }\n  getParent() {\n    const parent = this.getLatest().__parent;\n    if (parent === null) {\n      return null;\n    }\n    return $getNodeByKey(parent);\n  }\n  getParentOrThrow() {\n    const parent = this.getParent();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n    return parent;\n  }\n  getTopLevelElement() {\n    let node = this;\n    while (node !== null) {\n      const parent = node.getParent();\n      if ($isRootOrShadowRoot(parent)) {\n        return node;\n      }\n      node = parent;\n    }\n    return null;\n  }\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n    return parent;\n  }\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n    return parents;\n  }\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n    return parents;\n  }\n  getPreviousSibling() {\n    const self = this.getLatest();\n    const prevKey = self.__prev;\n    return prevKey === null ? null : $getNodeByKey(prevKey);\n  }\n  getPreviousSiblings() {\n    const siblings = [];\n    const parent = this.getParent();\n    if (parent === null) {\n      return siblings;\n    }\n    let node = parent.getFirstChild();\n    while (node !== null) {\n      if (node.is(this)) {\n        break;\n      }\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n  getNextSibling() {\n    const self = this.getLatest();\n    const nextKey = self.__next;\n    return nextKey === null ? null : $getNodeByKey(nextKey);\n  }\n  getNextSiblings() {\n    const siblings = [];\n    let node = this.getNextSibling();\n    while (node !== null) {\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n  getCommonAncestor(node) {\n    const a = this.getParents();\n    const b = node.getParents();\n    if ($isElementNode(this)) {\n      a.unshift(this);\n    }\n    if ($isElementNode(node)) {\n      b.unshift(node);\n    }\n    const aLength = a.length;\n    const bLength = b.length;\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\n      return null;\n    }\n    const bSet = new Set(b);\n    for (let i = 0; i < aLength; i++) {\n      const ancestor = a[i];\n      if (bSet.has(ancestor)) {\n        return ancestor;\n      }\n    }\n    return null;\n  }\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n    return this.__key === object.__key;\n  }\n  isBefore(targetNode) {\n    if (targetNode.isParentOf(this)) {\n      return true;\n    }\n    if (this.isParentOf(targetNode)) {\n      return false;\n    }\n    const commonAncestor = this.getCommonAncestor(targetNode);\n    let indexA = 0;\n    let indexB = 0;\n    let node = this;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexA = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    node = targetNode;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexB = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    return indexA < indexB;\n  }\n  isParentOf(targetNode) {\n    const key = this.__key;\n    if (key === targetNode.__key) {\n      return false;\n    }\n    let node = targetNode;\n    while (node !== null) {\n      if (node.__key === key) {\n        return true;\n      }\n      node = node.getParent();\n    }\n    return false;\n  }\n\n  // TO-DO: this function can be simplified a lot\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n    while (true) {\n      const key = node.__key;\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n      if (node === targetNode) {\n        break;\n      }\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n      const parent = node.getParentOrThrow();\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n      if (parent === targetNode) {\n        break;\n      }\n      let parentSibling = null;\n      let ancestor = parent;\n      do {\n        if (ancestor === null) {\n          {\n            throw Error(`getNodesBetween: ancestor is null`);\n          }\n        }\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n        if (ancestor !== null) {\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        }\n      } while (parentSibling === null);\n      node = parentSibling;\n    }\n    if (!isBefore) {\n      nodes.reverse();\n    }\n    return nodes;\n  }\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  }\n  getLatest() {\n    const latest = $getNodeByKey(this.__key);\n    if (latest === null) {\n      {\n        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);\n      }\n    }\n    return latest;\n  }\n  getWritable() {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key;\n    // Ensure we get the latest node from pending state\n    const latestNode = this.getLatest();\n    const parent = latestNode.__parent;\n    const cloneNotNeeded = editor._cloneNotNeeded;\n    const selection = $getSelection();\n    if (selection !== null) {\n      selection._cachedNodes = null;\n    }\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n    const constructor = latestNode.constructor;\n    // @ts-expect-error\n    const mutableNode = constructor.clone(latestNode);\n    mutableNode.__parent = parent;\n    mutableNode.__next = latestNode.__next;\n    mutableNode.__prev = latestNode.__prev;\n    if ($isElementNode(latestNode) && $isElementNode(mutableNode)) {\n      mutableNode.__first = latestNode.__first;\n      mutableNode.__last = latestNode.__last;\n      mutableNode.__size = latestNode.__size;\n      mutableNode.__indent = latestNode.__indent;\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__dir = latestNode.__dir;\n    } else if ($isTextNode(latestNode) && $isTextNode(mutableNode)) {\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__style = latestNode.__style;\n      mutableNode.__mode = latestNode.__mode;\n      mutableNode.__detail = latestNode.__detail;\n    }\n    cloneNotNeeded.add(key);\n    mutableNode.__key = key;\n    internalMarkNodeAsDirty(mutableNode);\n    // Update reference in node map\n    nodeMap.set(key, mutableNode);\n    return mutableNode;\n  }\n  getTextContent() {\n    return '';\n  }\n  getTextContentSize() {\n    return this.getTextContent().length;\n  }\n\n  // View\n\n  createDOM(_config, _editor) {\n    {\n      throw Error(`createDOM: base method not extended`);\n    }\n  }\n\n  /*\n   * This method is called when a node changes and should update the DOM\n   * in whatever way is necessary to make it align with any changes that might\n   * have happened during the update.\n   *\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\n   * (by calling createDOM). You would need to do this if the element tag changes,\n   * for instance.\n   *\n   * */\n  updateDOM(_prevNode, _dom, _config) {\n    {\n      throw Error(`updateDOM: base method not extended`);\n    }\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    {\n      throw Error(`exportJSON: base method not extended`);\n    }\n  }\n  static importJSON(_serializedNode) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);\n    }\n  }\n\n  // Setters and mutators\n\n  remove(preserveEmptyParent) {\n    removeNode(this, true, preserveEmptyParent);\n  }\n  replace(replaceWith, includeChildren) {\n    errorOnReadOnly();\n    let selection = $getSelection();\n    if (selection !== null) selection = selection.clone();\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\n    const self = this.getLatest();\n    const toReplaceKey = this.__key;\n    const key = replaceWith.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const size = writableParent.__size;\n    removeFromParent(writableReplaceWith);\n    const prevSibling = self.getPreviousSibling();\n    const nextSibling = self.getNextSibling();\n    const prevKey = self.__prev;\n    const nextKey = self.__next;\n    const parentKey = self.__parent;\n    removeNode(self, false, true);\n    if (prevSibling === null) {\n      writableParent.__first = key;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = key;\n    }\n    writableReplaceWith.__prev = prevKey;\n    if (nextSibling === null) {\n      writableParent.__last = key;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = key;\n    }\n    writableReplaceWith.__next = nextKey;\n    writableReplaceWith.__parent = parentKey;\n    writableParent.__size = size;\n    if (includeChildren) {\n      this.getChildren().forEach(child => {\n        writableReplaceWith.append(child);\n      });\n    }\n    if ($isRangeSelection(selection)) {\n      $setSelection(selection);\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(key);\n    }\n    return writableReplaceWith;\n  }\n  insertAfter(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n    if (oldParent !== null) {\n      // TODO: this is O(n), can we improve?\n      const oldIndex = nodeToInsert.getIndexWithinParent();\n      removeFromParent(writableNodeToInsert);\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n    const nextSibling = this.getNextSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    const nextKey = writableSelf.__next;\n    if (nextSibling === null) {\n      writableParent.__last = insertKey;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__next = insertKey;\n    writableNodeToInsert.__next = nextKey;\n    writableNodeToInsert.__prev = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const index = this.getIndexWithinParent();\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n    return nodeToInsert;\n  }\n  insertBefore(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    removeFromParent(writableNodeToInsert);\n    const prevSibling = this.getPreviousSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const prevKey = writableSelf.__prev;\n    // TODO: this is O(n), can we improve?\n    const index = this.getIndexWithinParent();\n    if (prevSibling === null) {\n      writableParent.__first = insertKey;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__prev = insertKey;\n    writableNodeToInsert.__prev = prevKey;\n    writableNodeToInsert.__next = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const selection = $getSelection();\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const parent = this.getParentOrThrow();\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\n    }\n    return nodeToInsert;\n  }\n  isParentRequired() {\n    return false;\n  }\n  createParentElementNode() {\n    return $createParagraphNode();\n  }\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n    if (nextSibling === null) {\n      return parent.select();\n    }\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n    return nextSibling.select(anchorOffset, focusOffset);\n  }\n  // Proxy to mark something as dirty\n  markDirty() {\n    this.getWritable();\n  }\n}\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getActiveEditor()._nodes.get(type);\n  // Common error - split in its own invariant\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);\n    }\n  }\n  const editorKlass = registeredNode.klass;\n  if (editorKlass !== klass) {\n    {\n      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass DecoratorNode extends LexicalNode {\n  constructor(key) {\n    super(key);\n  }\n  decorate(editor, config) {\n    {\n      throw Error(`decorate: base method not extended`);\n    }\n  }\n  isIsolated() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  isKeyboardSelectable() {\n    return true;\n  }\n}\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass ElementNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  constructor(key) {\n    super(key);\n    this.__first = null;\n    this.__last = null;\n    this.__size = 0;\n    this.__format = 0;\n    this.__indent = 0;\n    this.__dir = null;\n  }\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  getFormatType() {\n    const format = this.getFormat();\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\n  }\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n  getChildren() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenKeys() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child.__key);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__size;\n  }\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n  isLastChild() {\n    const self = this.getLatest();\n    const parentLastChild = this.getParentOrThrow().getLastChild();\n    return parentLastChild !== null && parentLastChild.is(self);\n  }\n  getAllTextNodes() {\n    const textNodes = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      if ($isTextNode(child)) {\n        textNodes.push(child);\n      }\n      if ($isElementNode(child)) {\n        const subChildrenNodes = child.getAllTextNodes();\n        textNodes.push(...subChildrenNodes);\n      }\n      child = child.getNextSibling();\n    }\n    return textNodes;\n  }\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n    while (node !== null) {\n      if ($isElementNode(node)) {\n        const child = node.getFirstChild();\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n      break;\n    }\n    return node;\n  }\n  getLastDescendant() {\n    let node = this.getLastChild();\n    while (node !== null) {\n      if ($isElementNode(node)) {\n        const child = node.getLastChild();\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n      break;\n    }\n    return node;\n  }\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;\n    }\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;\n  }\n  getFirstChild() {\n    const self = this.getLatest();\n    const firstKey = self.__first;\n    return firstKey === null ? null : $getNodeByKey(firstKey);\n  }\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n    if (firstChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n    return firstChild;\n  }\n  getLastChild() {\n    const self = this.getLatest();\n    const lastKey = self.__last;\n    return lastKey === null ? null : $getNodeByKey(lastKey);\n  }\n  getLastChildOrThrow() {\n    const lastChild = this.getLastChild();\n    if (lastChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a last child.`);\n      }\n    }\n    return lastChild;\n  }\n  getChildAtIndex(index) {\n    const size = this.getChildrenSize();\n    let node;\n    let i;\n    if (index < size / 2) {\n      node = this.getFirstChild();\n      i = 0;\n      while (node !== null && i <= index) {\n        if (i === index) {\n          return node;\n        }\n        node = node.getNextSibling();\n        i++;\n      }\n      return null;\n    }\n    node = this.getLastChild();\n    i = size - 1;\n    while (node !== null && i >= index) {\n      if (i === index) {\n        return node;\n      }\n      node = node.getPreviousSibling();\n      i--;\n    }\n    return null;\n  }\n  getTextContent() {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n    return textContent;\n  }\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n  hasFormat(type) {\n    if (type !== '') {\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n      return (this.getFormat() & formatFlag) !== 0;\n    }\n    return false;\n  }\n\n  // Mutators\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n    if (!this.canBeEmpty()) {\n      if (_anchorOffset === 0 && _focusOffset === 0) {\n        const firstChild = this.getFirstChild();\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\n          return firstChild.select(0, 0);\n        }\n      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {\n        const lastChild = this.getLastChild();\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\n          return lastChild.select();\n        }\n      }\n    }\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n    const key = this.__key;\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n    return selection;\n  }\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n    if ($isElementNode(firstNode) || $isTextNode(firstNode)) {\n      return firstNode.select(0, 0);\n    }\n    // Decorator or LineBreak\n    if (firstNode !== null) {\n      return firstNode.selectPrevious();\n    }\n    return this.select(0, 0);\n  }\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      return lastNode.select();\n    }\n    // Decorator or LineBreak\n    if (lastNode !== null) {\n      return lastNode.selectNext();\n    }\n    return this.select();\n  }\n  clear() {\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n  append(...nodesToAppend) {\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n  setDirection(direction) {\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n  setFormat(type) {\n    const self = this.getWritable();\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\n    return this;\n  }\n  setIndent(indentLevel) {\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    const nodesToInsertLength = nodesToInsert.length;\n    const oldSize = this.getChildrenSize();\n    const writableSelf = this.getWritable();\n    const writableSelfKey = writableSelf.__key;\n    const nodesToInsertKeys = [];\n    const nodesToRemoveKeys = [];\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n    let nodeBeforeRange = null;\n    let newSize = oldSize - deleteCount + nodesToInsertLength;\n    if (start !== 0) {\n      if (start === oldSize) {\n        nodeBeforeRange = this.getLastChild();\n      } else {\n        const node = this.getChildAtIndex(start);\n        if (node !== null) {\n          nodeBeforeRange = node.getPreviousSibling();\n        }\n      }\n    }\n    if (deleteCount > 0) {\n      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();\n      for (let i = 0; i < deleteCount; i++) {\n        if (nodeToDelete === null) {\n          {\n            throw Error(`splice: sibling not found`);\n          }\n        }\n        const nextSibling = nodeToDelete.getNextSibling();\n        const nodeKeyToDelete = nodeToDelete.__key;\n        const writableNodeToDelete = nodeToDelete.getWritable();\n        removeFromParent(writableNodeToDelete);\n        nodesToRemoveKeys.push(nodeKeyToDelete);\n        nodeToDelete = nextSibling;\n      }\n    }\n    let prevNode = nodeBeforeRange;\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\n      }\n      const writableNodeToInsert = nodeToInsert.getWritable();\n      if (writableNodeToInsert.__parent === writableSelfKey) {\n        newSize--;\n      }\n      removeFromParent(writableNodeToInsert);\n      const nodeKeyToInsert = nodeToInsert.__key;\n      if (prevNode === null) {\n        writableSelf.__first = nodeKeyToInsert;\n        writableNodeToInsert.__prev = null;\n      } else {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = nodeKeyToInsert;\n        writableNodeToInsert.__prev = writablePrevNode.__key;\n      }\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          throw Error(`append: attempting to append self`);\n        }\n      }\n      // Set child parent to self\n      writableNodeToInsert.__parent = writableSelfKey;\n      nodesToInsertKeys.push(nodeKeyToInsert);\n      prevNode = nodeToInsert;\n    }\n    if (start + deleteCount === oldSize) {\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = null;\n        writableSelf.__last = prevNode.__key;\n      }\n    } else if (nodeAfterRange !== null) {\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writableNodeAfterRange.__prev = prevNode.__key;\n        writablePrevNode.__next = nodeAfterRange.__key;\n      } else {\n        writableNodeAfterRange.__prev = null;\n      }\n    }\n    writableSelf.__size = newSize;\n\n    // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n        const {\n          anchor,\n          focus\n        } = selection;\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        // Cleanup if node can't be empty\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\n          this.remove();\n        }\n      }\n    }\n    return writableSelf;\n  }\n  // JSON serialization\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'element',\n      version: 1\n    };\n  }\n  // These are intended to be extends for specific element heuristics.\n  insertNewAfter(selection, restoreSelection) {\n    return null;\n  }\n  canInsertTab() {\n    return false;\n  }\n  canIndent() {\n    return true;\n  }\n  /*\n   * This method controls the behavior of a the node during backwards\n   * deletion (i.e., backspace) when selection is at the beginning of\n   * the node (offset 0)\n   */\n  collapseAtStart(selection) {\n    return false;\n  }\n  excludeFromCopy(destination) {\n    return false;\n  }\n  canExtractContents() {\n    return true;\n  }\n  canReplaceWith(replacement) {\n    return true;\n  }\n  canInsertAfter(node) {\n    return true;\n  }\n  canBeEmpty() {\n    return true;\n  }\n  canInsertTextBefore() {\n    return true;\n  }\n  canInsertTextAfter() {\n    return true;\n  }\n  isInline() {\n    return false;\n  }\n  // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\n  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\n  isShadowRoot() {\n    return false;\n  }\n  canMergeWith(node) {\n    return false;\n  }\n  extractWithChild(child, selection, destination) {\n    return false;\n  }\n}\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\nfunction isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {\n  let node = point.getNode();\n  while (node) {\n    const nodeKey = node.__key;\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n      return true;\n    }\n    node = node.getParent();\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass RootNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'root';\n  }\n  static clone() {\n    return new RootNode();\n  }\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n  getTopLevelElementOrThrow() {\n    {\n      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n  getTextContent() {\n    const cachedText = this.__cachedText;\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null) {\n        return cachedText;\n      }\n    }\n    return super.getTextContent();\n  }\n  remove() {\n    {\n      throw Error(`remove: cannot be called on root nodes`);\n    }\n  }\n  replace(node) {\n    {\n      throw Error(`replace: cannot be called on root nodes`);\n    }\n  }\n  insertBefore(nodeToInsert) {\n    {\n      throw Error(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n  insertAfter(nodeToInsert) {\n    {\n      throw Error(`insertAfter: cannot be called on root nodes`);\n    }\n  }\n\n  // View\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  // Mutate\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const node = nodesToAppend[i];\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\n        {\n          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);\n        }\n      }\n    }\n    return super.append(...nodesToAppend);\n  }\n  static importJSON(serializedNode) {\n    // We don't create a root, and instead use the existing root.\n    const node = $getRoot();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'root',\n      version: 1\n    };\n  }\n  collapseAtStart() {\n    return true;\n  }\n}\nfunction $createRootNode() {\n  return new RootNode();\n}\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n  const pendingSelection = editorState._selection;\n\n  // Check if we need to update because of changes in selection\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n  return false;\n}\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n\n  // @ts-expect-error TODO Replace Class utility type with InstanceType\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n\n  // @ts-expect-error TODO Replace Class utility type with InstanceType\n  const serializedChildren = serializedNode.children;\n  if ($isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const serializedChildNode = exportNodeToJSON(child);\n      serializedChildren.push(serializedChildNode);\n    }\n  }\n\n  // @ts-expect-error\n  return serializedNode;\n}\nclass EditorState {\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n  read(callbackFn) {\n    return readEditorState(this, callbackFn);\n  }\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n  toJSON() {\n    return readEditorState(this, () => ({\n      root: exportNodeToJSON($getRoot())\n    }));\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass LineBreakNode extends LexicalNode {\n  static getType() {\n    return 'linebreak';\n  }\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n  getTextContent() {\n    return '\\n';\n  }\n  createDOM() {\n    return document.createElement('br');\n  }\n  updateDOM() {\n    return false;\n  }\n  static importDOM() {\n    return {\n      br: node => {\n        const parentElement = node.parentElement;\n        // If the <br> is the only child, then skip including it\n        if (parentElement != null && parentElement.firstChild === node && parentElement.lastChild === node) {\n          return null;\n        }\n        return {\n          conversion: convertLineBreakElement,\n          priority: 0\n        };\n      }\n    };\n  }\n  static importJSON(serializedLineBreakNode) {\n    return $createLineBreakNode();\n  }\n  exportJSON() {\n    return {\n      type: 'linebreak',\n      version: 1\n    };\n  }\n}\nfunction convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\nfunction $createLineBreakNode() {\n  return $applyNodeReplacement(new LineBreakNode());\n}\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n  if (format & IS_HIGHLIGHT) {\n    return 'mark';\n  }\n  if (format & IS_SUBSCRIPT) {\n    return 'sub';\n  }\n  if (format & IS_SUPERSCRIPT) {\n    return 'sup';\n  }\n  return null;\n}\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n  return 'span';\n}\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList;\n  // Firstly we handle the base theme.\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  }\n  // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n          continue;\n        }\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\nfunction setTextContent(nextText, dom, node) {\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing();\n  // Always add a suffix if we're composing a node\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\n  const text = nextText + suffix;\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n    if (nodeValue !== text) {\n      if (isComposing || IS_FIREFOX) {\n        // We also use the diff composed text for general text in FF to avoid\n        // the spellcheck red line from flickering.\n        const [index, remove, insert] = diffComposedText(nodeValue, text);\n        if (remove !== 0) {\n          // @ts-expect-error\n          firstChild.deleteData(index, remove);\n        }\n        // @ts-expect-error\n        firstChild.insertData(index, insert);\n      } else {\n        firstChild.nodeValue = text;\n      }\n    }\n  }\n}\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme;\n  // Apply theme class names\n  const textClassNames = theme.text;\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\nfunction wrapElementWith(element, tag) {\n  const el = document.createElement(tag);\n  el.appendChild(element);\n  return el;\n}\n\n/** @noInheritDoc */\nclass TextNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'text';\n  }\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n  constructor(text, key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  getDetail() {\n    const self = this.getLatest();\n    return self.__detail;\n  }\n  getMode() {\n    const self = this.getLatest();\n    return TEXT_TYPE_TO_MODE[self.__mode];\n  }\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n  isSimpleText() {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n  getTextContent() {\n    const self = this.getLatest();\n    return self.__text;\n  }\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n\n  // View\n\n  createDOM(config) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n    if (prevTag !== nextTag) {\n      return true;\n    }\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // should always be an element\n      const prevInnerDOM = dom.firstChild;\n      if (prevInnerDOM == null) {\n        {\n          throw Error(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n    let innerDOM = dom;\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        innerDOM = dom.firstChild;\n        if (innerDOM == null) {\n          {\n            throw Error(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme;\n    // Apply theme class names\n    const textClassNames = theme.text;\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      '#text': () => ({\n        conversion: convertTextDOMNode,\n        priority: 0\n      }),\n      b: () => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      br: () => ({\n        conversion: convertLineBreakToElement,\n        priority: 0\n      }),\n      code: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      em: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      s: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: () => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sub: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sup: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createTextNode(serializedNode.text);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n\n  // This improves Lexical's basic text output in copy+paste plus\n  // for headless mode where people might use Lexical to generate\n  // HTML content and not have the ability to use CSS classes.\n  exportDOM(editor) {\n    let {\n      element\n    } = super.exportDOM(editor);\n\n    // This is the only way to properly add support for most clients,\n    // even if it's semantically incorrect to have to resort to using\n    // <b>, <u>, <s>, <i> elements.\n    if (element !== null) {\n      if (this.hasFormat('bold')) {\n        element = wrapElementWith(element, 'b');\n      }\n      if (this.hasFormat('italic')) {\n        element = wrapElementWith(element, 'i');\n      }\n      if (this.hasFormat('strikethrough')) {\n        element = wrapElementWith(element, 's');\n      }\n      if (this.hasFormat('underline')) {\n        element = wrapElementWith(element, 'u');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      detail: this.getDetail(),\n      format: this.getFormat(),\n      mode: this.getMode(),\n      style: this.getStyle(),\n      text: this.getTextContent(),\n      type: 'text',\n      version: 1\n    };\n  }\n\n  // Mutators\n  selectionTransform(prevSelection, nextSelection) {\n    return;\n  }\n\n  // TODO 0.5 This should just be a `string`.\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\n    return self;\n  }\n\n  // TODO 0.5 This should just be a `string`.\n  setDetail(detail) {\n    const self = this.getWritable();\n    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\n    return self;\n  }\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n  toggleFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return this.setFormat(this.getFormat() ^ formatFlag);\n  }\n  toggleDirectionless() {\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n  toggleUnmergeable() {\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n  setMode(type) {\n    const mode = TEXT_MODE_TO_TYPE[type];\n    if (this.__mode === mode) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n  setTextContent(text) {\n    if (this.__text === text) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__text = text;\n    return self;\n  }\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\n    } else {\n      const compositionKey = $getCompositionKey();\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n    return selection;\n  }\n  spliceText(offset, delCount, newText, moveSelection) {\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n    if (index < 0) {\n      index = handledTextLength + index;\n      if (index < 0) {\n        index = 0;\n      }\n    }\n    const selection = $getSelection();\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n  canInsertTextBefore() {\n    return true;\n  }\n  canInsertTextAfter() {\n    return true;\n  }\n  canContainTabs() {\n    return false;\n  }\n  splitText(...splitOffsets) {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const offsetsSet = new Set(splitOffsets);\n    const parts = [];\n    const textLength = textContent.length;\n    let string = '';\n    for (let i = 0; i < textLength; i++) {\n      if (string !== '' && offsetsSet.has(i)) {\n        parts.push(string);\n        string = '';\n      }\n      string += textContent[i];\n    }\n    if (string !== '') {\n      parts.push(string);\n    }\n    const partsLength = parts.length;\n    if (partsLength === 0) {\n      return [];\n    } else if (parts[0] === textContent) {\n      return [self];\n    }\n    const firstPart = parts[0];\n    const parent = self.getParentOrThrow();\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.getWritable();\n      writableNode.__text = firstPart;\n    }\n\n    // Handle selection\n    const selection = $getSelection();\n\n    // Then handle all other parts\n    const splitNodes = [writableNode];\n    let textSize = firstPart.length;\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const partSize = part.length;\n      const sibling = $createTextNode(part).getWritable();\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      const siblingKey = sibling.__key;\n      const nextTextSize = textSize + partSize;\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        if (anchor.key === key && anchor.type === 'text' && anchor.offset > textSize && anchor.offset <= nextTextSize) {\n          anchor.key = siblingKey;\n          anchor.offset -= textSize;\n          selection.dirty = true;\n        }\n        if (focus.key === key && focus.type === 'text' && focus.offset > textSize && focus.offset <= nextTextSize) {\n          focus.key = siblingKey;\n          focus.offset -= textSize;\n          selection.dirty = true;\n        }\n      }\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n      textSize = nextTextSize;\n      splitNodes.push(sibling);\n    }\n\n    // Insert the nodes into the parent's children\n    internalMarkSiblingsAsDirty(this);\n    const writableParent = parent.getWritable();\n    const insertionIndex = this.getIndexWithinParent();\n    if (hasReplacedSelf) {\n      writableParent.splice(insertionIndex, 0, splitNodes);\n      this.remove();\n    } else {\n      writableParent.splice(insertionIndex, 1, splitNodes);\n    }\n    if ($isRangeSelection(selection)) {\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n    }\n    return splitNodes;\n  }\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n    }\n    const targetText = target.__text;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n    target.remove();\n    return writableSelf;\n  }\n  isTextEntity() {\n    return false;\n  }\n}\nfunction convertSpanElement(domNode) {\n  // domNode is a <span> since we matched it by nodeName\n  const span = domNode;\n  // Google Docs uses span tags + font-weight for bold text\n  const hasBoldFontWeight = span.style.fontWeight === '700';\n  // Google Docs uses span tags + text-decoration: line-through for strikethrough text\n  const hasLinethroughTextDecoration = span.style.textDecoration === 'line-through';\n  // Google Docs uses span tags + font-style for italic text\n  const hasItalicFontStyle = span.style.fontStyle === 'italic';\n  // Google Docs uses span tags + text-decoration: underline for underline text\n  const hasUnderlineTextDecoration = span.style.textDecoration === 'underline';\n  // Google Docs uses span tags + vertical-align to specify subscript and superscript\n  const verticalAlign = span.style.verticalAlign;\n  return {\n    forChild: lexicalNode => {\n      if (!$isTextNode(lexicalNode)) {\n        return lexicalNode;\n      }\n      if (hasBoldFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n      if (hasLinethroughTextDecoration) {\n        lexicalNode.toggleFormat('strikethrough');\n      }\n      if (hasItalicFontStyle) {\n        lexicalNode.toggleFormat('italic');\n      }\n      if (hasUnderlineTextDecoration) {\n        lexicalNode.toggleFormat('underline');\n      }\n      if (verticalAlign === 'sub') {\n        lexicalNode.toggleFormat('subscript');\n      }\n      if (verticalAlign === 'super') {\n        lexicalNode.toggleFormat('superscript');\n      }\n      return lexicalNode;\n    },\n    node: null\n  };\n}\nfunction convertLineBreakToElement() {\n  return {\n    node: $createLineBreakNode()\n  };\n}\nfunction convertBringAttentionToElement(domNode) {\n  // domNode is a <b> since we matched it by nodeName\n  const b = domNode;\n  // Google Docs wraps all copied HTML in a <b> with font-weight normal\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !hasNormalFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n      return lexicalNode;\n    },\n    node: null\n  };\n}\nfunction convertTextDOMNode(domNode, _parent, preformatted) {\n  let textContent = domNode.textContent || '';\n  if (!preformatted && /\\n/.test(textContent)) {\n    textContent = textContent.replace(/\\r?\\n/gm, ' ');\n    if (textContent.trim().length === 0) {\n      return {\n        node: null\n      };\n    }\n  }\n  return {\n    node: $createTextNode(textContent)\n  };\n}\nconst nodeNameToTextFormat = {\n  code: 'code',\n  em: 'italic',\n  i: 'italic',\n  s: 'strikethrough',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  u: 'underline'\n};\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !lexicalNode.hasFormat(format)) {\n        lexicalNode.toggleFormat(format);\n      }\n      return lexicalNode;\n    },\n    node: null\n  };\n}\nfunction $createTextNode(text = '') {\n  return $applyNodeReplacement(new TextNode(text));\n}\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass ParagraphNode extends ElementNode {\n  static getType() {\n    return 'paragraph';\n  }\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && this.isEmpty()) {\n      element.append(document.createElement('br'));\n    }\n    if (element) {\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n      const indent = this.getIndent();\n      if (indent > 0) {\n        // padding-inline-start is not widely supported in email HTML, but\n        // Lexical Reconciler uses padding-inline-start. Using text-indent instead.\n        element.style.textIndent = `${indent * 20}px`;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createParagraphNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'paragraph',\n      version: 1\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(_, restoreSelection) {\n    const newElement = $createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart() {\n    const children = this.getChildren();\n    // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\n      const nextSibling = this.getNextSibling();\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n      const prevSibling = this.getPreviousSibling();\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction convertParagraphElement(element) {\n  const node = $createParagraphNode();\n  if (element.style) {\n    node.setFormat(element.style.textAlign);\n    const indent = parseInt(element.style.textIndent, 10) / 20;\n    if (indent > 0) {\n      node.setIndent(indent);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $createParagraphNode() {\n  return $applyNodeReplacement(new ParagraphNode());\n}\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n  editor._cloneNotNeeded.clear();\n  editor._dirtyLeaves = new Set();\n  editor._dirtyElements.clear();\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  editor._blockCursorElement = null;\n  const observer = editor._observer;\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  }\n\n  // Remove all the DOM nodes from the root element\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\nfunction initializeConversionCache(nodes) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM != null ? node.klass.importDOM.bind(node.klass) : null;\n    if (importDOM == null || handledConversions.has(importDOM)) {\n      return;\n    }\n    handledConversions.add(importDOM);\n    const map = importDOM();\n    if (map !== null) {\n      Object.keys(map).forEach(key => {\n        let currentCache = conversionCache.get(key);\n        if (currentCache === undefined) {\n          currentCache = [];\n          conversionCache.set(key, currentCache);\n        }\n        currentCache.push(map[key]);\n      });\n    }\n  });\n  return conversionCache;\n}\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const activeEditor = internalGetActiveEditor();\n  const theme = config.theme || {};\n  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, ParagraphNode, ...(config.nodes || [])];\n  const onError = config.onError;\n  const isEditable = config.editable !== undefined ? config.editable : true;\n  let registeredNodes;\n  if (editorConfig === undefined && activeEditor !== null) {\n    registeredNodes = activeEditor._nodes;\n  } else {\n    registeredNodes = new Map();\n    for (let i = 0; i < nodes.length; i++) {\n      let klass = nodes[i];\n      let replacementClass = null;\n      let replacementKlass = null;\n      if (typeof klass !== 'function') {\n        const options = klass;\n        klass = options.replace;\n        replacementClass = options.with;\n        replacementKlass = options.withKlass ? options.withKlass : null;\n      }\n      // Ensure custom nodes implement required methods.\n      {\n        const name = klass.name;\n        if (name !== 'RootNode') {\n          const proto = klass.prototype;\n          ['getType', 'clone'].forEach(method => {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!klass.hasOwnProperty(method)) {\n              console.warn(`${name} must implement static \"${method}\" method`);\n            }\n          });\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importDOM') &&\n          // eslint-disable-next-line no-prototype-builtins\n          klass.hasOwnProperty('exportDOM')) {\n            console.warn(`${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`);\n          }\n          if (proto instanceof DecoratorNode) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!proto.hasOwnProperty('decorate')) {\n              console.warn(`${proto.constructor.name} must implement \"decorate\" method`);\n            }\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importJSON')) {\n            console.warn(`${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !proto.hasOwnProperty('exportJSON')) {\n            console.warn(`${name} should implement \"exportJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n        }\n      }\n      const type = klass.getType();\n      registeredNodes.set(type, {\n        klass,\n        replace: replacementClass,\n        replaceWithKlass: replacementKlass,\n        transforms: new Set()\n      });\n    }\n  }\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    disableEvents,\n    namespace,\n    theme\n  }, onError ? onError : console.error, initializeConversionCache(registeredNodes), isEditable);\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n  return editor;\n}\nclass LexicalEditor {\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {\n    this._parentEditor = parentEditor;\n    // The root element associated with this editor\n    this._rootElement = null;\n    // The current editor state\n    this._editorState = editorState;\n    // Handling of drafts and updates\n    this._pendingEditorState = null;\n    // Used to help co-ordinate selection and events\n    this._compositionKey = null;\n    this._deferred = [];\n    // Used during reconciliation\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false;\n    // Listeners\n    this._listeners = {\n      decorator: new Set(),\n      editable: new Set(),\n      mutation: new Map(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    };\n    // Commands\n    this._commands = new Map();\n    // Editor configuration for theme/context.\n    this._config = config;\n    // Mapping of types to their nodes\n    this._nodes = nodes;\n    // React node decorators for portals\n    this._decorators = {};\n    this._pendingDecorators = null;\n    // Used to optimize reconciliation\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set();\n    // Handling of DOM mutations\n    this._observer = null;\n    // Used for identifying owning editors\n    this._key = createUID();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    // We don't actually make use of the `editable` argument above.\n    // Doing so, causes e2e tests around the lock to fail.\n    this._editable = true;\n    this._headless = parentEditor !== null && parentEditor._headless;\n    this._window = null;\n    this._blockCursorElement = null;\n  }\n  isComposing() {\n    return this._compositionKey != null;\n  }\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  registerEditableListener(listener) {\n    const listenerSetOrMap = this._listeners.editable;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        throw Error(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n    const commandsMap = this._commands;\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n    const listenersInPriorityOrder = commandsMap.get(command);\n    if (listenersInPriorityOrder === undefined) {\n      {\n        throw Error(`registerCommand: Command ${String(command)} not found in command map`);\n      }\n    }\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n  registerMutationListener(klass, listener) {\n    const registeredNode = this._nodes.get(klass.getType());\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    const mutations = this._listeners.mutation;\n    mutations.set(listener, klass);\n    return () => {\n      mutations.delete(listener);\n    };\n  }\n  registerNodeTransformToKlass(klass, listener) {\n    const type = klass.getType();\n    const registeredNode = this._nodes.get(type);\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    const transforms = registeredNode.transforms;\n    transforms.add(listener);\n    return registeredNode;\n  }\n  registerNodeTransform(klass, listener) {\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\n    const registeredNodes = [registeredNode];\n    const replaceWithKlass = registeredNode.replaceWithKlass;\n    if (replaceWithKlass != null) {\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);\n      registeredNodes.push(registeredReplaceWithNode);\n    }\n    markAllNodesAsDirty(this, klass.getType());\n    return () => {\n      registeredNodes.forEach(node => node.transforms.delete(listener));\n    };\n  }\n  hasNodes(nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const klass = nodes[i];\n      const type = klass.getType();\n      if (!this._nodes.has(type)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n  getDecorators() {\n    return this._decorators;\n  }\n  getRootElement() {\n    return this._rootElement;\n  }\n  getKey() {\n    return this._key;\n  }\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n    if (nextRootElement !== prevRootElement) {\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n        if (classNames != null) {\n          prevRootElement.classList.remove(...classNames);\n        }\n      }\n      if (nextRootElement !== null) {\n        const windowObj = getDefaultView(nextRootElement);\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._window = windowObj;\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n        this._updateTags.add('history-merge');\n        commitPendingUpdates(this);\n\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n        if (classNames != null) {\n          nextRootElement.classList.add(...classNames);\n        }\n      } else {\n        this._window = null;\n      }\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n  getEditorState() {\n    return this._editorState;\n  }\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n    flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n      commitPendingUpdates(this);\n    }\n    this._pendingEditorState = editorState;\n    this._dirtyType = FULL_RECONCILE;\n    this._dirtyElements.set('root', false);\n    this._compositionKey = null;\n    if (tag != null) {\n      tags.add(tag);\n    }\n    commitPendingUpdates(this);\n  }\n  parseEditorState(maybeStringifiedEditorState, updateFn) {\n    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n    return parseEditorState(serializedEditorState, this, updateFn);\n  }\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n  focus(callbackFn, options = {}) {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditor(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          selection.dirty = true;\n        } else if (root.getChildrenSize() !== 0) {\n          if (options.defaultSelection === 'rootStart') {\n            root.selectStart();\n          } else {\n            root.selectEnd();\n          }\n        }\n      }, {\n        onUpdate: () => {\n          rootElement.removeAttribute('autocapitalize');\n          if (callbackFn) {\n            callbackFn();\n          }\n        }\n      });\n      // In the case where onUpdate doesn't fire (due to the focus update not\n      // occuring).\n      if (this._pendingEditorState === null) {\n        rootElement.removeAttribute('autocapitalize');\n      }\n    }\n  }\n  blur() {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n    const domSelection = getDOMSelection(this._window);\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n  isEditable() {\n    return this._editable;\n  }\n  setEditable(editable) {\n    if (this._editable !== editable) {\n      this._editable = editable;\n      triggerListeners('editable', this, true, editable);\n    }\n  }\n  toJSON() {\n    return {\n      editorState: this._editorState.toJSON()\n    };\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass DEPRECATED_GridCellNode extends ElementNode {\n  /** @internal */\n\n  constructor(colSpan, key) {\n    super(key);\n    this.__colSpan = colSpan;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      colSpan: this.__colSpan\n    };\n  }\n}\nfunction DEPRECATED_$isGridCellNode(node) {\n  return node instanceof DEPRECATED_GridCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass DEPRECATED_GridNode extends ElementNode {}\nfunction DEPRECATED_$isGridNode(node) {\n  return node instanceof DEPRECATED_GridNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass DEPRECATED_GridRowNode extends ElementNode {}\nfunction DEPRECATED_$isGridRowNode(node) {\n  return node instanceof DEPRECATED_GridRowNode;\n}\n\nexports.$addUpdateTag = $addUpdateTag;\nexports.$applyNodeReplacement = $applyNodeReplacement;\nexports.$copyNode = $copyNode;\nexports.$createLineBreakNode = $createLineBreakNode;\nexports.$createNodeSelection = $createNodeSelection;\nexports.$createParagraphNode = $createParagraphNode;\nexports.$createRangeSelection = $createRangeSelection;\nexports.$createTextNode = $createTextNode;\nexports.$getAdjacentNode = $getAdjacentNode;\nexports.$getNearestNodeFromDOMNode = $getNearestNodeFromDOMNode;\nexports.$getNearestRootOrShadowRoot = $getNearestRootOrShadowRoot;\nexports.$getNodeByKey = $getNodeByKey;\nexports.$getPreviousSelection = $getPreviousSelection;\nexports.$getRoot = $getRoot;\nexports.$getSelection = $getSelection;\nexports.$getTextContent = $getTextContent;\nexports.$hasAncestor = $hasAncestor;\nexports.$insertNodes = $insertNodes;\nexports.$isDecoratorNode = $isDecoratorNode;\nexports.$isElementNode = $isElementNode;\nexports.$isInlineElementOrDecoratorNode = $isInlineElementOrDecoratorNode;\nexports.$isLeafNode = $isLeafNode;\nexports.$isLineBreakNode = $isLineBreakNode;\nexports.$isNodeSelection = $isNodeSelection;\nexports.$isParagraphNode = $isParagraphNode;\nexports.$isRangeSelection = $isRangeSelection;\nexports.$isRootNode = $isRootNode;\nexports.$isRootOrShadowRoot = $isRootOrShadowRoot;\nexports.$isTextNode = $isTextNode;\nexports.$nodesOfType = $nodesOfType;\nexports.$normalizeSelection__EXPERIMENTAL = $normalizeSelection;\nexports.$parseSerializedNode = $parseSerializedNode;\nexports.$setCompositionKey = $setCompositionKey;\nexports.$setSelection = $setSelection;\nexports.$splitNode = $splitNode;\nexports.BLUR_COMMAND = BLUR_COMMAND;\nexports.CAN_REDO_COMMAND = CAN_REDO_COMMAND;\nexports.CAN_UNDO_COMMAND = CAN_UNDO_COMMAND;\nexports.CLEAR_EDITOR_COMMAND = CLEAR_EDITOR_COMMAND;\nexports.CLEAR_HISTORY_COMMAND = CLEAR_HISTORY_COMMAND;\nexports.CLICK_COMMAND = CLICK_COMMAND;\nexports.COMMAND_PRIORITY_CRITICAL = COMMAND_PRIORITY_CRITICAL;\nexports.COMMAND_PRIORITY_EDITOR = COMMAND_PRIORITY_EDITOR;\nexports.COMMAND_PRIORITY_HIGH = COMMAND_PRIORITY_HIGH;\nexports.COMMAND_PRIORITY_LOW = COMMAND_PRIORITY_LOW;\nexports.COMMAND_PRIORITY_NORMAL = COMMAND_PRIORITY_NORMAL;\nexports.CONTROLLED_TEXT_INSERTION_COMMAND = CONTROLLED_TEXT_INSERTION_COMMAND;\nexports.COPY_COMMAND = COPY_COMMAND;\nexports.CUT_COMMAND = CUT_COMMAND;\nexports.DELETE_CHARACTER_COMMAND = DELETE_CHARACTER_COMMAND;\nexports.DELETE_LINE_COMMAND = DELETE_LINE_COMMAND;\nexports.DELETE_WORD_COMMAND = DELETE_WORD_COMMAND;\nexports.DEPRECATED_$createGridSelection = DEPRECATED_$createGridSelection;\nexports.DEPRECATED_$isGridCellNode = DEPRECATED_$isGridCellNode;\nexports.DEPRECATED_$isGridNode = DEPRECATED_$isGridNode;\nexports.DEPRECATED_$isGridRowNode = DEPRECATED_$isGridRowNode;\nexports.DEPRECATED_$isGridSelection = DEPRECATED_$isGridSelection;\nexports.DEPRECATED_GridCellNode = DEPRECATED_GridCellNode;\nexports.DEPRECATED_GridNode = DEPRECATED_GridNode;\nexports.DEPRECATED_GridRowNode = DEPRECATED_GridRowNode;\nexports.DRAGEND_COMMAND = DRAGEND_COMMAND;\nexports.DRAGOVER_COMMAND = DRAGOVER_COMMAND;\nexports.DRAGSTART_COMMAND = DRAGSTART_COMMAND;\nexports.DROP_COMMAND = DROP_COMMAND;\nexports.DecoratorNode = DecoratorNode;\nexports.ElementNode = ElementNode;\nexports.FOCUS_COMMAND = FOCUS_COMMAND;\nexports.FORMAT_ELEMENT_COMMAND = FORMAT_ELEMENT_COMMAND;\nexports.FORMAT_TEXT_COMMAND = FORMAT_TEXT_COMMAND;\nexports.INDENT_CONTENT_COMMAND = INDENT_CONTENT_COMMAND;\nexports.INSERT_LINE_BREAK_COMMAND = INSERT_LINE_BREAK_COMMAND;\nexports.INSERT_PARAGRAPH_COMMAND = INSERT_PARAGRAPH_COMMAND;\nexports.KEY_ARROW_DOWN_COMMAND = KEY_ARROW_DOWN_COMMAND;\nexports.KEY_ARROW_LEFT_COMMAND = KEY_ARROW_LEFT_COMMAND;\nexports.KEY_ARROW_RIGHT_COMMAND = KEY_ARROW_RIGHT_COMMAND;\nexports.KEY_ARROW_UP_COMMAND = KEY_ARROW_UP_COMMAND;\nexports.KEY_BACKSPACE_COMMAND = KEY_BACKSPACE_COMMAND;\nexports.KEY_DELETE_COMMAND = KEY_DELETE_COMMAND;\nexports.KEY_DOWN_COMMAND = KEY_DOWN_COMMAND;\nexports.KEY_ENTER_COMMAND = KEY_ENTER_COMMAND;\nexports.KEY_ESCAPE_COMMAND = KEY_ESCAPE_COMMAND;\nexports.KEY_MODIFIER_COMMAND = KEY_MODIFIER_COMMAND;\nexports.KEY_SPACE_COMMAND = KEY_SPACE_COMMAND;\nexports.KEY_TAB_COMMAND = KEY_TAB_COMMAND;\nexports.LineBreakNode = LineBreakNode;\nexports.MOVE_TO_END = MOVE_TO_END;\nexports.MOVE_TO_START = MOVE_TO_START;\nexports.OUTDENT_CONTENT_COMMAND = OUTDENT_CONTENT_COMMAND;\nexports.PASTE_COMMAND = PASTE_COMMAND;\nexports.ParagraphNode = ParagraphNode;\nexports.REDO_COMMAND = REDO_COMMAND;\nexports.REMOVE_TEXT_COMMAND = REMOVE_TEXT_COMMAND;\nexports.RootNode = RootNode;\nexports.SELECTION_CHANGE_COMMAND = SELECTION_CHANGE_COMMAND;\nexports.TextNode = TextNode;\nexports.UNDO_COMMAND = UNDO_COMMAND;\nexports.createCommand = createCommand;\nexports.createEditor = createEditor;\nexports.isSelectionWithinEditor = isSelectionWithinEditor;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst Lexical = process.env.NODE_ENV === 'development' ? require('./Lexical.dev.js') : require('./Lexical.prod.js')\nmodule.exports = Lexical;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar react = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst LexicalComposerContext = /*#__PURE__*/react.createContext(null);\nfunction createLexicalComposerContext(parent, theme) {\n  let parentContext = null;\n  if (parent != null) {\n    parentContext = parent[1];\n  }\n  function getTheme() {\n    if (theme != null) {\n      return theme;\n    }\n    return parentContext != null ? parentContext.getTheme() : null;\n  }\n  return {\n    getTheme\n  };\n}\nfunction useLexicalComposerContext() {\n  const composerContext = react.useContext(LexicalComposerContext);\n  if (composerContext == null) {\n    {\n      throw Error(`LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext`);\n    }\n  }\n  return composerContext;\n}\n\nexports.LexicalComposerContext = LexicalComposerContext;\nexports.createLexicalComposerContext = createLexicalComposerContext;\nexports.useLexicalComposerContext = useLexicalComposerContext;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalComposerContext = process.env.NODE_ENV === 'development' ? require('./LexicalComposerContext.dev.js') : require('./LexicalComposerContext.prod.js')\nmodule.exports = LexicalComposerContext;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar lexical = require('lexical');\nvar React = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst HISTORY_MERGE_OPTIONS = {\n  tag: 'history-merge'\n};\nfunction LexicalComposer({\n  initialConfig,\n  children\n}) {\n  const composerContext = React.useMemo(() => {\n    const {\n      theme,\n      namespace,\n      editor__DEPRECATED: initialEditor,\n      nodes,\n      onError,\n      editorState: initialEditorState\n    } = initialConfig;\n    const context = LexicalComposerContext.createLexicalComposerContext(null, theme);\n    let editor = initialEditor || null;\n    if (editor === null) {\n      const newEditor = lexical.createEditor({\n        editable: false,\n        namespace,\n        nodes,\n        onError: error => onError(error, newEditor),\n        theme\n      });\n      initializeEditor(newEditor, initialEditorState);\n      editor = newEditor;\n    }\n    return [editor, context];\n  },\n  // We only do this for init\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useLayoutEffect(() => {\n    const isEditable = initialConfig.editable;\n    const [editor] = composerContext;\n    editor.setEditable(isEditable !== undefined ? isEditable : true);\n\n    // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/React.createElement(LexicalComposerContext.LexicalComposerContext.Provider, {\n    value: composerContext\n  }, children);\n}\nfunction initializeEditor(editor, initialEditorState) {\n  if (initialEditorState === null) {\n    return;\n  } else if (initialEditorState === undefined) {\n    editor.update(() => {\n      const root = lexical.$getRoot();\n      if (root.isEmpty()) {\n        const paragraph = lexical.$createParagraphNode();\n        root.append(paragraph);\n        const activeElement = CAN_USE_DOM ? document.activeElement : null;\n        if (lexical.$getSelection() !== null || activeElement !== null && activeElement === editor.getRootElement()) {\n          paragraph.select();\n        }\n      }\n    }, HISTORY_MERGE_OPTIONS);\n  } else if (initialEditorState !== null) {\n    switch (typeof initialEditorState) {\n      case 'string':\n        {\n          const parsedEditorState = editor.parseEditorState(initialEditorState);\n          editor.setEditorState(parsedEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'object':\n        {\n          editor.setEditorState(initialEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'function':\n        {\n          editor.update(() => {\n            const root = lexical.$getRoot();\n            if (root.isEmpty()) {\n              initialEditorState(editor);\n            }\n          }, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n    }\n  }\n}\n\nexports.LexicalComposer = LexicalComposer;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalComposer = process.env.NODE_ENV === 'development' ? require('./LexicalComposer.dev.js') : require('./LexicalComposer.prod.js')\nmodule.exports = LexicalComposer;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar React = require('react');\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\n\nvar changedArray = function changedArray(a, b) {\n  if (a === void 0) {\n    a = [];\n  }\n\n  if (b === void 0) {\n    b = [];\n  }\n\n  return a.length !== b.length || a.some(function (item, index) {\n    return !Object.is(item, b[index]);\n  });\n};\n\nvar initialState = {\n  error: null\n};\n\nvar ErrorBoundary = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(ErrorBoundary, _React$Component);\n\n  function ErrorBoundary() {\n    var _this;\n\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;\n    _this.state = initialState;\n\n    _this.resetErrorBoundary = function () {\n      var _this$props;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);\n\n      _this.reset();\n    };\n\n    return _this;\n  }\n\n  ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {\n    return {\n      error: error\n    };\n  };\n\n  var _proto = ErrorBoundary.prototype;\n\n  _proto.reset = function reset() {\n    this.setState(initialState);\n  };\n\n  _proto.componentDidCatch = function componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n\n    (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    var error = this.state.error;\n    var resetKeys = this.props.resetKeys; // There's an edge case where if the thing that triggered the error\n    // happens to *also* be in the resetKeys array, we'd end up resetting\n    // the error boundary immediately. This would likely trigger a second\n    // error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call\n    // of cDU after the error is set\n\n    if (error !== null && prevState.error !== null && changedArray(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onResetKe, _this$props3;\n\n      (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);\n      this.reset();\n    }\n  };\n\n  _proto.render = function render() {\n    var error = this.state.error;\n    var _this$props4 = this.props,\n        fallbackRender = _this$props4.fallbackRender,\n        FallbackComponent = _this$props4.FallbackComponent,\n        fallback = _this$props4.fallback;\n\n    if (error !== null) {\n      var _props = {\n        error: error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n\n      if ( /*#__PURE__*/React.isValidElement(fallback)) {\n        return fallback;\n      } else if (typeof fallbackRender === 'function') {\n        return fallbackRender(_props);\n      } else if (FallbackComponent) {\n        return /*#__PURE__*/React.createElement(FallbackComponent, _props);\n      } else {\n        throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');\n      }\n    }\n\n    return this.props.children;\n  };\n\n  return ErrorBoundary;\n}(React.Component);\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction LexicalErrorBoundary({\n  children,\n  onError\n}) {\n  return /*#__PURE__*/React.createElement(ErrorBoundary, {\n    fallback: /*#__PURE__*/React.createElement(\"div\", {\n      style: {\n        border: '1px solid #f00',\n        color: '#f00',\n        padding: '8px'\n      }\n    }, \"An error was thrown.\"),\n    onError: onError\n  }, children);\n}\n\nmodule.exports = LexicalErrorBoundary;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalErrorBoundary = process.env.NODE_ENV === 'development' ? require('./LexicalErrorBoundary.dev.js') : require('./LexicalErrorBoundary.prod.js')\nmodule.exports = LexicalErrorBoundary;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar lexical = require('lexical');\nvar react = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction isNodeSelected(editor, key) {\n  return editor.getEditorState().read(() => {\n    const node = lexical.$getNodeByKey(key);\n    if (node === null) {\n      return false;\n    }\n    return node.isSelected();\n  });\n}\nfunction useLexicalNodeSelection(key) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const [isSelected, setIsSelected] = react.useState(() => isNodeSelected(editor, key));\n  react.useEffect(() => {\n    let isMounted = true;\n    const unregister = editor.registerUpdateListener(() => {\n      if (isMounted) {\n        setIsSelected(isNodeSelected(editor, key));\n      }\n    });\n    return () => {\n      isMounted = false;\n      unregister();\n    };\n  }, [editor, key]);\n  const setSelected = react.useCallback(selected => {\n    editor.update(() => {\n      let selection = lexical.$getSelection();\n      if (!lexical.$isNodeSelection(selection)) {\n        selection = lexical.$createNodeSelection();\n        lexical.$setSelection(selection);\n      }\n      if (selected) {\n        selection.add(key);\n      } else {\n        selection.delete(key);\n      }\n    });\n  }, [editor, key]);\n  const clearSelected = react.useCallback(() => {\n    editor.update(() => {\n      const selection = lexical.$getSelection();\n      if (lexical.$isNodeSelection(selection)) {\n        selection.clear();\n      }\n    });\n  }, [editor]);\n  return [isSelected, setSelected, clearSelected];\n}\n\nexports.useLexicalNodeSelection = useLexicalNodeSelection;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst useLexicalNodeSelection = process.env.NODE_ENV === 'development' ? require('./useLexicalNodeSelection.dev.js') : require('./useLexicalNodeSelection.prod.js')\nmodule.exports = useLexicalNodeSelection;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if (lexical.$isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if (lexical.$isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude a rect that is the exact same as the last rect. getClientRects() can return\n    // the same rect twice for some elements. A more sophisticated thing to do here is to\n    // merge all the rects together into a set of rects that don't overlap, so we don't\n    // generate backgrounds that are too dark.\n    const isDuplicateRect = prevRect && prevRect.top === selectionRect.top && prevRect.left === selectionRect.left && prevRect.width === selectionRect.width && prevRect.height === selectionRect.height;\n\n    // Exclude selections that span the entire element\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isDuplicateRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      styleObject[key.trim()] = value.trim();\n    }\n  }\n  return styleObject;\n}\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  return value;\n}\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $updateElementNodeProperties(target, source) {\n  target.__first = source.__first;\n  target.__last = source.__last;\n  target.__size = source.__size;\n  target.__format = source.__format;\n  target.__indent = source.__indent;\n  target.__dir = source.__dir;\n  return target;\n}\nfunction $updateTextNodeProperties(target, source) {\n  target.__format = source.__format;\n  target.__style = source.__style;\n  target.__mode = source.__mode;\n  target.__detail = source.__detail;\n  return target;\n}\nfunction $cloneWithProperties(node) {\n  const latest = node.getLatest();\n  const constructor = latest.constructor;\n  // @ts-expect-error\n  const clone = constructor.clone(latest);\n  clone.__parent = latest.__parent;\n  clone.__next = latest.__next;\n  clone.__prev = latest.__prev;\n  if (lexical.$isElementNode(latest) && lexical.$isElementNode(clone)) {\n    return $updateElementNodeProperties(clone, latest);\n  }\n  if (lexical.$isTextNode(latest) && lexical.$isTextNode(clone)) {\n    return $updateTextNodeProperties(clone, latest);\n  }\n  return clone;\n}\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  if (textNode.isSelected() && !textNode.isSegmented() && !textNode.isToken() && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const isBackward = selection.isBackward();\n      const [anchorOffset, focusOffset] = selection.getCharacterOffsets();\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n  return textNode;\n}\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  return point.offset === point.getNode().getChildrenSize();\n}\nfunction trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if (lexical.$isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        if (lexical.$isElementNode(parentSibling)) {\n          nextNode = parentSibling.getLastDescendant();\n        } else {\n          nextNode = parentSibling;\n        }\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && lexical.$isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const textNodeSize = text.length;\n    const offset = textNodeSize - remaining;\n    const slicedText = text.slice(0, offset);\n    if (!lexical.$isTextNode(currentNode) || remaining >= textNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0) {\n        parent.remove();\n      }\n      remaining -= textNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = lexical.$getNodeByKey(key);\n        if (lexical.$isTextNode(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = lexical.$getPreviousSelection();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = lexical.$createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if (lexical.$isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaniing number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = textNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = lexical.$createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\nfunction $patchStyle(target, patch) {\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  } || {});\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  target.setStyle(newCSSText);\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n  if (selection.isCollapsed()) {\n    $patchStyle(selection, patch);\n    return;\n  }\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  const isBefore = anchor.isBefore(focus);\n  let startOffset = isBefore ? anchorOffset : focusOffset;\n  let endOffset = isBefore ? focusOffset : anchorOffset;\n  const startType = isBefore ? anchor.type : focus.type;\n  const endType = isBefore ? focus.type : anchor.type;\n  const endKey = isBefore ? focus.key : anchor.key;\n\n  // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n  if (lexical.$isTextNode(firstNode) && startOffset === firstNodeTextLength) {\n    const nextSibling = firstNode.getNextSibling();\n    if (lexical.$isTextNode(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  }\n\n  // This is the case where we only selected a single node\n  if (firstNode.is(lastNode)) {\n    if (lexical.$isTextNode(firstNode)) {\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset;\n\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n\n      // The entire node is selected, so just format it\n      if (startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n  } else {\n    if (lexical.$isTextNode(firstNode) && startOffset < firstNode.getTextContentSize()) {\n      if (startOffset !== 0) {\n        // the entire first node isn't selected, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n      }\n      $patchStyle(firstNode, patch);\n    }\n    if (lexical.$isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n\n      // The last node might not actually be the end node\n      //\n      // If not, assume the last node is fully-selected unless the end offset is\n      // zero.\n      if (lastNode.__key !== endKey && endOffset !== 0) {\n        endOffset = lastNodeTextLength;\n      }\n\n      // if the entire last node isn't selected, split it\n      if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      if (endOffset !== 0) {\n        $patchStyle(lastNode, patch);\n      }\n    }\n\n    // style all the text nodes in between\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n      if (lexical.$isTextNode(selectedNode) && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchStyle(selectedNode, patch);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Converts all nodes in the selection that are of one block type to another specified by parameter\n *\n * @param selection\n * @param createElement\n * @returns\n */\nfunction $setBlocksType_experimental(selection, createElement) {\n  if (selection.anchor.key === 'root') {\n    const element = createElement();\n    const root = lexical.$getRoot();\n    const firstChild = root.getFirstChild();\n    if (firstChild) firstChild.replace(element, true);else root.append(element);\n    return;\n  }\n  const nodes = selection.getNodes();\n  if (selection.anchor.type === 'text') {\n    let firstBlock = selection.anchor.getNode().getParent();\n    firstBlock = firstBlock.isInline() ? firstBlock.getParent() : firstBlock;\n    if (nodes.indexOf(firstBlock) === -1) nodes.push(firstBlock);\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!isBlock(node)) continue;\n    const targetElement = createElement();\n    targetElement.setFormat(node.getFormatType());\n    targetElement.setIndent(node.getIndent());\n    node.replace(targetElement, true);\n  }\n}\nfunction isBlock(node) {\n  return lexical.$isElementNode(node) && !lexical.$isRootOrShadowRoot(node) && !node.isInline();\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !lexical.$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  const anchor = selection.anchor;\n  if (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if (lexical.$isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && lexical.$hasAncestor(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if (lexical.$isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && lexical.$isLeafNode(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if (lexical.$isElementNode(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if (lexical.$isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if (lexical.$isElementNode(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = lexical.$getPreviousSelection();\n  if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    lexical.$setSelection(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = lexical.$getAdjacentNode(selection.focus, isBackward);\n  return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\n}\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n  if (lexical.$isTextNode(firstNode)) {\n    firstType = 'text';\n  } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n  if (lexical.$isTextNode(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n  }\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if (selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if (lexical.$isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\n\nexports.$addNodeStyle = $addNodeStyle;\nexports.$cloneWithProperties = $cloneWithProperties;\nexports.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;\nexports.$isAtNodeEnd = $isAtNodeEnd;\nexports.$isParentElementRTL = $isParentElementRTL;\nexports.$moveCaretSelection = $moveCaretSelection;\nexports.$moveCharacter = $moveCharacter;\nexports.$patchStyleText = $patchStyleText;\nexports.$selectAll = $selectAll;\nexports.$setBlocksType_experimental = $setBlocksType_experimental;\nexports.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;\nexports.$sliceSelectedTextNodeContent = $sliceSelectedTextNodeContent;\nexports.$wrapNodes = $wrapNodes;\nexports.createDOMRange = createDOMRange;\nexports.createRectsFromDOMRange = createRectsFromDOMRange;\nexports.getStyleObjectFromCSS = getStyleObjectFromCSS;\nexports.trimTextContentFromAnchor = trimTextContentFromAnchor;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalSelection = process.env.NODE_ENV === 'development' ? require('./LexicalSelection.dev.js') : require('./LexicalSelection.prod.js')\nmodule.exports = LexicalSelection;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar lexical = require('lexical');\n\n/** @module @lexical/utils */\nfunction addClassNamesToElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      const classesToAdd = className.split(' ').filter(n => n !== '');\n      element.classList.add(...classesToAdd);\n    }\n  });\n}\nfunction removeClassNamesFromElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      element.classList.remove(...className.split(' '));\n    }\n  });\n}\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\n *   src: file.result,\n * }));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || lexical.$getRoot()).getLatest();\n  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\n  let node = start;\n  let depth = $getDepth(node);\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n  return nodes;\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());\n  if (!lexical.$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n  while (curr !== lexical.$getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n}\nfunction mergeRegister(...func) {\n  return () => {\n    func.forEach(f => f());\n  };\n}\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, elementNodeTransform);\n}\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    const clone = selection.$cloneWithProperties(node);\n    if (lexical.$isTextNode(clone)) {\n      clone.__text = node.__text;\n    }\n    nodeMap.set(key, clone);\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection$1 = editorState._selection;\n  lexical.$setSelection(selection$1 === null ? null : selection$1.clone());\n}\nfunction $insertNodeToNearestRoot(node) {\n  const selection = lexical.$getSelection();\n  if (lexical.$isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if (lexical.$isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if (lexical.$isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (lexical.$isNodeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = lexical.$getRoot();\n      root.append(node);\n    }\n    const paragraphNode = lexical.$createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\nfunction isHTMLElement(x) {\n  // @ts-ignore-next-line - strict check on nodeType here should filter out non-Element EventTarget implementors\n  return x.nodeType === 1;\n}\n\nexports.$splitNode = lexical.$splitNode;\nexports.$dfs = $dfs;\nexports.$findMatchingParent = $findMatchingParent;\nexports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\nexports.$getNearestNodeOfType = $getNearestNodeOfType;\nexports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;\nexports.$restoreEditorState = $restoreEditorState;\nexports.$wrapNodeInElement = $wrapNodeInElement;\nexports.addClassNamesToElement = addClassNamesToElement;\nexports.isHTMLAnchorElement = isHTMLAnchorElement;\nexports.isHTMLElement = isHTMLElement;\nexports.isMimeType = isMimeType;\nexports.mediaFileReader = mediaFileReader;\nexports.mergeRegister = mergeRegister;\nexports.registerNestedElementResolver = registerNestedElementResolver;\nexports.removeClassNamesFromElement = removeClassNamesFromElement;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalUtils = process.env.NODE_ENV === 'development' ? require('./LexicalUtils.dev.js') : require('./LexicalUtils.prod.js')\nmodule.exports = LexicalUtils;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar useLexicalNodeSelection = require('@lexical/react/useLexicalNodeSelection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\nvar React = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst INSERT_HORIZONTAL_RULE_COMMAND = lexical.createCommand('INSERT_HORIZONTAL_RULE_COMMAND');\nfunction HorizontalRuleComponent({\n  nodeKey\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const [isSelected, setSelected, clearSelection] = useLexicalNodeSelection.useLexicalNodeSelection(nodeKey);\n  const onDelete = React.useCallback(payload => {\n    if (isSelected && lexical.$isNodeSelection(lexical.$getSelection())) {\n      const event = payload;\n      event.preventDefault();\n      const node = lexical.$getNodeByKey(nodeKey);\n      if ($isHorizontalRuleNode(node)) {\n        node.remove();\n      }\n      setSelected(false);\n    }\n    return false;\n  }, [isSelected, nodeKey, setSelected]);\n  React.useEffect(() => {\n    return utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, event => {\n      const hrElem = editor.getElementByKey(nodeKey);\n      if (event.target === hrElem) {\n        if (!event.shiftKey) {\n          clearSelection();\n        }\n        setSelected(!isSelected);\n        return true;\n      }\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_DELETE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW));\n  }, [clearSelection, editor, isSelected, nodeKey, onDelete, setSelected]);\n  React.useEffect(() => {\n    const hrElem = editor.getElementByKey(nodeKey);\n    if (hrElem !== null) {\n      hrElem.className = isSelected ? 'selected' : '';\n    }\n  }, [editor, isSelected, nodeKey]);\n  return null;\n}\nclass HorizontalRuleNode extends lexical.DecoratorNode {\n  static getType() {\n    return 'horizontalrule';\n  }\n  static clone(node) {\n    return new HorizontalRuleNode(node.__key);\n  }\n  static importJSON(serializedNode) {\n    return $createHorizontalRuleNode();\n  }\n  static importDOM() {\n    return {\n      hr: () => ({\n        conversion: convertHorizontalRuleElement,\n        priority: 0\n      })\n    };\n  }\n  exportJSON() {\n    return {\n      type: 'horizontalrule',\n      version: 1\n    };\n  }\n  exportDOM() {\n    return {\n      element: document.createElement('hr')\n    };\n  }\n  createDOM() {\n    return document.createElement('hr');\n  }\n  getTextContent() {\n    return '\\n';\n  }\n  isInline() {\n    return false;\n  }\n  updateDOM() {\n    return false;\n  }\n  decorate() {\n    return /*#__PURE__*/React.createElement(HorizontalRuleComponent, {\n      nodeKey: this.__key\n    });\n  }\n}\nfunction convertHorizontalRuleElement() {\n  return {\n    node: $createHorizontalRuleNode()\n  };\n}\nfunction $createHorizontalRuleNode() {\n  return lexical.$applyNodeReplacement(new HorizontalRuleNode());\n}\nfunction $isHorizontalRuleNode(node) {\n  return node instanceof HorizontalRuleNode;\n}\n\nexports.$createHorizontalRuleNode = $createHorizontalRuleNode;\nexports.$isHorizontalRuleNode = $isHorizontalRuleNode;\nexports.HorizontalRuleNode = HorizontalRuleNode;\nexports.INSERT_HORIZONTAL_RULE_COMMAND = INSERT_HORIZONTAL_RULE_COMMAND;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalHorizontalRuleNode = process.env.NODE_ENV === 'development' ? require('./LexicalHorizontalRuleNode.dev.js') : require('./LexicalHorizontalRuleNode.prod.js')\nmodule.exports = LexicalHorizontalRuleNode;", "\n/* **********************************************\n     Begin prism-core.js\n********************************************** */\n\n/// <reference lib=\"WebWorker\"/>\n\nvar _self = (typeof window !== 'undefined')\n\t? window   // if in browser\n\t: (\n\t\t(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\n\t\t\t? self // if in worker\n\t\t\t: {}   // if in node js\n\t);\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n *\n * @license MIT <https://opensource.org/licenses/MIT>\n * @author Lea Verou <https://lea.verou.me>\n * @namespace\n * @public\n */\nvar Prism = (function (_self) {\n\n\t// Private helper vars\n\tvar lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\n\tvar uniqueId = 0;\n\n\t// The grammar object for plaintext\n\tvar plainTextGrammar = {};\n\n\n\tvar _ = {\n\t\t/**\n\t\t * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the\n\t\t * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load\n\t\t * additional languages or plugins yourself.\n\t\t *\n\t\t * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.\n\t\t *\n\t\t * You obviously have to change this value before the automatic highlighting started. To do this, you can add an\n\t\t * empty Prism object into the global scope before loading the Prism script like this:\n\t\t *\n\t\t * ```js\n\t\t * window.Prism = window.Prism || {};\n\t\t * Prism.manual = true;\n\t\t * // add a new <script> to load Prism's script\n\t\t * ```\n\t\t *\n\t\t * @default false\n\t\t * @type {boolean}\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tmanual: _self.Prism && _self.Prism.manual,\n\t\t/**\n\t\t * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses\n\t\t * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your\n\t\t * own worker, you don't want it to do this.\n\t\t *\n\t\t * By setting this value to `true`, Prism will not add its own listeners to the worker.\n\t\t *\n\t\t * You obviously have to change this value before Prism executes. To do this, you can add an\n\t\t * empty Prism object into the global scope before loading the Prism script like this:\n\t\t *\n\t\t * ```js\n\t\t * window.Prism = window.Prism || {};\n\t\t * Prism.disableWorkerMessageHandler = true;\n\t\t * // Load Prism's script\n\t\t * ```\n\t\t *\n\t\t * @default false\n\t\t * @type {boolean}\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tdisableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,\n\n\t\t/**\n\t\t * A namespace for utility methods.\n\t\t *\n\t\t * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n\t\t * change or disappear at any time.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t */\n\t\tutil: {\n\t\t\tencode: function encode(tokens) {\n\t\t\t\tif (tokens instanceof Token) {\n\t\t\t\t\treturn new Token(tokens.type, encode(tokens.content), tokens.alias);\n\t\t\t\t} else if (Array.isArray(tokens)) {\n\t\t\t\t\treturn tokens.map(encode);\n\t\t\t\t} else {\n\t\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the name of the type of the given value.\n\t\t\t *\n\t\t\t * @param {any} o\n\t\t\t * @returns {string}\n\t\t\t * @example\n\t\t\t * type(null)      === 'Null'\n\t\t\t * type(undefined) === 'Undefined'\n\t\t\t * type(123)       === 'Number'\n\t\t\t * type('foo')     === 'String'\n\t\t\t * type(true)      === 'Boolean'\n\t\t\t * type([1, 2])    === 'Array'\n\t\t\t * type({})        === 'Object'\n\t\t\t * type(String)    === 'Function'\n\t\t\t * type(/abc+/)    === 'RegExp'\n\t\t\t */\n\t\t\ttype: function (o) {\n\t\t\t\treturn Object.prototype.toString.call(o).slice(8, -1);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns a unique number for the given object. Later calls will still return the same number.\n\t\t\t *\n\t\t\t * @param {Object} obj\n\t\t\t * @returns {number}\n\t\t\t */\n\t\t\tobjId: function (obj) {\n\t\t\t\tif (!obj['__id']) {\n\t\t\t\t\tObject.defineProperty(obj, '__id', { value: ++uniqueId });\n\t\t\t\t}\n\t\t\t\treturn obj['__id'];\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Creates a deep clone of the given object.\n\t\t\t *\n\t\t\t * The main intended use of this function is to clone language definitions.\n\t\t\t *\n\t\t\t * @param {T} o\n\t\t\t * @param {Record<number, any>} [visited]\n\t\t\t * @returns {T}\n\t\t\t * @template T\n\t\t\t */\n\t\t\tclone: function deepClone(o, visited) {\n\t\t\t\tvisited = visited || {};\n\n\t\t\t\tvar clone; var id;\n\t\t\t\tswitch (_.util.type(o)) {\n\t\t\t\t\tcase 'Object':\n\t\t\t\t\t\tid = _.util.objId(o);\n\t\t\t\t\t\tif (visited[id]) {\n\t\t\t\t\t\t\treturn visited[id];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclone = /** @type {Record<string, any>} */ ({});\n\t\t\t\t\t\tvisited[id] = clone;\n\n\t\t\t\t\t\tfor (var key in o) {\n\t\t\t\t\t\t\tif (o.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tclone[key] = deepClone(o[key], visited);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn /** @type {any} */ (clone);\n\n\t\t\t\t\tcase 'Array':\n\t\t\t\t\t\tid = _.util.objId(o);\n\t\t\t\t\t\tif (visited[id]) {\n\t\t\t\t\t\t\treturn visited[id];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclone = [];\n\t\t\t\t\t\tvisited[id] = clone;\n\n\t\t\t\t\t\t(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {\n\t\t\t\t\t\t\tclone[i] = deepClone(v, visited);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn /** @type {any} */ (clone);\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn o;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.\n\t\t\t *\n\t\t\t * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @returns {string}\n\t\t\t */\n\t\t\tgetLanguage: function (element) {\n\t\t\t\twhile (element) {\n\t\t\t\t\tvar m = lang.exec(element.className);\n\t\t\t\t\tif (m) {\n\t\t\t\t\t\treturn m[1].toLowerCase();\n\t\t\t\t\t}\n\t\t\t\t\telement = element.parentElement;\n\t\t\t\t}\n\t\t\t\treturn 'none';\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Sets the Prism `language-xxxx` class of the given element.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} language\n\t\t\t * @returns {void}\n\t\t\t */\n\t\t\tsetLanguage: function (element, language) {\n\t\t\t\t// remove all `language-xxxx` classes\n\t\t\t\t// (this might leave behind a leading space)\n\t\t\t\telement.className = element.className.replace(RegExp(lang, 'gi'), '');\n\n\t\t\t\t// add the new `language-xxxx` class\n\t\t\t\t// (using `classList` will automatically clean up spaces for us)\n\t\t\t\telement.classList.add('language-' + language);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the script element that is currently executing.\n\t\t\t *\n\t\t\t * This does __not__ work for line script element.\n\t\t\t *\n\t\t\t * @returns {HTMLScriptElement | null}\n\t\t\t */\n\t\t\tcurrentScript: function () {\n\t\t\t\tif (typeof document === 'undefined') {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {\n\t\t\t\t\treturn /** @type {any} */ (document.currentScript);\n\t\t\t\t}\n\n\t\t\t\t// IE11 workaround\n\t\t\t\t// we'll get the src of the current script by parsing IE11's error stack trace\n\t\t\t\t// this will not work for inline scripts\n\n\t\t\t\ttry {\n\t\t\t\t\tthrow new Error();\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// Get file src url from stack. Specifically works with the format of stack traces in IE.\n\t\t\t\t\t// A stack will look like this:\n\t\t\t\t\t//\n\t\t\t\t\t// Error\n\t\t\t\t\t//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)\n\t\t\t\t\t//    at Global code (http://localhost/components/prism-core.js:606:1)\n\n\t\t\t\t\tvar src = (/at [^(\\r\\n]*\\((.*):[^:]+:[^:]+\\)$/i.exec(err.stack) || [])[1];\n\t\t\t\t\tif (src) {\n\t\t\t\t\t\tvar scripts = document.getElementsByTagName('script');\n\t\t\t\t\t\tfor (var i in scripts) {\n\t\t\t\t\t\t\tif (scripts[i].src == src) {\n\t\t\t\t\t\t\t\treturn scripts[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns whether a given class is active for `element`.\n\t\t\t *\n\t\t\t * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated\n\t\t\t * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the\n\t\t\t * given class is just the given class with a `no-` prefix.\n\t\t\t *\n\t\t\t * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is\n\t\t\t * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its\n\t\t\t * ancestors have the given class or the negated version of it, then the default activation will be returned.\n\t\t\t *\n\t\t\t * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated\n\t\t\t * version of it, the class is considered active.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} className\n\t\t\t * @param {boolean} [defaultActivation=false]\n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tisActive: function (element, className, defaultActivation) {\n\t\t\t\tvar no = 'no-' + className;\n\n\t\t\t\twhile (element) {\n\t\t\t\t\tvar classList = element.classList;\n\t\t\t\t\tif (classList.contains(className)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (classList.contains(no)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\telement = element.parentElement;\n\t\t\t\t}\n\t\t\t\treturn !!defaultActivation;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tlanguages: {\n\t\t\t/**\n\t\t\t * The grammar for plain, unformatted text.\n\t\t\t */\n\t\t\tplain: plainTextGrammar,\n\t\t\tplaintext: plainTextGrammar,\n\t\t\ttext: plainTextGrammar,\n\t\t\ttxt: plainTextGrammar,\n\n\t\t\t/**\n\t\t\t * Creates a deep copy of the language with the given id and appends the given tokens.\n\t\t\t *\n\t\t\t * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n\t\t\t * will be overwritten at its original position.\n\t\t\t *\n\t\t\t * ## Best practices\n\t\t\t *\n\t\t\t * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n\t\t\t * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n\t\t\t * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n\t\t\t *\n\t\t\t * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n\t\t\t * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n\t\t\t *\n\t\t\t * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n\t\t\t * @param {Grammar} redef The new tokens to append.\n\t\t\t * @returns {Grammar} The new language created.\n\t\t\t * @public\n\t\t\t * @example\n\t\t\t * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n\t\t\t *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n\t\t\t *     // at its original position\n\t\t\t *     'comment': { ... },\n\t\t\t *     // CSS doesn't have a 'color' token, so this token will be appended\n\t\t\t *     'color': /\\b(?:red|green|blue)\\b/\n\t\t\t * });\n\t\t\t */\n\t\t\textend: function (id, redef) {\n\t\t\t\tvar lang = _.util.clone(_.languages[id]);\n\n\t\t\t\tfor (var key in redef) {\n\t\t\t\t\tlang[key] = redef[key];\n\t\t\t\t}\n\n\t\t\t\treturn lang;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Inserts tokens _before_ another token in a language definition or any other grammar.\n\t\t\t *\n\t\t\t * ## Usage\n\t\t\t *\n\t\t\t * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n\t\t\t * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n\t\t\t * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n\t\t\t * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n\t\t\t * this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.markup.style = {\n\t\t\t *     // token\n\t\t\t * };\n\t\t\t * ```\n\t\t\t *\n\t\t\t * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n\t\t\t * before existing tokens. For the CSS example above, you would use it like this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'cdata', {\n\t\t\t *     'style': {\n\t\t\t *         // token\n\t\t\t *     }\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Special cases\n\t\t\t *\n\t\t\t * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n\t\t\t * will be ignored.\n\t\t\t *\n\t\t\t * This behavior can be used to insert tokens after `before`:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'comment', {\n\t\t\t *     'comment': Prism.languages.markup.comment,\n\t\t\t *     // tokens after 'comment'\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Limitations\n\t\t\t *\n\t\t\t * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n\t\t\t * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n\t\t\t * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n\t\t\t * deleting properties which is necessary to insert at arbitrary positions.\n\t\t\t *\n\t\t\t * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n\t\t\t * Instead, it will create a new object and replace all references to the target object with the new one. This\n\t\t\t * can be done without temporarily deleting properties, so the iteration order is well-defined.\n\t\t\t *\n\t\t\t * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n\t\t\t * you hold the target object in a variable, then the value of the variable will not change.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * var oldMarkup = Prism.languages.markup;\n\t\t\t * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n\t\t\t *\n\t\t\t * assert(oldMarkup !== Prism.languages.markup);\n\t\t\t * assert(newMarkup === Prism.languages.markup);\n\t\t\t * ```\n\t\t\t *\n\t\t\t * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n\t\t\t * object to be modified.\n\t\t\t * @param {string} before The key to insert before.\n\t\t\t * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n\t\t\t * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n\t\t\t * object to be modified.\n\t\t\t *\n\t\t\t * Defaults to `Prism.languages`.\n\t\t\t * @returns {Grammar} The new grammar object.\n\t\t\t * @public\n\t\t\t */\n\t\t\tinsertBefore: function (inside, before, insert, root) {\n\t\t\t\troot = root || /** @type {any} */ (_.languages);\n\t\t\t\tvar grammar = root[inside];\n\t\t\t\t/** @type {Grammar} */\n\t\t\t\tvar ret = {};\n\n\t\t\t\tfor (var token in grammar) {\n\t\t\t\t\tif (grammar.hasOwnProperty(token)) {\n\n\t\t\t\t\t\tif (token == before) {\n\t\t\t\t\t\t\tfor (var newToken in insert) {\n\t\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Do not insert token which also occur in insert. See #1525\n\t\t\t\t\t\tif (!insert.hasOwnProperty(token)) {\n\t\t\t\t\t\t\tret[token] = grammar[token];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar old = root[inside];\n\t\t\t\troot[inside] = ret;\n\n\t\t\t\t// Update references in other language definitions\n\t\t\t\t_.languages.DFS(_.languages, function (key, value) {\n\t\t\t\t\tif (value === old && key != inside) {\n\t\t\t\t\t\tthis[key] = ret;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn ret;\n\t\t\t},\n\n\t\t\t// Traverse a language definition with Depth First Search\n\t\t\tDFS: function DFS(o, callback, type, visited) {\n\t\t\t\tvisited = visited || {};\n\n\t\t\t\tvar objId = _.util.objId;\n\n\t\t\t\tfor (var i in o) {\n\t\t\t\t\tif (o.hasOwnProperty(i)) {\n\t\t\t\t\t\tcallback.call(o, i, o[i], type || i);\n\n\t\t\t\t\t\tvar property = o[i];\n\t\t\t\t\t\tvar propertyType = _.util.type(property);\n\n\t\t\t\t\t\tif (propertyType === 'Object' && !visited[objId(property)]) {\n\t\t\t\t\t\t\tvisited[objId(property)] = true;\n\t\t\t\t\t\t\tDFS(property, callback, null, visited);\n\t\t\t\t\t\t} else if (propertyType === 'Array' && !visited[objId(property)]) {\n\t\t\t\t\t\t\tvisited[objId(property)] = true;\n\t\t\t\t\t\t\tDFS(property, callback, i, visited);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tplugins: {},\n\n\t\t/**\n\t\t * This is the most high-level function in Prisms API.\n\t\t * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on\n\t\t * each one of them.\n\t\t *\n\t\t * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.\n\t\t *\n\t\t * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.\n\t\t * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightAll: function (async, callback) {\n\t\t\t_.highlightAllUnder(document, async, callback);\n\t\t},\n\n\t\t/**\n\t\t * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls\n\t\t * {@link Prism.highlightElement} on each one of them.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-highlightall`\n\t\t * 2. `before-all-elements-highlight`\n\t\t * 3. All hooks of {@link Prism.highlightElement} for each element.\n\t\t *\n\t\t * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.\n\t\t * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.\n\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightAllUnder: function (container, async, callback) {\n\t\t\tvar env = {\n\t\t\t\tcallback: callback,\n\t\t\t\tcontainer: container,\n\t\t\t\tselector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n\t\t\t};\n\n\t\t\t_.hooks.run('before-highlightall', env);\n\n\t\t\tenv.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));\n\n\t\t\t_.hooks.run('before-all-elements-highlight', env);\n\n\t\t\tfor (var i = 0, element; (element = env.elements[i++]);) {\n\t\t\t\t_.highlightElement(element, async === true, env.callback);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Highlights the code inside a single element.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-sanity-check`\n\t\t * 2. `before-highlight`\n\t\t * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.\n\t\t * 4. `before-insert`\n\t\t * 5. `after-highlight`\n\t\t * 6. `complete`\n\t\t *\n\t\t * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for\n\t\t * the element's language.\n\t\t *\n\t\t * @param {Element} element The element containing the code.\n\t\t * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.\n\t\t * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers\n\t\t * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is\n\t\t * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).\n\t\t *\n\t\t * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for\n\t\t * asynchronous highlighting to work. You can build your own bundle on the\n\t\t * [Download page](https://prismjs.com/download.html).\n\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.\n\t\t * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightElement: function (element, async, callback) {\n\t\t\t// Find language\n\t\t\tvar language = _.util.getLanguage(element);\n\t\t\tvar grammar = _.languages[language];\n\n\t\t\t// Set language on the element, if not present\n\t\t\t_.util.setLanguage(element, language);\n\n\t\t\t// Set language on the parent, for styling\n\t\t\tvar parent = element.parentElement;\n\t\t\tif (parent && parent.nodeName.toLowerCase() === 'pre') {\n\t\t\t\t_.util.setLanguage(parent, language);\n\t\t\t}\n\n\t\t\tvar code = element.textContent;\n\n\t\t\tvar env = {\n\t\t\t\telement: element,\n\t\t\t\tlanguage: language,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tcode: code\n\t\t\t};\n\n\t\t\tfunction insertHighlightedCode(highlightedCode) {\n\t\t\t\tenv.highlightedCode = highlightedCode;\n\n\t\t\t\t_.hooks.run('before-insert', env);\n\n\t\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t}\n\n\t\t\t_.hooks.run('before-sanity-check', env);\n\n\t\t\t// plugins may change/add the parent/element\n\t\t\tparent = env.element.parentElement;\n\t\t\tif (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {\n\t\t\t\tparent.setAttribute('tabindex', '0');\n\t\t\t}\n\n\t\t\tif (!env.code) {\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_.hooks.run('before-highlight', env);\n\n\t\t\tif (!env.grammar) {\n\t\t\t\tinsertHighlightedCode(_.util.encode(env.code));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (async && _self.Worker) {\n\t\t\t\tvar worker = new Worker(_.filename);\n\n\t\t\t\tworker.onmessage = function (evt) {\n\t\t\t\t\tinsertHighlightedCode(evt.data);\n\t\t\t\t};\n\n\t\t\t\tworker.postMessage(JSON.stringify({\n\t\t\t\t\tlanguage: env.language,\n\t\t\t\t\tcode: env.code,\n\t\t\t\t\timmediateClose: true\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tinsertHighlightedCode(_.highlight(env.code, env.grammar, env.language));\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Low-level function, only use if you know what youre doing. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns a string with the HTML produced.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-tokenize`\n\t\t * 2. `after-tokenize`\n\t\t * 3. `wrap`: On each {@link Token}.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @param {string} language The name of the language definition passed to `grammar`.\n\t\t * @returns {string} The highlighted HTML.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n\t\t */\n\t\thighlight: function (text, grammar, language) {\n\t\t\tvar env = {\n\t\t\t\tcode: text,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tlanguage: language\n\t\t\t};\n\t\t\t_.hooks.run('before-tokenize', env);\n\t\t\tif (!env.grammar) {\n\t\t\t\tthrow new Error('The language \"' + env.language + '\" has no grammar.');\n\t\t\t}\n\t\t\tenv.tokens = _.tokenize(env.code, env.grammar);\n\t\t\t_.hooks.run('after-tokenize', env);\n\t\t\treturn Token.stringify(_.util.encode(env.tokens), env.language);\n\t\t},\n\n\t\t/**\n\t\t * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns an array with the tokenized code.\n\t\t *\n\t\t * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n\t\t *\n\t\t * This method could be useful in other contexts as well, as a very crude parser.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @returns {TokenStream} An array of strings and tokens, a token stream.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * let code = `var foo = 0;`;\n\t\t * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n\t\t * tokens.forEach(token => {\n\t\t *     if (token instanceof Prism.Token && token.type === 'number') {\n\t\t *         console.log(`Found numeric literal: ${token.content}`);\n\t\t *     }\n\t\t * });\n\t\t */\n\t\ttokenize: function (text, grammar) {\n\t\t\tvar rest = grammar.rest;\n\t\t\tif (rest) {\n\t\t\t\tfor (var token in rest) {\n\t\t\t\t\tgrammar[token] = rest[token];\n\t\t\t\t}\n\n\t\t\t\tdelete grammar.rest;\n\t\t\t}\n\n\t\t\tvar tokenList = new LinkedList();\n\t\t\taddAfter(tokenList, tokenList.head, text);\n\n\t\t\tmatchGrammar(text, tokenList, grammar, tokenList.head, 0);\n\n\t\t\treturn toArray(tokenList);\n\t\t},\n\n\t\t/**\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thooks: {\n\t\t\tall: {},\n\n\t\t\t/**\n\t\t\t * Adds the given callback to the list of callbacks for the given hook.\n\t\t\t *\n\t\t\t * The callback will be invoked when the hook it is registered for is run.\n\t\t\t * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n\t\t\t *\n\t\t\t * One callback function can be registered to multiple hooks and the same hook multiple times.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {HookCallback} callback The callback function which is given environment variables.\n\t\t\t * @public\n\t\t\t */\n\t\t\tadd: function (name, callback) {\n\t\t\t\tvar hooks = _.hooks.all;\n\n\t\t\t\thooks[name] = hooks[name] || [];\n\n\t\t\t\thooks[name].push(callback);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Runs a hook invoking all registered callbacks with the given environment variables.\n\t\t\t *\n\t\t\t * Callbacks will be invoked synchronously and in the order in which they were registered.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n\t\t\t * @public\n\t\t\t */\n\t\t\trun: function (name, env) {\n\t\t\t\tvar callbacks = _.hooks.all[name];\n\n\t\t\t\tif (!callbacks || !callbacks.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, callback; (callback = callbacks[i++]);) {\n\t\t\t\t\tcallback(env);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tToken: Token\n\t};\n\t_self.Prism = _;\n\n\n\t// Typescript note:\n\t// The following can be used to import the Token type in JSDoc:\n\t//\n\t//   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\n\t/**\n\t * Creates a new token.\n\t *\n\t * @param {string} type See {@link Token#type type}\n\t * @param {string | TokenStream} content See {@link Token#content content}\n\t * @param {string|string[]} [alias] The alias(es) of the token.\n\t * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n\t * @class\n\t * @global\n\t * @public\n\t */\n\tfunction Token(type, content, alias, matchedStr) {\n\t\t/**\n\t\t * The type of the token.\n\t\t *\n\t\t * This is usually the key of a pattern in a {@link Grammar}.\n\t\t *\n\t\t * @type {string}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */\n\t\tthis.type = type;\n\t\t/**\n\t\t * The strings or tokens contained by this token.\n\t\t *\n\t\t * This will be a token stream if the pattern matched also defined an `inside` grammar.\n\t\t *\n\t\t * @type {string | TokenStream}\n\t\t * @public\n\t\t */\n\t\tthis.content = content;\n\t\t/**\n\t\t * The alias(es) of the token.\n\t\t *\n\t\t * @type {string|string[]}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */\n\t\tthis.alias = alias;\n\t\t// Copy of the full string this token was created from\n\t\tthis.length = (matchedStr || '').length | 0;\n\t}\n\n\t/**\n\t * A token stream is an array of strings and {@link Token Token} objects.\n\t *\n\t * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n\t * them.\n\t *\n\t * 1. No adjacent strings.\n\t * 2. No empty strings.\n\t *\n\t *    The only exception here is the token stream that only contains the empty string and nothing else.\n\t *\n\t * @typedef {Array<string | Token>} TokenStream\n\t * @global\n\t * @public\n\t */\n\n\t/**\n\t * Converts the given token or token stream to an HTML representation.\n\t *\n\t * The following hooks will be run:\n\t * 1. `wrap`: On each {@link Token}.\n\t *\n\t * @param {string | Token | TokenStream} o The token or token stream to be converted.\n\t * @param {string} language The name of current language.\n\t * @returns {string} The HTML representation of the token or token stream.\n\t * @memberof Token\n\t * @static\n\t */\n\tToken.stringify = function stringify(o, language) {\n\t\tif (typeof o == 'string') {\n\t\t\treturn o;\n\t\t}\n\t\tif (Array.isArray(o)) {\n\t\t\tvar s = '';\n\t\t\to.forEach(function (e) {\n\t\t\t\ts += stringify(e, language);\n\t\t\t});\n\t\t\treturn s;\n\t\t}\n\n\t\tvar env = {\n\t\t\ttype: o.type,\n\t\t\tcontent: stringify(o.content, language),\n\t\t\ttag: 'span',\n\t\t\tclasses: ['token', o.type],\n\t\t\tattributes: {},\n\t\t\tlanguage: language\n\t\t};\n\n\t\tvar aliases = o.alias;\n\t\tif (aliases) {\n\t\t\tif (Array.isArray(aliases)) {\n\t\t\t\tArray.prototype.push.apply(env.classes, aliases);\n\t\t\t} else {\n\t\t\t\tenv.classes.push(aliases);\n\t\t\t}\n\t\t}\n\n\t\t_.hooks.run('wrap', env);\n\n\t\tvar attributes = '';\n\t\tfor (var name in env.attributes) {\n\t\t\tattributes += ' ' + name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"';\n\t\t}\n\n\t\treturn '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\"' + attributes + '>' + env.content + '</' + env.tag + '>';\n\t};\n\n\t/**\n\t * @param {RegExp} pattern\n\t * @param {number} pos\n\t * @param {string} text\n\t * @param {boolean} lookbehind\n\t * @returns {RegExpExecArray | null}\n\t */\n\tfunction matchPattern(pattern, pos, text, lookbehind) {\n\t\tpattern.lastIndex = pos;\n\t\tvar match = pattern.exec(text);\n\t\tif (match && lookbehind && match[1]) {\n\t\t\t// change the match to remove the text matched by the Prism lookbehind group\n\t\t\tvar lookbehindLength = match[1].length;\n\t\t\tmatch.index += lookbehindLength;\n\t\t\tmatch[0] = match[0].slice(lookbehindLength);\n\t\t}\n\t\treturn match;\n\t}\n\n\t/**\n\t * @param {string} text\n\t * @param {LinkedList<string | Token>} tokenList\n\t * @param {any} grammar\n\t * @param {LinkedListNode<string | Token>} startNode\n\t * @param {number} startPos\n\t * @param {RematchOptions} [rematch]\n\t * @returns {void}\n\t * @private\n\t *\n\t * @typedef RematchOptions\n\t * @property {string} cause\n\t * @property {number} reach\n\t */\n\tfunction matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n\t\tfor (var token in grammar) {\n\t\t\tif (!grammar.hasOwnProperty(token) || !grammar[token]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar patterns = grammar[token];\n\t\t\tpatterns = Array.isArray(patterns) ? patterns : [patterns];\n\n\t\t\tfor (var j = 0; j < patterns.length; ++j) {\n\t\t\t\tif (rematch && rematch.cause == token + ',' + j) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar patternObj = patterns[j];\n\t\t\t\tvar inside = patternObj.inside;\n\t\t\t\tvar lookbehind = !!patternObj.lookbehind;\n\t\t\t\tvar greedy = !!patternObj.greedy;\n\t\t\t\tvar alias = patternObj.alias;\n\n\t\t\t\tif (greedy && !patternObj.pattern.global) {\n\t\t\t\t\t// Without the global flag, lastIndex won't work\n\t\t\t\t\tvar flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n\t\t\t\t\tpatternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');\n\t\t\t\t}\n\n\t\t\t\t/** @type {RegExp} */\n\t\t\t\tvar pattern = patternObj.pattern || patternObj;\n\n\t\t\t\tfor ( // iterate the token list and keep track of the current token/string position\n\t\t\t\t\tvar currentNode = startNode.next, pos = startPos;\n\t\t\t\t\tcurrentNode !== tokenList.tail;\n\t\t\t\t\tpos += currentNode.value.length, currentNode = currentNode.next\n\t\t\t\t) {\n\n\t\t\t\t\tif (rematch && pos >= rematch.reach) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar str = currentNode.value;\n\n\t\t\t\t\tif (tokenList.length > text.length) {\n\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (str instanceof Token) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar removeCount = 1; // this is the to parameter of removeBetween\n\t\t\t\t\tvar match;\n\n\t\t\t\t\tif (greedy) {\n\t\t\t\t\t\tmatch = matchPattern(pattern, pos, text, lookbehind);\n\t\t\t\t\t\tif (!match || match.index >= text.length) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar from = match.index;\n\t\t\t\t\t\tvar to = match.index + match[0].length;\n\t\t\t\t\t\tvar p = pos;\n\n\t\t\t\t\t\t// find the node that contains the match\n\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t\twhile (from >= p) {\n\t\t\t\t\t\t\tcurrentNode = currentNode.next;\n\t\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// adjust pos (and p)\n\t\t\t\t\t\tp -= currentNode.value.length;\n\t\t\t\t\t\tpos = p;\n\n\t\t\t\t\t\t// the current node is a Token, then the match starts inside another Token, which is invalid\n\t\t\t\t\t\tif (currentNode.value instanceof Token) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// find the last node which is affected by this match\n\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\tvar k = currentNode;\n\t\t\t\t\t\t\tk !== tokenList.tail && (p < to || typeof k.value === 'string');\n\t\t\t\t\t\t\tk = k.next\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tremoveCount++;\n\t\t\t\t\t\t\tp += k.value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremoveCount--;\n\n\t\t\t\t\t\t// replace with the new match\n\t\t\t\t\t\tstr = text.slice(pos, p);\n\t\t\t\t\t\tmatch.index -= pos;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatch = matchPattern(pattern, 0, str, lookbehind);\n\t\t\t\t\t\tif (!match) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// eslint-disable-next-line no-redeclare\n\t\t\t\t\tvar from = match.index;\n\t\t\t\t\tvar matchStr = match[0];\n\t\t\t\t\tvar before = str.slice(0, from);\n\t\t\t\t\tvar after = str.slice(from + matchStr.length);\n\n\t\t\t\t\tvar reach = pos + str.length;\n\t\t\t\t\tif (rematch && reach > rematch.reach) {\n\t\t\t\t\t\trematch.reach = reach;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar removeFrom = currentNode.prev;\n\n\t\t\t\t\tif (before) {\n\t\t\t\t\t\tremoveFrom = addAfter(tokenList, removeFrom, before);\n\t\t\t\t\t\tpos += before.length;\n\t\t\t\t\t}\n\n\t\t\t\t\tremoveRange(tokenList, removeFrom, removeCount);\n\n\t\t\t\t\tvar wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\n\t\t\t\t\tcurrentNode = addAfter(tokenList, removeFrom, wrapped);\n\n\t\t\t\t\tif (after) {\n\t\t\t\t\t\taddAfter(tokenList, currentNode, after);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (removeCount > 1) {\n\t\t\t\t\t\t// at least one Token object was removed, so we have to do some rematching\n\t\t\t\t\t\t// this can only happen if the current pattern is greedy\n\n\t\t\t\t\t\t/** @type {RematchOptions} */\n\t\t\t\t\t\tvar nestedRematch = {\n\t\t\t\t\t\t\tcause: token + ',' + j,\n\t\t\t\t\t\t\treach: reach\n\t\t\t\t\t\t};\n\t\t\t\t\t\tmatchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);\n\n\t\t\t\t\t\t// the reach might have been extended because of the rematching\n\t\t\t\t\t\tif (rematch && nestedRematch.reach > rematch.reach) {\n\t\t\t\t\t\t\trematch.reach = nestedRematch.reach;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @typedef LinkedListNode\n\t * @property {T} value\n\t * @property {LinkedListNode<T> | null} prev The previous node.\n\t * @property {LinkedListNode<T> | null} next The next node.\n\t * @template T\n\t * @private\n\t */\n\n\t/**\n\t * @template T\n\t * @private\n\t */\n\tfunction LinkedList() {\n\t\t/** @type {LinkedListNode<T>} */\n\t\tvar head = { value: null, prev: null, next: null };\n\t\t/** @type {LinkedListNode<T>} */\n\t\tvar tail = { value: null, prev: head, next: null };\n\t\thead.next = tail;\n\n\t\t/** @type {LinkedListNode<T>} */\n\t\tthis.head = head;\n\t\t/** @type {LinkedListNode<T>} */\n\t\tthis.tail = tail;\n\t\tthis.length = 0;\n\t}\n\n\t/**\n\t * Adds a new node with the given value to the list.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {T} value\n\t * @returns {LinkedListNode<T>} The added node.\n\t * @template T\n\t */\n\tfunction addAfter(list, node, value) {\n\t\t// assumes that node != list.tail && values.length >= 0\n\t\tvar next = node.next;\n\n\t\tvar newNode = { value: value, prev: node, next: next };\n\t\tnode.next = newNode;\n\t\tnext.prev = newNode;\n\t\tlist.length++;\n\n\t\treturn newNode;\n\t}\n\t/**\n\t * Removes `count` nodes after the given node. The given node will not be removed.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {number} count\n\t * @template T\n\t */\n\tfunction removeRange(list, node, count) {\n\t\tvar next = node.next;\n\t\tfor (var i = 0; i < count && next !== list.tail; i++) {\n\t\t\tnext = next.next;\n\t\t}\n\t\tnode.next = next;\n\t\tnext.prev = node;\n\t\tlist.length -= i;\n\t}\n\t/**\n\t * @param {LinkedList<T>} list\n\t * @returns {T[]}\n\t * @template T\n\t */\n\tfunction toArray(list) {\n\t\tvar array = [];\n\t\tvar node = list.head.next;\n\t\twhile (node !== list.tail) {\n\t\t\tarray.push(node.value);\n\t\t\tnode = node.next;\n\t\t}\n\t\treturn array;\n\t}\n\n\n\tif (!_self.document) {\n\t\tif (!_self.addEventListener) {\n\t\t\t// in Node.js\n\t\t\treturn _;\n\t\t}\n\n\t\tif (!_.disableWorkerMessageHandler) {\n\t\t\t// In worker\n\t\t\t_self.addEventListener('message', function (evt) {\n\t\t\t\tvar message = JSON.parse(evt.data);\n\t\t\t\tvar lang = message.language;\n\t\t\t\tvar code = message.code;\n\t\t\t\tvar immediateClose = message.immediateClose;\n\n\t\t\t\t_self.postMessage(_.highlight(code, _.languages[lang], lang));\n\t\t\t\tif (immediateClose) {\n\t\t\t\t\t_self.close();\n\t\t\t\t}\n\t\t\t}, false);\n\t\t}\n\n\t\treturn _;\n\t}\n\n\t// Get current script and highlight\n\tvar script = _.util.currentScript();\n\n\tif (script) {\n\t\t_.filename = script.src;\n\n\t\tif (script.hasAttribute('data-manual')) {\n\t\t\t_.manual = true;\n\t\t}\n\t}\n\n\tfunction highlightAutomaticallyCallback() {\n\t\tif (!_.manual) {\n\t\t\t_.highlightAll();\n\t\t}\n\t}\n\n\tif (!_.manual) {\n\t\t// If the document state is \"loading\", then we'll use DOMContentLoaded.\n\t\t// If the document state is \"interactive\" and the prism.js script is deferred, then we'll also use the\n\t\t// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they\n\t\t// might take longer one animation frame to execute which can create a race condition where only some plugins have\n\t\t// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.\n\t\t// See https://github.com/PrismJS/prism/issues/2102\n\t\tvar readyState = document.readyState;\n\t\tif (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {\n\t\t\tdocument.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);\n\t\t} else {\n\t\t\tif (window.requestAnimationFrame) {\n\t\t\t\twindow.requestAnimationFrame(highlightAutomaticallyCallback);\n\t\t\t} else {\n\t\t\t\twindow.setTimeout(highlightAutomaticallyCallback, 16);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn _;\n\n}(_self));\n\nif (typeof module !== 'undefined' && module.exports) {\n\tmodule.exports = Prism;\n}\n\n// hack for components to work correctly in node.js\nif (typeof global !== 'undefined') {\n\tglobal.Prism = Prism;\n}\n\n// some additional documentation/types\n\n/**\n * The expansion of a simple `RegExp` literal to support additional properties.\n *\n * @typedef GrammarToken\n * @property {RegExp} pattern The regular expression of the token.\n * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)\n * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.\n * @property {boolean} [greedy=false] Whether the token is greedy.\n * @property {string|string[]} [alias] An optional alias or list of aliases.\n * @property {Grammar} [inside] The nested grammar of this token.\n *\n * The `inside` grammar will be used to tokenize the text value of each token of this kind.\n *\n * This can be used to make nested and even recursive language definitions.\n *\n * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into\n * each another.\n * @global\n * @public\n */\n\n/**\n * @typedef Grammar\n * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}\n * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.\n * @global\n * @public\n */\n\n/**\n * A function which will invoked after an element was successfully highlighted.\n *\n * @callback HighlightCallback\n * @param {Element} element The element successfully highlighted.\n * @returns {void}\n * @global\n * @public\n */\n\n/**\n * @callback HookCallback\n * @param {Object<string, any>} env The environment variables of the hook.\n * @returns {void}\n * @global\n * @public\n */\n\n\n/* **********************************************\n     Begin prism-markup.js\n********************************************** */\n\nPrism.languages.markup = {\n\t'comment': {\n\t\tpattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n\t\tgreedy: true\n\t},\n\t'prolog': {\n\t\tpattern: /<\\?[\\s\\S]+?\\?>/,\n\t\tgreedy: true\n\t},\n\t'doctype': {\n\t\t// https://www.w3.org/TR/xml/#NT-doctypedecl\n\t\tpattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'internal-subset': {\n\t\t\t\tpattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: null // see below\n\t\t\t},\n\t\t\t'string': {\n\t\t\t\tpattern: /\"[^\"]*\"|'[^']*'/,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t'punctuation': /^<!|>$|[[\\]]/,\n\t\t\t'doctype-tag': /^DOCTYPE/i,\n\t\t\t'name': /[^\\s<>'\"]+/\n\t\t}\n\t},\n\t'cdata': {\n\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\tgreedy: true\n\t},\n\t'tag': {\n\t\tpattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'tag': {\n\t\t\t\tpattern: /^<\\/?[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^<\\/?/,\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'special-attr': [],\n\t\t\t'attr-value': {\n\t\t\t\tpattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /^(\\s*)[\"']|[\"']$/,\n\t\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t},\n\t\t\t'punctuation': /\\/?>/,\n\t\t\t'attr-name': {\n\t\t\t\tpattern: /[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\t'entity': [\n\t\t{\n\t\t\tpattern: /&[\\da-z]{1,8};/i,\n\t\t\talias: 'named-entity'\n\t\t},\n\t\t/&#x?[\\da-f]{1,8};/i\n\t]\n};\n\nPrism.languages.markup['tag'].inside['attr-value'].inside['entity'] =\n\tPrism.languages.markup['entity'];\nPrism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function (env) {\n\n\tif (env.type === 'entity') {\n\t\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\n\t}\n});\n\nObject.defineProperty(Prism.languages.markup.tag, 'addInlined', {\n\t/**\n\t * Adds an inlined language to markup.\n\t *\n\t * An example of an inlined language is CSS with `<style>` tags.\n\t *\n\t * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addInlined('style', 'css');\n\t */\n\tvalue: function addInlined(tagName, lang) {\n\t\tvar includedCdataInside = {};\n\t\tincludedCdataInside['language-' + lang] = {\n\t\t\tpattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\t\tincludedCdataInside['cdata'] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n\n\t\tvar inside = {\n\t\t\t'included-cdata': {\n\t\t\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\t\t\tinside: includedCdataInside\n\t\t\t}\n\t\t};\n\t\tinside['language-' + lang] = {\n\t\t\tpattern: /[\\s\\S]+/,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\n\t\tvar def = {};\n\t\tdef[tagName] = {\n\t\t\tpattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: inside\n\t\t};\n\n\t\tPrism.languages.insertBefore('markup', 'cdata', def);\n\t}\n});\nObject.defineProperty(Prism.languages.markup.tag, 'addAttribute', {\n\t/**\n\t * Adds an pattern to highlight languages embedded in HTML attributes.\n\t *\n\t * An example of an inlined language is CSS with `style` attributes.\n\t *\n\t * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addAttribute('style', 'css');\n\t */\n\tvalue: function (attrName, lang) {\n\t\tPrism.languages.markup.tag.inside['special-attr'].push({\n\t\t\tpattern: RegExp(\n\t\t\t\t/(^|[\"'\\s])/.source + '(?:' + attrName + ')' + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source,\n\t\t\t\t'i'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'attr-name': /^[^\\s=]+/,\n\t\t\t\t'attr-value': {\n\t\t\t\t\tpattern: /=[\\s\\S]+/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'value': {\n\t\t\t\t\t\t\tpattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\talias: [lang, 'language-' + lang],\n\t\t\t\t\t\t\tinside: Prism.languages[lang]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/\"|'/\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n});\n\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\n\nPrism.languages.xml = Prism.languages.extend('markup', {});\nPrism.languages.ssml = Prism.languages.xml;\nPrism.languages.atom = Prism.languages.xml;\nPrism.languages.rss = Prism.languages.xml;\n\n\n/* **********************************************\n     Begin prism-css.js\n********************************************** */\n\n(function (Prism) {\n\n\tvar string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n\n\tPrism.languages.css = {\n\t\t'comment': /\\/\\*[\\s\\S]*?\\*\\//,\n\t\t'atrule': {\n\t\t\tpattern: RegExp('@[\\\\w-](?:' + /[^;{\\s\"']|\\s+(?!\\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\\s*\\{))/.source),\n\t\t\tinside: {\n\t\t\t\t'rule': /^@[\\w-]+/,\n\t\t\t\t'selector-function-argument': {\n\t\t\t\t\tpattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'selector'\n\t\t\t\t},\n\t\t\t\t'keyword': {\n\t\t\t\t\tpattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t}\n\t\t\t\t// See rest below\n\t\t\t}\n\t\t},\n\t\t'url': {\n\t\t\t// https://drafts.csswg.org/css-values-3/#urls\n\t\t\tpattern: RegExp('\\\\burl\\\\((?:' + string.source + '|' + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + ')\\\\)', 'i'),\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'function': /^url/i,\n\t\t\t\t'punctuation': /^\\(|\\)$/,\n\t\t\t\t'string': {\n\t\t\t\t\tpattern: RegExp('^' + string.source + '$'),\n\t\t\t\t\talias: 'url'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'selector': {\n\t\t\tpattern: RegExp('(^|[{}\\\\s])[^{}\\\\s](?:[^{};\"\\'\\\\s]|\\\\s+(?![\\\\s{])|' + string.source + ')*(?=\\\\s*\\\\{)'),\n\t\t\tlookbehind: true\n\t\t},\n\t\t'string': {\n\t\t\tpattern: string,\n\t\t\tgreedy: true\n\t\t},\n\t\t'property': {\n\t\t\tpattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'important': /!important\\b/i,\n\t\t'function': {\n\t\t\tpattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'punctuation': /[(){};:,]/\n\t};\n\n\tPrism.languages.css['atrule'].inside.rest = Prism.languages.css;\n\n\tvar markup = Prism.languages.markup;\n\tif (markup) {\n\t\tmarkup.tag.addInlined('style', 'css');\n\t\tmarkup.tag.addAttribute('style', 'css');\n\t}\n\n}(Prism));\n\n\n/* **********************************************\n     Begin prism-clike.js\n********************************************** */\n\nPrism.languages.clike = {\n\t'comment': [\n\t\t{\n\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t}\n\t],\n\t'string': {\n\t\tpattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t\tgreedy: true\n\t},\n\t'class-name': {\n\t\tpattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'punctuation': /[.\\\\]/\n\t\t}\n\t},\n\t'keyword': /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n\t'boolean': /\\b(?:false|true)\\b/,\n\t'function': /\\b\\w+(?=\\()/,\n\t'number': /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n\t'operator': /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n\n\n/* **********************************************\n     Begin prism-javascript.js\n********************************************** */\n\nPrism.languages.javascript = Prism.languages.extend('clike', {\n\t'class-name': [\n\t\tPrism.languages.clike['class-name'],\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'keyword': [\n\t\t{\n\t\t\tpattern: /((?:^|\\})\\s*)catch\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t],\n\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n\t'function': /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n\t'number': {\n\t\tpattern: RegExp(\n\t\t\t/(^|[^\\w$])/.source +\n\t\t\t'(?:' +\n\t\t\t(\n\t\t\t\t// constant\n\t\t\t\t/NaN|Infinity/.source +\n\t\t\t\t'|' +\n\t\t\t\t// binary integer\n\t\t\t\t/0[bB][01]+(?:_[01]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// octal integer\n\t\t\t\t/0[oO][0-7]+(?:_[0-7]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// hexadecimal integer\n\t\t\t\t/0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// decimal bigint\n\t\t\t\t/\\d+(?:_\\d+)*n/.source +\n\t\t\t\t'|' +\n\t\t\t\t// decimal number (integer or float) but no bigint\n\t\t\t\t/(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source\n\t\t\t) +\n\t\t\t')' +\n\t\t\t/(?![\\w$])/.source\n\t\t),\n\t\tlookbehind: true\n\t},\n\t'operator': /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n});\n\nPrism.languages.javascript['class-name'][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n\t'regex': {\n\t\tpattern: RegExp(\n\t\t\t// lookbehind\n\t\t\t// eslint-disable-next-line regexp/no-dupe-characters-character-class\n\t\t\t/((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/.source +\n\t\t\t// Regex pattern:\n\t\t\t// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character\n\t\t\t// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible\n\t\t\t// with the only syntax, so we have to define 2 different regex patterns.\n\t\t\t/\\//.source +\n\t\t\t'(?:' +\n\t\t\t/(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}/.source +\n\t\t\t'|' +\n\t\t\t// `v` flag syntax. This supports 3 levels of nested character classes.\n\t\t\t/(?:\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +\n\t\t\t')' +\n\t\t\t// lookahead\n\t\t\t/(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/.source\n\t\t),\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'regex-source': {\n\t\t\t\tpattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'language-regex',\n\t\t\t\tinside: Prism.languages.regex\n\t\t\t},\n\t\t\t'regex-delimiter': /^\\/|\\/$/,\n\t\t\t'regex-flags': /^[a-z]+$/,\n\t\t}\n\t},\n\t// This must be declared before keyword because we use \"function\" inside the look-forward\n\t'function-variable': {\n\t\tpattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n\t\talias: 'function'\n\t},\n\t'parameter': [\n\t\t{\n\t\t\tpattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t}\n\t],\n\t'constant': /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\n\nPrism.languages.insertBefore('javascript', 'string', {\n\t'hashbang': {\n\t\tpattern: /^#!.*/,\n\t\tgreedy: true,\n\t\talias: 'comment'\n\t},\n\t'template-string': {\n\t\tpattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'template-punctuation': {\n\t\t\t\tpattern: /^`|`$/,\n\t\t\t\talias: 'string'\n\t\t\t},\n\t\t\t'interpolation': {\n\t\t\t\tpattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\t\tpattern: /^\\$\\{|\\}$/,\n\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t},\n\t\t\t\t\trest: Prism.languages.javascript\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t}\n\t},\n\t'string-property': {\n\t\tpattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\talias: 'property'\n\t}\n});\n\nPrism.languages.insertBefore('javascript', 'operator', {\n\t'literal-property': {\n\t\tpattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n\t\tlookbehind: true,\n\t\talias: 'property'\n\t},\n});\n\nif (Prism.languages.markup) {\n\tPrism.languages.markup.tag.addInlined('script', 'javascript');\n\n\t// add attribute support for all DOM events.\n\t// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n\tPrism.languages.markup.tag.addAttribute(\n\t\t/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,\n\t\t'javascript'\n\t);\n}\n\nPrism.languages.js = Prism.languages.javascript;\n\n\n/* **********************************************\n     Begin prism-file-highlight.js\n********************************************** */\n\n(function () {\n\n\tif (typeof Prism === 'undefined' || typeof document === 'undefined') {\n\t\treturn;\n\t}\n\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\n\tif (!Element.prototype.matches) {\n\t\tElement.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\t}\n\n\tvar LOADING_MESSAGE = 'Loading';\n\tvar FAILURE_MESSAGE = function (status, message) {\n\t\treturn ' Error ' + status + ' while fetching file: ' + message;\n\t};\n\tvar FAILURE_EMPTY_MESSAGE = ' Error: File does not exist or is empty';\n\n\tvar EXTENSIONS = {\n\t\t'js': 'javascript',\n\t\t'py': 'python',\n\t\t'rb': 'ruby',\n\t\t'ps1': 'powershell',\n\t\t'psm1': 'powershell',\n\t\t'sh': 'bash',\n\t\t'bat': 'batch',\n\t\t'h': 'c',\n\t\t'tex': 'latex'\n\t};\n\n\tvar STATUS_ATTR = 'data-src-status';\n\tvar STATUS_LOADING = 'loading';\n\tvar STATUS_LOADED = 'loaded';\n\tvar STATUS_FAILED = 'failed';\n\n\tvar SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '=\"' + STATUS_LOADED + '\"])'\n\t\t+ ':not([' + STATUS_ATTR + '=\"' + STATUS_LOADING + '\"])';\n\n\t/**\n\t * Loads the given file.\n\t *\n\t * @param {string} src The URL or path of the source file to load.\n\t * @param {(result: string) => void} success\n\t * @param {(reason: string) => void} error\n\t */\n\tfunction loadFile(src, success, error) {\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.open('GET', src, true);\n\t\txhr.onreadystatechange = function () {\n\t\t\tif (xhr.readyState == 4) {\n\t\t\t\tif (xhr.status < 400 && xhr.responseText) {\n\t\t\t\t\tsuccess(xhr.responseText);\n\t\t\t\t} else {\n\t\t\t\t\tif (xhr.status >= 400) {\n\t\t\t\t\t\terror(FAILURE_MESSAGE(xhr.status, xhr.statusText));\n\t\t\t\t\t} else {\n\t\t\t\t\t\terror(FAILURE_EMPTY_MESSAGE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\txhr.send(null);\n\t}\n\n\t/**\n\t * Parses the given range.\n\t *\n\t * This returns a range with inclusive ends.\n\t *\n\t * @param {string | null | undefined} range\n\t * @returns {[number, number | undefined] | undefined}\n\t */\n\tfunction parseRange(range) {\n\t\tvar m = /^\\s*(\\d+)\\s*(?:(,)\\s*(?:(\\d+)\\s*)?)?$/.exec(range || '');\n\t\tif (m) {\n\t\t\tvar start = Number(m[1]);\n\t\t\tvar comma = m[2];\n\t\t\tvar end = m[3];\n\n\t\t\tif (!comma) {\n\t\t\t\treturn [start, start];\n\t\t\t}\n\t\t\tif (!end) {\n\t\t\t\treturn [start, undefined];\n\t\t\t}\n\t\t\treturn [start, Number(end)];\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tPrism.hooks.add('before-highlightall', function (env) {\n\t\tenv.selector += ', ' + SELECTOR;\n\t});\n\n\tPrism.hooks.add('before-sanity-check', function (env) {\n\t\tvar pre = /** @type {HTMLPreElement} */ (env.element);\n\t\tif (pre.matches(SELECTOR)) {\n\t\t\tenv.code = ''; // fast-path the whole thing and go to complete\n\n\t\t\tpre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading\n\n\t\t\t// add code element with loading message\n\t\t\tvar code = pre.appendChild(document.createElement('CODE'));\n\t\t\tcode.textContent = LOADING_MESSAGE;\n\n\t\t\tvar src = pre.getAttribute('data-src');\n\n\t\t\tvar language = env.language;\n\t\t\tif (language === 'none') {\n\t\t\t\t// the language might be 'none' because there is no language set;\n\t\t\t\t// in this case, we want to use the extension as the language\n\t\t\t\tvar extension = (/\\.(\\w+)$/.exec(src) || [, 'none'])[1];\n\t\t\t\tlanguage = EXTENSIONS[extension] || extension;\n\t\t\t}\n\n\t\t\t// set language classes\n\t\t\tPrism.util.setLanguage(code, language);\n\t\t\tPrism.util.setLanguage(pre, language);\n\n\t\t\t// preload the language\n\t\t\tvar autoloader = Prism.plugins.autoloader;\n\t\t\tif (autoloader) {\n\t\t\t\tautoloader.loadLanguages(language);\n\t\t\t}\n\n\t\t\t// load file\n\t\t\tloadFile(\n\t\t\t\tsrc,\n\t\t\t\tfunction (text) {\n\t\t\t\t\t// mark as loaded\n\t\t\t\t\tpre.setAttribute(STATUS_ATTR, STATUS_LOADED);\n\n\t\t\t\t\t// handle data-range\n\t\t\t\t\tvar range = parseRange(pre.getAttribute('data-range'));\n\t\t\t\t\tif (range) {\n\t\t\t\t\t\tvar lines = text.split(/\\r\\n?|\\n/g);\n\n\t\t\t\t\t\t// the range is one-based and inclusive on both ends\n\t\t\t\t\t\tvar start = range[0];\n\t\t\t\t\t\tvar end = range[1] == null ? lines.length : range[1];\n\n\t\t\t\t\t\tif (start < 0) { start += lines.length; }\n\t\t\t\t\t\tstart = Math.max(0, Math.min(start - 1, lines.length));\n\t\t\t\t\t\tif (end < 0) { end += lines.length; }\n\t\t\t\t\t\tend = Math.max(0, Math.min(end, lines.length));\n\n\t\t\t\t\t\ttext = lines.slice(start, end).join('\\n');\n\n\t\t\t\t\t\t// add data-start for line numbers\n\t\t\t\t\t\tif (!pre.hasAttribute('data-start')) {\n\t\t\t\t\t\t\tpre.setAttribute('data-start', String(start + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// highlight code\n\t\t\t\t\tcode.textContent = text;\n\t\t\t\t\tPrism.highlightElement(code);\n\t\t\t\t},\n\t\t\t\tfunction (error) {\n\t\t\t\t\t// mark as failed\n\t\t\t\t\tpre.setAttribute(STATUS_ATTR, STATUS_FAILED);\n\n\t\t\t\t\tcode.textContent = error;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t});\n\n\tPrism.plugins.fileHighlight = {\n\t\t/**\n\t\t * Executes the File Highlight plugin for all matching `pre` elements under the given container.\n\t\t *\n\t\t * Note: Elements which are already loaded or currently loading will not be touched by this method.\n\t\t *\n\t\t * @param {ParentNode} [container=document]\n\t\t */\n\t\thighlight: function highlight(container) {\n\t\t\tvar elements = (container || document).querySelectorAll(SELECTOR);\n\n\t\t\tfor (var i = 0, element; (element = elements[i++]);) {\n\t\t\t\tPrism.highlightElement(element);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar logged = false;\n\t/** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */\n\tPrism.fileHighlight = function () {\n\t\tif (!logged) {\n\t\t\tconsole.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');\n\t\t\tlogged = true;\n\t\t}\n\t\tPrism.plugins.fileHighlight.highlight.apply(this, arguments);\n\t};\n\n}());\n", "Prism.languages.clike = {\n\t'comment': [\n\t\t{\n\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t}\n\t],\n\t'string': {\n\t\tpattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t\tgreedy: true\n\t},\n\t'class-name': {\n\t\tpattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'punctuation': /[.\\\\]/\n\t\t}\n\t},\n\t'keyword': /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n\t'boolean': /\\b(?:false|true)\\b/,\n\t'function': /\\b\\w+(?=\\()/,\n\t'number': /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n\t'operator': /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n", "Prism.languages.javascript = Prism.languages.extend('clike', {\n\t'class-name': [\n\t\tPrism.languages.clike['class-name'],\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'keyword': [\n\t\t{\n\t\t\tpattern: /((?:^|\\})\\s*)catch\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t],\n\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n\t'function': /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n\t'number': {\n\t\tpattern: RegExp(\n\t\t\t/(^|[^\\w$])/.source +\n\t\t\t'(?:' +\n\t\t\t(\n\t\t\t\t// constant\n\t\t\t\t/NaN|Infinity/.source +\n\t\t\t\t'|' +\n\t\t\t\t// binary integer\n\t\t\t\t/0[bB][01]+(?:_[01]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// octal integer\n\t\t\t\t/0[oO][0-7]+(?:_[0-7]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// hexadecimal integer\n\t\t\t\t/0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// decimal bigint\n\t\t\t\t/\\d+(?:_\\d+)*n/.source +\n\t\t\t\t'|' +\n\t\t\t\t// decimal number (integer or float) but no bigint\n\t\t\t\t/(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source\n\t\t\t) +\n\t\t\t')' +\n\t\t\t/(?![\\w$])/.source\n\t\t),\n\t\tlookbehind: true\n\t},\n\t'operator': /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n});\n\nPrism.languages.javascript['class-name'][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n\t'regex': {\n\t\tpattern: RegExp(\n\t\t\t// lookbehind\n\t\t\t// eslint-disable-next-line regexp/no-dupe-characters-character-class\n\t\t\t/((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/.source +\n\t\t\t// Regex pattern:\n\t\t\t// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character\n\t\t\t// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible\n\t\t\t// with the only syntax, so we have to define 2 different regex patterns.\n\t\t\t/\\//.source +\n\t\t\t'(?:' +\n\t\t\t/(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}/.source +\n\t\t\t'|' +\n\t\t\t// `v` flag syntax. This supports 3 levels of nested character classes.\n\t\t\t/(?:\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +\n\t\t\t')' +\n\t\t\t// lookahead\n\t\t\t/(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/.source\n\t\t),\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'regex-source': {\n\t\t\t\tpattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'language-regex',\n\t\t\t\tinside: Prism.languages.regex\n\t\t\t},\n\t\t\t'regex-delimiter': /^\\/|\\/$/,\n\t\t\t'regex-flags': /^[a-z]+$/,\n\t\t}\n\t},\n\t// This must be declared before keyword because we use \"function\" inside the look-forward\n\t'function-variable': {\n\t\tpattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n\t\talias: 'function'\n\t},\n\t'parameter': [\n\t\t{\n\t\t\tpattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t}\n\t],\n\t'constant': /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\n\nPrism.languages.insertBefore('javascript', 'string', {\n\t'hashbang': {\n\t\tpattern: /^#!.*/,\n\t\tgreedy: true,\n\t\talias: 'comment'\n\t},\n\t'template-string': {\n\t\tpattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'template-punctuation': {\n\t\t\t\tpattern: /^`|`$/,\n\t\t\t\talias: 'string'\n\t\t\t},\n\t\t\t'interpolation': {\n\t\t\t\tpattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\t\tpattern: /^\\$\\{|\\}$/,\n\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t},\n\t\t\t\t\trest: Prism.languages.javascript\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t}\n\t},\n\t'string-property': {\n\t\tpattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\talias: 'property'\n\t}\n});\n\nPrism.languages.insertBefore('javascript', 'operator', {\n\t'literal-property': {\n\t\tpattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n\t\tlookbehind: true,\n\t\talias: 'property'\n\t},\n});\n\nif (Prism.languages.markup) {\n\tPrism.languages.markup.tag.addInlined('script', 'javascript');\n\n\t// add attribute support for all DOM events.\n\t// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n\tPrism.languages.markup.tag.addAttribute(\n\t\t/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,\n\t\t'javascript'\n\t);\n}\n\nPrism.languages.js = Prism.languages.javascript;\n", "Prism.languages.markup = {\n\t'comment': {\n\t\tpattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n\t\tgreedy: true\n\t},\n\t'prolog': {\n\t\tpattern: /<\\?[\\s\\S]+?\\?>/,\n\t\tgreedy: true\n\t},\n\t'doctype': {\n\t\t// https://www.w3.org/TR/xml/#NT-doctypedecl\n\t\tpattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'internal-subset': {\n\t\t\t\tpattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: null // see below\n\t\t\t},\n\t\t\t'string': {\n\t\t\t\tpattern: /\"[^\"]*\"|'[^']*'/,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t'punctuation': /^<!|>$|[[\\]]/,\n\t\t\t'doctype-tag': /^DOCTYPE/i,\n\t\t\t'name': /[^\\s<>'\"]+/\n\t\t}\n\t},\n\t'cdata': {\n\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\tgreedy: true\n\t},\n\t'tag': {\n\t\tpattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'tag': {\n\t\t\t\tpattern: /^<\\/?[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^<\\/?/,\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'special-attr': [],\n\t\t\t'attr-value': {\n\t\t\t\tpattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /^(\\s*)[\"']|[\"']$/,\n\t\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t},\n\t\t\t'punctuation': /\\/?>/,\n\t\t\t'attr-name': {\n\t\t\t\tpattern: /[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\t'entity': [\n\t\t{\n\t\t\tpattern: /&[\\da-z]{1,8};/i,\n\t\t\talias: 'named-entity'\n\t\t},\n\t\t/&#x?[\\da-f]{1,8};/i\n\t]\n};\n\nPrism.languages.markup['tag'].inside['attr-value'].inside['entity'] =\n\tPrism.languages.markup['entity'];\nPrism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function (env) {\n\n\tif (env.type === 'entity') {\n\t\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\n\t}\n});\n\nObject.defineProperty(Prism.languages.markup.tag, 'addInlined', {\n\t/**\n\t * Adds an inlined language to markup.\n\t *\n\t * An example of an inlined language is CSS with `<style>` tags.\n\t *\n\t * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addInlined('style', 'css');\n\t */\n\tvalue: function addInlined(tagName, lang) {\n\t\tvar includedCdataInside = {};\n\t\tincludedCdataInside['language-' + lang] = {\n\t\t\tpattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\t\tincludedCdataInside['cdata'] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n\n\t\tvar inside = {\n\t\t\t'included-cdata': {\n\t\t\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\t\t\tinside: includedCdataInside\n\t\t\t}\n\t\t};\n\t\tinside['language-' + lang] = {\n\t\t\tpattern: /[\\s\\S]+/,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\n\t\tvar def = {};\n\t\tdef[tagName] = {\n\t\t\tpattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: inside\n\t\t};\n\n\t\tPrism.languages.insertBefore('markup', 'cdata', def);\n\t}\n});\nObject.defineProperty(Prism.languages.markup.tag, 'addAttribute', {\n\t/**\n\t * Adds an pattern to highlight languages embedded in HTML attributes.\n\t *\n\t * An example of an inlined language is CSS with `style` attributes.\n\t *\n\t * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addAttribute('style', 'css');\n\t */\n\tvalue: function (attrName, lang) {\n\t\tPrism.languages.markup.tag.inside['special-attr'].push({\n\t\t\tpattern: RegExp(\n\t\t\t\t/(^|[\"'\\s])/.source + '(?:' + attrName + ')' + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source,\n\t\t\t\t'i'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'attr-name': /^[^\\s=]+/,\n\t\t\t\t'attr-value': {\n\t\t\t\t\tpattern: /=[\\s\\S]+/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'value': {\n\t\t\t\t\t\t\tpattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\talias: [lang, 'language-' + lang],\n\t\t\t\t\t\t\tinside: Prism.languages[lang]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/\"|'/\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n});\n\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\n\nPrism.languages.xml = Prism.languages.extend('markup', {});\nPrism.languages.ssml = Prism.languages.xml;\nPrism.languages.atom = Prism.languages.xml;\nPrism.languages.rss = Prism.languages.xml;\n", "(function (Prism) {\n\n\t// Allow only one line break\n\tvar inner = /(?:\\\\.|[^\\\\\\n\\r]|(?:\\n|\\r\\n?)(?![\\r\\n]))/.source;\n\n\t/**\n\t * This function is intended for the creation of the bold or italic pattern.\n\t *\n\t * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.\n\t *\n\t * _Note:_ Keep in mind that this adds a capturing group.\n\t *\n\t * @param {string} pattern\n\t * @returns {RegExp}\n\t */\n\tfunction createInline(pattern) {\n\t\tpattern = pattern.replace(/<inner>/g, function () { return inner; });\n\t\treturn RegExp(/((?:^|[^\\\\])(?:\\\\{2})*)/.source + '(?:' + pattern + ')');\n\t}\n\n\n\tvar tableCell = /(?:\\\\.|``(?:[^`\\r\\n]|`(?!`))+``|`[^`\\r\\n]+`|[^\\\\|\\r\\n`])+/.source;\n\tvar tableRow = /\\|?__(?:\\|__)+\\|?(?:(?:\\n|\\r\\n?)|(?![\\s\\S]))/.source.replace(/__/g, function () { return tableCell; });\n\tvar tableLine = /\\|?[ \\t]*:?-{3,}:?[ \\t]*(?:\\|[ \\t]*:?-{3,}:?[ \\t]*)+\\|?(?:\\n|\\r\\n?)/.source;\n\n\n\tPrism.languages.markdown = Prism.languages.extend('markup', {});\n\tPrism.languages.insertBefore('markdown', 'prolog', {\n\t\t'front-matter-block': {\n\t\t\tpattern: /(^(?:\\s*[\\r\\n])?)---(?!.)[\\s\\S]*?[\\r\\n]---(?!.)/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /^---|---$/,\n\t\t\t\t'front-matter': {\n\t\t\t\t\tpattern: /\\S+(?:\\s+\\S+)*/,\n\t\t\t\t\talias: ['yaml', 'language-yaml'],\n\t\t\t\t\tinside: Prism.languages.yaml\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'blockquote': {\n\t\t\t// > ...\n\t\t\tpattern: /^>(?:[\\t ]*>)*/m,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'table': {\n\t\t\tpattern: RegExp('^' + tableRow + tableLine + '(?:' + tableRow + ')*', 'm'),\n\t\t\tinside: {\n\t\t\t\t'table-data-rows': {\n\t\t\t\t\tpattern: RegExp('^(' + tableRow + tableLine + ')(?:' + tableRow + ')*$'),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'table-data': {\n\t\t\t\t\t\t\tpattern: RegExp(tableCell),\n\t\t\t\t\t\t\tinside: Prism.languages.markdown\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'punctuation': /\\|/\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'table-line': {\n\t\t\t\t\tpattern: RegExp('^(' + tableRow + ')' + tableLine + '$'),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'punctuation': /\\||:?-{3,}:?/\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'table-header-row': {\n\t\t\t\t\tpattern: RegExp('^' + tableRow + '$'),\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'table-header': {\n\t\t\t\t\t\t\tpattern: RegExp(tableCell),\n\t\t\t\t\t\t\talias: 'important',\n\t\t\t\t\t\t\tinside: Prism.languages.markdown\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'punctuation': /\\|/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'code': [\n\t\t\t{\n\t\t\t\t// Prefixed by 4 spaces or 1 tab and preceded by an empty line\n\t\t\t\tpattern: /((?:^|\\n)[ \\t]*\\n|(?:^|\\r\\n?)[ \\t]*\\r\\n?)(?: {4}|\\t).+(?:(?:\\n|\\r\\n?)(?: {4}|\\t).+)*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'keyword'\n\t\t\t},\n\t\t\t{\n\t\t\t\t// ```optional language\n\t\t\t\t// code block\n\t\t\t\t// ```\n\t\t\t\tpattern: /^```[\\s\\S]*?^```$/m,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'code-block': {\n\t\t\t\t\t\tpattern: /^(```.*(?:\\n|\\r\\n?))[\\s\\S]+?(?=(?:\\n|\\r\\n?)^```$)/m,\n\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t},\n\t\t\t\t\t'code-language': {\n\t\t\t\t\t\tpattern: /^(```).+/,\n\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t},\n\t\t\t\t\t'punctuation': /```/\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'title': [\n\t\t\t{\n\t\t\t\t// title 1\n\t\t\t\t// =======\n\n\t\t\t\t// title 2\n\t\t\t\t// -------\n\t\t\t\tpattern: /\\S.*(?:\\n|\\r\\n?)(?:==+|--+)(?=[ \\t]*$)/m,\n\t\t\t\talias: 'important',\n\t\t\t\tinside: {\n\t\t\t\t\tpunctuation: /==+$|--+$/\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\t// # title 1\n\t\t\t\t// ###### title 6\n\t\t\t\tpattern: /(^\\s*)#.+/m,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'important',\n\t\t\t\tinside: {\n\t\t\t\t\tpunctuation: /^#+|#+$/\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'hr': {\n\t\t\t// ***\n\t\t\t// ---\n\t\t\t// * * *\n\t\t\t// -----------\n\t\t\tpattern: /(^\\s*)([*-])(?:[\\t ]*\\2){2,}(?=\\s*$)/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'list': {\n\t\t\t// * item\n\t\t\t// + item\n\t\t\t// - item\n\t\t\t// 1. item\n\t\t\tpattern: /(^\\s*)(?:[*+-]|\\d+\\.)(?=[\\t ].)/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'url-reference': {\n\t\t\t// [id]: http://example.com \"Optional title\"\n\t\t\t// [id]: http://example.com 'Optional title'\n\t\t\t// [id]: http://example.com (Optional title)\n\t\t\t// [id]: <http://example.com> \"Optional title\"\n\t\t\tpattern: /!?\\[[^\\]]+\\]:[\\t ]+(?:\\S+|<(?:\\\\.|[^>\\\\])+>)(?:[\\t ]+(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\)))?/,\n\t\t\tinside: {\n\t\t\t\t'variable': {\n\t\t\t\t\tpattern: /^(!?\\[)[^\\]]+/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'string': /(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\))$/,\n\t\t\t\t'punctuation': /^[\\[\\]!:]|[<>]/\n\t\t\t},\n\t\t\talias: 'url'\n\t\t},\n\t\t'bold': {\n\t\t\t// **strong**\n\t\t\t// __strong__\n\n\t\t\t// allow one nested instance of italic text using the same delimiter\n\t\t\tpattern: createInline(/\\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\\b|\\*\\*(?:(?!\\*)<inner>|\\*(?:(?!\\*)<inner>)+\\*)+\\*\\*/.source),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'content': {\n\t\t\t\t\tpattern: /(^..)[\\s\\S]+(?=..$)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {} // see below\n\t\t\t\t},\n\t\t\t\t'punctuation': /\\*\\*|__/\n\t\t\t}\n\t\t},\n\t\t'italic': {\n\t\t\t// *em*\n\t\t\t// _em_\n\n\t\t\t// allow one nested instance of bold text using the same delimiter\n\t\t\tpattern: createInline(/\\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\\b|\\*(?:(?!\\*)<inner>|\\*\\*(?:(?!\\*)<inner>)+\\*\\*)+\\*/.source),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'content': {\n\t\t\t\t\tpattern: /(^.)[\\s\\S]+(?=.$)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {} // see below\n\t\t\t\t},\n\t\t\t\t'punctuation': /[*_]/\n\t\t\t}\n\t\t},\n\t\t'strike': {\n\t\t\t// ~~strike through~~\n\t\t\t// ~strike~\n\t\t\t// eslint-disable-next-line regexp/strict\n\t\t\tpattern: createInline(/(~~?)(?:(?!~)<inner>)+\\2/.source),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'content': {\n\t\t\t\t\tpattern: /(^~~?)[\\s\\S]+(?=\\1$)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {} // see below\n\t\t\t\t},\n\t\t\t\t'punctuation': /~~?/\n\t\t\t}\n\t\t},\n\t\t'code-snippet': {\n\t\t\t// `code`\n\t\t\t// ``code``\n\t\t\tpattern: /(^|[^\\\\`])(?:``[^`\\r\\n]+(?:`[^`\\r\\n]+)*``(?!`)|`[^`\\r\\n]+`(?!`))/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\talias: ['code', 'keyword']\n\t\t},\n\t\t'url': {\n\t\t\t// [example](http://example.com \"Optional title\")\n\t\t\t// [example][id]\n\t\t\t// [example] [id]\n\t\t\tpattern: createInline(/!?\\[(?:(?!\\])<inner>)+\\](?:\\([^\\s)]+(?:[\\t ]+\"(?:\\\\.|[^\"\\\\])*\")?\\)|[ \\t]?\\[(?:(?!\\])<inner>)+\\])/.source),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'operator': /^!/,\n\t\t\t\t'content': {\n\t\t\t\t\tpattern: /(^\\[)[^\\]]+(?=\\])/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {} // see below\n\t\t\t\t},\n\t\t\t\t'variable': {\n\t\t\t\t\tpattern: /(^\\][ \\t]?\\[)[^\\]]+(?=\\]$)/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'url': {\n\t\t\t\t\tpattern: /(^\\]\\()[^\\s)]+/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'string': {\n\t\t\t\t\tpattern: /(^[ \\t]+)\"(?:\\\\.|[^\"\\\\])*\"(?=\\)$)/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t['url', 'bold', 'italic', 'strike'].forEach(function (token) {\n\t\t['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(function (inside) {\n\t\t\tif (token !== inside) {\n\t\t\t\tPrism.languages.markdown[token].inside.content.inside[inside] = Prism.languages.markdown[inside];\n\t\t\t}\n\t\t});\n\t});\n\n\tPrism.hooks.add('after-tokenize', function (env) {\n\t\tif (env.language !== 'markdown' && env.language !== 'md') {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction walkTokens(tokens) {\n\t\t\tif (!tokens || typeof tokens === 'string') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var i = 0, l = tokens.length; i < l; i++) {\n\t\t\t\tvar token = tokens[i];\n\n\t\t\t\tif (token.type !== 'code') {\n\t\t\t\t\twalkTokens(token.content);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token\n\t\t\t\t * is optional. But the grammar is defined so that there is only one case we have to handle:\n\t\t\t\t *\n\t\t\t\t * token.content = [\n\t\t\t\t *     <span class=\"punctuation\">```</span>,\n\t\t\t\t *     <span class=\"code-language\">xxxx</span>,\n\t\t\t\t *     '\\n', // exactly one new lines (\\r or \\n or \\r\\n)\n\t\t\t\t *     <span class=\"code-block\">...</span>,\n\t\t\t\t *     '\\n', // exactly one new lines again\n\t\t\t\t *     <span class=\"punctuation\">```</span>\n\t\t\t\t * ];\n\t\t\t\t */\n\n\t\t\t\tvar codeLang = token.content[1];\n\t\t\t\tvar codeBlock = token.content[3];\n\n\t\t\t\tif (codeLang && codeBlock &&\n\t\t\t\t\tcodeLang.type === 'code-language' && codeBlock.type === 'code-block' &&\n\t\t\t\t\ttypeof codeLang.content === 'string') {\n\n\t\t\t\t\t// this might be a language that Prism does not support\n\n\t\t\t\t\t// do some replacements to support C++, C#, and F#\n\t\t\t\t\tvar lang = codeLang.content.replace(/\\b#/g, 'sharp').replace(/\\b\\+\\+/g, 'pp');\n\t\t\t\t\t// only use the first word\n\t\t\t\t\tlang = (/[a-z][\\w-]*/i.exec(lang) || [''])[0].toLowerCase();\n\t\t\t\t\tvar alias = 'language-' + lang;\n\n\t\t\t\t\t// add alias\n\t\t\t\t\tif (!codeBlock.alias) {\n\t\t\t\t\t\tcodeBlock.alias = [alias];\n\t\t\t\t\t} else if (typeof codeBlock.alias === 'string') {\n\t\t\t\t\t\tcodeBlock.alias = [codeBlock.alias, alias];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcodeBlock.alias.push(alias);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twalkTokens(env.tokens);\n\t});\n\n\tPrism.hooks.add('wrap', function (env) {\n\t\tif (env.type !== 'code-block') {\n\t\t\treturn;\n\t\t}\n\n\t\tvar codeLang = '';\n\t\tfor (var i = 0, l = env.classes.length; i < l; i++) {\n\t\t\tvar cls = env.classes[i];\n\t\t\tvar match = /language-(.+)/.exec(cls);\n\t\t\tif (match) {\n\t\t\t\tcodeLang = match[1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tvar grammar = Prism.languages[codeLang];\n\n\t\tif (!grammar) {\n\t\t\tif (codeLang && codeLang !== 'none' && Prism.plugins.autoloader) {\n\t\t\t\tvar id = 'md-' + new Date().valueOf() + '-' + Math.floor(Math.random() * 1e16);\n\t\t\t\tenv.attributes['id'] = id;\n\n\t\t\t\tPrism.plugins.autoloader.loadLanguages(codeLang, function () {\n\t\t\t\t\tvar ele = document.getElementById(id);\n\t\t\t\t\tif (ele) {\n\t\t\t\t\t\tele.innerHTML = Prism.highlight(ele.textContent, Prism.languages[codeLang], codeLang);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tenv.content = Prism.highlight(textContent(env.content), grammar, codeLang);\n\t\t}\n\t});\n\n\tvar tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, 'gi');\n\n\t/**\n\t * A list of known entity names.\n\t *\n\t * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.\n\t *\n\t * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}\n\t */\n\tvar KNOWN_ENTITY_NAMES = {\n\t\t'amp': '&',\n\t\t'lt': '<',\n\t\t'gt': '>',\n\t\t'quot': '\"',\n\t};\n\n\t// IE 11 doesn't support `String.fromCodePoint`\n\tvar fromCodePoint = String.fromCodePoint || String.fromCharCode;\n\n\t/**\n\t * Returns the text content of a given HTML source code string.\n\t *\n\t * @param {string} html\n\t * @returns {string}\n\t */\n\tfunction textContent(html) {\n\t\t// remove all tags\n\t\tvar text = html.replace(tagPattern, '');\n\n\t\t// decode known entities\n\t\ttext = text.replace(/&(\\w{1,8}|#x?[\\da-f]{1,8});/gi, function (m, code) {\n\t\t\tcode = code.toLowerCase();\n\n\t\t\tif (code[0] === '#') {\n\t\t\t\tvar value;\n\t\t\t\tif (code[1] === 'x') {\n\t\t\t\t\tvalue = parseInt(code.slice(2), 16);\n\t\t\t\t} else {\n\t\t\t\t\tvalue = Number(code.slice(1));\n\t\t\t\t}\n\n\t\t\t\treturn fromCodePoint(value);\n\t\t\t} else {\n\t\t\t\tvar known = KNOWN_ENTITY_NAMES[code];\n\t\t\t\tif (known) {\n\t\t\t\t\treturn known;\n\t\t\t\t}\n\n\t\t\t\t// unable to decode\n\t\t\t\treturn m;\n\t\t\t}\n\t\t});\n\n\t\treturn text;\n\t}\n\n\tPrism.languages.md = Prism.languages.markdown;\n\n}(Prism));\n", "Prism.languages.c = Prism.languages.extend('clike', {\n\t'comment': {\n\t\tpattern: /\\/\\/(?:[^\\r\\n\\\\]|\\\\(?:\\r\\n?|\\n|(?![\\r\\n])))*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n\t\tgreedy: true\n\t},\n\t'string': {\n\t\t// https://en.cppreference.com/w/c/language/string_literal\n\t\tpattern: /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n\t\tgreedy: true\n\t},\n\t'class-name': {\n\t\tpattern: /(\\b(?:enum|struct)\\s+(?:__attribute__\\s*\\(\\([\\s\\S]*?\\)\\)\\s*)?)\\w+|\\b[a-z]\\w*_t\\b/,\n\t\tlookbehind: true\n\t},\n\t'keyword': /\\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b/,\n\t'function': /\\b[a-z_]\\w*(?=\\s*\\()/i,\n\t'number': /(?:\\b0x(?:[\\da-f]+(?:\\.[\\da-f]*)?|\\.[\\da-f]+)(?:p[+-]?\\d+)?|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)[ful]{0,4}/i,\n\t'operator': />>=?|<<=?|->|([-+&|:])\\1|[?:~]|[-+*/%&|^!=<>]=?/\n});\n\nPrism.languages.insertBefore('c', 'string', {\n\t'char': {\n\t\t// https://en.cppreference.com/w/c/language/character_constant\n\t\tpattern: /'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n]){0,32}'/,\n\t\tgreedy: true\n\t}\n});\n\nPrism.languages.insertBefore('c', 'string', {\n\t'macro': {\n\t\t// allow for multiline macro definitions\n\t\t// spaces after the # character compile fine with gcc\n\t\tpattern: /(^[\\t ]*)#\\s*[a-z](?:[^\\r\\n\\\\/]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|\\\\(?:\\r\\n|[\\s\\S]))*/im,\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\talias: 'property',\n\t\tinside: {\n\t\t\t'string': [\n\t\t\t\t{\n\t\t\t\t\t// highlight the path of the include statement as a string\n\t\t\t\t\tpattern: /^(#\\s*include\\s*)<[^>]+>/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\tPrism.languages.c['string']\n\t\t\t],\n\t\t\t'char': Prism.languages.c['char'],\n\t\t\t'comment': Prism.languages.c['comment'],\n\t\t\t'macro-name': [\n\t\t\t\t{\n\t\t\t\t\tpattern: /(^#\\s*define\\s+)\\w+\\b(?!\\()/i,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tpattern: /(^#\\s*define\\s+)\\w+\\b(?=\\()/i,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'function'\n\t\t\t\t}\n\t\t\t],\n\t\t\t// highlight macro directives as keywords\n\t\t\t'directive': {\n\t\t\t\tpattern: /^(#\\s*)[a-z]+/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'keyword'\n\t\t\t},\n\t\t\t'directive-hash': /^#/,\n\t\t\t'punctuation': /##|\\\\(?=[\\r\\n])/,\n\t\t\t'expression': {\n\t\t\t\tpattern: /\\S[\\s\\S]*/,\n\t\t\t\tinside: Prism.languages.c\n\t\t\t}\n\t\t}\n\t}\n});\n\nPrism.languages.insertBefore('c', 'function', {\n\t// highlight predefined macros as constants\n\t'constant': /\\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\\b/\n});\n\ndelete Prism.languages.c['boolean'];\n", "(function (Prism) {\n\n\tvar string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n\n\tPrism.languages.css = {\n\t\t'comment': /\\/\\*[\\s\\S]*?\\*\\//,\n\t\t'atrule': {\n\t\t\tpattern: RegExp('@[\\\\w-](?:' + /[^;{\\s\"']|\\s+(?!\\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\\s*\\{))/.source),\n\t\t\tinside: {\n\t\t\t\t'rule': /^@[\\w-]+/,\n\t\t\t\t'selector-function-argument': {\n\t\t\t\t\tpattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'selector'\n\t\t\t\t},\n\t\t\t\t'keyword': {\n\t\t\t\t\tpattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t}\n\t\t\t\t// See rest below\n\t\t\t}\n\t\t},\n\t\t'url': {\n\t\t\t// https://drafts.csswg.org/css-values-3/#urls\n\t\t\tpattern: RegExp('\\\\burl\\\\((?:' + string.source + '|' + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + ')\\\\)', 'i'),\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'function': /^url/i,\n\t\t\t\t'punctuation': /^\\(|\\)$/,\n\t\t\t\t'string': {\n\t\t\t\t\tpattern: RegExp('^' + string.source + '$'),\n\t\t\t\t\talias: 'url'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'selector': {\n\t\t\tpattern: RegExp('(^|[{}\\\\s])[^{}\\\\s](?:[^{};\"\\'\\\\s]|\\\\s+(?![\\\\s{])|' + string.source + ')*(?=\\\\s*\\\\{)'),\n\t\t\tlookbehind: true\n\t\t},\n\t\t'string': {\n\t\t\tpattern: string,\n\t\t\tgreedy: true\n\t\t},\n\t\t'property': {\n\t\t\tpattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'important': /!important\\b/i,\n\t\t'function': {\n\t\t\tpattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'punctuation': /[(){};:,]/\n\t};\n\n\tPrism.languages.css['atrule'].inside.rest = Prism.languages.css;\n\n\tvar markup = Prism.languages.markup;\n\tif (markup) {\n\t\tmarkup.tag.addInlined('style', 'css');\n\t\tmarkup.tag.addAttribute('style', 'css');\n\t}\n\n}(Prism));\n", "Prism.languages.objectivec = Prism.languages.extend('c', {\n\t'string': {\n\t\tpattern: /@?\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n\t\tgreedy: true\n\t},\n\t'keyword': /\\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\\b/,\n\t'operator': /-[->]?|\\+\\+?|!=?|<<?=?|>>?=?|==?|&&?|\\|\\|?|[~^%?*\\/@]/\n});\n\ndelete Prism.languages.objectivec['class-name'];\n\nPrism.languages.objc = Prism.languages.objectivec;\n", "Prism.languages.sql = {\n\t'comment': {\n\t\tpattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|(?:--|\\/\\/|#).*)/,\n\t\tlookbehind: true\n\t},\n\t'variable': [\n\t\t{\n\t\t\tpattern: /@([\"'`])(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1/,\n\t\t\tgreedy: true\n\t\t},\n\t\t/@[\\w.$]+/\n\t],\n\t'string': {\n\t\tpattern: /(^|[^@\\\\])(\"|')(?:\\\\[\\s\\S]|(?!\\2)[^\\\\]|\\2\\2)*\\2/,\n\t\tgreedy: true,\n\t\tlookbehind: true\n\t},\n\t'identifier': {\n\t\tpattern: /(^|[^@\\\\])`(?:\\\\[\\s\\S]|[^`\\\\]|``)*`/,\n\t\tgreedy: true,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'punctuation': /^`|`$/\n\t\t}\n\t},\n\t'function': /\\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\\s*\\()/i, // Should we highlight user defined functions too?\n\t'keyword': /\\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\\b/i,\n\t'boolean': /\\b(?:FALSE|NULL|TRUE)\\b/i,\n\t'number': /\\b0x[\\da-f]+\\b|\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+\\b/i,\n\t'operator': /[-+*\\/=%^~]|&&?|\\|\\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\\b/i,\n\t'punctuation': /[;[\\]()`,.]/\n};\n", "Prism.languages.python = {\n\t'comment': {\n\t\tpattern: /(^|[^\\\\])#.*/,\n\t\tlookbehind: true,\n\t\tgreedy: true\n\t},\n\t'string-interpolation': {\n\t\tpattern: /(?:f|fr|rf)(?:(\"\"\"|''')[\\s\\S]*?\\1|(\"|')(?:\\\\.|(?!\\2)[^\\\\\\r\\n])*\\2)/i,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'interpolation': {\n\t\t\t\t// \"{\" <expression> <optional \"!s\", \"!r\", or \"!a\"> <optional \":\" format specifier> \"}\"\n\t\t\t\tpattern: /((?:^|[^{])(?:\\{\\{)*)\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}])+\\})+\\})+\\}/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'format-spec': {\n\t\t\t\t\t\tpattern: /(:)[^:(){}]+(?=\\}$)/,\n\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t},\n\t\t\t\t\t'conversion-option': {\n\t\t\t\t\t\tpattern: /![sra](?=[:}]$)/,\n\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t},\n\t\t\t\t\trest: null\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t}\n\t},\n\t'triple-quoted-string': {\n\t\tpattern: /(?:[rub]|br|rb)?(\"\"\"|''')[\\s\\S]*?\\1/i,\n\t\tgreedy: true,\n\t\talias: 'string'\n\t},\n\t'string': {\n\t\tpattern: /(?:[rub]|br|rb)?(\"|')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/i,\n\t\tgreedy: true\n\t},\n\t'function': {\n\t\tpattern: /((?:^|\\s)def[ \\t]+)[a-zA-Z_]\\w*(?=\\s*\\()/g,\n\t\tlookbehind: true\n\t},\n\t'class-name': {\n\t\tpattern: /(\\bclass\\s+)\\w+/i,\n\t\tlookbehind: true\n\t},\n\t'decorator': {\n\t\tpattern: /(^[\\t ]*)@\\w+(?:\\.\\w+)*/m,\n\t\tlookbehind: true,\n\t\talias: ['annotation', 'punctuation'],\n\t\tinside: {\n\t\t\t'punctuation': /\\./\n\t\t}\n\t},\n\t'keyword': /\\b(?:_(?=\\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\\b/,\n\t'builtin': /\\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\\b/,\n\t'boolean': /\\b(?:False|None|True)\\b/,\n\t'number': /\\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\\b|(?:\\b\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\B\\.\\d+(?:_\\d+)*)(?:e[+-]?\\d+(?:_\\d+)*)?j?(?!\\w)/i,\n\t'operator': /[-+%=]=?|!=|:=|\\*\\*?=?|\\/\\/?=?|<[<=>]?|>[=>]?|[&|^~]/,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n\nPrism.languages.python['string-interpolation'].inside['interpolation'].inside.rest = Prism.languages.python;\n\nPrism.languages.py = Prism.languages.python;\n", "(function (Prism) {\n\n\tvar multilineComment = /\\/\\*(?:[^*/]|\\*(?!\\/)|\\/(?!\\*)|<self>)*\\*\\//.source;\n\tfor (var i = 0; i < 2; i++) {\n\t\t// support 4 levels of nested comments\n\t\tmultilineComment = multilineComment.replace(/<self>/g, function () { return multilineComment; });\n\t}\n\tmultilineComment = multilineComment.replace(/<self>/g, function () { return /[^\\s\\S]/.source; });\n\n\n\tPrism.languages.rust = {\n\t\t'comment': [\n\t\t\t{\n\t\t\t\tpattern: RegExp(/(^|[^\\\\])/.source + multilineComment),\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true\n\t\t\t}\n\t\t],\n\t\t'string': {\n\t\t\tpattern: /b?\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|b?r(#*)\"(?:[^\"]|\"(?!\\1))*\"\\1/,\n\t\t\tgreedy: true\n\t\t},\n\t\t'char': {\n\t\t\tpattern: /b?'(?:\\\\(?:x[0-7][\\da-fA-F]|u\\{(?:[\\da-fA-F]_*){1,6}\\}|.)|[^\\\\\\r\\n\\t'])'/,\n\t\t\tgreedy: true\n\t\t},\n\t\t'attribute': {\n\t\t\tpattern: /#!?\\[(?:[^\\[\\]\"]|\"(?:\\\\[\\s\\S]|[^\\\\\"])*\")*\\]/,\n\t\t\tgreedy: true,\n\t\t\talias: 'attr-name',\n\t\t\tinside: {\n\t\t\t\t'string': null // see below\n\t\t\t}\n\t\t},\n\n\t\t// Closure params should not be confused with bitwise OR |\n\t\t'closure-params': {\n\t\t\tpattern: /([=(,:]\\s*|\\bmove\\s*)\\|[^|]*\\||\\|[^|]*\\|(?=\\s*(?:\\{|->))/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'closure-punctuation': {\n\t\t\t\t\tpattern: /^\\||\\|$/,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\trest: null // see below\n\t\t\t}\n\t\t},\n\n\t\t'lifetime-annotation': {\n\t\t\tpattern: /'\\w+/,\n\t\t\talias: 'symbol'\n\t\t},\n\n\t\t'fragment-specifier': {\n\t\t\tpattern: /(\\$\\w+:)[a-z]+/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'variable': /\\$\\w+/,\n\n\t\t'function-definition': {\n\t\t\tpattern: /(\\bfn\\s+)\\w+/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'function'\n\t\t},\n\t\t'type-definition': {\n\t\t\tpattern: /(\\b(?:enum|struct|trait|type|union)\\s+)\\w+/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'class-name'\n\t\t},\n\t\t'module-declaration': [\n\t\t\t{\n\t\t\t\tpattern: /(\\b(?:crate|mod)\\s+)[a-z][a-z_\\d]*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'namespace'\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(\\b(?:crate|self|super)\\s*)::\\s*[a-z][a-z_\\d]*\\b(?:\\s*::(?:\\s*[a-z][a-z_\\d]*\\s*::)*)?/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'namespace',\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /::/\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'keyword': [\n\t\t\t// https://github.com/rust-lang/reference/blob/master/src/keywords.md\n\t\t\t/\\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\\b/,\n\t\t\t// primitives and str\n\t\t\t// https://doc.rust-lang.org/stable/rust-by-example/primitives.html\n\t\t\t/\\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\\b/\n\t\t],\n\n\t\t// functions can technically start with an upper-case letter, but this will introduce a lot of false positives\n\t\t// and Rust's naming conventions recommend snake_case anyway.\n\t\t// https://doc.rust-lang.org/1.0.0/style/style/naming/README.html\n\t\t'function': /\\b[a-z_]\\w*(?=\\s*(?:::\\s*<|\\())/,\n\t\t'macro': {\n\t\t\tpattern: /\\b\\w+!/,\n\t\t\talias: 'property'\n\t\t},\n\t\t'constant': /\\b[A-Z_][A-Z_\\d]+\\b/,\n\t\t'class-name': /\\b[A-Z]\\w*\\b/,\n\n\t\t'namespace': {\n\t\t\tpattern: /(?:\\b[a-z][a-z_\\d]*\\s*::\\s*)*\\b[a-z][a-z_\\d]*\\s*::(?!\\s*<)/,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /::/\n\t\t\t}\n\t\t},\n\n\t\t// Hex, oct, bin, dec numbers with visual separators and type suffix\n\t\t'number': /\\b(?:0x[\\dA-Fa-f](?:_?[\\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\\d(?:_?\\d)*)?\\.)?\\d(?:_?\\d)*(?:[Ee][+-]?\\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\\b/,\n\t\t'boolean': /\\b(?:false|true)\\b/,\n\t\t'punctuation': /->|\\.\\.=|\\.{1,3}|::|[{}[\\];(),:]/,\n\t\t'operator': /[-+*\\/%!^]=?|=[=>]?|&[&=]?|\\|[|=]?|<<?=?|>>?=?|[@?]/\n\t};\n\n\tPrism.languages.rust['closure-params'].inside.rest = Prism.languages.rust;\n\tPrism.languages.rust['attribute'].inside['string'] = Prism.languages.rust['string'];\n\n}(Prism));\n", "Prism.languages.swift = {\n\t'comment': {\n\t\t// Nested comments are supported up to 2 levels\n\t\tpattern: /(^|[^\\\\:])(?:\\/\\/.*|\\/\\*(?:[^/*]|\\/(?!\\*)|\\*(?!\\/)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*\\*\\/)/,\n\t\tlookbehind: true,\n\t\tgreedy: true\n\t},\n\t'string-literal': [\n\t\t// https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html\n\t\t{\n\t\t\tpattern: RegExp(\n\t\t\t\t/(^|[^\"#])/.source\n\t\t\t\t+ '(?:'\n\t\t\t\t// single-line string\n\t\t\t\t+ /\"(?:\\\\(?:\\((?:[^()]|\\([^()]*\\))*\\)|\\r\\n|[^(])|[^\\\\\\r\\n\"])*\"/.source\n\t\t\t\t+ '|'\n\t\t\t\t// multi-line string\n\t\t\t\t+ /\"\"\"(?:\\\\(?:\\((?:[^()]|\\([^()]*\\))*\\)|[^(])|[^\\\\\"]|\"(?!\"\"))*\"\"\"/.source\n\t\t\t\t+ ')'\n\t\t\t\t+ /(?![\"#])/.source\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'interpolation': {\n\t\t\t\t\tpattern: /(\\\\\\()(?:[^()]|\\([^()]*\\))*(?=\\))/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: null // see below\n\t\t\t\t},\n\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\tpattern: /^\\)|\\\\\\($/,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\t'punctuation': /\\\\(?=[\\r\\n])/,\n\t\t\t\t'string': /[\\s\\S]+/\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tpattern: RegExp(\n\t\t\t\t/(^|[^\"#])(#+)/.source\n\t\t\t\t+ '(?:'\n\t\t\t\t// single-line string\n\t\t\t\t+ /\"(?:\\\\(?:#+\\((?:[^()]|\\([^()]*\\))*\\)|\\r\\n|[^#])|[^\\\\\\r\\n])*?\"/.source\n\t\t\t\t+ '|'\n\t\t\t\t// multi-line string\n\t\t\t\t+ /\"\"\"(?:\\\\(?:#+\\((?:[^()]|\\([^()]*\\))*\\)|[^#])|[^\\\\])*?\"\"\"/.source\n\t\t\t\t+ ')'\n\t\t\t\t+ '\\\\2'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'interpolation': {\n\t\t\t\t\tpattern: /(\\\\#+\\()(?:[^()]|\\([^()]*\\))*(?=\\))/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: null // see below\n\t\t\t\t},\n\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\tpattern: /^\\)|\\\\#+\\($/,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\t'string': /[\\s\\S]+/\n\t\t\t}\n\t\t},\n\t],\n\n\t'directive': {\n\t\t// directives with conditions\n\t\tpattern: RegExp(\n\t\t\t/#/.source\n\t\t\t+ '(?:'\n\t\t\t+ (\n\t\t\t\t/(?:elseif|if)\\b/.source\n\t\t\t\t+ '(?:[ \\t]*'\n\t\t\t\t// This regex is a little complex. It's equivalent to this:\n\t\t\t\t//   (?:![ \\t]*)?(?:\\b\\w+\\b(?:[ \\t]*<round>)?|<round>)(?:[ \\t]*(?:&&|\\|\\|))?\n\t\t\t\t// where <round> is a general parentheses expression.\n\t\t\t\t+ /(?:![ \\t]*)?(?:\\b\\w+\\b(?:[ \\t]*\\((?:[^()]|\\([^()]*\\))*\\))?|\\((?:[^()]|\\([^()]*\\))*\\))(?:[ \\t]*(?:&&|\\|\\|))?/.source\n\t\t\t\t+ ')+'\n\t\t\t)\n\t\t\t+ '|'\n\t\t\t+ /(?:else|endif)\\b/.source\n\t\t\t+ ')'\n\t\t),\n\t\talias: 'property',\n\t\tinside: {\n\t\t\t'directive-name': /^#\\w+/,\n\t\t\t'boolean': /\\b(?:false|true)\\b/,\n\t\t\t'number': /\\b\\d+(?:\\.\\d+)*\\b/,\n\t\t\t'operator': /!|&&|\\|\\||[<>]=?/,\n\t\t\t'punctuation': /[(),]/\n\t\t}\n\t},\n\t'literal': {\n\t\tpattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\\b/,\n\t\talias: 'constant'\n\t},\n\t'other-directive': {\n\t\tpattern: /#\\w+\\b/,\n\t\talias: 'property'\n\t},\n\n\t'attribute': {\n\t\tpattern: /@\\w+/,\n\t\talias: 'atrule'\n\t},\n\n\t'function-definition': {\n\t\tpattern: /(\\bfunc\\s+)\\w+/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'label': {\n\t\t// https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141\n\t\tpattern: /\\b(break|continue)\\s+\\w+|\\b[a-zA-Z_]\\w*(?=\\s*:\\s*(?:for|repeat|while)\\b)/,\n\t\tlookbehind: true,\n\t\talias: 'important'\n\t},\n\n\t'keyword': /\\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\\b/,\n\t'boolean': /\\b(?:false|true)\\b/,\n\t'nil': {\n\t\tpattern: /\\bnil\\b/,\n\t\talias: 'constant'\n\t},\n\n\t'short-argument': /\\$\\d+\\b/,\n\t'omit': {\n\t\tpattern: /\\b_\\b/,\n\t\talias: 'keyword'\n\t},\n\t'number': /\\b(?:[\\d_]+(?:\\.[\\de_]+)?|0x[a-f0-9_]+(?:\\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\\b/i,\n\n\t// A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.\n\t'class-name': /\\b[A-Z](?:[A-Z_\\d]*[a-z]\\w*)?\\b/,\n\t'function': /\\b[a-z_]\\w*(?=\\s*\\()/i,\n\t'constant': /\\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\\b/,\n\n\t// Operators are generic in Swift. Developers can even create new operators (e.g. +++).\n\t// https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481\n\t// This regex only supports ASCII operators.\n\t'operator': /[-+*/%=!<>&|^~?]+|\\.[.\\-+*/%=!<>&|^~?]+/,\n\t'punctuation': /[{}[\\]();,.:\\\\]/\n};\n\nPrism.languages.swift['string-literal'].forEach(function (rule) {\n\trule.inside['interpolation'].inside = Prism.languages.swift;\n});\n", "(function (Prism) {\n\n\tPrism.languages.typescript = Prism.languages.extend('javascript', {\n\t\t'class-name': {\n\t\t\tpattern: /(\\b(?:class|extends|implements|instanceof|interface|new|type)\\s+)(?!keyof\\b)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?:\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: null // see below\n\t\t},\n\t\t'builtin': /\\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\\b/,\n\t});\n\n\t// The keywords TypeScript adds to JavaScript\n\tPrism.languages.typescript.keyword.push(\n\t\t/\\b(?:abstract|declare|is|keyof|readonly|require)\\b/,\n\t\t// keywords that have to be followed by an identifier\n\t\t/\\b(?:asserts|infer|interface|module|namespace|type)\\b(?=\\s*(?:[{_$a-zA-Z\\xA0-\\uFFFF]|$))/,\n\t\t// This is for `import type *, {}`\n\t\t/\\btype\\b(?=\\s*(?:[\\{*]|$))/\n\t);\n\n\t// doesn't work with TS because TS is too complex\n\tdelete Prism.languages.typescript['parameter'];\n\tdelete Prism.languages.typescript['literal-property'];\n\n\t// a version of typescript specifically for highlighting types\n\tvar typeInside = Prism.languages.extend('typescript', {});\n\tdelete typeInside['class-name'];\n\n\tPrism.languages.typescript['class-name'].inside = typeInside;\n\n\tPrism.languages.insertBefore('typescript', 'function', {\n\t\t'decorator': {\n\t\t\tpattern: /@[$\\w\\xA0-\\uFFFF]+/,\n\t\t\tinside: {\n\t\t\t\t'at': {\n\t\t\t\t\tpattern: /^@/,\n\t\t\t\t\talias: 'operator'\n\t\t\t\t},\n\t\t\t\t'function': /^[\\s\\S]+/\n\t\t\t}\n\t\t},\n\t\t'generic-function': {\n\t\t\t// e.g. foo<T extends \"bar\" | \"baz\">( ...\n\t\t\tpattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\\s*\\()/,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'function': /^#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/,\n\t\t\t\t'generic': {\n\t\t\t\t\tpattern: /<[\\s\\S]+/, // everything after the first <\n\t\t\t\t\talias: 'class-name',\n\t\t\t\t\tinside: typeInside\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tPrism.languages.ts = Prism.languages.typescript;\n\n}(Prism));\n", "(function (Prism) {\n\n\tvar keywords = /\\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\\s*[(){}[\\]<>=%~.:,;?+\\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\\b/;\n\n\t// full package (optional) + parent classes (optional)\n\tvar classNamePrefix = /(?:[a-z]\\w*\\s*\\.\\s*)*(?:[A-Z]\\w*\\s*\\.\\s*)*/.source;\n\n\t// based on the java naming conventions\n\tvar className = {\n\t\tpattern: RegExp(/(^|[^\\w.])/.source + classNamePrefix + /[A-Z](?:[\\d_A-Z]*[a-z]\\w*)?\\b/.source),\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'namespace': {\n\t\t\t\tpattern: /^[a-z]\\w*(?:\\s*\\.\\s*[a-z]\\w*)*(?:\\s*\\.)?/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /\\./\n\t\t\t\t}\n\t\t\t},\n\t\t\t'punctuation': /\\./\n\t\t}\n\t};\n\n\tPrism.languages.java = Prism.languages.extend('clike', {\n\t\t'string': {\n\t\t\tpattern: /(^|[^\\\\])\"(?:\\\\.|[^\"\\\\\\r\\n])*\"/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t},\n\t\t'class-name': [\n\t\t\tclassName,\n\t\t\t{\n\t\t\t\t// variables, parameters, and constructor references\n\t\t\t\t// this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)\n\t\t\t\tpattern: RegExp(/(^|[^\\w.])/.source + classNamePrefix + /[A-Z]\\w*(?=\\s+\\w+\\s*[;,=()]|\\s*(?:\\[[\\s,]*\\]\\s*)?::\\s*new\\b)/.source),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: className.inside\n\t\t\t},\n\t\t\t{\n\t\t\t\t// class names based on keyword\n\t\t\t\t// this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)\n\t\t\t\tpattern: RegExp(/(\\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\\s+)/.source + classNamePrefix + /[A-Z]\\w*\\b/.source),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: className.inside\n\t\t\t}\n\t\t],\n\t\t'keyword': keywords,\n\t\t'function': [\n\t\t\tPrism.languages.clike.function,\n\t\t\t{\n\t\t\t\tpattern: /(::\\s*)[a-z_]\\w*/,\n\t\t\t\tlookbehind: true\n\t\t\t}\n\t\t],\n\t\t'number': /\\b0b[01][01_]*L?\\b|\\b0x(?:\\.[\\da-f_p+-]+|[\\da-f_]+(?:\\.[\\da-f_p+-]+)?)\\b|(?:\\b\\d[\\d_]*(?:\\.[\\d_]*)?|\\B\\.\\d[\\d_]*)(?:e[+-]?\\d[\\d_]*)?[dfl]?/i,\n\t\t'operator': {\n\t\t\tpattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\\+\\+|&&|\\|\\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'constant': /\\b[A-Z][A-Z_\\d]+\\b/\n\t});\n\n\tPrism.languages.insertBefore('java', 'string', {\n\t\t'triple-quoted-string': {\n\t\t\t// http://openjdk.java.net/jeps/355#Description\n\t\t\tpattern: /\"\"\"[ \\t]*[\\r\\n](?:(?:\"|\"\")?(?:\\\\.|[^\"\\\\]))*\"\"\"/,\n\t\t\tgreedy: true,\n\t\t\talias: 'string'\n\t\t},\n\t\t'char': {\n\t\t\tpattern: /'(?:\\\\.|[^'\\\\\\r\\n]){1,6}'/,\n\t\t\tgreedy: true\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('java', 'class-name', {\n\t\t'annotation': {\n\t\t\tpattern: /(^|[^.])@\\w+(?:\\s*\\.\\s*\\w+)*/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'generics': {\n\t\t\tpattern: /<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&))*>)*>)*>)*>/,\n\t\t\tinside: {\n\t\t\t\t'class-name': className,\n\t\t\t\t'keyword': keywords,\n\t\t\t\t'punctuation': /[<>(),.:]/,\n\t\t\t\t'operator': /[?&|]/\n\t\t\t}\n\t\t},\n\t\t'import': [\n\t\t\t{\n\t\t\t\tpattern: RegExp(/(\\bimport\\s+)/.source + classNamePrefix + /(?:[A-Z]\\w*|\\*)(?=\\s*;)/.source),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': className.inside.namespace,\n\t\t\t\t\t'punctuation': /\\./,\n\t\t\t\t\t'operator': /\\*/,\n\t\t\t\t\t'class-name': /\\w+/\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: RegExp(/(\\bimport\\s+static\\s+)/.source + classNamePrefix + /(?:\\w+|\\*)(?=\\s*;)/.source),\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'static',\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': className.inside.namespace,\n\t\t\t\t\t'static': /\\b\\w+$/,\n\t\t\t\t\t'punctuation': /\\./,\n\t\t\t\t\t'operator': /\\*/,\n\t\t\t\t\t'class-name': /\\w+/\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'namespace': {\n\t\t\tpattern: RegExp(\n\t\t\t\t/(\\b(?:exports|import(?:\\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\\s+)(?!<keyword>)[a-z]\\w*(?:\\.[a-z]\\w*)*\\.?/\n\t\t\t\t\t.source.replace(/<keyword>/g, function () { return keywords.source; })),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /\\./,\n\t\t\t}\n\t\t}\n\t});\n}(Prism));\n", "(function (Prism) {\n\n\tvar keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n\tvar modName = /\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g, function () { return keyword.source; });\n\n\tPrism.languages.cpp = Prism.languages.extend('c', {\n\t\t'class-name': [\n\t\t\t{\n\t\t\t\tpattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source\n\t\t\t\t\t.replace(/<keyword>/g, function () { return keyword.source; })),\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t// This is intended to capture the class name of method implementations like:\n\t\t\t//   void foo::bar() const {}\n\t\t\t// However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n\t\t\t// it starts with an uppercase letter. This approximation should give decent results.\n\t\t\t/\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/,\n\t\t\t// This will capture the class name before destructors like:\n\t\t\t//   Foo::~Foo() {}\n\t\t\t/\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i,\n\t\t\t// This also intends to capture the class name of method implementations but here the class has template\n\t\t\t// parameters, so it can't be a namespace (until C++ adds generic namespaces).\n\t\t\t/\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/\n\t\t],\n\t\t'keyword': keyword,\n\t\t'number': {\n\t\t\tpattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n\t\t\tgreedy: true\n\t\t},\n\t\t'operator': />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n\t\t'boolean': /\\b(?:false|true)\\b/\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'string', {\n\t\t'module': {\n\t\t\t// https://en.cppreference.com/w/cpp/language/modules\n\t\t\tpattern: RegExp(\n\t\t\t\t/(\\b(?:import|module)\\s+)/.source +\n\t\t\t\t'(?:' +\n\t\t\t\t// header-name\n\t\t\t\t/\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source +\n\t\t\t\t'|' +\n\t\t\t\t// module name or partition or both\n\t\t\t\t/<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g, function () { return modName; }) +\n\t\t\t\t')'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'string': /^[<\"][\\s\\S]+/,\n\t\t\t\t'operator': /:/,\n\t\t\t\t'punctuation': /\\./\n\t\t\t}\n\t\t},\n\t\t'raw-string': {\n\t\t\tpattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n\t\t\talias: 'string',\n\t\t\tgreedy: true\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'keyword', {\n\t\t'generic-function': {\n\t\t\tpattern: /\\b(?!operator\\b)[a-z_]\\w*\\s*<(?:[^<>]|<[^<>]*>)*>(?=\\s*\\()/i,\n\t\t\tinside: {\n\t\t\t\t'function': /^\\w+/,\n\t\t\t\t'generic': {\n\t\t\t\t\tpattern: /<[\\s\\S]+/,\n\t\t\t\t\talias: 'class-name',\n\t\t\t\t\tinside: Prism.languages.cpp\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'operator', {\n\t\t'double-colon': {\n\t\t\tpattern: /::/,\n\t\t\talias: 'punctuation'\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'class-name', {\n\t\t// the base clause is an optional list of parent classes\n\t\t// https://en.cppreference.com/w/cpp/language/class\n\t\t'base-clause': {\n\t\t\tpattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: Prism.languages.extend('cpp', {})\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('inside', 'double-colon', {\n\t\t// All untokenized words that are not namespaces should be class names\n\t\t'class-name': /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n\t}, Prism.languages.cpp['base-clause']);\n\n}(Prism));\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar Prism = require('prismjs');\nrequire('prismjs/components/prism-clike');\nrequire('prismjs/components/prism-javascript');\nrequire('prismjs/components/prism-markup');\nrequire('prismjs/components/prism-markdown');\nrequire('prismjs/components/prism-c');\nrequire('prismjs/components/prism-css');\nrequire('prismjs/components/prism-objectivec');\nrequire('prismjs/components/prism-sql');\nrequire('prismjs/components/prism-python');\nrequire('prismjs/components/prism-rust');\nrequire('prismjs/components/prism-swift');\nrequire('prismjs/components/prism-typescript');\nrequire('prismjs/components/prism-java');\nrequire('prismjs/components/prism-cpp');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst mapToPrismLanguage = language => {\n  // eslint-disable-next-line no-prototype-builtins\n  return language != null && Prism.languages.hasOwnProperty(language) ? language : undefined;\n};\nfunction hasChildDOMNodeTag(node, tagName) {\n  for (const child of node.childNodes) {\n    if (utils.isHTMLElement(child) && child.tagName === tagName) {\n      return true;\n    }\n    hasChildDOMNodeTag(child, tagName);\n  }\n  return false;\n}\nconst LANGUAGE_DATA_ATTRIBUTE = 'data-highlight-language';\n\n/** @noInheritDoc */\nclass CodeNode extends lexical.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'code';\n  }\n  static clone(node) {\n    return new CodeNode(node.__language, node.__key);\n  }\n  constructor(language, key) {\n    super(key);\n    this.__language = mapToPrismLanguage(language);\n  }\n\n  // View\n  createDOM(config) {\n    const element = document.createElement('code');\n    utils.addClassNamesToElement(element, config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const language = this.__language;\n    const prevLanguage = prevNode.__language;\n    if (language) {\n      if (language !== prevLanguage) {\n        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    } else if (prevLanguage) {\n      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      // Typically <pre> is used for code blocks, and <code> for inline code styles\n      // but if it's a multi line <code> we'll create a block. Pass through to\n      // inline format handled by TextNode otherwise.\n      code: node => {\n        const isMultiLine = node.textContent != null && (/\\r?\\n/.test(node.textContent) || hasChildDOMNodeTag(node, 'BR'));\n        return isMultiLine ? {\n          conversion: convertPreElement,\n          priority: 1\n        } : null;\n      },\n      div: node => ({\n        conversion: convertDivElement,\n        priority: 1\n      }),\n      pre: node => ({\n        conversion: convertPreElement,\n        priority: 0\n      }),\n      table: node => {\n        const table = node;\n        // domNode is a <table> since we matched it by nodeName\n        if (isGitHubCodeTable(table)) {\n          return {\n            conversion: convertTableElement,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      td: node => {\n        // element is a <td> since we matched it by nodeName\n        const td = node;\n        const table = td.closest('table');\n        if (isGitHubCodeCell(td)) {\n          return {\n            conversion: convertTableCellElement,\n            priority: 3\n          };\n        }\n        if (table && isGitHubCodeTable(table)) {\n          // Return a no-op if it's a table cell in a code table, but not a code line.\n          // Otherwise it'll fall back to the T\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      tr: node => {\n        // element is a <tr> since we matched it by nodeName\n        const tr = node;\n        const table = tr.closest('table');\n        if (table && isGitHubCodeTable(table)) {\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createCodeNode(serializedNode.language);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      language: this.getLanguage(),\n      type: 'code',\n      version: 1\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === '\\n' && children[childrenLength - 2].getTextContent() === '\\n' && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {\n      children[childrenLength - 1].remove();\n      children[childrenLength - 2].remove();\n      const newElement = lexical.$createParagraphNode();\n      this.insertAfter(newElement, restoreSelection);\n      return newElement;\n    }\n\n    // If the selection is within the codeblock, find all leading tabs and\n    // spaces of the current line. Create a new line that has all those\n    // tabs and spaces, such that leading indentation is preserved.\n    const anchor = selection.anchor.getNode();\n    const firstNode = getFirstCodeHighlightNodeOfLine(anchor);\n    if (firstNode != null) {\n      let leadingWhitespace = 0;\n      const firstNodeText = firstNode.getTextContent();\n      while (leadingWhitespace < firstNodeText.length && /[\\t ]/.test(firstNodeText[leadingWhitespace])) {\n        leadingWhitespace += 1;\n      }\n      if (leadingWhitespace > 0) {\n        const whitespace = firstNodeText.substring(0, leadingWhitespace);\n        const indentedChild = $createCodeHighlightNode(whitespace);\n        anchor.insertAfter(indentedChild);\n        selection.insertNodes([lexical.$createLineBreakNode()]);\n        indentedChild.select();\n        return indentedChild;\n      }\n    }\n    return null;\n  }\n  canInsertTab() {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n      return false;\n    }\n    return true;\n  }\n  canIndent() {\n    return false;\n  }\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n  setLanguage(language) {\n    const writable = this.getWritable();\n    writable.__language = mapToPrismLanguage(language);\n  }\n  getLanguage() {\n    return this.getLatest().__language;\n  }\n}\nfunction $createCodeNode(language) {\n  return lexical.$applyNodeReplacement(new CodeNode(language));\n}\nfunction $isCodeNode(node) {\n  return node instanceof CodeNode;\n}\nfunction convertPreElement(domNode) {\n  return {\n    node: $createCodeNode(),\n    preformatted: true\n  };\n}\nfunction convertDivElement(domNode) {\n  // domNode is a <div> since we matched it by nodeName\n  const div = domNode;\n  const isCode = isCodeElement(div);\n  if (!isCode && !isCodeChildElement(div)) {\n    return {\n      node: null\n    };\n  }\n  return {\n    after: childLexicalNodes => {\n      const domParent = domNode.parentNode;\n      if (domParent != null && domNode !== domParent.lastChild) {\n        childLexicalNodes.push(lexical.$createLineBreakNode());\n      }\n      return childLexicalNodes;\n    },\n    node: isCode ? $createCodeNode() : null,\n    preformatted: isCode\n  };\n}\nfunction convertTableElement() {\n  return {\n    node: $createCodeNode(),\n    preformatted: true\n  };\n}\nfunction convertCodeNoop() {\n  return {\n    node: null\n  };\n}\nfunction convertTableCellElement(domNode) {\n  // domNode is a <td> since we matched it by nodeName\n  const cell = domNode;\n  return {\n    after: childLexicalNodes => {\n      if (cell.parentNode && cell.parentNode.nextSibling) {\n        // Append newline between code lines\n        childLexicalNodes.push(lexical.$createLineBreakNode());\n      }\n      return childLexicalNodes;\n    },\n    node: null\n  };\n}\nfunction isCodeElement(div) {\n  return div.style.fontFamily.match('monospace') !== null;\n}\nfunction isCodeChildElement(node) {\n  let parent = node.parentElement;\n  while (parent !== null) {\n    if (isCodeElement(parent)) {\n      return true;\n    }\n    parent = parent.parentElement;\n  }\n  return false;\n}\nfunction isGitHubCodeCell(cell) {\n  return cell.classList.contains('js-file-line');\n}\nfunction isGitHubCodeTable(table) {\n  return table.classList.contains('js-file-line-container');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst DEFAULT_CODE_LANGUAGE = 'javascript';\nconst CODE_LANGUAGE_FRIENDLY_NAME_MAP = {\n  c: 'C',\n  clike: 'C-like',\n  cpp: 'C++',\n  css: 'CSS',\n  html: 'HTML',\n  java: 'Java',\n  js: 'JavaScript',\n  markdown: 'Markdown',\n  objc: 'Objective-C',\n  plain: 'Plain Text',\n  py: 'Python',\n  rust: 'Rust',\n  sql: 'SQL',\n  swift: 'Swift',\n  typescript: 'TypeScript',\n  xml: 'XML'\n};\nconst CODE_LANGUAGE_MAP = {\n  cpp: 'cpp',\n  java: 'java',\n  javascript: 'js',\n  md: 'markdown',\n  plaintext: 'plain',\n  python: 'py',\n  text: 'plain',\n  ts: 'typescript'\n};\nfunction normalizeCodeLang(lang) {\n  return CODE_LANGUAGE_MAP[lang] || lang;\n}\nfunction getLanguageFriendlyName(lang) {\n  const _lang = normalizeCodeLang(lang);\n  return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;\n}\nconst getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;\nconst getCodeLanguages = () => Object.keys(Prism.languages).filter(\n// Prism has several language helpers mixed into languages object\n// so filtering them out here to get langs list\nlanguage => typeof Prism.languages[language] !== 'function').sort();\n\n/** @noInheritDoc */\nclass CodeHighlightNode extends lexical.TextNode {\n  /** @internal */\n\n  constructor(text, highlightType, key) {\n    super(text, key);\n    this.__highlightType = highlightType;\n  }\n  static getType() {\n    return 'code-highlight';\n  }\n  static clone(node) {\n    return new CodeHighlightNode(node.__text, node.__highlightType || undefined, node.__key);\n  }\n  getHighlightType() {\n    const self = this.getLatest();\n    return self.__highlightType;\n  }\n  createDOM(config) {\n    const element = super.createDOM(config);\n    const className = getHighlightThemeClass(config.theme, this.__highlightType);\n    utils.addClassNamesToElement(element, className);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const update = super.updateDOM(prevNode, dom, config);\n    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);\n    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);\n    if (prevClassName !== nextClassName) {\n      if (prevClassName) {\n        utils.removeClassNamesFromElement(dom, prevClassName);\n      }\n      if (nextClassName) {\n        utils.addClassNamesToElement(dom, nextClassName);\n      }\n    }\n    return update;\n  }\n  static importJSON(serializedNode) {\n    const node = $createCodeHighlightNode(serializedNode.text, serializedNode.highlightType);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      highlightType: this.getHighlightType(),\n      type: 'code-highlight',\n      version: 1\n    };\n  }\n\n  // Prevent formatting (bold, underline, etc)\n  setFormat(format) {\n    return this;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createCodeNode();\n  }\n}\nfunction getHighlightThemeClass(theme, highlightType) {\n  return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];\n}\nfunction $createCodeHighlightNode(text, highlightType) {\n  return lexical.$applyNodeReplacement(new CodeHighlightNode(text, highlightType));\n}\nfunction $isCodeHighlightNode(node) {\n  return node instanceof CodeHighlightNode;\n}\nfunction getFirstCodeHighlightNodeOfLine(anchor) {\n  let currentNode = null;\n  const previousSiblings = anchor.getPreviousSiblings();\n  previousSiblings.push(anchor);\n  while (previousSiblings.length > 0) {\n    const node = previousSiblings.pop();\n    if ($isCodeHighlightNode(node)) {\n      currentNode = node;\n    }\n    if (lexical.$isLineBreakNode(node)) {\n      break;\n    }\n  }\n  return currentNode;\n}\nfunction getLastCodeHighlightNodeOfLine(anchor) {\n  let currentNode = null;\n  const nextSiblings = anchor.getNextSiblings();\n  nextSiblings.unshift(anchor);\n  while (nextSiblings.length > 0) {\n    const node = nextSiblings.shift();\n    if ($isCodeHighlightNode(node)) {\n      currentNode = node;\n    }\n    if (lexical.$isLineBreakNode(node)) {\n      break;\n    }\n  }\n  return currentNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PrismTokenizer = {\n  defaultLanguage: DEFAULT_CODE_LANGUAGE,\n  tokenize(code, language) {\n    return Prism.tokenize(code, Prism.languages[language || ''] || Prism.languages[this.defaultLanguage]);\n  }\n};\nfunction isSpaceOrTabChar(char) {\n  return char === ' ' || char === '\\t';\n}\nfunction findFirstNotSpaceOrTabCharAtText(text, isForward) {\n  const length = text.length;\n  let offset = -1;\n  if (isForward) {\n    for (let i = 0; i < length; i++) {\n      const char = text[i];\n      if (!isSpaceOrTabChar(char)) {\n        offset = i;\n        break;\n      }\n    }\n  } else {\n    for (let i = length - 1; i > -1; i--) {\n      const char = text[i];\n      if (!isSpaceOrTabChar(char)) {\n        offset = i;\n        break;\n      }\n    }\n  }\n  return offset;\n}\nfunction getStartOfCodeInLine(anchor) {\n  let currentNode = null;\n  let currentNodeOffset = -1;\n  const previousSiblings = anchor.getPreviousSiblings();\n  previousSiblings.push(anchor);\n  while (previousSiblings.length > 0) {\n    const node = previousSiblings.pop();\n    if ($isCodeHighlightNode(node)) {\n      const text = node.getTextContent();\n      const offset = findFirstNotSpaceOrTabCharAtText(text, true);\n      if (offset !== -1) {\n        currentNode = node;\n        currentNodeOffset = offset;\n      }\n    }\n    if (lexical.$isLineBreakNode(node)) {\n      break;\n    }\n  }\n  if (currentNode === null) {\n    const nextSiblings = anchor.getNextSiblings();\n    while (nextSiblings.length > 0) {\n      const node = nextSiblings.shift();\n      if ($isCodeHighlightNode(node)) {\n        const text = node.getTextContent();\n        const offset = findFirstNotSpaceOrTabCharAtText(text, true);\n        if (offset !== -1) {\n          currentNode = node;\n          currentNodeOffset = offset;\n          break;\n        }\n      }\n      if (lexical.$isLineBreakNode(node)) {\n        break;\n      }\n    }\n  }\n  return {\n    node: currentNode,\n    offset: currentNodeOffset\n  };\n}\nfunction getEndOfCodeInLine(anchor) {\n  let currentNode = null;\n  let currentNodeOffset = -1;\n  const nextSiblings = anchor.getNextSiblings();\n  nextSiblings.unshift(anchor);\n  while (nextSiblings.length > 0) {\n    const node = nextSiblings.shift();\n    if ($isCodeHighlightNode(node)) {\n      const text = node.getTextContent();\n      const offset = findFirstNotSpaceOrTabCharAtText(text, false);\n      if (offset !== -1) {\n        currentNode = node;\n        currentNodeOffset = offset + 1;\n      }\n    }\n    if (lexical.$isLineBreakNode(node)) {\n      break;\n    }\n  }\n  if (currentNode === null) {\n    const previousSiblings = anchor.getPreviousSiblings();\n    while (previousSiblings.length > 0) {\n      const node = previousSiblings.pop();\n      if ($isCodeHighlightNode(node)) {\n        const text = node.getTextContent();\n        const offset = findFirstNotSpaceOrTabCharAtText(text, false);\n        if (offset !== -1) {\n          currentNode = node;\n          currentNodeOffset = offset + 1;\n          break;\n        }\n      }\n      if (lexical.$isLineBreakNode(node)) {\n        break;\n      }\n    }\n  }\n  return {\n    node: currentNode,\n    offset: currentNodeOffset\n  };\n}\nfunction textNodeTransform(node, editor, tokenizer) {\n  // Since CodeNode has flat children structure we only need to check\n  // if node's parent is a code node and run highlighting if so\n  const parentNode = node.getParent();\n  if ($isCodeNode(parentNode)) {\n    codeNodeTransform(parentNode, editor, tokenizer);\n  } else if ($isCodeHighlightNode(node)) {\n    // When code block converted into paragraph or other element\n    // code highlight nodes converted back to normal text\n    node.replace(lexical.$createTextNode(node.__text));\n  }\n}\nfunction updateCodeGutter(node, editor) {\n  const codeElement = editor.getElementByKey(node.getKey());\n  if (codeElement === null) {\n    return;\n  }\n  const children = node.getChildren();\n  const childrenLength = children.length;\n  // @ts-ignore: internal field\n  if (childrenLength === codeElement.__cachedChildrenLength) {\n    // Avoid updating the attribute if the children length hasn't changed.\n    return;\n  }\n  // @ts-ignore:: internal field\n  codeElement.__cachedChildrenLength = childrenLength;\n  let gutter = '1';\n  let count = 1;\n  for (let i = 0; i < childrenLength; i++) {\n    if (lexical.$isLineBreakNode(children[i])) {\n      gutter += '\\n' + ++count;\n    }\n  }\n  codeElement.setAttribute('data-gutter', gutter);\n}\n\n// Using `skipTransforms` to prevent extra transforms since reformatting the code\n// will not affect code block content itself.\n//\n// Using extra cache (`nodesCurrentlyHighlighting`) since both CodeNode and CodeHighlightNode\n// transforms might be called at the same time (e.g. new CodeHighlight node inserted) and\n// in both cases we'll rerun whole reformatting over CodeNode, which is redundant.\n// Especially when pasting code into CodeBlock.\n\nconst nodesCurrentlyHighlighting = new Set();\nfunction codeNodeTransform(node, editor, tokenizer) {\n  const nodeKey = node.getKey();\n  if (nodesCurrentlyHighlighting.has(nodeKey)) {\n    return;\n  }\n  nodesCurrentlyHighlighting.add(nodeKey);\n\n  // When new code block inserted it might not have language selected\n  if (node.getLanguage() === undefined) {\n    node.setLanguage(tokenizer.defaultLanguage);\n  }\n\n  // Using nested update call to pass `skipTransforms` since we don't want\n  // each individual codehighlight node to be transformed again as it's already\n  // in its final state\n  editor.update(() => {\n    updateAndRetainSelection(nodeKey, () => {\n      const currentNode = lexical.$getNodeByKey(nodeKey);\n      if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {\n        return false;\n      }\n      const code = currentNode.getTextContent();\n      const tokens = tokenizer.tokenize(code, currentNode.getLanguage() || tokenizer.defaultLanguage);\n      const highlightNodes = getHighlightNodes(tokens);\n      const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);\n      const {\n        from,\n        to,\n        nodesForReplacement\n      } = diffRange;\n      if (from !== to || nodesForReplacement.length) {\n        node.splice(from, to - from, nodesForReplacement);\n        return true;\n      }\n      return false;\n    });\n  }, {\n    onUpdate: () => {\n      nodesCurrentlyHighlighting.delete(nodeKey);\n    },\n    skipTransforms: true\n  });\n}\nfunction getHighlightNodes(tokens) {\n  const nodes = [];\n  tokens.forEach(token => {\n    if (typeof token === 'string') {\n      const partials = token.split('\\n');\n      for (let i = 0; i < partials.length; i++) {\n        const text = partials[i];\n        if (text.length) {\n          nodes.push($createCodeHighlightNode(text));\n        }\n        if (i < partials.length - 1) {\n          nodes.push(lexical.$createLineBreakNode());\n        }\n      }\n    } else {\n      const {\n        content\n      } = token;\n      if (typeof content === 'string') {\n        nodes.push($createCodeHighlightNode(content, token.type));\n      } else if (Array.isArray(content) && content.length === 1 && typeof content[0] === 'string') {\n        nodes.push($createCodeHighlightNode(content[0], token.type));\n      } else if (Array.isArray(content)) {\n        nodes.push(...getHighlightNodes(content));\n      }\n    }\n  });\n  return nodes;\n}\n\n// Wrapping update function into selection retainer, that tries to keep cursor at the same\n// position as before.\nfunction updateAndRetainSelection(nodeKey, updateFn) {\n  const node = lexical.$getNodeByKey(nodeKey);\n  if (!$isCodeNode(node) || !node.isAttached()) {\n    return;\n  }\n  const selection = lexical.$getSelection();\n  // If it's not range selection (or null selection) there's no need to change it,\n  // but we can still run highlighting logic\n  if (!lexical.$isRangeSelection(selection)) {\n    updateFn();\n    return;\n  }\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const isNewLineAnchor = anchor.type === 'element' && lexical.$isLineBreakNode(node.getChildAtIndex(anchor.offset - 1));\n  let textOffset = 0;\n\n  // Calculating previous text offset (all text node prior to anchor + anchor own text offset)\n  if (!isNewLineAnchor) {\n    const anchorNode = anchor.getNode();\n    textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {\n      return offset + _node.getTextContentSize();\n    }, 0);\n  }\n  const hasChanges = updateFn();\n  if (!hasChanges) {\n    return;\n  }\n\n  // Non-text anchors only happen for line breaks, otherwise\n  // selection will be within text node (code highlight node)\n  if (isNewLineAnchor) {\n    anchor.getNode().select(anchorOffset, anchorOffset);\n    return;\n  }\n\n  // If it was non-element anchor then we walk through child nodes\n  // and looking for a position of original text offset\n  node.getChildren().some(_node => {\n    const isText = lexical.$isTextNode(_node);\n    if (isText || lexical.$isLineBreakNode(_node)) {\n      const textContentSize = _node.getTextContentSize();\n      if (isText && textContentSize >= textOffset) {\n        _node.select(textOffset, textOffset);\n        return true;\n      }\n      textOffset -= textContentSize;\n    }\n    return false;\n  });\n}\n\n// Finds minimal diff range between two nodes lists. It returns from/to range boundaries of prevNodes\n// that needs to be replaced with `nodes` (subset of nextNodes) to make prevNodes equal to nextNodes.\nfunction getDiffRange(prevNodes, nextNodes) {\n  let leadingMatch = 0;\n  while (leadingMatch < prevNodes.length) {\n    if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {\n      break;\n    }\n    leadingMatch++;\n  }\n  const prevNodesLength = prevNodes.length;\n  const nextNodesLength = nextNodes.length;\n  const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;\n  let trailingMatch = 0;\n  while (trailingMatch < maxTrailingMatch) {\n    trailingMatch++;\n    if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {\n      trailingMatch--;\n      break;\n    }\n  }\n  const from = leadingMatch;\n  const to = prevNodesLength - trailingMatch;\n  const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);\n  return {\n    from,\n    nodesForReplacement,\n    to\n  };\n}\nfunction isEqual(nodeA, nodeB) {\n  // Only checking for code higlight nodes and linebreaks. If it's regular text node\n  // returning false so that it's transformed into code highlight node\n  if ($isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB)) {\n    return nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType;\n  }\n  if (lexical.$isLineBreakNode(nodeA) && lexical.$isLineBreakNode(nodeB)) {\n    return true;\n  }\n  return false;\n}\nfunction handleMultilineIndent(type) {\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection) || selection.isCollapsed()) {\n    return false;\n  }\n\n  // Only run multiline indent logic on selections exclusively composed of code highlights and linebreaks\n  const nodes = selection.getNodes();\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!$isCodeHighlightNode(node) && !lexical.$isLineBreakNode(node)) {\n      return false;\n    }\n  }\n  const startOfLine = getFirstCodeHighlightNodeOfLine(nodes[0]);\n  if (startOfLine != null) {\n    doIndent(startOfLine, type);\n  }\n  for (let i = 1; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (lexical.$isLineBreakNode(nodes[i - 1]) && $isCodeHighlightNode(node)) {\n      doIndent(node, type);\n    }\n  }\n  return true;\n}\nfunction doIndent(node, type) {\n  const text = node.getTextContent();\n  if (type === lexical.INDENT_CONTENT_COMMAND) {\n    // If the codeblock node doesn't start with whitespace, we don't want to\n    // naively prepend a '\\t'; Prism will then mangle all of our nodes when\n    // it separates the whitespace from the first non-whitespace node. This\n    // will lead to selection bugs when indenting lines that previously\n    // didn't start with a whitespace character\n    if (text.length > 0 && /\\s/.test(text[0])) {\n      node.setTextContent('\\t' + text);\n    } else {\n      const indentNode = $createCodeHighlightNode('\\t');\n      node.insertBefore(indentNode);\n    }\n  } else {\n    if (text.indexOf('\\t') === 0) {\n      // Same as above - if we leave empty text nodes lying around, the resulting\n      // selection will be mangled\n      if (text.length === 1) {\n        node.remove();\n      } else {\n        node.setTextContent(text.substring(1));\n      }\n    }\n  }\n}\nfunction handleShiftLines(type, event) {\n  // We only care about the alt+arrow keys\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  }\n\n  // I'm not quite sure why, but it seems like calling anchor.getNode() collapses the selection here\n  // So first, get the anchor and the focus, then get their nodes\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const arrowIsUp = type === lexical.KEY_ARROW_UP_COMMAND;\n\n  // Ensure the selection is within the codeblock\n  if (!$isCodeHighlightNode(anchorNode) || !$isCodeHighlightNode(focusNode)) {\n    return false;\n  }\n  if (!event.altKey) {\n    // Handle moving selection out of the code block, given there are no\n    // sibling thats can natively take the selection.\n    if (selection.isCollapsed()) {\n      const codeNode = anchorNode.getParentOrThrow();\n      if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {\n        const codeNodeSibling = codeNode.getPreviousSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectPrevious();\n          event.preventDefault();\n          return true;\n        }\n      } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {\n        const codeNodeSibling = codeNode.getNextSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectNext();\n          event.preventDefault();\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  const start = getFirstCodeHighlightNodeOfLine(anchorNode);\n  const end = getLastCodeHighlightNodeOfLine(focusNode);\n  if (start == null || end == null) {\n    return false;\n  }\n  const range = start.getNodesBetween(end);\n  for (let i = 0; i < range.length; i++) {\n    const node = range[i];\n    if (!$isCodeHighlightNode(node) && !lexical.$isLineBreakNode(node)) {\n      return false;\n    }\n  }\n\n  // After this point, we know the selection is within the codeblock. We may not be able to\n  // actually move the lines around, but we want to return true either way to prevent\n  // the event's default behavior\n  event.preventDefault();\n  event.stopPropagation(); // required to stop cursor movement under Firefox\n\n  const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();\n  if (!lexical.$isLineBreakNode(linebreak)) {\n    return true;\n  }\n  const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();\n  if (sibling == null) {\n    return true;\n  }\n  const maybeInsertionPoint = arrowIsUp ? getFirstCodeHighlightNodeOfLine(sibling) : getLastCodeHighlightNodeOfLine(sibling);\n  let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;\n  linebreak.remove();\n  range.forEach(node => node.remove());\n  if (type === lexical.KEY_ARROW_UP_COMMAND) {\n    range.forEach(node => insertionPoint.insertBefore(node));\n    insertionPoint.insertBefore(linebreak);\n  } else {\n    insertionPoint.insertAfter(linebreak);\n    insertionPoint = linebreak;\n    range.forEach(node => {\n      insertionPoint.insertAfter(node);\n      insertionPoint = node;\n    });\n  }\n  selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);\n  return true;\n}\nfunction handleMoveTo(type, event) {\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const isMoveToStart = type === lexical.MOVE_TO_START;\n  if (!$isCodeHighlightNode(anchorNode) || !$isCodeHighlightNode(focusNode)) {\n    return false;\n  }\n  let node;\n  let offset;\n  if (isMoveToStart) {\n    ({\n      node,\n      offset\n    } = getStartOfCodeInLine(focusNode));\n  } else {\n    ({\n      node,\n      offset\n    } = getEndOfCodeInLine(focusNode));\n  }\n  if (node !== null && offset !== -1) {\n    selection.setTextNodeRange(node, offset, node, offset);\n  }\n  event.preventDefault();\n  event.stopPropagation();\n  return true;\n}\nfunction registerCodeHighlighting(editor, tokenizer) {\n  if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {\n    throw new Error('CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor');\n  }\n  if (tokenizer == null) {\n    tokenizer = PrismTokenizer;\n  }\n  return utils.mergeRegister(editor.registerMutationListener(CodeNode, mutations => {\n    editor.update(() => {\n      for (const [key, type] of mutations) {\n        if (type !== 'destroyed') {\n          const node = lexical.$getNodeByKey(key);\n          if (node !== null) {\n            updateCodeGutter(node, editor);\n          }\n        }\n      }\n    });\n  }), editor.registerNodeTransform(CodeNode, node => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(lexical.TextNode, node => textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, node => textNodeTransform(node, editor, tokenizer)), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, payload => handleMultilineIndent(lexical.INDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, payload => handleMultilineIndent(lexical.OUTDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, payload => handleShiftLines(lexical.KEY_ARROW_UP_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, payload => handleShiftLines(lexical.KEY_ARROW_DOWN_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_END, payload => handleMoveTo(lexical.MOVE_TO_END, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_START, payload => handleMoveTo(lexical.MOVE_TO_START, payload), lexical.COMMAND_PRIORITY_LOW));\n}\n\nexports.$createCodeHighlightNode = $createCodeHighlightNode;\nexports.$createCodeNode = $createCodeNode;\nexports.$isCodeHighlightNode = $isCodeHighlightNode;\nexports.$isCodeNode = $isCodeNode;\nexports.CODE_LANGUAGE_FRIENDLY_NAME_MAP = CODE_LANGUAGE_FRIENDLY_NAME_MAP;\nexports.CODE_LANGUAGE_MAP = CODE_LANGUAGE_MAP;\nexports.CodeHighlightNode = CodeHighlightNode;\nexports.CodeNode = CodeNode;\nexports.DEFAULT_CODE_LANGUAGE = DEFAULT_CODE_LANGUAGE;\nexports.PrismTokenizer = PrismTokenizer;\nexports.getCodeLanguages = getCodeLanguages;\nexports.getDefaultCodeLanguage = getDefaultCodeLanguage;\nexports.getEndOfCodeInLine = getEndOfCodeInLine;\nexports.getFirstCodeHighlightNodeOfLine = getFirstCodeHighlightNodeOfLine;\nexports.getLanguageFriendlyName = getLanguageFriendlyName;\nexports.getLastCodeHighlightNodeOfLine = getLastCodeHighlightNodeOfLine;\nexports.getStartOfCodeInLine = getStartOfCodeInLine;\nexports.normalizeCodeLang = normalizeCodeLang;\nexports.registerCodeHighlighting = registerCodeHighlighting;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalCode = process.env.NODE_ENV === 'development' ? require('./LexicalCode.dev.js') : require('./LexicalCode.prod.js')\nmodule.exports = LexicalCode;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar utils = require('@lexical/utils');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\nfunction wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\nfunction $getListItemValue(listItem) {\n  const list = listItem.getParent();\n  let value = 1;\n  if (list != null) {\n    if (!$isListNode(list)) {\n      {\n        throw Error(`$getListItemValue: list node is not parent of list item node`);\n      }\n    } else {\n      value = list.getStart();\n    }\n  }\n  const siblings = listItem.getPreviousSiblings();\n  for (let i = 0; i < siblings.length; i++) {\n    const sibling = siblings[i];\n    if ($isListItemNode(sibling) && !$isListNode(sibling.getFirstChild())) {\n      value++;\n    }\n  }\n  return value;\n}\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n        if (lexical.$isRootOrShadowRoot(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n          if (lexical.$isElementNode(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n        return;\n      } else {\n        const handled = new Set();\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if (lexical.$isElementNode(node) && node.isEmpty() && !handled.has(node.getKey())) {\n            createListOrMerge(node, listType);\n            continue;\n          }\n          if (lexical.$isLeafNode(node)) {\n            let parent = node.getParent();\n            while (parent != null) {\n              const parentKey = parent.getKey();\n              if ($isListNode(parent)) {\n                if (!handled.has(parentKey)) {\n                  const newListNode = $createListNode(listType);\n                  append(newListNode, parent.getChildren());\n                  parent.replace(newListNode);\n                  updateChildrenListItemValue(newListNode);\n                  handled.add(parentKey);\n                }\n                break;\n              } else {\n                const nextParent = parent.getParent();\n                if (lexical.$isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                  handled.add(parentKey);\n                  createListOrMerge(parent, listType);\n                  break;\n                }\n                parent = nextParent;\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    node.remove();\n    // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    updateChildrenListItemValue(list);\n    return list;\n  }\n}\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if (lexical.$isLeafNode(node)) {\n            const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode);\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n        for (const listItemNode of listItems) {\n          const paragraph = lexical.$createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph;\n\n          // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n          listItemNode.remove();\n        }\n        listNode.remove();\n      }\n    }\n  });\n}\nfunction updateChildrenListItemValue(list, children) {\n  const childrenOrExisting = children || list.getChildren();\n  if (childrenOrExisting !== undefined) {\n    for (let i = 0; i < childrenOrExisting.length; i++) {\n      const child = childrenOrExisting[i];\n      if ($isListItemNode(child)) {\n        const prevValue = child.getValue();\n        const nextValue = $getListItemValue(child);\n        if (prevValue !== nextValue) {\n          child.setValue(nextValue);\n        }\n      }\n    }\n  }\n}\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n      updateChildrenListItemValue(innerList);\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n      updateChildrenListItemValue(innerList);\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      updateChildrenListItemValue(innerList);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode();\n      const newList = $createListNode(parent.getListType());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n  if ($isListNode(parent)) {\n    updateChildrenListItemValue(parent);\n  }\n}\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n    updateChildrenListItemValue(parentList);\n    updateChildrenListItemValue(greatGrandparentList);\n  }\n}\nfunction $handleListInsertParagraph() {\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getTextContent() !== '') {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if (lexical.$isRootOrShadowRoot(grandparent)) {\n    replacementNode = lexical.$createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if (lexical.$isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass ListItemNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'listitem';\n  }\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      updateChildrenListItemValue(parent);\n      updateListItemChecked(element, this, null, parent);\n    }\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      updateChildrenListItemValue(parent);\n      updateListItemChecked(dom, this, prevNode, parent);\n    }\n    // @ts-expect-error - this is always HTMLListItemElement\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static importDOM() {\n    return {\n      li: node => ({\n        conversion: convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = new ListItemNode(serializedNode.value, serializedNode.checked);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (lexical.$isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    const list = this.getParentOrThrow();\n    if ($isListNode(list)) {\n      const childrenKeys = list.getChildrenKeys();\n      const childrenLength = childrenKeys.length;\n      const index = childrenKeys.indexOf(this.__key);\n      if (index === 0) {\n        list.insertBefore(replaceWithNode);\n      } else if (index === childrenLength - 1) {\n        list.insertAfter(replaceWithNode);\n      } else {\n        // Split the list\n        const newList = $createListNode(list.getListType());\n        const children = list.getChildren();\n        for (let i = index + 1; i < childrenLength; i++) {\n          const child = children[i];\n          newList.append(child);\n        }\n        list.insertAfter(replaceWithNode);\n        replaceWithNode.insertAfter(newList);\n      }\n      if (includeChildren) {\n        this.getChildren().forEach(child => {\n          replaceWithNode.append(child);\n        });\n      }\n      this.remove();\n      if (childrenLength === 1) {\n        list.remove();\n      }\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    const siblings = this.getNextSiblings();\n    if ($isListItemNode(node)) {\n      const after = super.insertAfter(node, restoreSelection);\n      const afterListNode = node.getParentOrThrow();\n      if ($isListNode(afterListNode)) {\n        updateChildrenListItemValue(afterListNode);\n      }\n      return after;\n    }\n\n    // Attempt to merge if the list is of the same type.\n\n    if ($isListNode(node) && node.getListType() === listNode.getListType()) {\n      let child = node;\n      const children = node.getChildren();\n      for (let i = children.length - 1; i >= 0; i--) {\n        child = children[i];\n        this.insertAfter(child, restoreSelection);\n      }\n      return child;\n    }\n\n    // Otherwise, split the list\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (nextSibling !== null) {\n      const parent = nextSibling.getParent();\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n      }\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    return self.__checked;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n  insertBefore(nodeToInsert) {\n    if ($isListItemNode(nodeToInsert)) {\n      const parent = this.getParentOrThrow();\n      if ($isListNode(parent)) {\n        const siblings = this.getNextSiblings();\n        updateChildrenListItemValue(parent, siblings);\n      }\n    }\n    return super.insertBefore(nodeToInsert);\n  }\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return lexical.$isParagraphNode(node) || $isListItemNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    const listItemClasses = listItemClassName.split(' ');\n    classesToAdd.push(...listItemClasses);\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = nestedListItemClassName.split(' ');\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  const isCheckList = listNode.getListType() === 'check';\n  if (isCheckList) {\n    // Only add attributes for leaf list items\n    if ($isListNode(listItemNode.getFirstChild())) {\n      dom.removeAttribute('role');\n      dom.removeAttribute('tabIndex');\n      dom.removeAttribute('aria-checked');\n    } else {\n      dom.setAttribute('role', 'checkbox');\n      dom.setAttribute('tabIndex', '-1');\n      if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n        dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n      }\n    }\n  } else {\n    // Clean up checked state\n    if (listItemNode.getChecked() != null) {\n      listItemNode.setChecked(undefined);\n    }\n  }\n}\nfunction convertListItemElement(domNode) {\n  const checked = utils.isHTMLElement(domNode) && domNode.getAttribute('aria-checked') === 'true';\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $createListItemNode(checked) {\n  return lexical.$applyNodeReplacement(new ListItemNode(undefined, checked));\n}\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass ListNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'list';\n  }\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n  constructor(listType, start, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  getListType() {\n    return this.__listType;\n  }\n  getStart() {\n    return this.__start;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static importDOM() {\n    return {\n      ol: node => ({\n        conversion: convertListNode,\n        priority: 0\n      }),\n      ul: node => ({\n        conversion: convertListNode,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if (lexical.$isElementNode(currentNode)) {\n          const textNode = lexical.$createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        } else {\n          listItemNode.append(currentNode);\n        }\n        super.append(listItemNode);\n      }\n    }\n    return this;\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      const listItemClasses = listLevelClassName.split(' ');\n      classesToAdd.push(...listItemClasses);\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = nestedListClassName.split(' ');\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push(wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push(wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    node = $createListNode('number');\n  } else if (nodeName === 'ul') {\n    if (utils.isHTMLElement(domNode) && domNode.getAttribute('__lexicallisttype') === 'check') {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\nfunction $createListNode(listType, start = 1) {\n  return lexical.$applyNodeReplacement(new ListNode(listType, start));\n}\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/** @module @lexical/list */\nconst INSERT_UNORDERED_LIST_COMMAND = lexical.createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = lexical.createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = lexical.createCommand('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = lexical.createCommand('REMOVE_LIST_COMMAND');\n\nexports.$createListItemNode = $createListItemNode;\nexports.$createListNode = $createListNode;\nexports.$getListDepth = $getListDepth;\nexports.$handleListInsertParagraph = $handleListInsertParagraph;\nexports.$isListItemNode = $isListItemNode;\nexports.$isListNode = $isListNode;\nexports.INSERT_CHECK_LIST_COMMAND = INSERT_CHECK_LIST_COMMAND;\nexports.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND;\nexports.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND;\nexports.ListItemNode = ListItemNode;\nexports.ListNode = ListNode;\nexports.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND;\nexports.insertList = insertList;\nexports.removeList = removeList;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalList = process.env.NODE_ENV === 'development' ? require('./LexicalList.dev.js') : require('./LexicalList.prod.js')\nmodule.exports = LexicalList;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar lexical = require('lexical');\n\n/** @module @lexical/html */\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivilant library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  let lexicalNodes = [];\n  const elements = dom.body ? Array.from(dom.body.childNodes) : [];\n  const elementsLength = elements.length;\n  for (let i = 0; i < elementsLength; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection$1 = null) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected() : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const {\n    element,\n    after\n  } = target.exportDOM(editor);\n  if (!element) {\n    return false;\n  }\n  const fragment = new DocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    element.append(fragment);\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) element.replaceWith(newElement);\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE']);\nfunction $createNodesFromDOM(node, editor, forChildMap = new Map(), parentLexicalNode, preformatted = false) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node, undefined, preformatted) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    currentLexicalNode = transformOutput.node;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(currentLexicalNode);\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode, preformatted || (transformOutput && transformOutput.preformatted) === true));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if (lexical.$isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\n\nexports.$generateHtmlFromNodes = $generateHtmlFromNodes;\nexports.$generateNodesFromDOM = $generateNodesFromDOM;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalHtml = process.env.NODE_ENV === 'development' ? require('./LexicalHtml.dev.js') : require('./LexicalHtml.prod.js')\nmodule.exports = LexicalHtml;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar html = require('@lexical/html');\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $getHtmlContent(editor) {\n  const selection = lexical.$getSelection();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return html.$generateHtmlFromNodes(editor, selection);\n}\n\n// TODO 0.6.0 Return a blank string instead\n// TODO 0.6.0 Rename to $getJSON\nfunction $getLexicalContent(editor) {\n  const selection = lexical.$getSelection();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = html.$generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  const text = dataTransfer.getData('text/plain');\n  if (text != null) {\n    if (lexical.$isRangeSelection(selection)) {\n      const lines = text.split(/\\r?\\n/);\n      const linesLength = lines.length;\n      for (let i = 0; i < linesLength; i++) {\n        selection.insertText(lines[i]);\n        if (i < linesLength - 1) {\n          selection.insertParagraph();\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  const isSelectionInsideOfGrid = lexical.DEPRECATED_$isGridSelection(selection) || utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection.focus.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null;\n  if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    $mergeGridNodesStrategy(nodes, selection, false, editor);\n    return;\n  }\n  $basicInsertStrategy(nodes, selection);\n  return;\n}\nfunction $basicInsertStrategy(nodes, selection) {\n  // Wrap text and inline nodes in paragraph nodes so we have all blocks at the top-level\n  const topLevelBlocks = [];\n  let currentBlock = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = lexical.$isLineBreakNode(node);\n    if (isLineBreakNode || lexical.$isDecoratorNode(node) && node.isInline() || lexical.$isElementNode(node) && node.isInline() || lexical.$isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        topLevelBlocks.push(currentBlock);\n        // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      topLevelBlocks.push(node);\n      currentBlock = null;\n    }\n  }\n  if (lexical.$isRangeSelection(selection)) {\n    selection.insertNodes(topLevelBlocks);\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    // If there's an active grid selection and a non grid is pasted, add to the anchor.\n    const anchorCell = selection.anchor.getNode();\n    if (!lexical.DEPRECATED_$isGridCellNode(anchorCell)) {\n      {\n        throw Error(`Expected Grid Cell in Grid Selection`);\n      }\n    }\n    anchorCell.append(...topLevelBlocks);\n  }\n}\nfunction $mergeGridNodesStrategy(nodes, selection, isFromLexical, editor) {\n  if (nodes.length !== 1 || !lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);\n    }\n  }\n  const newGrid = nodes[0];\n  const newGridRows = newGrid.getChildren();\n  const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n  const newRowCount = newGrid.getChildrenSize();\n  const gridCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n));\n  const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, n => lexical.DEPRECATED_$isGridRowNode(n));\n  const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, n => lexical.DEPRECATED_$isGridNode(n));\n  if (!lexical.DEPRECATED_$isGridCellNode(gridCellNode) || !lexical.DEPRECATED_$isGridRowNode(gridRowNode) || !lexical.DEPRECATED_$isGridNode(gridNode)) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);\n    }\n  }\n  const startY = gridRowNode.getIndexWithinParent();\n  const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n  const startX = gridCellNode.getIndexWithinParent();\n  const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n  const fromX = Math.min(startX, stopX);\n  const fromY = Math.min(startY, stopY);\n  const toX = Math.max(startX, stopX);\n  const toY = Math.max(startY, stopY);\n  const gridRowNodes = gridNode.getChildren();\n  let newRowIdx = 0;\n  let newAnchorCellKey;\n  let newFocusCellKey;\n  for (let r = fromY; r <= toY; r++) {\n    const currentGridRowNode = gridRowNodes[r];\n    if (!lexical.DEPRECATED_$isGridRowNode(currentGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n    const newGridRowNode = newGridRows[newRowIdx];\n    if (!lexical.DEPRECATED_$isGridRowNode(newGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n    const gridCellNodes = currentGridRowNode.getChildren();\n    const newGridCellNodes = newGridRowNode.getChildren();\n    let newColumnIdx = 0;\n    for (let c = fromX; c <= toX; c++) {\n      const currentGridCellNode = gridCellNodes[c];\n      if (!lexical.DEPRECATED_$isGridCellNode(currentGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n      const newGridCellNode = newGridCellNodes[newColumnIdx];\n      if (!lexical.DEPRECATED_$isGridCellNode(newGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n      if (r === fromY && c === fromX) {\n        newAnchorCellKey = currentGridCellNode.getKey();\n      } else if (r === toY && c === toX) {\n        newFocusCellKey = currentGridCellNode.getKey();\n      }\n      const originalChildren = currentGridCellNode.getChildren();\n      newGridCellNode.getChildren().forEach(child => {\n        if (lexical.$isTextNode(child)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          paragraphNode.append(child);\n          currentGridCellNode.append(child);\n        } else {\n          currentGridCellNode.append(child);\n        }\n      });\n      originalChildren.forEach(n => n.remove());\n      newColumnIdx++;\n    }\n    newRowIdx++;\n  }\n  if (newAnchorCellKey && newFocusCellKey) {\n    const newGridSelection = lexical.DEPRECATED_$createGridSelection();\n    newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);\n    lexical.$setSelection(newGridSelection);\n    editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n\n  // @ts-expect-error TODO Replace Class utility type with InstanceType\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n\n  // @ts-expect-error TODO Replace Class utility type with InstanceType\n  const serializedChildren = serializedNode.children;\n  if (lexical.$isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection$1, currentNode, targetArray = []) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n  if (lexical.$isTextNode(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = lexical.$parseSerializedNode(serializedNode);\n    if (lexical.$isTextNode(node)) {\n      selection.$addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\nasync function copyToClipboard__EXPERIMENTAL(editor, event) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const domSelection = document.getSelection();\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = document.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(document.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(lexical.COPY_COMMAND, secondEvent => {\n      if (secondEvent instanceof ClipboardEvent) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, lexical.COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    document.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event) {\n  const domSelection = window.getSelection();\n  if (!domSelection) {\n    return false;\n  }\n  const anchorDOM = domSelection.anchorNode;\n  const focusDOM = domSelection.focusNode;\n  if (anchorDOM !== null && focusDOM !== null && !lexical.isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return false;\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  const selection = lexical.$getSelection();\n  if (clipboardData === null || selection === null) {\n    return false;\n  }\n  const htmlString = $getHtmlContent(editor);\n  const lexicalString = $getLexicalContent(editor);\n  let plainString = '';\n  if (selection !== null) {\n    plainString = selection.getTextContent();\n  }\n  if (htmlString !== null) {\n    clipboardData.setData('text/html', htmlString);\n  }\n  if (lexicalString !== null) {\n    clipboardData.setData('application/x-lexical-editor', lexicalString);\n  }\n  clipboardData.setData('text/plain', plainString);\n  return true;\n}\n\nexports.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;\nexports.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;\nexports.$getHtmlContent = $getHtmlContent;\nexports.$getLexicalContent = $getLexicalContent;\nexports.$insertDataTransferForPlainText = $insertDataTransferForPlainText;\nexports.$insertDataTransferForRichText = $insertDataTransferForRichText;\nexports.$insertGeneratedNodes = $insertGeneratedNodes;\nexports.copyToClipboard__EXPERIMENTAL = copyToClipboard__EXPERIMENTAL;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalClipboard = process.env.NODE_ENV === 'development' ? require('./LexicalClipboard.dev.js') : require('./LexicalClipboard.prod.js')\nmodule.exports = LexicalClipboard;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar clipboard = require('@lexical/clipboard');\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction caretFromPoint(x, y) {\n  if (typeof document.caretRangeFromPoint !== 'undefined') {\n    const range = document.caretRangeFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.startContainer,\n      offset: range.startOffset\n    };\n    // @ts-ignore\n  } else if (document.caretPositionFromPoint !== 'undefined') {\n    // @ts-ignore FF - no types\n    const range = document.caretPositionFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.offsetNode,\n      offset: range.offset\n    };\n  } else {\n    // Gracefully handle IE\n    return null;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/** @module @lexical/rich-text */\nconst DRAG_DROP_PASTE = lexical.createCommand('DRAG_DROP_PASTE_FILE');\n/** @noInheritDoc */\nclass QuoteNode extends lexical.ElementNode {\n  static getType() {\n    return 'quote';\n  }\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    utils.addClassNamesToElement(element, config.theme.quote);\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      blockquote: node => ({\n        conversion: convertBlockquoteElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createQuoteNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'quote'\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(_, restoreSelection) {\n    const newBlock = lexical.$createParagraphNode();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock, restoreSelection);\n    return newBlock;\n  }\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n}\nfunction $createQuoteNode() {\n  return lexical.$applyNodeReplacement(new QuoteNode());\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\n/** @noInheritDoc */\nclass HeadingNode extends lexical.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'heading';\n  }\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n  getTag() {\n    return this.__tag;\n  }\n\n  // View\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      utils.addClassNamesToElement(element, className);\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h6: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      p: node => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node;\n        const firstChild = paragraph.firstChild;\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({\n              node: null\n            }),\n            priority: 3\n          };\n        }\n        return null;\n      },\n      span: node => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: domNode => {\n              return {\n                node: $createHeadingNode('h1')\n              };\n            },\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createHeadingNode(serializedNode.tag);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      tag: this.getTag(),\n      type: 'heading',\n      version: 1\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const anchorOffet = selection ? selection.anchor.offset : 0;\n    const newElement = anchorOffet > 0 && anchorOffet < this.getTextContentSize() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart() {\n    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => newElement.append(child));\n    this.replace(newElement);\n    return true;\n  }\n  extractWithChild() {\n    return true;\n  }\n}\nfunction isGoogleDocsTitle(domNode) {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return domNode.style.fontSize === '26pt';\n  }\n  return false;\n}\nfunction convertHeadingElement(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {\n    node = $createHeadingNode(nodeName);\n  }\n  return {\n    node\n  };\n}\nfunction convertBlockquoteElement() {\n  const node = $createQuoteNode();\n  return {\n    node\n  };\n}\nfunction $createHeadingNode(headingTag) {\n  return lexical.$applyNodeReplacement(new HeadingNode(headingTag));\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    const clipboardData = event instanceof InputEvent || event instanceof KeyboardEvent ? null : event.clipboardData;\n    if (clipboardData != null && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n      clipboard.$insertDataTransferForRichText(clipboardData, selection, editor);\n    }\n  }, {\n    tag: 'paste'\n  });\n}\nasync function onCutForRichText(event, editor) {\n  await clipboard.copyToClipboard__EXPERIMENTAL(editor, event instanceof ClipboardEvent ? event : null);\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isRangeSelection(selection)) {\n      selection.removeText();\n    } else if (lexical.$isNodeSelection(selection)) {\n      selection.getNodes().forEach(node => node.remove());\n    }\n  });\n}\n\n// Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,\n// in certain ocassions, we want to know whether it was a file transfer, as opposed to text. We\n// control this with the first boolean flag.\nfunction eventFiles(event) {\n  let dataTransfer = null;\n  if (event instanceof DragEvent) {\n    dataTransfer = event.dataTransfer;\n  } else if (event instanceof ClipboardEvent) {\n    dataTransfer = event.clipboardData;\n  }\n  if (dataTransfer === null) {\n    return [false, [], false];\n  }\n  const types = dataTransfer.types;\n  const hasFiles = types.includes('Files');\n  const hasContent = types.includes('text/html') || types.includes('text/plain');\n  return [hasFiles, Array.from(dataTransfer.files), hasContent];\n}\nfunction handleIndentAndOutdent(insertTab, indentOrOutdent) {\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection)) {\n    return;\n  }\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n    const parentBlock = utils.$getNearestBlockElementAncestorOrThrow(node);\n    const parentKey = parentBlock.getKey();\n    if (parentBlock.canInsertTab()) {\n      insertTab(node);\n      alreadyHandled.add(key);\n    } else if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n      alreadyHandled.add(parentKey);\n      indentOrOutdent(parentBlock);\n    }\n  }\n}\nfunction $isTargetWithinDecorator(target) {\n  const node = lexical.$getNearestNodeFromDOMNode(target);\n  return lexical.$isDecoratorNode(node);\n}\nfunction $isSelectionAtEndOfRoot(selection) {\n  const focus = selection.focus;\n  return focus.key === 'root' && focus.offset === lexical.$getRoot().getChildrenSize();\n}\nfunction registerRichText(editor) {\n  const removeListener = utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isNodeSelection(selection)) {\n      selection.clear();\n      return true;\n    }\n    return false;\n  }, 0), editor.registerCommand(lexical.DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_WORD_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteWord(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_LINE_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteLine(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = lexical.$getSelection();\n    if (typeof eventOrText === 'string') {\n      if (lexical.$isRangeSelection(selection)) {\n        selection.insertText(eventOrText);\n      } else if (lexical.DEPRECATED_$isGridSelection(selection)) ;\n    } else {\n      if (!lexical.$isRangeSelection(selection) && !lexical.DEPRECATED_$isGridSelection(selection)) {\n        return false;\n      }\n      const dataTransfer = eventOrText.dataTransfer;\n      if (dataTransfer != null) {\n        clipboard.$insertDataTransferForRichText(dataTransfer, selection, editor);\n      } else if (lexical.$isRangeSelection(selection)) {\n        const data = eventOrText.data;\n        if (data) {\n          selection.insertText(data);\n        }\n        return true;\n      }\n    }\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REMOVE_TEXT_COMMAND, () => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.removeText();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, format => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.formatText(format);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_ELEMENT_COMMAND, format => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection) && !lexical.$isNodeSelection(selection)) {\n      return false;\n    }\n    const nodes = selection.getNodes();\n    for (const node of nodes) {\n      const element = utils.$getNearestBlockElementAncestorOrThrow(node);\n      element.setFormat(format);\n    }\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertParagraph();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, () => {\n    handleIndentAndOutdent(() => {\n      editor.dispatchCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, '\\t');\n    }, block => {\n      const indent = block.getIndent();\n      if (indent !== 10) {\n        block.setIndent(indent + 1);\n      }\n    });\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, () => {\n    handleIndentAndOutdent(node => {\n      if (lexical.$isTextNode(node)) {\n        const textContent = node.getTextContent();\n        const character = textContent[textContent.length - 1];\n        if (character === '\\t') {\n          editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);\n        }\n      }\n    }, block => {\n      const indent = block.getIndent();\n      if (indent !== 0) {\n        block.setIndent(indent - 1);\n      }\n    });\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, event => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isNodeSelection(selection) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectPrevious();\n        return true;\n      }\n    } else if (lexical.$isRangeSelection(selection)) {\n      const possibleNode = lexical.$getAdjacentNode(selection.focus, true);\n      if (lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectPrevious();\n        event.preventDefault();\n        return true;\n      } else if (lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\n        possibleNode.select();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    } else if (lexical.$isRangeSelection(selection)) {\n      if ($isSelectionAtEndOfRoot(selection)) {\n        event.preventDefault();\n        return true;\n      }\n      const possibleNode = lexical.$getAdjacentNode(selection.focus, false);\n      if (lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectNext();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, event => {\n    const selection$1 = lexical.$getSelection();\n    if (lexical.$isNodeSelection(selection$1)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection$1.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, true)) {\n      const isHoldingShift = event.shiftKey;\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, true);\n      return true;\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection$1 = lexical.$getSelection();\n    if (lexical.$isNodeSelection(selection$1) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection$1.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n    const isHoldingShift = event.shiftKey;\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, false)) {\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, false);\n      return true;\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n    if (selection.isCollapsed() && anchor.offset === 0 && !lexical.$isRootNode(anchorNode)) {\n      const element = utils.$getNearestBlockElementAncestorOrThrow(anchorNode);\n      if (element.getIndent() > 0) {\n        return editor.dispatchCommand(lexical.OUTDENT_CONTENT_COMMAND, undefined);\n      }\n    }\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_DELETE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, false);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ENTER_COMMAND, event => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n      event.preventDefault();\n      if (event.shiftKey) {\n        return editor.dispatchCommand(lexical.INSERT_LINE_BREAK_COMMAND, false);\n      }\n    }\n    return editor.dispatchCommand(lexical.INSERT_PARAGRAPH_COMMAND, undefined);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, () => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    editor.blur();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DROP_COMMAND, event => {\n    const [, files] = eventFiles(event);\n    if (files.length > 0) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const eventRange = caretFromPoint(x, y);\n      if (eventRange !== null) {\n        const {\n          offset: domOffset,\n          node: domNode\n        } = eventRange;\n        const node = lexical.$getNearestNodeFromDOMNode(domNode);\n        if (node !== null) {\n          const selection = lexical.$createRangeSelection();\n          if (lexical.$isTextNode(node)) {\n            selection.anchor.set(node.getKey(), domOffset, 'text');\n            selection.focus.set(node.getKey(), domOffset, 'text');\n          } else {\n            const parentKey = node.getParentOrThrow().getKey();\n            const offset = node.getIndexWithinParent() + 1;\n            selection.anchor.set(parentKey, offset, 'element');\n            selection.focus.set(parentKey, offset, 'element');\n          }\n          const normalizedSelection = lexical.$normalizeSelection__EXPERIMENTAL(selection);\n          lexical.$setSelection(normalizedSelection);\n        }\n        editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      }\n      event.preventDefault();\n      return true;\n    }\n    const selection = lexical.$getSelection();\n    if (lexical.$isRangeSelection(selection)) {\n      return true;\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGSTART_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = lexical.$getSelection();\n    if (isFileTransfer && !lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGOVER_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = lexical.$getSelection();\n    if (isFileTransfer && !lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    const x = event.clientX;\n    const y = event.clientY;\n    const eventRange = caretFromPoint(x, y);\n    if (eventRange !== null) {\n      const node = lexical.$getNearestNodeFromDOMNode(eventRange.node);\n      if (lexical.$isDecoratorNode(node)) {\n        // Show browser caret as the user is dragging the media across the screen. Won't work\n        // for DecoratorNode nor it's relevant.\n        event.preventDefault();\n      }\n    }\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.COPY_COMMAND, event => {\n    clipboard.copyToClipboard__EXPERIMENTAL(editor, event instanceof ClipboardEvent ? event : null);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CUT_COMMAND, event => {\n    onCutForRichText(event, editor);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.PASTE_COMMAND, event => {\n    const [, files, hasTextContent] = eventFiles(event);\n    if (files.length > 0 && !hasTextContent) {\n      editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      return true;\n    }\n    const selection = lexical.$getSelection();\n    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\nexports.$createHeadingNode = $createHeadingNode;\nexports.$createQuoteNode = $createQuoteNode;\nexports.$isHeadingNode = $isHeadingNode;\nexports.$isQuoteNode = $isQuoteNode;\nexports.DRAG_DROP_PASTE = DRAG_DROP_PASTE;\nexports.HeadingNode = HeadingNode;\nexports.QuoteNode = QuoteNode;\nexports.eventFiles = eventFiles;\nexports.registerRichText = registerRichText;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalRichText = process.env.NODE_ENV === 'development' ? require('./LexicalRichText.dev.js') : require('./LexicalRichText.prod.js')\nmodule.exports = LexicalRichText;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/** @module @lexical/link */\n/** @noInheritDoc */\nclass LinkNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'link';\n  }\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target\n    }, node.__key);\n  }\n  constructor(url, attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n  }\n  createDOM(config) {\n    const element = document.createElement('a');\n    element.href = this.__url;\n    if (this.__target !== null) {\n      element.target = this.__target;\n    }\n    if (this.__rel !== null) {\n      element.rel = this.__rel;\n    }\n    utils.addClassNamesToElement(element, config.theme.link);\n    return element;\n  }\n  updateDOM(prevNode, anchor, config) {\n    const url = this.__url;\n    const target = this.__target;\n    const rel = this.__rel;\n    if (url !== prevNode.__url) {\n      anchor.href = url;\n    }\n    if (target !== prevNode.__target) {\n      if (target) {\n        anchor.target = target;\n      } else {\n        anchor.removeAttribute('target');\n      }\n    }\n    if (rel !== prevNode.__rel) {\n      if (rel) {\n        anchor.rel = rel;\n      } else {\n        anchor.removeAttribute('rel');\n      }\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      type: 'link',\n      url: this.getURL(),\n      version: 1\n    };\n  }\n  getURL() {\n    return this.getLatest().__url;\n  }\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n  }\n  getTarget() {\n    return this.getLatest().__target;\n  }\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n  }\n  getRel() {\n    return this.getLatest().__rel;\n  }\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if (lexical.$isElementNode(element)) {\n      const linkNode = $createLinkNode(this.__url, {\n        rel: this.__rel,\n        target: this.__target\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n}\nfunction convertAnchorElement(domNode) {\n  let node = null;\n  if (utils.isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent;\n    if (content !== null && content !== '') {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target')\n      });\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $createLinkNode(url, attributes) {\n  return lexical.$applyNodeReplacement(new LinkNode(url, attributes));\n}\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  static getType() {\n    return 'autolink';\n  }\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target\n    }, node.__key);\n  }\n  static importJSON(serializedNode) {\n    const node = $createAutoLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'autolink',\n      version: 1\n    };\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if (lexical.$isElementNode(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        rel: this._rel,\n        target: this.__target\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n}\nfunction $createAutoLinkNode(url, attributes) {\n  return lexical.$applyNodeReplacement(new AutoLinkNode(url, attributes));\n}\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = lexical.createCommand('TOGGLE_LINK_COMMAND');\nfunction toggleLink(url, attributes = {}) {\n  const {\n    target\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noopener' : attributes.rel;\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection)) {\n    return;\n  }\n  const nodes = selection.extract();\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parent = node.getParent();\n      if ($isLinkNode(parent)) {\n        const children = parent.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          parent.insertBefore(children[i]);\n        }\n        parent.remove();\n      }\n    });\n  } else {\n    // Add or merge LinkNodes\n    if (nodes.length === 1) {\n      const firstNode = nodes[0];\n      // if the first node is a LinkNode or if its\n      // parent is a LinkNode, we update the URL, target and rel.\n      const linkNode = $isLinkNode(firstNode) ? firstNode : $getLinkAncestor(firstNode);\n      if (linkNode !== null) {\n        linkNode.setURL(url);\n        if (target !== undefined) {\n          linkNode.setTarget(target);\n        }\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n        return;\n      }\n    }\n    let prevParent = null;\n    let linkNode = null;\n    nodes.forEach(node => {\n      const parent = node.getParent();\n      if (parent === linkNode || parent === null || lexical.$isElementNode(node) && !node.isInline()) {\n        return;\n      }\n      if ($isLinkNode(parent)) {\n        linkNode = parent;\n        parent.setURL(url);\n        if (target !== undefined) {\n          parent.setTarget(target);\n        }\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n        return;\n      }\n      if (!parent.is(prevParent)) {\n        prevParent = parent;\n        linkNode = $createLinkNode(url, {\n          rel,\n          target\n        });\n        if ($isLinkNode(parent)) {\n          if (node.getPreviousSibling() === null) {\n            parent.insertBefore(linkNode);\n          } else {\n            parent.insertAfter(linkNode);\n          }\n        } else {\n          node.insertBefore(linkNode);\n        }\n      }\n      if ($isLinkNode(node)) {\n        if (node.is(linkNode)) {\n          return;\n        }\n        if (linkNode !== null) {\n          const children = node.getChildren();\n          for (let i = 0; i < children.length; i++) {\n            linkNode.append(children[i]);\n          }\n        }\n        node.remove();\n        return;\n      }\n      if (linkNode !== null) {\n        linkNode.append(node);\n      }\n    });\n  }\n}\nfunction $getLinkAncestor(node) {\n  return $getAncestor(node, ancestor => $isLinkNode(ancestor));\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && (parent = parent.getParent()) !== null && !predicate(parent));\n  return parent;\n}\n\nexports.$createAutoLinkNode = $createAutoLinkNode;\nexports.$createLinkNode = $createLinkNode;\nexports.$isAutoLinkNode = $isAutoLinkNode;\nexports.$isLinkNode = $isLinkNode;\nexports.AutoLinkNode = AutoLinkNode;\nexports.LinkNode = LinkNode;\nexports.TOGGLE_LINK_COMMAND = TOGGLE_LINK_COMMAND;\nexports.toggleLink = toggleLink;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalLink = process.env.NODE_ENV === 'development' ? require('./LexicalLink.dev.js') : require('./LexicalLink.prod.js')\nmodule.exports = LexicalLink;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar code = require('@lexical/code');\nvar list = require('@lexical/list');\nvar richText = require('@lexical/rich-text');\nvar utils = require('@lexical/utils');\nvar link = require('@lexical/link');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction indexBy(list, callback) {\n  const index = {};\n  for (const item of list) {\n    const key = callback(item);\n    if (index[key]) {\n      index[key].push(item);\n    } else {\n      index[key] = [item];\n    }\n  }\n  return index;\n}\nfunction transformersByType(transformers) {\n  const byType = indexBy(transformers, t => t.type);\n  return {\n    element: byType.element || [],\n    textFormat: byType['text-format'] || [],\n    textMatch: byType['text-match'] || []\n  };\n}\nconst PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\\s]/;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction createMarkdownExport(transformers) {\n  const byType = transformersByType(transformers);\n\n  // Export only uses text formats that are responsible for single format\n  // e.g. it will filter out *** (bold, italic) and instead use separate ** and *\n  const textFormatTransformers = byType.textFormat.filter(transformer => transformer.format.length === 1);\n  return () => {\n    const output = [];\n    const children = lexical.$getRoot().getChildren();\n    for (const child of children) {\n      const result = exportTopLevelElements(child, byType.element, textFormatTransformers, byType.textMatch);\n      if (result != null) {\n        output.push(result);\n      }\n    }\n    return output.join('\\n\\n');\n  };\n}\nfunction exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {\n  for (const transformer of elementTransformers) {\n    const result = transformer.export(node, _node => exportChildren(_node, textTransformersIndex, textMatchTransformers));\n    if (result != null) {\n      return result;\n    }\n  }\n  if (lexical.$isElementNode(node)) {\n    return exportChildren(node, textTransformersIndex, textMatchTransformers);\n  } else if (lexical.$isDecoratorNode(node)) {\n    return node.getTextContent();\n  } else {\n    return null;\n  }\n}\nfunction exportChildren(node, textTransformersIndex, textMatchTransformers) {\n  const output = [];\n  const children = node.getChildren();\n  mainLoop: for (const child of children) {\n    for (const transformer of textMatchTransformers) {\n      const result = transformer.export(child, parentNode => exportChildren(parentNode, textTransformersIndex, textMatchTransformers), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex));\n      if (result != null) {\n        output.push(result);\n        continue mainLoop;\n      }\n    }\n    if (lexical.$isLineBreakNode(child)) {\n      output.push('\\n');\n    } else if (lexical.$isTextNode(child)) {\n      output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex));\n    } else if (lexical.$isElementNode(child)) {\n      output.push(exportChildren(child, textTransformersIndex, textMatchTransformers));\n    } else if (lexical.$isDecoratorNode(child)) {\n      output.push(child.getTextContent());\n    }\n  }\n  return output.join('');\n}\nfunction exportTextFormat(node, textContent, textTransformers) {\n  // This function handles the case of a string looking like this: \"   foo   \"\n  // Where it would be invalid markdown to generate: \"**   foo   **\"\n  // We instead want to trim the whitespace out, apply formatting, and then\n  // bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\n  const frozenString = textContent.trim();\n  let output = frozenString;\n  const applied = new Set();\n  for (const transformer of textTransformers) {\n    const format = transformer.format[0];\n    const tag = transformer.tag;\n    if (hasFormat(node, format) && !applied.has(format)) {\n      // Multiple tags might be used for the same format (*, _)\n      applied.add(format);\n      // Prevent adding opening tag is already opened by the previous sibling\n      const previousNode = getTextSibling(node, true);\n      if (!hasFormat(previousNode, format)) {\n        output = tag + output;\n      }\n\n      // Prevent adding closing tag if next sibling will do it\n      const nextNode = getTextSibling(node, false);\n      if (!hasFormat(nextNode, format)) {\n        output += tag;\n      }\n    }\n  }\n\n  // Replace trimmed version of textContent ensuring surrounding whitespace is not modified\n  return textContent.replace(frozenString, output);\n}\n\n// Get next or previous text sibling a text node, including cases\n// when it's a child of inline element (e.g. link)\nfunction getTextSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  if (!sibling) {\n    const parent = node.getParentOrThrow();\n    if (parent.isInline()) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n  while (sibling) {\n    if (lexical.$isElementNode(sibling)) {\n      if (!sibling.isInline()) {\n        break;\n      }\n      const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();\n      if (lexical.$isTextNode(descendant)) {\n        return descendant;\n      } else {\n        sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();\n      }\n    }\n    if (lexical.$isTextNode(sibling)) {\n      return sibling;\n    }\n    if (!lexical.$isElementNode(sibling)) {\n      return null;\n    }\n  }\n  return null;\n}\nfunction hasFormat(node, format) {\n  return lexical.$isTextNode(node) && node.hasFormat(format);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst MARKDOWN_EMPTY_LINE_REG_EXP = /^\\s{0,3}$/;\nconst CODE_BLOCK_REG_EXP = /^```(\\w{1,10})?\\s?$/;\nfunction createMarkdownImport(transformers) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);\n  return markdownString => {\n    const lines = markdownString.split('\\n');\n    const linesLength = lines.length;\n    const root = lexical.$getRoot();\n    root.clear();\n    for (let i = 0; i < linesLength; i++) {\n      const lineText = lines[i];\n      // Codeblocks are processed first as anything inside such block\n      // is ignored for further processing\n      // TODO:\n      // Abstract it to be dynamic as other transformers (add multiline match option)\n      const [codeBlockNode, shiftedIndex] = importCodeBlock(lines, i, root);\n      if (codeBlockNode != null) {\n        i = shiftedIndex;\n        continue;\n      }\n      importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch);\n    }\n\n    // Removing empty paragraphs as md does not really\n    // allow empty lines and uses them as dilimiter\n    const children = root.getChildren();\n    for (const child of children) {\n      if (isEmptyParagraph(child)) {\n        child.remove();\n      }\n    }\n    root.selectEnd();\n  };\n}\nfunction isEmptyParagraph(node) {\n  if (!lexical.$isParagraphNode(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  return firstChild == null || node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());\n}\nfunction importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers) {\n  const lineTextTrimmed = lineText.trim();\n  const textNode = lexical.$createTextNode(lineTextTrimmed);\n  const elementNode = lexical.$createParagraphNode();\n  elementNode.append(textNode);\n  rootNode.append(elementNode);\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = lineText.match(regExp);\n    if (match) {\n      textNode.setTextContent(lineText.slice(match[0].length));\n      replace(elementNode, [textNode], match, true);\n      break;\n    }\n  }\n  importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers);\n\n  // If no transformer found and we left with original paragraph node\n  // can check if its content can be appended to the previous node\n  // if it's a paragraph, quote or list\n  if (elementNode.isAttached() && lineTextTrimmed.length > 0) {\n    const previousNode = elementNode.getPreviousSibling();\n    if (lexical.$isParagraphNode(previousNode) || richText.$isQuoteNode(previousNode) || list.$isListNode(previousNode)) {\n      let targetNode = previousNode;\n      if (list.$isListNode(previousNode)) {\n        const lastDescendant = previousNode.getLastDescendant();\n        if (lastDescendant == null) {\n          targetNode = null;\n        } else {\n          targetNode = utils.$findMatchingParent(lastDescendant, list.$isListItemNode);\n        }\n      }\n      if (targetNode != null && targetNode.getTextContentSize() > 0) {\n        targetNode.splice(targetNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...elementNode.getChildren()]);\n        elementNode.remove();\n      }\n    }\n  }\n}\nfunction importCodeBlock(lines, startLineIndex, rootNode) {\n  const openMatch = lines[startLineIndex].match(CODE_BLOCK_REG_EXP);\n  if (openMatch) {\n    let endLineIndex = startLineIndex;\n    const linesLength = lines.length;\n    while (++endLineIndex < linesLength) {\n      const closeMatch = lines[endLineIndex].match(CODE_BLOCK_REG_EXP);\n      if (closeMatch) {\n        const codeBlockNode = code.$createCodeNode(openMatch[1]);\n        const textNode = lexical.$createTextNode(lines.slice(startLineIndex + 1, endLineIndex).join('\\n'));\n        codeBlockNode.append(textNode);\n        rootNode.append(codeBlockNode);\n        return [codeBlockNode, endLineIndex];\n      }\n    }\n  }\n  return [null, startLineIndex];\n}\n\n// Processing text content and replaces text format tags.\n// It takes outermost tag match and its content, creates text node with\n// format based on tag and then recursively executed over node's content\n//\n// E.g. for \"*Hello **world**!*\" string it will create text node with\n// \"Hello **world**!\" content and italic format and run recursively over\n// its content to transform \"**world**\" part\nfunction importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {\n  const textContent = textNode.getTextContent();\n  const match = findOutermostMatch(textContent, textFormatTransformersIndex);\n  if (!match) {\n    // Once text format processing is done run text match transformers, as it\n    // only can span within single text node (unline formats that can cover multiple nodes)\n    importTextMatchTransformers(textNode, textMatchTransformers);\n    return;\n  }\n  let currentNode, remainderNode, leadingNode;\n\n  // If matching full content there's no need to run splitText and can reuse existing textNode\n  // to update its content and apply format. E.g. for **_Hello_** string after applying bold\n  // format (**) it will reuse the same text node to apply italic (_)\n  if (match[0] === textContent) {\n    currentNode = textNode;\n  } else {\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    if (startIndex === 0) {\n      [currentNode, remainderNode] = textNode.splitText(endIndex);\n    } else {\n      [leadingNode, currentNode, remainderNode] = textNode.splitText(startIndex, endIndex);\n    }\n  }\n  currentNode.setTextContent(match[2]);\n  const transformer = textFormatTransformersIndex.transformersByTag[match[1]];\n  if (transformer) {\n    for (const format of transformer.format) {\n      if (!currentNode.hasFormat(format)) {\n        currentNode.toggleFormat(format);\n      }\n    }\n  }\n\n  // Recursively run over inner text if it's not inline code\n  if (!currentNode.hasFormat('code')) {\n    importTextFormatTransformers(currentNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n\n  // Run over leading/remaining text if any\n  if (leadingNode) {\n    importTextFormatTransformers(leadingNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n  if (remainderNode) {\n    importTextFormatTransformers(remainderNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n}\nfunction importTextMatchTransformers(textNode_, textMatchTransformers) {\n  let textNode = textNode_;\n  mainLoop: while (textNode) {\n    for (const transformer of textMatchTransformers) {\n      const match = textNode.getTextContent().match(transformer.importRegExp);\n      if (!match) {\n        continue;\n      }\n      const startIndex = match.index || 0;\n      const endIndex = startIndex + match[0].length;\n      let replaceNode, leftTextNode, rightTextNode;\n      if (startIndex === 0) {\n        [replaceNode, textNode] = textNode.splitText(endIndex);\n      } else {\n        [leftTextNode, replaceNode, rightTextNode] = textNode.splitText(startIndex, endIndex);\n      }\n      if (leftTextNode) {\n        importTextMatchTransformers(leftTextNode, textMatchTransformers);\n      }\n      if (rightTextNode) {\n        textNode = rightTextNode;\n      }\n      transformer.replace(replaceNode, match);\n      continue mainLoop;\n    }\n    break;\n  }\n}\n\n// Finds first \"<tag>content<tag>\" match that is not nested into another tag\nfunction findOutermostMatch(textContent, textTransformersIndex) {\n  const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);\n  if (openTagsMatch == null) {\n    return null;\n  }\n  for (const match of openTagsMatch) {\n    // Open tags reg exp might capture leading space so removing it\n    // before using match to find transformer\n    const tag = match.replace(/^\\s/, '');\n    const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];\n    if (fullMatchRegExp == null) {\n      continue;\n    }\n    const fullMatch = textContent.match(fullMatchRegExp);\n    const transformer = textTransformersIndex.transformersByTag[tag];\n    if (fullMatch != null && transformer != null) {\n      if (transformer.intraword !== false) {\n        return fullMatch;\n      }\n\n      // For non-intraword transformers checking if it's within a word\n      // or surrounded with space/punctuation/newline\n      const {\n        index = 0\n      } = fullMatch;\n      const beforeChar = textContent[index - 1];\n      const afterChar = textContent[index + fullMatch[0].length];\n      if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {\n        return fullMatch;\n      }\n    }\n  }\n  return null;\n}\nfunction createTextFormatTransformersIndex(textTransformers) {\n  const transformersByTag = {};\n  const fullMatchRegExpByTag = {};\n  const openTagsRegExp = [];\n  const escapeRegExp = `(?<![\\\\\\\\])`;\n  for (const transformer of textTransformers) {\n    const {\n      tag\n    } = transformer;\n    transformersByTag[tag] = transformer;\n    const tagRegExp = tag.replace(/(\\*|\\^|\\+)/g, '\\\\$1');\n    openTagsRegExp.push(tagRegExp);\n    if (IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT) {\n      fullMatchRegExpByTag[tag] = new RegExp(`(${tagRegExp})(?![${tagRegExp}\\\\s])(.*?[^${tagRegExp}\\\\s])${tagRegExp}(?!${tagRegExp})`);\n    } else {\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\\\\${tagRegExp}])(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^${tagRegExp}\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?![\\\\\\\\${tagRegExp}])`);\n    }\n  }\n  return {\n    // Reg exp to find open tag + content + close tag\n    fullMatchRegExpByTag,\n    // Reg exp to find opening tags\n    openTagsRegExp: new RegExp((IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? '' : `${escapeRegExp}`) + '(' + openTagsRegExp.join('|') + ')', 'g'),\n    transformersByTag\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n  if (!lexical.$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n  const textContent = anchorNode.getTextContent();\n\n  // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = textContent.match(regExp);\n    if (match && match[0].length === anchorOffset) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      leadingNode.remove();\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      replace(parentNode, siblings, match, false);\n      return true;\n    }\n  }\n  return false;\n}\nfunction runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {\n  let textContent = anchorNode.getTextContent();\n  const lastChar = textContent[anchorOffset - 1];\n  const transformers = transformersByTrigger[lastChar];\n  if (transformers == null) {\n    return false;\n  }\n\n  // If typing in the middle of content, remove the tail to do\n  // reg exp match up to a string end (caret position)\n  if (anchorOffset < textContent.length) {\n    textContent = textContent.slice(0, anchorOffset);\n  }\n  for (const transformer of transformers) {\n    const match = textContent.match(transformer.regExp);\n    if (match === null) {\n      continue;\n    }\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    let replaceNode;\n    if (startIndex === 0) {\n      [replaceNode] = anchorNode.splitText(endIndex);\n    } else {\n      [, replaceNode] = anchorNode.splitText(startIndex, endIndex);\n    }\n    replaceNode.selectNext(0, 0);\n    transformer.replace(replaceNode, match);\n    return true;\n  }\n  return false;\n}\nfunction runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {\n  const textContent = anchorNode.getTextContent();\n  const closeTagEndIndex = anchorOffset - 1;\n  const closeChar = textContent[closeTagEndIndex];\n  // Quick check if we're possibly at the end of inline markdown style\n  const matchers = textFormatTransformers[closeChar];\n  if (!matchers) {\n    return false;\n  }\n  for (const matcher of matchers) {\n    const {\n      tag\n    } = matcher;\n    const tagLength = tag.length;\n    const closeTagStartIndex = closeTagEndIndex - tagLength + 1;\n\n    // If tag is not single char check if rest of it matches with text content\n    if (tagLength > 1) {\n      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {\n        continue;\n      }\n    }\n\n    // Space before closing tag cancels inline markdown\n    if (textContent[closeTagStartIndex - 1] === ' ') {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation after it\n    const afterCloseTagChar = textContent[closeTagEndIndex + 1];\n    if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {\n      continue;\n    }\n    const closeNode = anchorNode;\n    let openNode = closeNode;\n    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag);\n\n    // Go through text node siblings and search for opening tag\n    // if haven't found it within the same text node as closing tag\n    let sibling = openNode;\n    while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {\n      if (lexical.$isLineBreakNode(sibling)) {\n        break;\n      }\n      if (lexical.$isTextNode(sibling)) {\n        const siblingTextContent = sibling.getTextContent();\n        openNode = sibling;\n        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);\n      }\n    }\n\n    // Opening tag is not found\n    if (openTagStartIndex < 0) {\n      continue;\n    }\n\n    // No content between opening and closing tag\n    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {\n      continue;\n    }\n\n    // Checking longer tags for repeating chars (e.g. *** vs **)\n    const prevOpenNodeText = openNode.getTextContent();\n    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation before it\n    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];\n    if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {\n      continue;\n    }\n\n    // Clean text from opening and closing tags (starting from closing tag\n    // to prevent any offset shifts if we start from opening one)\n    const prevCloseNodeText = closeNode.getTextContent();\n    const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);\n    closeNode.setTextContent(closeNodeText);\n    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;\n    openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));\n    const selection = lexical.$getSelection();\n    const nextSelection = lexical.$createRangeSelection();\n    lexical.$setSelection(nextSelection);\n    // Adjust offset based on deleted chars\n    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;\n    nextSelection.anchor.set(openNode.__key, openTagStartIndex, 'text');\n    nextSelection.focus.set(closeNode.__key, newOffset, 'text');\n\n    // Apply formatting to selected text\n    for (const format of matcher.format) {\n      if (!nextSelection.hasFormat(format)) {\n        nextSelection.formatText(format);\n      }\n    }\n\n    // Collapse selection up to the focus point\n    nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type);\n\n    // Remove formatting from collapsed selection\n    for (const format of matcher.format) {\n      if (nextSelection.hasFormat(format)) {\n        nextSelection.toggleFormat(format);\n      }\n    }\n    if (lexical.$isRangeSelection(selection)) {\n      nextSelection.format = selection.format;\n    }\n    return true;\n  }\n  return false;\n}\nfunction getOpenTagStartIndex(string, maxIndex, tag) {\n  const tagLength = tag.length;\n  for (let i = maxIndex; i >= tagLength; i--) {\n    const startIndex = i - tagLength;\n    if (isEqualSubString(string, startIndex, tag, 0, tagLength) &&\n    // Space after opening tag cancels transformation\n    string[startIndex + tagLength] !== ' ') {\n      return startIndex;\n    }\n  }\n  return -1;\n}\nfunction isEqualSubString(stringA, aStart, stringB, bStart, length) {\n  for (let i = 0; i < length; i++) {\n    if (stringA[aStart + i] !== stringB[bStart + i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = indexBy(byType.textFormat, ({\n    tag\n  }) => tag[tag.length - 1]);\n  const textMatchTransformersIndex = indexBy(byType.textMatch, ({\n    trigger\n  }) => trigger);\n  for (const transformer of transformers) {\n    const type = transformer.type;\n    if (type === 'element' || type === 'text-match') {\n      const dependencies = transformer.dependencies;\n      if (!editor.hasNodes(dependencies)) {\n        {\n          throw Error(`MarkdownShortcuts: missing dependency for transformer. Ensure node dependency is included in editor initial config.`);\n        }\n      }\n    }\n  }\n  const transform = (parentNode, anchorNode, anchorOffset) => {\n    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {\n      return;\n    }\n    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersIndex)) {\n      return;\n    }\n    runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersIndex);\n  };\n  return editor.registerUpdateListener(({\n    tags,\n    dirtyLeaves,\n    editorState,\n    prevEditorState\n  }) => {\n    // Ignore updates from undo/redo (as changes already calculated)\n    if (tags.has('historic')) {\n      return;\n    }\n    const selection = editorState.read(lexical.$getSelection);\n    const prevSelection = prevEditorState.read(lexical.$getSelection);\n    if (!lexical.$isRangeSelection(prevSelection) || !lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n      return;\n    }\n    const anchorKey = selection.anchor.key;\n    const anchorOffset = selection.anchor.offset;\n    const anchorNode = editorState._nodeMap.get(anchorKey);\n    if (!lexical.$isTextNode(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset !== prevSelection.anchor.offset + 1) {\n      return;\n    }\n    editor.update(() => {\n      // Markdown is not available inside code\n      if (anchorNode.hasFormat('code')) {\n        return;\n      }\n      const parentNode = anchorNode.getParent();\n      if (parentNode === null || code.$isCodeNode(parentNode)) {\n        return;\n      }\n      transform(parentNode, anchorNode, selection.anchor.offset);\n    });\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst createBlockNode = createNode => {\n  return (parentNode, children, match) => {\n    const node = createNode(match);\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  };\n};\n\n// Amount of spaces that define indentation level\n// TODO: should be an option\nconst LIST_INDENT_SIZE = 4;\nconst listReplace = listType => {\n  return (parentNode, children, match) => {\n    const previousNode = parentNode.getPreviousSibling();\n    const listItem = list.$createListItemNode(listType === 'check' ? match[3] === 'x' : undefined);\n    if (list.$isListNode(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem);\n      parentNode.remove();\n    } else {\n      const list$1 = list.$createListNode(listType, listType === 'number' ? Number(match[2]) : undefined);\n      list$1.append(listItem);\n      parentNode.replace(list$1);\n    }\n    listItem.append(...children);\n    listItem.select(0, 0);\n    const indent = Math.floor(match[1].length / LIST_INDENT_SIZE);\n    if (indent) {\n      listItem.setIndent(indent);\n    }\n  };\n};\nconst listExport = (listNode, exportChildren, depth) => {\n  const output = [];\n  const children = listNode.getChildren();\n  let index = 0;\n  for (const listItemNode of children) {\n    if (list.$isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild();\n        if (list.$isListNode(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1));\n          continue;\n        }\n      }\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE);\n      const listType = listNode.getListType();\n      const prefix = listType === 'number' ? `${listNode.getStart() + index}. ` : listType === 'check' ? `- [${listItemNode.getChecked() ? 'x' : ' '}] ` : '- ';\n      output.push(indent + prefix + exportChildren(listItemNode));\n      index++;\n    }\n  }\n  return output.join('\\n');\n};\nconst HEADING = {\n  dependencies: [richText.HeadingNode],\n  export: (node, exportChildren) => {\n    if (!richText.$isHeadingNode(node)) {\n      return null;\n    }\n    const level = Number(node.getTag().slice(1));\n    return '#'.repeat(level) + ' ' + exportChildren(node);\n  },\n  regExp: /^(#{1,6})\\s/,\n  replace: createBlockNode(match => {\n    const tag = 'h' + match[1].length;\n    return richText.$createHeadingNode(tag);\n  }),\n  type: 'element'\n};\nconst QUOTE = {\n  dependencies: [richText.QuoteNode],\n  export: (node, exportChildren) => {\n    if (!richText.$isQuoteNode(node)) {\n      return null;\n    }\n    const lines = exportChildren(node).split('\\n');\n    const output = [];\n    for (const line of lines) {\n      output.push('> ' + line);\n    }\n    return output.join('\\n');\n  },\n  regExp: /^>\\s/,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling();\n      if (richText.$isQuoteNode(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...children]);\n        previousNode.select(0, 0);\n        parentNode.remove();\n        return;\n      }\n    }\n    const node = richText.$createQuoteNode();\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  },\n  type: 'element'\n};\nconst CODE = {\n  dependencies: [code.CodeNode],\n  export: node => {\n    if (!code.$isCodeNode(node)) {\n      return null;\n    }\n    const textContent = node.getTextContent();\n    return '```' + (node.getLanguage() || '') + (textContent ? '\\n' + textContent : '') + '\\n' + '```';\n  },\n  regExp: /^```(\\w{1,10})?\\s/,\n  replace: createBlockNode(match => {\n    return code.$createCodeNode(match ? match[1] : undefined);\n  }),\n  type: 'element'\n};\nconst UNORDERED_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)[-*+]\\s/,\n  replace: listReplace('bullet'),\n  type: 'element'\n};\nconst CHECK_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i,\n  replace: listReplace('check'),\n  type: 'element'\n};\nconst ORDERED_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(\\d{1,})\\.\\s/,\n  replace: listReplace('number'),\n  type: 'element'\n};\nconst INLINE_CODE = {\n  format: ['code'],\n  tag: '`',\n  type: 'text-format'\n};\nconst HIGHLIGHT = {\n  format: ['highlight'],\n  tag: '==',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_STAR = {\n  format: ['bold', 'italic'],\n  tag: '***',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_UNDERSCORE = {\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n  type: 'text-format'\n};\nconst BOLD_STAR = {\n  format: ['bold'],\n  tag: '**',\n  type: 'text-format'\n};\nconst BOLD_UNDERSCORE = {\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n  type: 'text-format'\n};\nconst STRIKETHROUGH = {\n  format: ['strikethrough'],\n  tag: '~~',\n  type: 'text-format'\n};\nconst ITALIC_STAR = {\n  format: ['italic'],\n  tag: '*',\n  type: 'text-format'\n};\nconst ITALIC_UNDERSCORE = {\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n  type: 'text-format'\n};\n\n// Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst LINK = {\n  dependencies: [link.LinkNode],\n  export: (node, exportChildren, exportFormat) => {\n    if (!link.$isLinkNode(node)) {\n      return null;\n    }\n    const linkContent = `[${node.getTextContent()}](${node.getURL()})`;\n    const firstChild = node.getFirstChild();\n    // Add text styles only if link has single text node inside. If it's more\n    // then one we ignore it as markdown does not support nested styles for links\n    if (node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild)) {\n      return exportFormat(firstChild, linkContent);\n    } else {\n      return linkContent;\n    }\n  },\n  importRegExp: /(?:\\[([^[]+)\\])(?:\\(([^()]+)\\))/,\n  regExp: /(?:\\[([^[]+)\\])(?:\\(([^()]+)\\))$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl] = match;\n    const linkNode = link.$createLinkNode(linkUrl);\n    const linkTextNode = lexical.$createTextNode(linkText);\n    linkTextNode.setFormat(textNode.getFormat());\n    linkNode.append(linkTextNode);\n    textNode.replace(linkNode);\n  },\n  trigger: ')',\n  type: 'text-match'\n};\n\n/** @module @lexical/markdown */\nconst ELEMENT_TRANSFORMERS = [HEADING, QUOTE, CODE, UNORDERED_LIST, ORDERED_LIST];\n\n// Order of text format transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];\nconst TEXT_MATCH_TRANSFORMERS = [LINK];\nconst TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];\nfunction $convertFromMarkdownString(markdown, transformers = TRANSFORMERS) {\n  const importMarkdown = createMarkdownImport(transformers);\n  return importMarkdown(markdown);\n}\nfunction $convertToMarkdownString(transformers = TRANSFORMERS) {\n  const exportMarkdown = createMarkdownExport(transformers);\n  return exportMarkdown();\n}\n\nexports.$convertFromMarkdownString = $convertFromMarkdownString;\nexports.$convertToMarkdownString = $convertToMarkdownString;\nexports.BOLD_ITALIC_STAR = BOLD_ITALIC_STAR;\nexports.BOLD_ITALIC_UNDERSCORE = BOLD_ITALIC_UNDERSCORE;\nexports.BOLD_STAR = BOLD_STAR;\nexports.BOLD_UNDERSCORE = BOLD_UNDERSCORE;\nexports.CHECK_LIST = CHECK_LIST;\nexports.CODE = CODE;\nexports.ELEMENT_TRANSFORMERS = ELEMENT_TRANSFORMERS;\nexports.HEADING = HEADING;\nexports.HIGHLIGHT = HIGHLIGHT;\nexports.INLINE_CODE = INLINE_CODE;\nexports.ITALIC_STAR = ITALIC_STAR;\nexports.ITALIC_UNDERSCORE = ITALIC_UNDERSCORE;\nexports.LINK = LINK;\nexports.ORDERED_LIST = ORDERED_LIST;\nexports.QUOTE = QUOTE;\nexports.STRIKETHROUGH = STRIKETHROUGH;\nexports.TEXT_FORMAT_TRANSFORMERS = TEXT_FORMAT_TRANSFORMERS;\nexports.TEXT_MATCH_TRANSFORMERS = TEXT_MATCH_TRANSFORMERS;\nexports.TRANSFORMERS = TRANSFORMERS;\nexports.UNORDERED_LIST = UNORDERED_LIST;\nexports.registerMarkdownShortcuts = registerMarkdownShortcuts;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalMarkdown = process.env.NODE_ENV === 'development' ? require('./LexicalMarkdown.dev.js') : require('./LexicalMarkdown.prod.js')\nmodule.exports = LexicalMarkdown;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar markdown = require('@lexical/markdown');\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar LexicalHorizontalRuleNode = require('@lexical/react/LexicalHorizontalRuleNode');\nvar react = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst HR = {\n  dependencies: [LexicalHorizontalRuleNode.HorizontalRuleNode],\n  export: node => {\n    return LexicalHorizontalRuleNode.$isHorizontalRuleNode(node) ? '***' : null;\n  },\n  regExp: /^(---|\\*\\*\\*|___)\\s?$/,\n  replace: (parentNode, _1, _2, isImport) => {\n    const line = LexicalHorizontalRuleNode.$createHorizontalRuleNode();\n\n    // TODO: Get rid of isImport flag\n    if (isImport || parentNode.getNextSibling() != null) {\n      parentNode.replace(line);\n    } else {\n      parentNode.insertBefore(line);\n    }\n    line.selectNext();\n  },\n  type: 'element'\n};\nconst DEFAULT_TRANSFORMERS = [HR, ...markdown.TRANSFORMERS];\nfunction MarkdownShortcutPlugin({\n  transformers = DEFAULT_TRANSFORMERS\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    return markdown.registerMarkdownShortcuts(editor, transformers);\n  }, [editor, transformers]);\n  return null;\n}\n\nexports.DEFAULT_TRANSFORMERS = DEFAULT_TRANSFORMERS;\nexports.MarkdownShortcutPlugin = MarkdownShortcutPlugin;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalMarkdownShortcutPlugin = process.env.NODE_ENV === 'development' ? require('./LexicalMarkdownShortcutPlugin.dev.js') : require('./LexicalMarkdownShortcutPlugin.prod.js')\nmodule.exports = LexicalMarkdownShortcutPlugin;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar react = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? react.useLayoutEffect : react.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/**\n * Shortcut to Lexical subscriptions when values are used for render.\n */\nfunction useLexicalSubscription(subscription) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const initializedSubscription = react.useMemo(() => subscription(editor), [editor, subscription]);\n  const valueRef = react.useRef(initializedSubscription.initialValueFn());\n  const [value, setValue] = react.useState(valueRef.current);\n  useLayoutEffect(() => {\n    const {\n      initialValueFn,\n      subscribe\n    } = initializedSubscription;\n    const currentValue = initialValueFn();\n    if (valueRef.current !== currentValue) {\n      valueRef.current = currentValue;\n      setValue(currentValue);\n    }\n    return subscribe(newValue => {\n      valueRef.current = newValue;\n      setValue(newValue);\n    });\n  }, [initializedSubscription, subscription]);\n  return value;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction subscription(editor) {\n  return {\n    initialValueFn: () => editor.isEditable(),\n    subscribe: callback => {\n      return editor.registerEditableListener(callback);\n    }\n  };\n}\nfunction useLexicalEditable() {\n  return useLexicalSubscription(subscription);\n}\n\nmodule.exports = useLexicalEditable;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst useLexicalEditable = process.env.NODE_ENV === 'development' ? require('./useLexicalEditable.dev.js') : require('./useLexicalEditable.prod.js')\nmodule.exports = useLexicalEditable;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/** @module @lexical/text */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n  mainLoop: while (node !== null) {\n    if (lexical.$isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if (lexical.$isTextNode(node)) {\n      const characters = node.getTextContentSize();\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n      currentCharacters += characters;\n    }\n    const sibling = node.getNextSibling();\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n    let parent = node.getParent();\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n      parent = parent.getParent();\n    }\n    break;\n  }\n  return null;\n}\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n  let text = $rootTextContent();\n  if (trim) {\n    text = text.trim();\n  }\n  return text === '';\n}\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\nfunction $rootTextContent() {\n  const root = lexical.$getRoot();\n  return root.getTextContent();\n}\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n  const root = lexical.$getRoot();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n  if (childrenLength > 1) {\n    return false;\n  }\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n    if (lexical.$isElementNode(topBlock)) {\n      if (!lexical.$isParagraphNode(topBlock)) {\n        return false;\n      }\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n        if (!lexical.$isTextNode(child)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const replaceWithSimpleText = node => {\n    const textNode = lexical.$createTextNode(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n  const textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n    if (lexical.$isTextNode(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    }\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n        if (lexical.$isTextNode(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      } else {\n        const nextMatch = getMatch(nextText);\n        if (nextMatch !== null && nextMatch.start === 0) {\n          return;\n        }\n      }\n      if (match === null) {\n        return;\n      }\n      if (match.start === 0 && lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n        continue;\n      }\n      let nodeToReplace;\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start, match.end);\n      }\n      const replacementNode = createNode(nodeToReplace);\n      nodeToReplace.replace(replacementNode);\n      if (currentNode == null) {\n        return;\n      }\n    }\n  };\n  const reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n    if (match === null || match.start !== 0) {\n      replaceWithSimpleText(node);\n      return;\n    }\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    if (lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n      replaceWithSimpleText(prevSibling);\n      replaceWithSimpleText(node);\n    }\n    const nextSibling = node.getNextSibling();\n    if (lexical.$isTextNode(nextSibling) && nextSibling.isTextEntity()) {\n      replaceWithSimpleText(nextSibling);\n\n      // This may have already been converted in the previous block\n      if (isTargetNode(node)) {\n        replaceWithSimpleText(node);\n      }\n    }\n  };\n  const removePlainTextTransform = editor.registerNodeTransform(lexical.TextNode, textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\nexports.$canShowPlaceholder = $canShowPlaceholder;\nexports.$canShowPlaceholderCurry = $canShowPlaceholderCurry;\nexports.$findTextIntersectionFromCharacters = $findTextIntersectionFromCharacters;\nexports.$isRootTextContentEmpty = $isRootTextContentEmpty;\nexports.$isRootTextContentEmptyCurry = $isRootTextContentEmptyCurry;\nexports.$rootTextContent = $rootTextContent;\nexports.registerLexicalTextEntity = registerLexicalTextEntity;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalText = process.env.NODE_ENV === 'development' ? require('./LexicalText.dev.js') : require('./LexicalText.prod.js')\nmodule.exports = LexicalText;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/** @module @lexical/dragon */\nfunction registerDragonSupport(editor) {\n  const origin = window.location.origin;\n  const handler = event => {\n    if (event.origin !== origin) {\n      return;\n    }\n    const rootElement = editor.getRootElement();\n    if (document.activeElement !== rootElement) {\n      return;\n    }\n    const data = event.data;\n    if (typeof data === 'string') {\n      let parsedData;\n      try {\n        parsedData = JSON.parse(data);\n      } catch (e) {\n        return;\n      }\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\n        const payload = parsedData.payload;\n        if (payload && payload.functionId === 'makeChanges') {\n          const args = payload.args;\n          if (args) {\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args;\n            editor.update(() => {\n              const selection = lexical.$getSelection();\n              if (lexical.$isRangeSelection(selection)) {\n                const anchor = selection.anchor;\n                let anchorNode = anchor.getNode();\n                let setSelStart = 0;\n                let setSelEnd = 0;\n                if (lexical.$isTextNode(anchorNode)) {\n                  // set initial selection\n                  if (elementStart >= 0 && elementLength >= 0) {\n                    setSelStart = elementStart;\n                    setSelEnd = elementStart + elementLength;\n                    // If the offset is more than the end, make it the end\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                  }\n                }\n                if (setSelStart !== setSelEnd || text !== '') {\n                  selection.insertRawText(text);\n                  anchorNode = anchor.getNode();\n                }\n                if (lexical.$isTextNode(anchorNode)) {\n                  // set final selection\n                  setSelStart = selStart;\n                  setSelEnd = selStart + selLength;\n                  const anchorNodeTextLength = anchorNode.getTextContentSize();\n                  // If the offset is more than the end, make it the end\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                }\n\n                // block the chrome extension from handling this event\n                event.stopImmediatePropagation();\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n  window.addEventListener('message', handler, true);\n  return () => {\n    window.removeEventListener('message', handler, true);\n  };\n}\n\nexports.registerDragonSupport = registerDragonSupport;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalDragon = process.env.NODE_ENV === 'development' ? require('./LexicalDragon.dev.js') : require('./LexicalDragon.prod.js')\nmodule.exports = LexicalDragon;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar useLexicalEditable = require('@lexical/react/useLexicalEditable');\nvar React = require('react');\nvar text = require('@lexical/text');\nvar utils = require('@lexical/utils');\nvar reactDom = require('react-dom');\nvar dragon = require('@lexical/dragon');\nvar richText = require('@lexical/rich-text');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction canShowPlaceholderFromCurrentEditorState(editor) {\n  const currentCanShowPlaceholder = editor.getEditorState().read(text.$canShowPlaceholderCurry(editor.isComposing()));\n  return currentCanShowPlaceholder;\n}\nfunction useCanShowPlaceholder(editor) {\n  const [canShowPlaceholder, setCanShowPlaceholder] = React.useState(() => canShowPlaceholderFromCurrentEditorState(editor));\n  useLayoutEffect(() => {\n    function resetCanShowPlaceholder() {\n      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);\n      setCanShowPlaceholder(currentCanShowPlaceholder);\n    }\n    resetCanShowPlaceholder();\n    return utils.mergeRegister(editor.registerUpdateListener(() => {\n      resetCanShowPlaceholder();\n    }), editor.registerEditableListener(() => {\n      resetCanShowPlaceholder();\n    }));\n  }, [editor]);\n  return canShowPlaceholder;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useDecorators(editor, ErrorBoundary) {\n  const [decorators, setDecorators] = React.useState(() => editor.getDecorators());\n\n  // Subscribe to changes\n  useLayoutEffect(() => {\n    return editor.registerDecoratorListener(nextDecorators => {\n      reactDom.flushSync(() => {\n        setDecorators(nextDecorators);\n      });\n    });\n  }, [editor]);\n  React.useEffect(() => {\n    // If the content editable mounts before the subscription is added, then\n    // nothing will be rendered on initial pass. We can get around that by\n    // ensuring that we set the value.\n    setDecorators(editor.getDecorators());\n  }, [editor]);\n\n  // Return decorators defined as React Portals\n  return React.useMemo(() => {\n    const decoratedPortals = [];\n    const decoratorKeys = Object.keys(decorators);\n    for (let i = 0; i < decoratorKeys.length; i++) {\n      const nodeKey = decoratorKeys[i];\n      const reactDecorator = /*#__PURE__*/React.createElement(ErrorBoundary, {\n        onError: e => editor._onError(e)\n      }, /*#__PURE__*/React.createElement(React.Suspense, {\n        fallback: null\n      }, decorators[nodeKey]));\n      const element = editor.getElementByKey(nodeKey);\n      if (element !== null) {\n        decoratedPortals.push( /*#__PURE__*/reactDom.createPortal(reactDecorator, element));\n      }\n    }\n    return decoratedPortals;\n  }, [ErrorBoundary, decorators, editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useRichTextSetup(editor) {\n  useLayoutEffect(() => {\n    return utils.mergeRegister(richText.registerRichText(editor), dragon.registerDragonSupport(editor));\n\n    // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction RichTextPlugin({\n  contentEditable,\n  placeholder,\n  ErrorBoundary\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const decorators = useDecorators(editor, ErrorBoundary);\n  useRichTextSetup(editor);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, contentEditable, /*#__PURE__*/React.createElement(Placeholder, {\n    content: placeholder\n  }), decorators);\n}\nfunction Placeholder({\n  content\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const showPlaceholder = useCanShowPlaceholder(editor);\n  const editable = useLexicalEditable();\n  if (!showPlaceholder) {\n    return null;\n  }\n  if (typeof content === 'function') {\n    return content(editable);\n  } else {\n    return content;\n  }\n}\n\nexports.RichTextPlugin = RichTextPlugin;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalRichTextPlugin = process.env.NODE_ENV === 'development' ? require('./LexicalRichTextPlugin.dev.js') : require('./LexicalRichTextPlugin.prod.js')\nmodule.exports = LexicalRichTextPlugin;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar lexical = require('lexical');\nvar react = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * This plugin adds the ability to indent content using the tab key. Generally, we don't\n * recommend using this plugin as it could negatively affect acessibility for keyboard\n * users, causing focus to become trapped within the editor.\n */\nfunction TabIndentationPlugin() {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    return editor.registerCommand(lexical.KEY_TAB_COMMAND, event => {\n      const selection = lexical.$getSelection();\n      if (!lexical.$isRangeSelection(selection)) {\n        return false;\n      }\n      event.preventDefault();\n      return editor.dispatchCommand(event.shiftKey ? lexical.OUTDENT_CONTENT_COMMAND : lexical.INDENT_CONTENT_COMMAND, undefined);\n    }, lexical.COMMAND_PRIORITY_EDITOR);\n  });\n  return null;\n}\n\nexports.TabIndentationPlugin = TabIndentationPlugin;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalTabIndentationPlugin = process.env.NODE_ENV === 'development' ? require('./LexicalTabIndentationPlugin.dev.js') : require('./LexicalTabIndentationPlugin.prod.js')\nmodule.exports = LexicalTabIndentationPlugin;", "\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z\"\n}), 'Code');\n\nexports.default = _default;", "\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z\"\n}), 'FormatBold');\n\nexports.default = _default;", "\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z\"\n}), 'FormatItalic');\n\nexports.default = _default;", "\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z\"\n}), 'FormatListNumbered');\n\nexports.default = _default;", "\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M6.85 7.08C6.85 4.37 9.45 3 12.24 3c1.64 0 3 .49 3.9 1.28.77.65 1.46 1.73 1.46 3.24h-3.01c0-.31-.05-.59-.15-.85-.29-.86-1.2-1.28-2.25-1.28-1.86 0-2.34 1.02-2.34 1.7 0 .48.25.88.74 1.21.38.25.77.48 1.41.7H7.39c-.21-.34-.54-.89-.54-1.92zM21 12v-2H3v2h9.62c1.15.45 1.96.75 1.96 1.97 0 1-.81 1.67-2.28 1.67-1.54 0-2.93-.54-2.93-2.51H6.4c0 .55.08 1.13.24 1.58.81 2.29 3.29 3.3 5.67 3.3 2.27 0 5.3-.89 5.3-4.05 0-.3-.01-1.16-.48-1.94H21V12z\"\n}), 'StrikethroughS');\n\nexports.default = _default;", "\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M14 17H4v2h10v-2zm6-8H4v2h16V9zM4 15h16v-2H4v2zM4 5v2h16V5H4z\"\n}), 'Subject');\n\nexports.default = _default;", "\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M5 4v3h5.5v12h3V7H19V4z\"\n}), 'Title');\n\nexports.default = _default;", "import React, { useState, useEffect, Fragment, useRef, useContext, useCallback, createElement } from \"react\";\nimport { jsxs, jsx, Fragment as Fragment$1 } from \"react/jsx-runtime\";\nimport Avatar from \"@material-ui/core/Avatar\";\nimport Tooltip from \"@material-ui/core/Tooltip\";\nimport Typography from \"@material-ui/core/Typography\";\nimport { makeStyles, useTheme, withStyles } from \"@material-ui/core/styles\";\nimport { gql as gql$2, useLazyQuery, useMutation, useSubscription } from \"@apollo/client\";\nimport CircularProgress from \"@material-ui/core/CircularProgress\";\nimport HelpOutlineOutlined from \"@material-ui/icons/HelpOutlineOutlined\";\nimport { getCSSColor, ServerContext, useMultiToast, useSelection, useDeletionConfirmationDialog, IconOverlay, Toast } from \"@eclipse-sirius/sirius-components-core\";\nimport { useMachine } from \"@xstate/react\";\nimport Tab from \"@material-ui/core/Tab\";\nimport Tabs from \"@material-ui/core/Tabs\";\nimport ToggleButton from \"@material-ui/lab/ToggleButton\";\nimport ToggleButtonGroup from \"@material-ui/lab/ToggleButtonGroup\";\nimport Button from \"@material-ui/core/Button\";\nimport { parse } from \"graphql\";\nimport { BarChart, PieChart } from \"@eclipse-sirius/sirius-components-charts\";\nimport Checkbox from \"@material-ui/core/Checkbox\";\nimport FormControl from \"@material-ui/core/FormControl\";\nimport FormControlLabel from \"@material-ui/core/FormControlLabel\";\nimport FormHelperText from \"@material-ui/core/FormHelperText\";\nimport Link from \"@material-ui/core/Link\";\nimport IconButton from \"@material-ui/core/IconButton\";\nimport Table from \"@material-ui/core/Table\";\nimport TableBody from \"@material-ui/core/TableBody\";\nimport TableCell from \"@material-ui/core/TableCell\";\nimport TableRow from \"@material-ui/core/TableRow\";\nimport DeleteIcon from \"@material-ui/icons/Delete\";\nimport ListItemIcon from \"@material-ui/core/ListItemIcon\";\nimport ListItemText from \"@material-ui/core/ListItemText\";\nimport MenuItem from \"@material-ui/core/MenuItem\";\nimport Select from \"@material-ui/core/Select\";\nimport Radio from \"@material-ui/core/Radio\";\nimport RadioGroup from \"@material-ui/core/RadioGroup\";\nimport require$$1, { COMMAND_PRIORITY_LOW, INSERT_PARAGRAPH_COMMAND, $getSelection, $isRangeSelection, SELECTION_CHANGE_COMMAND, $createParagraphNode, FORMAT_TEXT_COMMAND, $setSelection, TextNode } from \"lexical\";\nimport { LexicalComposer } from \"@lexical/react/LexicalComposer\";\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport LexicalErrorBoundary from \"@lexical/react/LexicalErrorBoundary\";\nimport { HorizontalRuleNode } from \"@lexical/react/LexicalHorizontalRuleNode\";\nimport { MarkdownShortcutPlugin } from \"@lexical/react/LexicalMarkdownShortcutPlugin\";\nimport { RichTextPlugin } from \"@lexical/react/LexicalRichTextPlugin\";\nimport { TabIndentationPlugin } from \"@lexical/react/LexicalTabIndentationPlugin\";\nimport Divider from \"@material-ui/core/Divider\";\nimport Paper from \"@material-ui/core/Paper\";\nimport CodeIcon from \"@material-ui/icons/Code\";\nimport FormatBoldIcon from \"@material-ui/icons/FormatBold\";\nimport FormatItalicIcon from \"@material-ui/icons/FormatItalic\";\nimport FormatListBulletedIcon from \"@material-ui/icons/FormatListBulleted\";\nimport FormatListNumberedIcon from \"@material-ui/icons/FormatListNumbered\";\nimport StrikethroughSIcon from \"@material-ui/icons/StrikethroughS\";\nimport SubjectIcon from \"@material-ui/icons/Subject\";\nimport TitleIcon from \"@material-ui/icons/Title\";\nimport TextField from \"@material-ui/core/TextField\";\nimport MenuList from \"@material-ui/core/MenuList\";\nimport Popover from \"@material-ui/core/Popover\";\nimport { Machine, assign } from \"xstate\";\nimport ChevronRightIcon from \"@material-ui/icons/ChevronRight\";\nimport ExpandMoreIcon from \"@material-ui/icons/ExpandMore\";\nimport { TreeItem as TreeItem$1 } from \"@material-ui/lab\";\nimport TreeView from \"@material-ui/lab/TreeView\";\nconst propertySectionsRegistry = {\n  getComponent: (_widget) => {\n    return null;\n  },\n  getPreviewComponent: (_widget) => {\n    return null;\n  },\n  getWidgetContributions: () => []\n};\nconst value = {\n  propertySectionsRegistry\n};\nconst PropertySectionContext = React.createContext(value);\nconst subscribersUpdatedEventPayloadFragment = `\n  fragment subscribersUpdatedEventPayloadFragment on SubscribersUpdatedEventPayload {\n    id\n    subscribers {\n      username\n    }\n  }\n`;\nconst widgetSubscriptionsUpdatedEventPayloadFragment = `\n  fragment widgetSubscriptionsUpdatedEventPayloadFragment on WidgetSubscriptionsUpdatedEventPayload {\n    id\n    widgetSubscriptions {\n      widgetId\n      subscribers {\n        username\n      }\n    }\n  }\n`;\nconst commonFields = `\n  fragment commonFields on Widget {\n    id\n    __typename\n    diagnostics {\n      id\n      kind\n      message\n    }\n    hasHelpText\n    readOnly\n  }\n`;\nconst widgetFields = (contributions) => `\n  ${commonFields}\n  \n  fragment textfieldFields on Textfield {\n    label\n    iconURL\n    stringValue: value\n    supportsCompletion\n    style {\n      backgroundColor\n      foregroundColor\n      fontSize\n      italic\n      bold\n      underline\n      strikeThrough\n    }\n  }\n\n  fragment textareaFields on Textarea {\n    label\n    iconURL\n    stringValue: value\n    supportsCompletion\n    style {\n      backgroundColor\n      foregroundColor\n      fontSize\n      italic\n      bold\n      underline\n      strikeThrough\n    }\n  }\n\n  fragment checkboxFields on Checkbox {\n    label\n    iconURL\n    booleanValue: value\n    style {\n      color\n      labelPlacement\n    }\n  }\n\n  fragment selectFields on Select {\n    label\n    iconURL\n    value\n    options {\n      id\n      label\n      iconURL\n    }\n    style {\n      backgroundColor\n      foregroundColor\n      fontSize\n      italic\n      bold\n      underline\n      strikeThrough\n    }\n  }\n\n  fragment multiSelectFields on MultiSelect {\n    label\n    iconURL\n    values\n    options {\n      id\n      label\n      iconURL\n    }\n    style {\n      backgroundColor\n      foregroundColor\n      fontSize\n      italic\n      bold\n      underline\n      strikeThrough\n    }\n  }\n\n  fragment radioFields on Radio {\n    label\n    iconURL\n    options {\n      id\n      label\n      selected\n    }\n    style {\n      color\n      fontSize\n      italic\n      bold\n      underline\n      strikeThrough\n    }\n  }\n\n  fragment listFields on List {\n    label\n    iconURL\n    items {\n      id\n      label\n      kind\n      iconURL\n      deletable\n    }\n    style {\n      color\n      fontSize\n      italic\n      bold\n      underline\n      strikeThrough\n    }\n  }\n\n  fragment linkFields on Link {\n    label\n    iconURL\n    url\n    style {\n      color\n      fontSize\n      italic\n      bold\n      underline\n      strikeThrough\n    }\n  }\n\n  fragment buttonFields on Button {\n    label\n    buttonLabel\n    imageURL\n    style {\n      backgroundColor\n      foregroundColor\n      fontSize\n      italic\n      bold\n      underline\n      strikeThrough\n    }\n  }\n\n  fragment toolbarActionFields on ToolbarAction {\n    label\n    buttonLabel\n    imageURL\n    style {\n      backgroundColor\n      foregroundColor\n      fontSize\n      italic\n      bold\n      underline\n      strikeThrough\n    }\n  }\n\n  fragment chartWidgetFields on ChartWidget {\n    label\n    chart {\n      ... on BarChart {\n        metadata {\n          label\n          kind\n        }\n        label\n        entries {\n          key\n          value\n        }\n        style {\n          barsColor\n          fontSize\n          italic\n          bold\n          underline\n          strikeThrough\n        }\n        width\n        height\n      }\n      ... on PieChart {\n        metadata {\n          label\n          kind\n        }\n        label\n        entries {\n          key\n          value\n        }\n        style {\n          colors\n          strokeColor\n          strokeWidth\n          fontSize\n          italic\n          bold\n          underline\n          strikeThrough\n        }\n      }\n    }\n  } \n\n  fragment labelWidgetFields on LabelWidget {\n    label\n    stringValue: value\n    style {\n      color\n      fontSize\n      italic\n      bold\n      underline\n      strikeThrough\n    }\n  }\n\n  fragment treeWidgetFields on TreeWidget {\n    label\n    iconURL\n    expandedNodesIds\n    nodes {\n      id\n      parentId\n      label\n      kind\n      iconURL\n      selectable\n    }\n  }\n\n  fragment imageFields on Image {\n    label\n    iconURL\n    url\n    maxWidth\n  }\n\n  fragment richTextFields on RichText {\n    label\n    iconURL\n    stringValue: value\n  }\n\n  ${contributions.map(\n  (widget) => `\n    fragment ${widget.name.toLowerCase()}Fields on ${widget.name} {\n      ${widget.fields}\n    }\n    `\n)}\n\n  fragment widgetFields on Widget {\n    ...commonFields\n    ... on Textfield {\n      ...textfieldFields\n    }\n    ... on Textarea {\n      ...textareaFields\n    }\n    ... on Checkbox {\n      ...checkboxFields\n    }\n    ... on Select {\n      ...selectFields\n    }\n    ... on MultiSelect {\n      ...multiSelectFields\n    }\n    ... on Radio {\n      ...radioFields\n    }\n    ... on List {\n      ...listFields\n    }\n    ... on Link {\n      ...linkFields\n    }\n    ... on Button {\n      ...buttonFields\n    }\n    ... on ToolbarAction {\n      ...toolbarActionFields\n    }\n    ... on LabelWidget {\n      ...labelWidgetFields\n    }\n    ... on ChartWidget {\n      ...chartWidgetFields\n    }\n    ... on TreeWidget {\n      ...treeWidgetFields\n    }\n    ... on Image {\n      ...imageFields\n    }\n    ... on RichText {\n      ...richTextFields\n    }\n\n    ${contributions.map(\n  (widget) => `\n      ... on ${widget.name} {\n        ...${widget.name.toLowerCase()}Fields\n      }\n      `\n)}\n  }\n`;\nconst flexboxContainerFields = (contributions) => `\n  ${commonFields}\n  ${widgetFields(contributions)}\n  fragment flexboxContainerFields on FlexboxContainer {\n    ...commonFields\n    label\n    flexDirection\n    flexWrap\n    flexGrow\n    children {\n      ...widgetFields\n      ... on FlexboxContainer {\n        ...commonFields\n        label\n        flexDirection\n        flexWrap\n        flexGrow\n        children {\n          ...widgetFields\n          ... on FlexboxContainer {\n            ...commonFields\n            label\n            flexDirection\n            flexWrap\n            flexGrow\n            children {\n              ...widgetFields\n            }\n            borderStyle {\n              color\n              lineStyle\n              size\n              radius\n            }\n          }\n        }\n        borderStyle {\n          color\n          lineStyle\n          size\n          radius\n        }\n      }\n    }\n    borderStyle {\n      color\n      lineStyle\n      size\n      radius\n    }\n  }\n`;\nconst formRefreshedEventPayloadFragment = (contributions) => `\n  ${widgetFields(contributions)}\n  ${flexboxContainerFields(contributions)}\n  fragment formRefreshedEventPayloadFragment on FormRefreshedEventPayload {\n    id\n    form {\n      id\n      metadata {\n        label\n      }\n      pages {\n        id\n        label\n        groups {\n          id\n          label\n          displayMode\n          toolbarActions {\n            ...commonFields\n            ...toolbarActionFields\n          }\n          borderStyle {\n            color\n            lineStyle\n            size\n            radius\n          }\n          widgets {\n            ...widgetFields\n            ... on FlexboxContainer {\n              ...flexboxContainerFields\n            }\n          }\n        }\n        toolbarActions {\n            ...commonFields\n            ...toolbarActionFields\n        }\n      }\n    }\n  }\n`;\nconst getHelpTextQuery = gql$2`\n  query helpText($editingContextId: ID!, $formId: ID!, $widgetId: ID!) {\n    viewer {\n      editingContext(editingContextId: $editingContextId) {\n        representation(representationId: $formId) {\n          description {\n            ... on FormDescription {\n              helpText(widgetId: $widgetId)\n            }\n          }\n        }\n      }\n    }\n  }\n`;\nfunction HelpTooltip({ editingContextId, formId, widgetId, children }) {\n  const [state, setState] = useState({ open: false, content: null });\n  const [fetchHelpText, { loading, data, error }] = useLazyQuery(\n    getHelpTextQuery\n  );\n  useEffect(() => {\n    if (!loading) {\n      if (error) {\n        setState((prevState) => ({\n          ...prevState,\n          content: /* @__PURE__ */ jsxs(\"div\", { children: [\n            \"`Error while loading the help text: $\",\n            error.message,\n            \"`\"\n          ] })\n        }));\n      }\n      if (data) {\n        const text = data.viewer.editingContext.representation.description.helpText;\n        if (text === null || text.trim().length === 0) {\n          setState((prevState) => ({ ...prevState, content: /* @__PURE__ */ jsx(\"i\", { children: \"No help provided\" }) }));\n        } else {\n          const lines = text.split(\"\\n\");\n          const content = /* @__PURE__ */ jsx(\"div\", { children: lines.map((line, index) => /* @__PURE__ */ jsxs(Fragment, { children: [\n            line,\n            /* @__PURE__ */ jsx(\"br\", {})\n          ] }, index)) });\n          setState((prevState) => ({ ...prevState, content }));\n        }\n      }\n    }\n  }, [loading, data, error]);\n  const handleOpen = () => {\n    setState((prevState) => ({ ...prevState, open: true, content: /* @__PURE__ */ jsx(CircularProgress, { size: \"1em\" }) }));\n    const variables = {\n      editingContextId,\n      formId,\n      widgetId\n    };\n    fetchHelpText({ variables });\n  };\n  const handleClose = () => setState((prevState) => ({ ...prevState, open: false, content: null }));\n  return /* @__PURE__ */ jsx(\n    Tooltip,\n    {\n      open: state.open && state.content !== null,\n      onClose: handleClose,\n      onOpen: handleOpen,\n      title: state.content || \"\",\n      placement: \"top\",\n      arrow: true,\n      children: children || /* @__PURE__ */ jsx(HelpOutlineOutlined, { color: \"secondary\", style: { marginLeft: 8, fontSize: 16 } })\n    }\n  );\n}\nconst usePropertySectionLabelStyles = makeStyles((theme) => ({\n  propertySectionLabel: {\n    display: \"flex\",\n    flexDirection: \"row\",\n    alignItems: \"center\"\n  },\n  subscribers: {\n    marginLeft: \"auto\",\n    display: \"flex\",\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    \"& > *\": {\n      marginLeft: theme.spacing(0.5),\n      marginRight: theme.spacing(0.5)\n    }\n  },\n  avatar: {\n    fontSize: \"0.875rem\",\n    width: theme.spacing(2),\n    height: theme.spacing(2)\n  }\n}));\nconst PropertySectionLabel = ({ editingContextId, formId, widget, subscribers }) => {\n  const classes = usePropertySectionLabelStyles();\n  return /* @__PURE__ */ jsxs(\"div\", { className: classes.propertySectionLabel, children: [\n    /* @__PURE__ */ jsx(Typography, { variant: \"subtitle2\", children: widget.label }),\n    widget.hasHelpText ? /* @__PURE__ */ jsx(HelpTooltip, { editingContextId, formId, widgetId: widget.id }) : null,\n    /* @__PURE__ */ jsx(\"div\", { className: classes.subscribers, children: subscribers.map((subscriber) => /* @__PURE__ */ jsx(Tooltip, { title: subscriber.username, arrow: true, children: /* @__PURE__ */ jsx(Avatar, { classes: { root: classes.avatar }, children: subscriber.username.substring(0, 1).toUpperCase() }) }, subscriber.username)) })\n  ] });\n};\nconst getTextDecorationLineValue = (underline, strikeThrough) => {\n  let value2 = null;\n  if (underline) {\n    if (strikeThrough) {\n      value2 = \"underline line-through\";\n    } else {\n      value2 = \"underline\";\n    }\n  } else if (strikeThrough) {\n    if (underline) {\n      value2 = \"underline line-through\";\n    } else {\n      value2 = \"line-through\";\n    }\n  }\n  return value2;\n};\nfunction useClickHandler(onSimpleClick, onDoubleClick, delay = 250) {\n  const eventRef = useRef(null);\n  const [clicks, setClicks] = useState(0);\n  useEffect(() => {\n    let singleClickTimer;\n    if (clicks === 1) {\n      singleClickTimer = setTimeout(function() {\n        onSimpleClick == null ? void 0 : onSimpleClick(eventRef.current);\n        setClicks(0);\n        eventRef.current = null;\n      }, delay);\n    } else if (clicks === 2) {\n      onDoubleClick == null ? void 0 : onDoubleClick(eventRef.current);\n      eventRef.current = null;\n      setClicks(0);\n    }\n    return () => clearTimeout(singleClickTimer);\n  }, [clicks, onSimpleClick, onDoubleClick, delay]);\n  return (element) => {\n    eventRef.current = element;\n    setClicks(clicks + 1);\n  };\n}\nvar __assign = function() {\n  __assign = Object.assign || function __assign2(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s)\n        if (Object.prototype.hasOwnProperty.call(s, p))\n          t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nvar docCache = /* @__PURE__ */ new Map();\nvar fragmentSourceMap = /* @__PURE__ */ new Map();\nvar printFragmentWarnings = true;\nvar experimentalFragmentVariables = false;\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, \" \").trim();\n}\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\nfunction processFragments(ast) {\n  var seenKeys = /* @__PURE__ */ new Set();\n  var definitions = [];\n  ast.definitions.forEach(function(fragmentDefinition) {\n    if (fragmentDefinition.kind === \"FragmentDefinition\") {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n      var sourceKeySet = fragmentSourceMap.get(fragmentName);\n      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\ngraphql-tag enforces all fragment names across your application to be unique; read more about\\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n      } else if (!sourceKeySet) {\n        fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());\n      }\n      sourceKeySet.add(sourceKey);\n      if (!seenKeys.has(sourceKey)) {\n        seenKeys.add(sourceKey);\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  });\n  return __assign(__assign({}, ast), { definitions });\n}\nfunction stripLoc(doc) {\n  var workSet = new Set(doc.definitions);\n  workSet.forEach(function(node) {\n    if (node.loc)\n      delete node.loc;\n    Object.keys(node).forEach(function(key) {\n      var value2 = node[key];\n      if (value2 && typeof value2 === \"object\") {\n        workSet.add(value2);\n      }\n    });\n  });\n  var loc = doc.loc;\n  if (loc) {\n    delete loc.startToken;\n    delete loc.endToken;\n  }\n  return doc;\n}\nfunction parseDocument(source) {\n  var cacheKey = normalize(source);\n  if (!docCache.has(cacheKey)) {\n    var parsed = parse(source, {\n      experimentalFragmentVariables,\n      allowLegacyFragmentVariables: experimentalFragmentVariables\n    });\n    if (!parsed || parsed.kind !== \"Document\") {\n      throw new Error(\"Not a valid GraphQL document.\");\n    }\n    docCache.set(cacheKey, stripLoc(processFragments(parsed)));\n  }\n  return docCache.get(cacheKey);\n}\nfunction gql(literals) {\n  var args = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n  if (typeof literals === \"string\") {\n    literals = [literals];\n  }\n  var result = literals[0];\n  args.forEach(function(arg, i) {\n    if (arg && arg.kind === \"Document\") {\n      result += arg.loc.source.body;\n    } else {\n      result += arg;\n    }\n    result += literals[i + 1];\n  });\n  return parseDocument(result);\n}\nfunction resetCaches() {\n  docCache.clear();\n  fragmentSourceMap.clear();\n}\nfunction disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\nfunction enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\nfunction disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\nvar extras = {\n  gql,\n  resetCaches,\n  disableFragmentWarnings,\n  enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables\n};\n(function(gql_1) {\n  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\n})(gql || (gql = {}));\ngql[\"default\"] = gql;\nconst gql$1 = gql;\nconst useStyle$7 = makeStyles((theme) => ({\n  style: {\n    backgroundColor: ({ backgroundColor }) => backgroundColor ? getCSSColor(backgroundColor, theme) : theme.palette.primary.light,\n    color: ({ foregroundColor }) => foregroundColor ? getCSSColor(foregroundColor, theme) : \"white\",\n    fontSize: ({ fontSize }) => fontSize ? fontSize : null,\n    fontStyle: ({ italic }) => italic ? \"italic\" : null,\n    fontWeight: ({ bold }) => bold ? \"bold\" : null,\n    textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough),\n    \"&:hover\": {\n      backgroundColor: ({ backgroundColor }) => backgroundColor ? getCSSColor(backgroundColor, theme) : theme.palette.primary.main,\n      color: ({ foregroundColor }) => foregroundColor ? getCSSColor(foregroundColor, theme) : \"white\",\n      fontSize: ({ fontSize }) => fontSize ? fontSize : null,\n      fontStyle: ({ italic }) => italic ? \"italic\" : null,\n      fontWeight: ({ bold }) => bold ? \"bold\" : null,\n      textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough)\n    }\n  },\n  icon: {\n    marginRight: ({ iconOnly }) => iconOnly ? theme.spacing(0) : theme.spacing(2)\n  }\n}));\nconst pushButtonMutation$1 = gql$1`\n  mutation pushButton($input: PushButtonInput!) {\n    pushButton(input: $input) {\n      __typename\n      ... on ErrorPayload {\n        messages {\n          body\n          level\n        }\n      }\n      ... on SuccessPayload {\n        messages {\n          body\n          level\n        }\n      }\n    }\n  }\n`;\nconst updateWidgetFocusMutation$7 = gql$1`\n  mutation updateWidgetFocus($input: UpdateWidgetFocusInput!) {\n    updateWidgetFocus(input: $input) {\n      __typename\n      ... on ErrorPayload {\n        messages {\n          body\n          level\n        }\n      }\n    }\n  }\n`;\nconst isErrorPayload$8 = (payload) => payload.__typename === \"ErrorPayload\";\nconst isSuccessPayload$8 = (payload) => payload.__typename === \"SuccessPayload\";\nconst ButtonPropertySection = ({\n  editingContextId,\n  formId,\n  widget,\n  subscribers,\n  readOnly\n}) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n  const props = {\n    backgroundColor: ((_a = widget.style) == null ? void 0 : _a.backgroundColor) ?? null,\n    foregroundColor: ((_b = widget.style) == null ? void 0 : _b.foregroundColor) ?? null,\n    fontSize: ((_c = widget.style) == null ? void 0 : _c.fontSize) ?? null,\n    italic: ((_d = widget.style) == null ? void 0 : _d.italic) ?? null,\n    bold: ((_e = widget.style) == null ? void 0 : _e.bold) ?? null,\n    underline: ((_f = widget.style) == null ? void 0 : _f.underline) ?? null,\n    strikeThrough: ((_g = widget.style) == null ? void 0 : _g.strikeThrough) ?? null,\n    iconOnly: widget.buttonLabel ? false : true\n  };\n  const classes = useStyle$7(props);\n  const { httpOrigin } = useContext(ServerContext);\n  const [pushButton, { loading, data, error }] = useMutation(\n    pushButtonMutation$1\n  );\n  const { addErrorMessage, addMessages } = useMultiToast();\n  useEffect(() => {\n    if (!loading) {\n      if (error) {\n        addErrorMessage(\"An unexpected error has occurred, please refresh the page\");\n      }\n      if (data) {\n        const { pushButton: pushButton2 } = data;\n        if (isErrorPayload$8(pushButton2) || isSuccessPayload$8(pushButton2)) {\n          addMessages(pushButton2.messages);\n        }\n      }\n    }\n  }, [loading, error, data]);\n  const [\n    updateWidgetFocus,\n    { loading: updateWidgetFocusLoading, data: updateWidgetFocusData, error: updateWidgetFocusError }\n  ] = useMutation(updateWidgetFocusMutation$7);\n  const sendUpdateWidgetFocus = (selected) => {\n    const input = {\n      id: crypto.randomUUID(),\n      editingContextId,\n      representationId: formId,\n      widgetId: widget.id,\n      selected\n    };\n    const variables = {\n      input\n    };\n    updateWidgetFocus({ variables });\n  };\n  useEffect(() => {\n    if (!updateWidgetFocusLoading) {\n      if (updateWidgetFocusError) {\n        addErrorMessage(\"An unexpected error has occurred, please refresh the page\");\n      }\n      if (updateWidgetFocusData) {\n        const { updateWidgetFocus: updateWidgetFocus2 } = updateWidgetFocusData;\n        if (isErrorPayload$8(updateWidgetFocus2)) {\n          addMessages(updateWidgetFocus2.messages);\n        }\n      }\n    }\n  }, [updateWidgetFocusLoading, updateWidgetFocusData, updateWidgetFocusError]);\n  const onFocus = () => sendUpdateWidgetFocus(true);\n  const onBlur = () => {\n    sendUpdateWidgetFocus(false);\n  };\n  const onClick = () => {\n    const input = {\n      id: crypto.randomUUID(),\n      editingContextId,\n      representationId: formId,\n      buttonId: widget.id\n    };\n    const variables = { input };\n    pushButton({ variables });\n  };\n  return /* @__PURE__ */ jsxs(\"div\", { children: [\n    /* @__PURE__ */ jsx(\n      PropertySectionLabel,\n      {\n        editingContextId,\n        formId,\n        widget,\n        subscribers,\n        \"data-testid\": widget.label\n      }\n    ),\n    /* @__PURE__ */ jsxs(\n      Button,\n      {\n        \"data-testid\": widget.buttonLabel,\n        variant: \"contained\",\n        color: \"primary\",\n        onClick,\n        onBlur,\n        onFocus,\n        disabled: readOnly || widget.readOnly,\n        classes: { root: classes.style },\n        children: [\n          ((_h = widget.imageURL) == null ? void 0 : _h.length) > 0 ? /* @__PURE__ */ jsx(\"img\", { className: classes.icon, width: \"16\", height: \"16\", alt: widget.label, src: httpOrigin + widget.imageURL }) : null,\n          widget.buttonLabel\n        ]\n      }\n    )\n  ] });\n};\nconst useStyles = makeStyles(() => ({\n  chart: {\n    overflowX: \"auto\"\n  }\n}));\nconst ChartWidgetPropertySection = ({\n  editingContextId,\n  formId,\n  widget,\n  subscribers\n}) => {\n  const classes = useStyles();\n  const { chart } = widget;\n  let chartComponent;\n  if (isBarChart(chart)) {\n    chartComponent = /* @__PURE__ */ jsx(\"div\", { className: classes.chart, children: /* @__PURE__ */ jsx(BarChart, { chart }) });\n  } else if (isPieChart(chart)) {\n    chartComponent = /* @__PURE__ */ jsx(PieChart, { width: 300, height: 300, chart });\n  }\n  let content;\n  if (chartComponent) {\n    content = /* @__PURE__ */ jsxs(Fragment$1, { children: [\n      /* @__PURE__ */ jsx(\n        PropertySectionLabel,\n        {\n          editingContextId,\n          formId,\n          widget,\n          subscribers\n        }\n      ),\n      chartComponent\n    ] });\n  }\n  return /* @__PURE__ */ jsx(\"div\", { children: content });\n};\nconst isBarChart = (chart) => {\n  return chart.metadata.kind === \"BarChart\";\n};\nconst isPieChart = (chart) => {\n  return chart.metadata.kind === \"PieChart\";\n};\nconst useStyle$6 = makeStyles((theme) => ({\n  formControl: {\n    alignItems: \"flex-start\"\n  },\n  style: {\n    color: ({ color }) => color ? getCSSColor(color, theme) : theme.palette.primary.light\n  },\n  disabled: {}\n}));\nconst editCheckboxMutation = gql$2`\n  mutation editCheckbox($input: EditCheckboxInput!) {\n    editCheckbox(input: $input) {\n      __typename\n      ... on ErrorPayload {\n        messages {\n          body\n          level\n        }\n      }\n      ... on SuccessPayload {\n        messages {\n          body\n          level\n        }\n      }\n    }\n  }\n`;\nconst updateWidgetFocusMutation$6 = gql$2`\n  mutation updateWidgetFocus($input: UpdateWidgetFocusInput!) {\n    updateWidgetFocus(input: $input) {\n      __typename\n      ... on ErrorPayload {\n        messages {\n          body\n          level\n        }\n      }\n    }\n  }\n`;\nconst isErrorPayload$7 = (payload) => payload.__typename === \"ErrorPayload\";\nconst isSuccessPayload$7 = (payload) => payload.__typename === \"SuccessPayload\";\nconst CheckboxPropertySection = ({\n  editingContextId,\n  formId,\n  widget,\n  subscribers,\n  readOnly\n}) => {\n  var _a, _b, _c;\n  const props = {\n    color: ((_a = widget.style) == null ? void 0 : _a.color) ?? null\n  };\n  const classes = useStyle$6(props);\n  const [editCheckbox, { loading, error, data }] = useMutation(editCheckboxMutation);\n  const onChange = (event) => {\n    const newValue = event.target.checked;\n    const input = {\n      id: crypto.randomUUID(),\n      editingContextId,\n      representationId: formId,\n      checkboxId: widget.id,\n      newValue\n    };\n    const variables = {\n      input\n    };\n    editCheckbox({ variables });\n  };\n  const { addErrorMessage, addMessages } = useMultiToast();\n  useEffect(() => {\n    if (!loading) {\n      if (error) {\n        addErrorMessage(\"An unexpected error has occurred, please refresh the page\");\n      }\n      if (data) {\n        const { editCheckbox: editCheckbox2 } = data;\n        if (isErrorPayload$7(editCheckbox2) || isSuccessPayload$7(editCheckbox2)) {\n          addMessages(editCheckbox2.messages);\n        }\n      }\n    }\n  }, [loading, error, data]);\n  const [\n    updateWidgetFocus,\n    { loading: updateWidgetFocusLoading, data: updateWidgetFocusData, error: updateWidgetFocusError }\n  ] = useMutation(updateWidgetFocusMutation$6);\n  const sendUpdateWidgetFocus = (selected) => {\n    const input = {\n      id: crypto.randomUUID(),\n      editingContextId,\n      representationId: formId,\n      widgetId: widget.id,\n      selected\n    };\n    const variables = {\n      input\n    };\n    updateWidgetFocus({ variables });\n  };\n  useEffect(() => {\n    if (!updateWidgetFocusLoading) {\n      if (updateWidgetFocusError) {\n        addErrorMessage(\"An unexpected error has occurred, please refresh the page\");\n      }\n      if (updateWidgetFocusData) {\n        const { updateWidgetFocus: updateWidgetFocus2 } = updateWidgetFocusData;\n        if (isErrorPayload$7(updateWidgetFocus2)) {\n          addMessages(updateWidgetFocus2.messages);\n        }\n      }\n    }\n  }, [updateWidgetFocusLoading, updateWidgetFocusData, updateWidgetFocusError]);\n  const onFocus = () => sendUpdateWidgetFocus(true);\n  const onBlur = () => sendUpdateWidgetFocus(false);\n  return /* @__PURE__ */ jsxs(FormControl, { classes: { root: classes.formControl }, error: widget.diagnostics.length > 0, children: [\n    /* @__PURE__ */ jsx(\n      FormControlLabel,\n      {\n        labelPlacement: ((_b = widget.style) == null ? void 0 : _b.labelPlacement) ?? \"end\",\n        label: /* @__PURE__ */ jsx(\n          PropertySectionLabel,\n          {\n            editingContextId,\n            formId,\n            widget,\n            subscribers\n          }\n        ),\n        control: /* @__PURE__ */ jsx(\n          Checkbox,\n          {\n            name: widget.label,\n            color: \"default\",\n            checked: widget.booleanValue,\n            onChange,\n            onFocus,\n            onBlur,\n            \"data-testid\": widget.label,\n            disabled: readOnly || widget.readOnly,\n            classes: { root: classes.style, disabled: classes.disabled }\n          }\n        )\n      }\n    ),\n    /* @__PURE__ */ jsx(FormHelperText, { children: (_c = widget.diagnostics[0]) == null ? void 0 : _c.message })\n  ] });\n};\nconst useFlexboxContainerPropertySectionStyles = makeStyles(\n  (theme) => ({\n    containerAndLabel: {\n      margin: ({ borderStyle }) => borderStyle ? theme.spacing(0.5) : 0,\n      padding: ({ borderStyle }) => borderStyle ? theme.spacing(0.5) : 0,\n      borderWidth: ({ borderStyle }) => (borderStyle == null ? void 0 : borderStyle.size) || 0,\n      borderColor: ({ borderStyle }) => getCSSColor(borderStyle == null ? void 0 : borderStyle.color, theme) || \"transparent\",\n      borderStyle: ({ borderStyle }) => (borderStyle == null ? void 0 : borderStyle.lineStyle) || \"solid\",\n      borderRadius: ({ borderStyle }) => (borderStyle == null ? void 0 : borderStyle.radius) || 0\n    },\n    container: {\n      display: \"flex\",\n      flexWrap: ({ flexWrap }) => flexWrap,\n      flexDirection: ({ flexDirection }) => flexDirection,\n      \"& > *\": {\n        marginBottom: theme.spacing(0)\n      }\n    },\n    children: {\n      flexGrow: ({ flexGrow }) => flexGrow\n    }\n  })\n);\nconst FlexboxContainerPropertySection = ({\n  editingContextId,\n  formId,\n  widget,\n  widgetSubscriptions,\n  readOnly\n}) => {\n  const classes = useFlexboxContainerPropertySectionStyles({\n    flexDirection: widget.flexDirection,\n    flexWrap: widget.flexWrap,\n    flexGrow: widget.flexGrow,\n    borderStyle: widget.borderStyle\n  });\n  let children = widget.children.map((childWidget) => /* @__PURE__ */ jsx(\"div\", { className: classes.children, children: /* @__PURE__ */ jsx(\n    PropertySection,\n    {\n      editingContextId,\n      formId,\n      widget: childWidget,\n      widgetSubscriptions,\n      readOnly: readOnly || widget.readOnly\n    },\n    childWidget.id\n  ) }, childWidget.id));\n  return /* @__PURE__ */ jsxs(\"div\", { className: classes.containerAndLabel, \"data-testid\": `flexbox-${widget.label}`, children: [\n    /* @__PURE__ */ jsx(PropertySectionLabel, { editingContextId, formId, widget, subscribers: [] }),\n    /* @__PURE__ */ jsx(\"div\", { className: classes.container, children })\n  ] });\n};\nconst useImageStyles = makeStyles(() => ({\n  container: {\n    display: \"grid\",\n    gridTemplateColumns: ({ maxWidth }) => {\n      if (maxWidth) {\n        let max = maxWidth;\n        if (maxWidth.match(/[0-9]$/)) {\n          max = maxWidth + \"px\";\n        }\n        return `minmax(auto, ${max})`;\n      } else {\n        return \"1fr\";\n      }\n    }\n  }\n}));\nconst ImagePropertySection = ({ editingContextId, formId, widget }) => {\n  const { httpOrigin } = useContext(ServerContext);\n  const [validImage, setValidImage] = useState(true);\n  const onErrorLoadingImage = () => {\n    setValidImage(false);\n  };\n  useEffect(() => {\n    setValidImage(true);\n  }, [widget.url]);\n  let imageURL;\n  if (widget.url.startsWith(\"http://\") || widget.url.startsWith(\"https://\")) {\n    imageURL = widget.url;\n  } else {\n    imageURL = httpOrigin + widget.url;\n  }\n  const classes = useImageStyles({\n    maxWidth: widget.maxWidth\n  });\n  return /* @__PURE__ */ jsxs(\"div\", { children: [\n    /* @__PURE__ */ jsx(PropertySectionLabel, { editingContextId, formId, widget, subscribers: [] }),\n    /* @__PURE__ */ jsx(\"div\", { className: classes.container, children: validImage ? /* @__PURE__ */ jsx(\"img\", { id: widget.id, src: imageURL, width: \"100%\", onError: onErrorLoadingImage }) : /* @__PURE__ */ jsx(Typography, { variant: \"caption\", children: \"No image\" }) })\n  ] });\n};\nconst useStyle$5 = makeStyles((theme) => ({\n  style: {\n    color: ({ color }) => color ? getCSSColor(color, theme) : null,\n    fontSize: ({ fontSize }) => fontSize ? fontSize : null,\n    fontStyle: ({ italic }) => italic ? \"italic\" : null,\n    fontWeight: ({ bold }) => bold ? \"bold\" : null,\n    textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough)\n  }\n}));\nconst LabelWidgetPropertySection = ({\n  editingContextId,\n  formId,\n  widget,\n  subscribers\n}) => {\n  var _a, _b, _c, _d, _e, _f;\n  const props = {\n    color: ((_a = widget.style) == null ? void 0 : _a.color) ?? null,\n    fontSize: ((_b = widget.style) == null ? void 0 : _b.fontSize) ?? null,\n    italic: ((_c = widget.style) == null ? void 0 : _c.italic) ?? null,\n    bold: ((_d = widget.style) == null ? void 0 : _d.bold) ?? null,\n    underline: ((_e = widget.style) == null ? void 0 : _e.underline) ?? null,\n    strikeThrough: ((_f = widget.style) == null ? void 0 : _f.strikeThrough) ?? null\n  };\n  const classes = useStyle$5(props);\n  return /* @__PURE__ */ jsxs(\"div\", { children: [\n    /* @__PURE__ */ jsx(\n      PropertySectionLabel,\n      {\n        editingContextId,\n        formId,\n        widget,\n        subscribers\n      }\n    ),\n    /* @__PURE__ */ jsx(Typography, { className: classes.style, children: widget.stringValue })\n  ] });\n};\nconst useStyle$4 = makeStyles((theme) => ({\n  style: {\n    color: ({ color }) => color ? getCSSColor(color, theme) : null,\n    fontSize: ({ fontSize }) => fontSize ? fontSize : null,\n    fontStyle: ({ italic }) => italic ? \"italic\" : null,\n    fontWeight: ({ bold }) => bold ? \"bold\" : null,\n    textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough)\n  },\n  propertySectionLabel: {\n    display: \"flex\",\n    flexDirection: \"row\",\n    alignItems: \"center\"\n  }\n}));\nconst LinkPropertySection = ({ editingContextId, formId, widget }) => {\n  var _a, _b, _c, _d, _e, _f;\n  const props = {\n    color: ((_a = widget.style) == null ? void 0 : _a.color) ?? null,\n    fontSize: ((_b = widget.style) == null ? void 0 : _b.fontSize) ?? null,\n    italic: ((_c = widget.style) == null ? void 0 : _c.italic) ?? null,\n    bold: ((_d = widget.style) == null ? void 0 : _d.bold) ?? null,\n    underline: ((_e = widget.style) == null ? void 0 : _e.underline) ?? null,\n    strikeThrough: ((_f = widget.style) == null ? void 0 : _f.strikeThrough) ?? null\n  };\n  const classes = useStyle$4(props);\n  return /* @__PURE__ */ jsxs(\"div\", { className: classes.propertySectionLabel, children: [\n    /* @__PURE__ */ jsx(Link, { className: classes.style, id: widget.id, href: widget.url, rel: \"noopener noreferrer\", target: \"_blank\", children: widget.label }),\n    widget.hasHelpText ? /* @__PURE__ */ jsx(HelpTooltip, { editingContextId, formId, widgetId: widget.id }) : null\n  ] });\n};\nconst deleteListItemMutation = gql$2`\n  mutation deleteListItem($input: DeleteListItemInput!) {\n    deleteListItem(input: $input) {\n      __typename\n      ... on ErrorPayload {\n        messages {\n          body\n          level\n        }\n      }\n      ... on SuccessPayload {\n        messages {\n          body\n          level\n        }\n      }\n    }\n  }\n`;\nconst clickListItemMutation = gql$2`\n  mutation clickListItem($input: ClickListItemInput!) {\n    clickListItem(input: $input) {\n      __typename\n      ... on ErrorPayload {\n        messages {\n          body\n          level\n        }\n      }\n      ... on SuccessPayload {\n        messages {\n          body\n          level\n        }\n      }\n    }\n  }\n`;\nconst useListPropertySectionStyles = makeStyles((theme) => ({\n  cell: {\n    display: \"flex\",\n    flexDirection: \"row\",\n    alignItems: \"center\"\n  },\n  canBeSelectedItem: {\n    \"&:hover\": {\n      textDecoration: \"underline\",\n      cursor: \"pointer\"\n    }\n  },\n  style: {\n    color: ({ color }) => color ? getCSSColor(color, theme) : null,\n    fontSize: ({ fontSize }) => fontSize ? fontSize : null,\n    fontStyle: ({ italic }) => italic ? \"italic\" : null,\n    fontWeight: ({ bold }) => bold ? \"bold\" : null,\n    textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough),\n    overflow: \"hidden\",\n    textOverflow: \"ellipsis\",\n    whiteSpace: \"nowrap\",\n    flexGrow: 1\n  }\n}));\nconst NONE_WIDGET_ITEM_ID = \"none\";\nconst isErrorPayload$6 = (payload) => payload.__typename === \"ErrorPayload\";\nconst isSuccessPayload$6 = (payload) => payload.__typename === \"SuccessPayload\";\nconst ListPropertySection = ({\n  editingContextId,\n  formId,\n  widget,\n  subscribers,\n  readOnly\n}) => {\n  var _a, _b, _c, _d, _e, _f, _g;\n  const props = {\n    color: ((_a = widget.style) == null ? void 0 : _a.color) ?? null,\n    fontSize: ((_b = widget.style) == null ? void 0 : _b.fontSize) ?? null,\n    italic: ((_c = widget.style) == null ? void 0 : _c.italic) ?? null,\n    bold: ((_d = widget.style) == null ? void 0 : _d.bold) ?? null,\n    underline: ((_e = widget.style) == null ? void 0 : _e.underline) ?? null,\n    strikeThrough: ((_f = widget.style) == null ? void 0 : _f.strikeThrough) ?? null\n  };\n  const classes = useListPropertySectionStyles(props);\n  const theme = useTheme();\n  const { setSelection } = useSelection();\n  const { showDeletionConfirmation } = useDeletionConfirmationDialog();\n  let items = [...widget.items];\n  if (items.length === 0) {\n    items.push({\n      id: NONE_WIDGET_ITEM_ID,\n      iconURL: [],\n      label: \"None\",\n      kind: \"Unknown\",\n      deletable: false\n    });\n  }\n  const [deleteListItem, { loading: deleteLoading, error: deleteError, data: deleteData }] = useMutation(deleteListItemMutation);\n  const [clickListItem, { loading: clickLoading, error: clickError, data: clickData }] = useMutation(clickListItemMutation);\n  const onDelete = (_, item) => {\n    const variables = {\n      input: {\n        id: crypto.randomUUID(),\n        editingContextId,\n        representationId: formId,\n        listId: widget.id,\n        listItemId: item.id\n      }\n    };\n    showDeletionConfirmation(() => {\n      deleteListItem({ variables });\n    });\n  };\n  const { addErrorMessage, addMessages } = useMultiToast();\n  useEffect(() => {\n    if (!deleteLoading) {\n      if (deleteError) {\n        addErrorMessage(\"An unexpected error has occurred, please refresh the page\");\n      }\n      if (deleteData) {\n        const { deleteListItem: deleteListItem2 } = deleteData;\n        if (isErrorPayload$6(deleteListItem2) || isSuccessPayload$6(deleteListItem2)) {\n          addMessages(deleteListItem2.messages);\n        }\n      }\n    }\n  }, [deleteLoading, deleteError, deleteData]);\n  useEffect(() => {\n    if (!clickLoading) {\n      if (clickError) {\n        addErrorMessage(\"An unexpected error has occurred, please refresh the page\");\n      }\n      if (clickData) {\n        const { clickListItem: clickListItem2 } = clickData;\n        if (isErrorPayload$6(clickListItem2) || isSuccessPayload$6(clickListItem2)) {\n          addMessages(clickListItem2.messages);\n        }\n      }\n    }\n  }, [clickLoading, clickError, clickData]);\n  const onSimpleClick = (item) => {\n    const { id, label, kind } = item;\n    setSelection({ entries: [{ id, label, kind }] });\n    const variables = {\n      input: {\n        id: crypto.randomUUID(),\n        editingContextId,\n        representationId: formId,\n        listId: widget.id,\n        listItemId: item.id,\n        clickEventKind: \"SINGLE_CLICK\"\n      }\n    };\n    clickListItem({ variables });\n  };\n  const onDoubleClick = (item) => {\n    const { id, label, kind } = item;\n    setSelection({ entries: [{ id, label, kind }] });\n    const variables = {\n      input: {\n        id: crypto.randomUUID(),\n        editingContextId,\n        representationId: formId,\n        listId: widget.id,\n        listItemId: item.id,\n        clickEventKind: \"DOUBLE_CLICK\"\n      }\n    };\n    clickListItem({ variables });\n  };\n  const clickHandler = useClickHandler(onSimpleClick, onDoubleClick);\n  const getTableCellContent = (item) => {\n    return /* @__PURE__ */ jsxs(Fragment$1, { children: [\n      /* @__PURE__ */ jsx(IconOverlay, { iconURL: item.iconURL, alt: item.label, customIconStyle: { marginRight: theme.spacing(2) } }),\n      /* @__PURE__ */ jsx(\n        Typography,\n        {\n          className: `${readOnly || widget.readOnly ? \"\" : classes.canBeSelectedItem} ${classes.style}`,\n          onClick: () => readOnly || widget.readOnly ? {} : clickHandler(item),\n          color: \"textPrimary\",\n          \"data-testid\": `representation-${item.label}`,\n          children: item.label\n        }\n      ),\n      /* @__PURE__ */ jsx(\n        IconButton,\n        {\n          \"aria-label\": \"deleteListItem\",\n          onClick: (event) => onDelete(event, item),\n          disabled: readOnly || !item.deletable || widget.readOnly,\n          \"data-testid\": `delete-representation-${item.label}`,\n          children: /* @__PURE__ */ jsx(DeleteIcon, {})\n        }\n      )\n    ] });\n  };\n  return /* @__PURE__ */ jsxs(FormControl, { error: widget.diagnostics.length > 0, fullWidth: true, children: [\n    /* @__PURE__ */ jsx(\n      PropertySectionLabel,\n      {\n        editingContextId,\n        formId,\n        widget,\n        subscribers\n      }\n    ),\n    /* @__PURE__ */ jsx(Table, { size: \"small\", \"data-testid\": `table-${widget.label}`, children: /* @__PURE__ */ jsx(TableBody, { children: items.map((item) => /* @__PURE__ */ jsx(TableRow, { children: /* @__PURE__ */ jsx(TableCell, { className: classes.cell, children: getTableCellContent(item) }) }, item.id)) }) }),\n    /* @__PURE__ */ jsx(FormHelperText, { children: (_g = widget.diagnostics[0]) == null ? void 0 : _g.message })\n  ] });\n};\nconst useStyle$3 = makeStyles((theme) => ({\n  style: {\n    backgroundColor: ({ backgroundColor }) => backgroundColor ? getCSSColor(backgroundColor, theme) : null,\n    color: ({ foregroundColor }) => foregroundColor ? getCSSColor(foregroundColor, theme) : null,\n    fontSize: ({ fontSize }) => fontSize ? fontSize : null,\n    fontStyle: ({ italic }) => italic ? \"italic\" : null,\n    fontWeight: ({ bold }) => bold ? \"bold\" : null,\n    textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough)\n  },\n  iconRoot: {\n    minWidth: theme.spacing(3)\n  }\n}));\nconst editMultiSelectMutation = gql$2`\n  mutation editMultiSelect($input: EditMultiSelectInput!) {\n    editMultiSelect(input: $input) {\n      __typename\n      ... on ErrorPayload {\n        messages {\n          body\n          level\n        }\n      }\n      ... on SuccessPayload {\n        messages {\n          body\n          level\n        }\n      }\n    }\n  }\n`;\nconst updateWidgetFocusMutation$5 = gql$2`\n  mutation updateWidgetFocus($input: UpdateWidgetFocusInput!) {\n    updateWidgetFocus(input: $input) {\n      __typename\n      ... on ErrorPayload {\n        messages {\n          body\n          level\n        }\n      }\n    }\n  }\n`;\nconst isErrorPayload$5 = (payload) => payload.__typename === \"ErrorPayload\";\nconst isSuccessPayload$5 = (payload) => payload.__typename === \"SuccessPayload\";\nconst MultiSelectPropertySection = ({\n  editingContextId,\n  formId,\n  widget,\n  subscribers,\n  readOnly\n}) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n  const props = {\n    backgroundColor: ((_a = widget.style) == null ? void 0 : _a.backgroundColor) ?? null,\n    foregroundColor: ((_b = widget.style) == null ? void 0 : _b.foregroundColor) ?? null,\n    fontSize: ((_c = widget.style) == null ? void 0 : _c.fontSize) ?? null,\n    italic: ((_d = widget.style) == null ? void 0 : _d.italic) ?? null,\n    bold: ((_e = widget.style) == null ? void 0 : _e.bold) ?? null,\n    underline: ((_f = widget.style) == null ? void 0 : _f.underline) ?? null,\n    strikeThrough: ((_g = widget.style) == null ? void 0 : _g.strikeThrough) ?? null\n  };\n  const classes = useStyle$3(props);\n  const [isFocused, setFocus] = useState(false);\n  const [editMultiSelect, { loading, error, data }] = useMutation(editMultiSelectMutation);\n  const onChange = (event) => {\n    const newValues = event.target.value;\n    const variables = {\n      input: {\n        id: crypto.randomUUID(),\n        editingContextId,\n        representationId: formId,\n        selectId: widget.id,\n        newValues\n      }\n    };\n    editMultiSelect({ variables });\n  };\n  const { addErrorMessage, addMessages } = useMultiToast();\n  useEffect(() => {\n    if (!loading) {\n      if (error) {\n        addErrorMessage(\"An unexpected error has occurred, please refresh the page\");\n      }\n      if (data) {\n        const { editMultiSelect: editMultiSelect2 } = data;\n        if (isErrorPayload$5(editMultiSelect2) || isSuccessPayload$5(editMultiSelect2)) {\n          addMessages(editMultiSelect2.messages);\n        }\n      }\n    }\n  }, [loading, error, data]);\n  const [\n    updateWidgetFocus,\n    { loading: updateWidgetFocusLoading, data: updateWidgetFocusData, error: updateWidgetFocusError }\n  ] = useMutation(updateWidgetFocusMutation$5);\n  const sendUpdateWidgetFocus = (selected) => {\n    const variables = {\n      input: {\n        id: crypto.randomUUID(),\n        editingContextId,\n        representationId: formId,\n        widgetId: widget.id,\n        selected\n      }\n    };\n    updateWidgetFocus({ variables });\n  };\n  useEffect(() => {\n    if (!updateWidgetFocusLoading) {\n      if (updateWidgetFocusError) {\n        addErrorMessage(\"An unexpected error has occurred, please refresh the page\");\n      }\n      if (updateWidgetFocusData) {\n        const { updateWidgetFocus: updateWidgetFocus2 } = updateWidgetFocusData;\n        if (isErrorPayload$5(updateWidgetFocus2)) {\n          addMessages(updateWidgetFocus2.messages);\n        }\n      }\n    }\n  }, [updateWidgetFocusLoading, updateWidgetFocusData, updateWidgetFocusError]);\n  const onFocus = () => {\n    if (!isFocused) {\n      setFocus(true);\n      sendUpdateWidgetFocus(true);\n    }\n  };\n  const onBlur = () => {\n    setFocus(false);\n    sendUpdateWidgetFocus(false);\n  };\n  return /* @__PURE__ */ jsxs(FormControl, { error: widget.diagnostics.length > 0, children: [\n    /* @__PURE__ */ jsx(\n      PropertySectionLabel,\n      {\n        editingContextId,\n        formId,\n        widget,\n        subscribers\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      Select,\n      {\n        value: widget.values,\n        onChange,\n        displayEmpty: true,\n        onFocus,\n        onBlur,\n        fullWidth: true,\n        \"data-testid\": widget.label,\n        disabled: readOnly || widget.readOnly,\n        renderValue: (selected) => widget.options.filter((option) => selected.includes(option.id)).map((option) => option.label).join(\", \"),\n        multiple: true,\n        inputProps: widget.style ? {\n          className: classes.style\n        } : {},\n        children: widget.options.map((option) => /* @__PURE__ */ jsxs(MenuItem, { value: option.id, children: [\n          /* @__PURE__ */ jsx(Checkbox, { checked: widget.values.indexOf(option.id) > -1 }),\n          option.iconURL.length > 0 && /* @__PURE__ */ jsx(ListItemIcon, { className: classes.iconRoot, children: /* @__PURE__ */ jsx(IconOverlay, { iconURL: option.iconURL, alt: option.label }) }),\n          /* @__PURE__ */ jsx(\n            ListItemText,\n            {\n              primary: option.label,\n              primaryTypographyProps: widget.style ? {\n                className: classes.style\n              } : {}\n            }\n          )\n        ] }, option.id))\n      }\n    ),\n    /* @__PURE__ */ jsx(FormHelperText, { children: (_h = widget.diagnostics[0]) == null ? void 0 : _h.message })\n  ] });\n};\nconst editRadioMutation = gql$2`\n  mutation editRadio($input: EditRadioInput!) {\n    editRadio(input: $input) {\n      __typename\n      ... on ErrorPayload {\n        messages {\n          body\n          level\n        }\n      }\n      ... on SuccessPayload {\n        messages {\n          body\n          level\n        }\n      }\n    }\n  }\n`;\nconst updateWidgetFocusMutation$4 = gql$2`\n  mutation updateWidgetFocus($input: UpdateWidgetFocusInput!) {\n    updateWidgetFocus(input: $input) {\n      __typename\n      ... on ErrorPayload {\n        messages {\n          body\n          level\n        }\n      }\n    }\n  }\n`;\nconst useRadioPropertySectionStyles = makeStyles((theme) => ({\n  radioGroupRoot: {\n    flexDirection: \"row\"\n  },\n  style: {\n    color: ({ color }) => color ? getCSSColor(color, theme) : null,\n    fontSize: ({ fontSize }) => fontSize ? fontSize : null,\n    fontStyle: ({ italic }) => italic ? \"italic\" : null,\n    fontWeight: ({ bold }) => bold ? \"bold\" : null,\n    textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough)\n  }\n}));\nconst isErrorPayload$4 = (payload) => payload.__typename === \"ErrorPayload\";\nconst isSuccessPayload$4 = (payload) => payload.__typename === \"SuccessPayload\";\nconst RadioPropertySection = ({\n  editingContextId,\n  formId,\n  widget,\n  subscribers,\n  readOnly\n}) => {\n  var _a, _b, _c, _d, _e, _f, _g;\n  const props = {\n    color: ((_a = widget.style) == null ? void 0 : _a.color) ?? null,\n    fontSize: ((_b = widget.style) == null ? void 0 : _b.fontSize) ?? null,\n    italic: ((_c = widget.style) == null ? void 0 : _c.italic) ?? null,\n    bold: ((_d = widget.style) == null ? void 0 : _d.bold) ?? null,\n    underline: ((_e = widget.style) == null ? void 0 : _e.underline) ?? null,\n    strikeThrough: ((_f = widget.style) == null ? void 0 : _f.strikeThrough) ?? null\n  };\n  const classes = useRadioPropertySectionStyles(props);\n  const [editRadio, { loading, error, data }] = useMutation(editRadioMutation);\n  const onChange = (event) => {\n    const newValue = event.target.value;\n    const input = {\n      id: crypto.randomUUID(),\n      editingContextId,\n      representationId: formId,\n      radioId: widget.id,\n      newValue\n    };\n    const variables = { input };\n    editRadio({ variables });\n  };\n  const { addErrorMessage, addMessages } = useMultiToast();\n  useEffect(() => {\n    if (!loading) {\n      if (error) {\n        addErrorMessage(\"An unexpected error has occurred, please refresh the page\");\n      }\n      if (data) {\n        const { editRadio: editRadio2 } = data;\n        if (isErrorPayload$4(editRadio2) || isSuccessPayload$4(editRadio2)) {\n          addMessages(editRadio2.messages);\n        }\n      }\n    }\n  }, [loading, error, data]);\n  const [\n    updateWidgetFocus,\n    { loading: updateWidgetFocusLoading, data: updateWidgetFocusData, error: updateWidgetFocusError }\n  ] = useMutation(updateWidgetFocusMutation$4);\n  const sendUpdateWidgetFocus = (selected) => {\n    const input = {\n      id: crypto.randomUUID(),\n      editingContextId,\n      representationId: formId,\n      widgetId: widget.id,\n      selected\n    };\n    const variables = {\n      input\n    };\n    updateWidgetFocus({ variables });\n  };\n  useEffect(() => {\n    if (!updateWidgetFocusLoading) {\n      if (updateWidgetFocusError) {\n        addErrorMessage(\"An unexpected error has occurred, please refresh the page\");\n      }\n      if (updateWidgetFocusData) {\n        const { updateWidgetFocus: updateWidgetFocus2 } = updateWidgetFocusData;\n        if (isErrorPayload$4(updateWidgetFocus2)) {\n          addMessages(updateWidgetFocus2.messages);\n        }\n      }\n    }\n  }, [updateWidgetFocusLoading, updateWidgetFocusData, updateWidgetFocusError]);\n  const onFocus = () => sendUpdateWidgetFocus(true);\n  const onBlur = () => sendUpdateWidgetFocus(false);\n  const selectedOption = widget.options.find((option) => option.selected);\n  return /* @__PURE__ */ jsxs(FormControl, { error: widget.diagnostics.length > 0, children: [\n    /* @__PURE__ */ jsx(\n      PropertySectionLabel,\n      {\n        editingContextId,\n        formId,\n        widget,\n        subscribers\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      RadioGroup,\n      {\n        classes: { root: classes.radioGroupRoot },\n        \"aria-label\": widget.label,\n        name: widget.label,\n        value: selectedOption ? selectedOption.id : null,\n        onChange,\n        children: widget.options.map((option) => /* @__PURE__ */ jsx(\n          FormControlLabel,\n          {\n            value: option.id,\n            control: /* @__PURE__ */ jsx(Radio, { color: \"primary\", onFocus, onBlur, \"data-testid\": option.label }),\n            label: /* @__PURE__ */ jsx(\n              Typography,\n              {\n                classes: widget.style ? {\n                  root: classes.style\n                } : {},\n                children: option.label\n              }\n            ),\n            disabled: readOnly || widget.readOnly\n          },\n          option.id\n        ))\n      }\n    ),\n    /* @__PURE__ */ jsx(FormHelperText, { children: (_g = widget.diagnostics[0]) == null ? void 0 : _g.message })\n  ] });\n};\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nvar LexicalCode_dev = {};\nvar prism = { exports: {} };\nvar hasRequiredPrism;\nfunction requirePrism() {\n  if (hasRequiredPrism)\n    return prism.exports;\n  hasRequiredPrism = 1;\n  (function(module) {\n    var _self = typeof window !== \"undefined\" ? window : typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope ? self : {};\n    /**\n     * Prism: Lightweight, robust, elegant syntax highlighting\n     *\n     * @license MIT <https://opensource.org/licenses/MIT>\n     * @author Lea Verou <https://lea.verou.me>\n     * @namespace\n     * @public\n     */\n    var Prism2 = function(_self2) {\n      var lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\n      var uniqueId = 0;\n      var plainTextGrammar = {};\n      var _ = {\n        /**\n         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the\n         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load\n         * additional languages or plugins yourself.\n         *\n         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.\n         *\n         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an\n         * empty Prism object into the global scope before loading the Prism script like this:\n         *\n         * ```js\n         * window.Prism = window.Prism || {};\n         * Prism.manual = true;\n         * // add a new <script> to load Prism's script\n         * ```\n         *\n         * @default false\n         * @type {boolean}\n         * @memberof Prism\n         * @public\n         */\n        manual: _self2.Prism && _self2.Prism.manual,\n        /**\n         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses\n         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your\n         * own worker, you don't want it to do this.\n         *\n         * By setting this value to `true`, Prism will not add its own listeners to the worker.\n         *\n         * You obviously have to change this value before Prism executes. To do this, you can add an\n         * empty Prism object into the global scope before loading the Prism script like this:\n         *\n         * ```js\n         * window.Prism = window.Prism || {};\n         * Prism.disableWorkerMessageHandler = true;\n         * // Load Prism's script\n         * ```\n         *\n         * @default false\n         * @type {boolean}\n         * @memberof Prism\n         * @public\n         */\n        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,\n        /**\n         * A namespace for utility methods.\n         *\n         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n         * change or disappear at any time.\n         *\n         * @namespace\n         * @memberof Prism\n         */\n        util: {\n          encode: function encode(tokens) {\n            if (tokens instanceof Token) {\n              return new Token(tokens.type, encode(tokens.content), tokens.alias);\n            } else if (Array.isArray(tokens)) {\n              return tokens.map(encode);\n            } else {\n              return tokens.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/\\u00a0/g, \" \");\n            }\n          },\n          /**\n           * Returns the name of the type of the given value.\n           *\n           * @param {any} o\n           * @returns {string}\n           * @example\n           * type(null)      === 'Null'\n           * type(undefined) === 'Undefined'\n           * type(123)       === 'Number'\n           * type('foo')     === 'String'\n           * type(true)      === 'Boolean'\n           * type([1, 2])    === 'Array'\n           * type({})        === 'Object'\n           * type(String)    === 'Function'\n           * type(/abc+/)    === 'RegExp'\n           */\n          type: function(o) {\n            return Object.prototype.toString.call(o).slice(8, -1);\n          },\n          /**\n           * Returns a unique number for the given object. Later calls will still return the same number.\n           *\n           * @param {Object} obj\n           * @returns {number}\n           */\n          objId: function(obj) {\n            if (!obj[\"__id\"]) {\n              Object.defineProperty(obj, \"__id\", { value: ++uniqueId });\n            }\n            return obj[\"__id\"];\n          },\n          /**\n           * Creates a deep clone of the given object.\n           *\n           * The main intended use of this function is to clone language definitions.\n           *\n           * @param {T} o\n           * @param {Record<number, any>} [visited]\n           * @returns {T}\n           * @template T\n           */\n          clone: function deepClone(o, visited) {\n            visited = visited || {};\n            var clone;\n            var id;\n            switch (_.util.type(o)) {\n              case \"Object\":\n                id = _.util.objId(o);\n                if (visited[id]) {\n                  return visited[id];\n                }\n                clone = /** @type {Record<string, any>} */\n                {};\n                visited[id] = clone;\n                for (var key in o) {\n                  if (o.hasOwnProperty(key)) {\n                    clone[key] = deepClone(o[key], visited);\n                  }\n                }\n                return (\n                  /** @type {any} */\n                  clone\n                );\n              case \"Array\":\n                id = _.util.objId(o);\n                if (visited[id]) {\n                  return visited[id];\n                }\n                clone = [];\n                visited[id] = clone;\n                /** @type {Array} */\n                /** @type {any} */\n                o.forEach(function(v, i) {\n                  clone[i] = deepClone(v, visited);\n                });\n                return (\n                  /** @type {any} */\n                  clone\n                );\n              default:\n                return o;\n            }\n          },\n          /**\n           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.\n           *\n           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.\n           *\n           * @param {Element} element\n           * @returns {string}\n           */\n          getLanguage: function(element) {\n            while (element) {\n              var m = lang.exec(element.className);\n              if (m) {\n                return m[1].toLowerCase();\n              }\n              element = element.parentElement;\n            }\n            return \"none\";\n          },\n          /**\n           * Sets the Prism `language-xxxx` class of the given element.\n           *\n           * @param {Element} element\n           * @param {string} language\n           * @returns {void}\n           */\n          setLanguage: function(element, language) {\n            element.className = element.className.replace(RegExp(lang, \"gi\"), \"\");\n            element.classList.add(\"language-\" + language);\n          },\n          /**\n           * Returns the script element that is currently executing.\n           *\n           * This does __not__ work for line script element.\n           *\n           * @returns {HTMLScriptElement | null}\n           */\n          currentScript: function() {\n            if (typeof document === \"undefined\") {\n              return null;\n            }\n            if (\"currentScript\" in document && 1 < 2) {\n              return (\n                /** @type {any} */\n                document.currentScript\n              );\n            }\n            try {\n              throw new Error();\n            } catch (err) {\n              var src = (/at [^(\\r\\n]*\\((.*):[^:]+:[^:]+\\)$/i.exec(err.stack) || [])[1];\n              if (src) {\n                var scripts = document.getElementsByTagName(\"script\");\n                for (var i in scripts) {\n                  if (scripts[i].src == src) {\n                    return scripts[i];\n                  }\n                }\n              }\n              return null;\n            }\n          },\n          /**\n           * Returns whether a given class is active for `element`.\n           *\n           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated\n           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the\n           * given class is just the given class with a `no-` prefix.\n           *\n           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is\n           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its\n           * ancestors have the given class or the negated version of it, then the default activation will be returned.\n           *\n           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated\n           * version of it, the class is considered active.\n           *\n           * @param {Element} element\n           * @param {string} className\n           * @param {boolean} [defaultActivation=false]\n           * @returns {boolean}\n           */\n          isActive: function(element, className, defaultActivation) {\n            var no = \"no-\" + className;\n            while (element) {\n              var classList = element.classList;\n              if (classList.contains(className)) {\n                return true;\n              }\n              if (classList.contains(no)) {\n                return false;\n              }\n              element = element.parentElement;\n            }\n            return !!defaultActivation;\n          }\n        },\n        /**\n         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n         *\n         * @namespace\n         * @memberof Prism\n         * @public\n         */\n        languages: {\n          /**\n           * The grammar for plain, unformatted text.\n           */\n          plain: plainTextGrammar,\n          plaintext: plainTextGrammar,\n          text: plainTextGrammar,\n          txt: plainTextGrammar,\n          /**\n           * Creates a deep copy of the language with the given id and appends the given tokens.\n           *\n           * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n           * will be overwritten at its original position.\n           *\n           * ## Best practices\n           *\n           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n           * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n           *\n           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n           *\n           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n           * @param {Grammar} redef The new tokens to append.\n           * @returns {Grammar} The new language created.\n           * @public\n           * @example\n           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n           *     // at its original position\n           *     'comment': { ... },\n           *     // CSS doesn't have a 'color' token, so this token will be appended\n           *     'color': /\\b(?:red|green|blue)\\b/\n           * });\n           */\n          extend: function(id, redef) {\n            var lang2 = _.util.clone(_.languages[id]);\n            for (var key in redef) {\n              lang2[key] = redef[key];\n            }\n            return lang2;\n          },\n          /**\n           * Inserts tokens _before_ another token in a language definition or any other grammar.\n           *\n           * ## Usage\n           *\n           * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n           * this:\n           *\n           * ```js\n           * Prism.languages.markup.style = {\n           *     // token\n           * };\n           * ```\n           *\n           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n           * before existing tokens. For the CSS example above, you would use it like this:\n           *\n           * ```js\n           * Prism.languages.insertBefore('markup', 'cdata', {\n           *     'style': {\n           *         // token\n           *     }\n           * });\n           * ```\n           *\n           * ## Special cases\n           *\n           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n           * will be ignored.\n           *\n           * This behavior can be used to insert tokens after `before`:\n           *\n           * ```js\n           * Prism.languages.insertBefore('markup', 'comment', {\n           *     'comment': Prism.languages.markup.comment,\n           *     // tokens after 'comment'\n           * });\n           * ```\n           *\n           * ## Limitations\n           *\n           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n           * deleting properties which is necessary to insert at arbitrary positions.\n           *\n           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n           * Instead, it will create a new object and replace all references to the target object with the new one. This\n           * can be done without temporarily deleting properties, so the iteration order is well-defined.\n           *\n           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n           * you hold the target object in a variable, then the value of the variable will not change.\n           *\n           * ```js\n           * var oldMarkup = Prism.languages.markup;\n           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n           *\n           * assert(oldMarkup !== Prism.languages.markup);\n           * assert(newMarkup === Prism.languages.markup);\n           * ```\n           *\n           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n           * object to be modified.\n           * @param {string} before The key to insert before.\n           * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n           * object to be modified.\n           *\n           * Defaults to `Prism.languages`.\n           * @returns {Grammar} The new grammar object.\n           * @public\n           */\n          insertBefore: function(inside, before, insert, root) {\n            root = root || /** @type {any} */\n            _.languages;\n            var grammar = root[inside];\n            var ret = {};\n            for (var token in grammar) {\n              if (grammar.hasOwnProperty(token)) {\n                if (token == before) {\n                  for (var newToken in insert) {\n                    if (insert.hasOwnProperty(newToken)) {\n                      ret[newToken] = insert[newToken];\n                    }\n                  }\n                }\n                if (!insert.hasOwnProperty(token)) {\n                  ret[token] = grammar[token];\n                }\n              }\n            }\n            var old = root[inside];\n            root[inside] = ret;\n            _.languages.DFS(_.languages, function(key, value2) {\n              if (value2 === old && key != inside) {\n                this[key] = ret;\n              }\n            });\n            return ret;\n          },\n          // Traverse a language definition with Depth First Search\n          DFS: function DFS(o, callback, type, visited) {\n            visited = visited || {};\n            var objId = _.util.objId;\n            for (var i in o) {\n              if (o.hasOwnProperty(i)) {\n                callback.call(o, i, o[i], type || i);\n                var property = o[i];\n                var propertyType = _.util.type(property);\n                if (propertyType === \"Object\" && !visited[objId(property)]) {\n                  visited[objId(property)] = true;\n                  DFS(property, callback, null, visited);\n                } else if (propertyType === \"Array\" && !visited[objId(property)]) {\n                  visited[objId(property)] = true;\n                  DFS(property, callback, i, visited);\n                }\n              }\n            }\n          }\n        },\n        plugins: {},\n        /**\n         * This is the most high-level function in Prisms API.\n         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on\n         * each one of them.\n         *\n         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.\n         *\n         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.\n         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.\n         * @memberof Prism\n         * @public\n         */\n        highlightAll: function(async, callback) {\n          _.highlightAllUnder(document, async, callback);\n        },\n        /**\n         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls\n         * {@link Prism.highlightElement} on each one of them.\n         *\n         * The following hooks will be run:\n         * 1. `before-highlightall`\n         * 2. `before-all-elements-highlight`\n         * 3. All hooks of {@link Prism.highlightElement} for each element.\n         *\n         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.\n         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.\n         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.\n         * @memberof Prism\n         * @public\n         */\n        highlightAllUnder: function(container, async, callback) {\n          var env = {\n            callback,\n            container,\n            selector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n          };\n          _.hooks.run(\"before-highlightall\", env);\n          env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));\n          _.hooks.run(\"before-all-elements-highlight\", env);\n          for (var i = 0, element; element = env.elements[i++]; ) {\n            _.highlightElement(element, async === true, env.callback);\n          }\n        },\n        /**\n         * Highlights the code inside a single element.\n         *\n         * The following hooks will be run:\n         * 1. `before-sanity-check`\n         * 2. `before-highlight`\n         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.\n         * 4. `before-insert`\n         * 5. `after-highlight`\n         * 6. `complete`\n         *\n         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for\n         * the element's language.\n         *\n         * @param {Element} element The element containing the code.\n         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.\n         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers\n         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is\n         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).\n         *\n         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for\n         * asynchronous highlighting to work. You can build your own bundle on the\n         * [Download page](https://prismjs.com/download.html).\n         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.\n         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.\n         * @memberof Prism\n         * @public\n         */\n        highlightElement: function(element, async, callback) {\n          var language = _.util.getLanguage(element);\n          var grammar = _.languages[language];\n          _.util.setLanguage(element, language);\n          var parent = element.parentElement;\n          if (parent && parent.nodeName.toLowerCase() === \"pre\") {\n            _.util.setLanguage(parent, language);\n          }\n          var code = element.textContent;\n          var env = {\n            element,\n            language,\n            grammar,\n            code\n          };\n          function insertHighlightedCode(highlightedCode) {\n            env.highlightedCode = highlightedCode;\n            _.hooks.run(\"before-insert\", env);\n            env.element.innerHTML = env.highlightedCode;\n            _.hooks.run(\"after-highlight\", env);\n            _.hooks.run(\"complete\", env);\n            callback && callback.call(env.element);\n          }\n          _.hooks.run(\"before-sanity-check\", env);\n          parent = env.element.parentElement;\n          if (parent && parent.nodeName.toLowerCase() === \"pre\" && !parent.hasAttribute(\"tabindex\")) {\n            parent.setAttribute(\"tabindex\", \"0\");\n          }\n          if (!env.code) {\n            _.hooks.run(\"complete\", env);\n            callback && callback.call(env.element);\n            return;\n          }\n          _.hooks.run(\"before-highlight\", env);\n          if (!env.grammar) {\n            insertHighlightedCode(_.util.encode(env.code));\n            return;\n          }\n          if (async && _self2.Worker) {\n            var worker = new Worker(_.filename);\n            worker.onmessage = function(evt) {\n              insertHighlightedCode(evt.data);\n            };\n            worker.postMessage(JSON.stringify({\n              language: env.language,\n              code: env.code,\n              immediateClose: true\n            }));\n          } else {\n            insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));\n          }\n        },\n        /**\n         * Low-level function, only use if you know what youre doing. It accepts a string of text as input\n         * and the language definitions to use, and returns a string with the HTML produced.\n         *\n         * The following hooks will be run:\n         * 1. `before-tokenize`\n         * 2. `after-tokenize`\n         * 3. `wrap`: On each {@link Token}.\n         *\n         * @param {string} text A string with the code to be highlighted.\n         * @param {Grammar} grammar An object containing the tokens to use.\n         *\n         * Usually a language definition like `Prism.languages.markup`.\n         * @param {string} language The name of the language definition passed to `grammar`.\n         * @returns {string} The highlighted HTML.\n         * @memberof Prism\n         * @public\n         * @example\n         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n         */\n        highlight: function(text, grammar, language) {\n          var env = {\n            code: text,\n            grammar,\n            language\n          };\n          _.hooks.run(\"before-tokenize\", env);\n          if (!env.grammar) {\n            throw new Error('The language \"' + env.language + '\" has no grammar.');\n          }\n          env.tokens = _.tokenize(env.code, env.grammar);\n          _.hooks.run(\"after-tokenize\", env);\n          return Token.stringify(_.util.encode(env.tokens), env.language);\n        },\n        /**\n         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n         * and the language definitions to use, and returns an array with the tokenized code.\n         *\n         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n         *\n         * This method could be useful in other contexts as well, as a very crude parser.\n         *\n         * @param {string} text A string with the code to be highlighted.\n         * @param {Grammar} grammar An object containing the tokens to use.\n         *\n         * Usually a language definition like `Prism.languages.markup`.\n         * @returns {TokenStream} An array of strings and tokens, a token stream.\n         * @memberof Prism\n         * @public\n         * @example\n         * let code = `var foo = 0;`;\n         * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n         * tokens.forEach(token => {\n         *     if (token instanceof Prism.Token && token.type === 'number') {\n         *         console.log(`Found numeric literal: ${token.content}`);\n         *     }\n         * });\n         */\n        tokenize: function(text, grammar) {\n          var rest = grammar.rest;\n          if (rest) {\n            for (var token in rest) {\n              grammar[token] = rest[token];\n            }\n            delete grammar.rest;\n          }\n          var tokenList = new LinkedList();\n          addAfter(tokenList, tokenList.head, text);\n          matchGrammar(text, tokenList, grammar, tokenList.head, 0);\n          return toArray(tokenList);\n        },\n        /**\n         * @namespace\n         * @memberof Prism\n         * @public\n         */\n        hooks: {\n          all: {},\n          /**\n           * Adds the given callback to the list of callbacks for the given hook.\n           *\n           * The callback will be invoked when the hook it is registered for is run.\n           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n           *\n           * One callback function can be registered to multiple hooks and the same hook multiple times.\n           *\n           * @param {string} name The name of the hook.\n           * @param {HookCallback} callback The callback function which is given environment variables.\n           * @public\n           */\n          add: function(name, callback) {\n            var hooks = _.hooks.all;\n            hooks[name] = hooks[name] || [];\n            hooks[name].push(callback);\n          },\n          /**\n           * Runs a hook invoking all registered callbacks with the given environment variables.\n           *\n           * Callbacks will be invoked synchronously and in the order in which they were registered.\n           *\n           * @param {string} name The name of the hook.\n           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n           * @public\n           */\n          run: function(name, env) {\n            var callbacks = _.hooks.all[name];\n            if (!callbacks || !callbacks.length) {\n              return;\n            }\n            for (var i = 0, callback; callback = callbacks[i++]; ) {\n              callback(env);\n            }\n          }\n        },\n        Token\n      };\n      _self2.Prism = _;\n      function Token(type, content, alias, matchedStr) {\n        this.type = type;\n        this.content = content;\n        this.alias = alias;\n        this.length = (matchedStr || \"\").length | 0;\n      }\n      Token.stringify = function stringify(o, language) {\n        if (typeof o == \"string\") {\n          return o;\n        }\n        if (Array.isArray(o)) {\n          var s = \"\";\n          o.forEach(function(e) {\n            s += stringify(e, language);\n          });\n          return s;\n        }\n        var env = {\n          type: o.type,\n          content: stringify(o.content, language),\n          tag: \"span\",\n          classes: [\"token\", o.type],\n          attributes: {},\n          language\n        };\n        var aliases = o.alias;\n        if (aliases) {\n          if (Array.isArray(aliases)) {\n            Array.prototype.push.apply(env.classes, aliases);\n          } else {\n            env.classes.push(aliases);\n          }\n        }\n        _.hooks.run(\"wrap\", env);\n        var attributes = \"\";\n        for (var name in env.attributes) {\n          attributes += \" \" + name + '=\"' + (env.attributes[name] || \"\").replace(/\"/g, \"&quot;\") + '\"';\n        }\n        return \"<\" + env.tag + ' class=\"' + env.classes.join(\" \") + '\"' + attributes + \">\" + env.content + \"</\" + env.tag + \">\";\n      };\n      function matchPattern(pattern, pos, text, lookbehind) {\n        pattern.lastIndex = pos;\n        var match = pattern.exec(text);\n        if (match && lookbehind && match[1]) {\n          var lookbehindLength = match[1].length;\n          match.index += lookbehindLength;\n          match[0] = match[0].slice(lookbehindLength);\n        }\n        return match;\n      }\n      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n        for (var token in grammar) {\n          if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n            continue;\n          }\n          var patterns = grammar[token];\n          patterns = Array.isArray(patterns) ? patterns : [patterns];\n          for (var j = 0; j < patterns.length; ++j) {\n            if (rematch && rematch.cause == token + \",\" + j) {\n              return;\n            }\n            var patternObj = patterns[j];\n            var inside = patternObj.inside;\n            var lookbehind = !!patternObj.lookbehind;\n            var greedy = !!patternObj.greedy;\n            var alias = patternObj.alias;\n            if (greedy && !patternObj.pattern.global) {\n              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n              patternObj.pattern = RegExp(patternObj.pattern.source, flags + \"g\");\n            }\n            var pattern = patternObj.pattern || patternObj;\n            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {\n              if (rematch && pos >= rematch.reach) {\n                break;\n              }\n              var str = currentNode.value;\n              if (tokenList.length > text.length) {\n                return;\n              }\n              if (str instanceof Token) {\n                continue;\n              }\n              var removeCount = 1;\n              var match;\n              if (greedy) {\n                match = matchPattern(pattern, pos, text, lookbehind);\n                if (!match || match.index >= text.length) {\n                  break;\n                }\n                var from = match.index;\n                var to = match.index + match[0].length;\n                var p = pos;\n                p += currentNode.value.length;\n                while (from >= p) {\n                  currentNode = currentNode.next;\n                  p += currentNode.value.length;\n                }\n                p -= currentNode.value.length;\n                pos = p;\n                if (currentNode.value instanceof Token) {\n                  continue;\n                }\n                for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === \"string\"); k = k.next) {\n                  removeCount++;\n                  p += k.value.length;\n                }\n                removeCount--;\n                str = text.slice(pos, p);\n                match.index -= pos;\n              } else {\n                match = matchPattern(pattern, 0, str, lookbehind);\n                if (!match) {\n                  continue;\n                }\n              }\n              var from = match.index;\n              var matchStr = match[0];\n              var before = str.slice(0, from);\n              var after = str.slice(from + matchStr.length);\n              var reach = pos + str.length;\n              if (rematch && reach > rematch.reach) {\n                rematch.reach = reach;\n              }\n              var removeFrom = currentNode.prev;\n              if (before) {\n                removeFrom = addAfter(tokenList, removeFrom, before);\n                pos += before.length;\n              }\n              removeRange(tokenList, removeFrom, removeCount);\n              var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\n              currentNode = addAfter(tokenList, removeFrom, wrapped);\n              if (after) {\n                addAfter(tokenList, currentNode, after);\n              }\n              if (removeCount > 1) {\n                var nestedRematch = {\n                  cause: token + \",\" + j,\n                  reach\n                };\n                matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);\n                if (rematch && nestedRematch.reach > rematch.reach) {\n                  rematch.reach = nestedRematch.reach;\n                }\n              }\n            }\n          }\n        }\n      }\n      function LinkedList() {\n        var head = { value: null, prev: null, next: null };\n        var tail = { value: null, prev: head, next: null };\n        head.next = tail;\n        this.head = head;\n        this.tail = tail;\n        this.length = 0;\n      }\n      function addAfter(list, node, value2) {\n        var next = node.next;\n        var newNode = { value: value2, prev: node, next };\n        node.next = newNode;\n        next.prev = newNode;\n        list.length++;\n        return newNode;\n      }\n      function removeRange(list, node, count) {\n        var next = node.next;\n        for (var i = 0; i < count && next !== list.tail; i++) {\n          next = next.next;\n        }\n        node.next = next;\n        next.prev = node;\n        list.length -= i;\n      }\n      function toArray(list) {\n        var array = [];\n        var node = list.head.next;\n        while (node !== list.tail) {\n          array.push(node.value);\n          node = node.next;\n        }\n        return array;\n      }\n      if (!_self2.document) {\n        if (!_self2.addEventListener) {\n          return _;\n        }\n        if (!_.disableWorkerMessageHandler) {\n          _self2.addEventListener(\"message\", function(evt) {\n            var message = JSON.parse(evt.data);\n            var lang2 = message.language;\n            var code = message.code;\n            var immediateClose = message.immediateClose;\n            _self2.postMessage(_.highlight(code, _.languages[lang2], lang2));\n            if (immediateClose) {\n              _self2.close();\n            }\n          }, false);\n        }\n        return _;\n      }\n      var script = _.util.currentScript();\n      if (script) {\n        _.filename = script.src;\n        if (script.hasAttribute(\"data-manual\")) {\n          _.manual = true;\n        }\n      }\n      function highlightAutomaticallyCallback() {\n        if (!_.manual) {\n          _.highlightAll();\n        }\n      }\n      if (!_.manual) {\n        var readyState = document.readyState;\n        if (readyState === \"loading\" || readyState === \"interactive\" && script && script.defer) {\n          document.addEventListener(\"DOMContentLoaded\", highlightAutomaticallyCallback);\n        } else {\n          if (window.requestAnimationFrame) {\n            window.requestAnimationFrame(highlightAutomaticallyCallback);\n          } else {\n            window.setTimeout(highlightAutomaticallyCallback, 16);\n          }\n        }\n      }\n      return _;\n    }(_self);\n    if (module.exports) {\n      module.exports = Prism2;\n    }\n    if (typeof commonjsGlobal !== \"undefined\") {\n      commonjsGlobal.Prism = Prism2;\n    }\n    Prism2.languages.markup = {\n      \"comment\": {\n        pattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n        greedy: true\n      },\n      \"prolog\": {\n        pattern: /<\\?[\\s\\S]+?\\?>/,\n        greedy: true\n      },\n      \"doctype\": {\n        // https://www.w3.org/TR/xml/#NT-doctypedecl\n        pattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n        greedy: true,\n        inside: {\n          \"internal-subset\": {\n            pattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n            lookbehind: true,\n            greedy: true,\n            inside: null\n            // see below\n          },\n          \"string\": {\n            pattern: /\"[^\"]*\"|'[^']*'/,\n            greedy: true\n          },\n          \"punctuation\": /^<!|>$|[[\\]]/,\n          \"doctype-tag\": /^DOCTYPE/i,\n          \"name\": /[^\\s<>'\"]+/\n        }\n      },\n      \"cdata\": {\n        pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n        greedy: true\n      },\n      \"tag\": {\n        pattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n        greedy: true,\n        inside: {\n          \"tag\": {\n            pattern: /^<\\/?[^\\s>\\/]+/,\n            inside: {\n              \"punctuation\": /^<\\/?/,\n              \"namespace\": /^[^\\s>\\/:]+:/\n            }\n          },\n          \"special-attr\": [],\n          \"attr-value\": {\n            pattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n            inside: {\n              \"punctuation\": [\n                {\n                  pattern: /^=/,\n                  alias: \"attr-equals\"\n                },\n                {\n                  pattern: /^(\\s*)[\"']|[\"']$/,\n                  lookbehind: true\n                }\n              ]\n            }\n          },\n          \"punctuation\": /\\/?>/,\n          \"attr-name\": {\n            pattern: /[^\\s>\\/]+/,\n            inside: {\n              \"namespace\": /^[^\\s>\\/:]+:/\n            }\n          }\n        }\n      },\n      \"entity\": [\n        {\n          pattern: /&[\\da-z]{1,8};/i,\n          alias: \"named-entity\"\n        },\n        /&#x?[\\da-f]{1,8};/i\n      ]\n    };\n    Prism2.languages.markup[\"tag\"].inside[\"attr-value\"].inside[\"entity\"] = Prism2.languages.markup[\"entity\"];\n    Prism2.languages.markup[\"doctype\"].inside[\"internal-subset\"].inside = Prism2.languages.markup;\n    Prism2.hooks.add(\"wrap\", function(env) {\n      if (env.type === \"entity\") {\n        env.attributes[\"title\"] = env.content.replace(/&amp;/, \"&\");\n      }\n    });\n    Object.defineProperty(Prism2.languages.markup.tag, \"addInlined\", {\n      /**\n       * Adds an inlined language to markup.\n       *\n       * An example of an inlined language is CSS with `<style>` tags.\n       *\n       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n       * case insensitive.\n       * @param {string} lang The language key.\n       * @example\n       * addInlined('style', 'css');\n       */\n      value: function addInlined(tagName, lang) {\n        var includedCdataInside = {};\n        includedCdataInside[\"language-\" + lang] = {\n          pattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n          lookbehind: true,\n          inside: Prism2.languages[lang]\n        };\n        includedCdataInside[\"cdata\"] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n        var inside = {\n          \"included-cdata\": {\n            pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n            inside: includedCdataInside\n          }\n        };\n        inside[\"language-\" + lang] = {\n          pattern: /[\\s\\S]+/,\n          inside: Prism2.languages[lang]\n        };\n        var def = {};\n        def[tagName] = {\n          pattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function() {\n            return tagName;\n          }), \"i\"),\n          lookbehind: true,\n          greedy: true,\n          inside\n        };\n        Prism2.languages.insertBefore(\"markup\", \"cdata\", def);\n      }\n    });\n    Object.defineProperty(Prism2.languages.markup.tag, \"addAttribute\", {\n      /**\n       * Adds an pattern to highlight languages embedded in HTML attributes.\n       *\n       * An example of an inlined language is CSS with `style` attributes.\n       *\n       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n       * case insensitive.\n       * @param {string} lang The language key.\n       * @example\n       * addAttribute('style', 'css');\n       */\n      value: function(attrName, lang) {\n        Prism2.languages.markup.tag.inside[\"special-attr\"].push({\n          pattern: RegExp(\n            /(^|[\"'\\s])/.source + \"(?:\" + attrName + \")\" + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source,\n            \"i\"\n          ),\n          lookbehind: true,\n          inside: {\n            \"attr-name\": /^[^\\s=]+/,\n            \"attr-value\": {\n              pattern: /=[\\s\\S]+/,\n              inside: {\n                \"value\": {\n                  pattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n                  lookbehind: true,\n                  alias: [lang, \"language-\" + lang],\n                  inside: Prism2.languages[lang]\n                },\n                \"punctuation\": [\n                  {\n                    pattern: /^=/,\n                    alias: \"attr-equals\"\n                  },\n                  /\"|'/\n                ]\n              }\n            }\n          }\n        });\n      }\n    });\n    Prism2.languages.html = Prism2.languages.markup;\n    Prism2.languages.mathml = Prism2.languages.markup;\n    Prism2.languages.svg = Prism2.languages.markup;\n    Prism2.languages.xml = Prism2.languages.extend(\"markup\", {});\n    Prism2.languages.ssml = Prism2.languages.xml;\n    Prism2.languages.atom = Prism2.languages.xml;\n    Prism2.languages.rss = Prism2.languages.xml;\n    (function(Prism3) {\n      var string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n      Prism3.languages.css = {\n        \"comment\": /\\/\\*[\\s\\S]*?\\*\\//,\n        \"atrule\": {\n          pattern: RegExp(\"@[\\\\w-](?:\" + /[^;{\\s\"']|\\s+(?!\\s)/.source + \"|\" + string.source + \")*?\" + /(?:;|(?=\\s*\\{))/.source),\n          inside: {\n            \"rule\": /^@[\\w-]+/,\n            \"selector-function-argument\": {\n              pattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n              lookbehind: true,\n              alias: \"selector\"\n            },\n            \"keyword\": {\n              pattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n              lookbehind: true\n            }\n            // See rest below\n          }\n        },\n        \"url\": {\n          // https://drafts.csswg.org/css-values-3/#urls\n          pattern: RegExp(\"\\\\burl\\\\((?:\" + string.source + \"|\" + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + \")\\\\)\", \"i\"),\n          greedy: true,\n          inside: {\n            \"function\": /^url/i,\n            \"punctuation\": /^\\(|\\)$/,\n            \"string\": {\n              pattern: RegExp(\"^\" + string.source + \"$\"),\n              alias: \"url\"\n            }\n          }\n        },\n        \"selector\": {\n          pattern: RegExp(`(^|[{}\\\\s])[^{}\\\\s](?:[^{};\"'\\\\s]|\\\\s+(?![\\\\s{])|` + string.source + \")*(?=\\\\s*\\\\{)\"),\n          lookbehind: true\n        },\n        \"string\": {\n          pattern: string,\n          greedy: true\n        },\n        \"property\": {\n          pattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n          lookbehind: true\n        },\n        \"important\": /!important\\b/i,\n        \"function\": {\n          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n          lookbehind: true\n        },\n        \"punctuation\": /[(){};:,]/\n      };\n      Prism3.languages.css[\"atrule\"].inside.rest = Prism3.languages.css;\n      var markup = Prism3.languages.markup;\n      if (markup) {\n        markup.tag.addInlined(\"style\", \"css\");\n        markup.tag.addAttribute(\"style\", \"css\");\n      }\n    })(Prism2);\n    Prism2.languages.clike = {\n      \"comment\": [\n        {\n          pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n          lookbehind: true,\n          greedy: true\n        },\n        {\n          pattern: /(^|[^\\\\:])\\/\\/.*/,\n          lookbehind: true,\n          greedy: true\n        }\n      ],\n      \"string\": {\n        pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n        greedy: true\n      },\n      \"class-name\": {\n        pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n        lookbehind: true,\n        inside: {\n          \"punctuation\": /[.\\\\]/\n        }\n      },\n      \"keyword\": /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n      \"boolean\": /\\b(?:false|true)\\b/,\n      \"function\": /\\b\\w+(?=\\()/,\n      \"number\": /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n      \"operator\": /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n      \"punctuation\": /[{}[\\];(),.:]/\n    };\n    Prism2.languages.javascript = Prism2.languages.extend(\"clike\", {\n      \"class-name\": [\n        Prism2.languages.clike[\"class-name\"],\n        {\n          pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n          lookbehind: true\n        }\n      ],\n      \"keyword\": [\n        {\n          pattern: /((?:^|\\})\\s*)catch\\b/,\n          lookbehind: true\n        },\n        {\n          pattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n          lookbehind: true\n        }\n      ],\n      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n      \"function\": /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n      \"number\": {\n        pattern: RegExp(\n          /(^|[^\\w$])/.source + \"(?:\" + // constant\n          (/NaN|Infinity/.source + \"|\" + // binary integer\n          /0[bB][01]+(?:_[01]+)*n?/.source + \"|\" + // octal integer\n          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + \"|\" + // hexadecimal integer\n          /0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source + \"|\" + // decimal bigint\n          /\\d+(?:_\\d+)*n/.source + \"|\" + // decimal number (integer or float) but no bigint\n          /(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source) + \")\" + /(?![\\w$])/.source\n        ),\n        lookbehind: true\n      },\n      \"operator\": /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n    });\n    Prism2.languages.javascript[\"class-name\"][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\n    Prism2.languages.insertBefore(\"javascript\", \"keyword\", {\n      \"regex\": {\n        pattern: RegExp(\n          // lookbehind\n          // eslint-disable-next-line regexp/no-dupe-characters-character-class\n          /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/.source + // Regex pattern:\n          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character\n          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible\n          // with the only syntax, so we have to define 2 different regex patterns.\n          /\\//.source + \"(?:\" + /(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}/.source + \"|\" + // `v` flag syntax. This supports 3 levels of nested character classes.\n          /(?:\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + \")\" + // lookahead\n          /(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/.source\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          \"regex-source\": {\n            pattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n            lookbehind: true,\n            alias: \"language-regex\",\n            inside: Prism2.languages.regex\n          },\n          \"regex-delimiter\": /^\\/|\\/$/,\n          \"regex-flags\": /^[a-z]+$/\n        }\n      },\n      // This must be declared before keyword because we use \"function\" inside the look-forward\n      \"function-variable\": {\n        pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n        alias: \"function\"\n      },\n      \"parameter\": [\n        {\n          pattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n          lookbehind: true,\n          inside: Prism2.languages.javascript\n        },\n        {\n          pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n          lookbehind: true,\n          inside: Prism2.languages.javascript\n        },\n        {\n          pattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n          lookbehind: true,\n          inside: Prism2.languages.javascript\n        },\n        {\n          pattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n          lookbehind: true,\n          inside: Prism2.languages.javascript\n        }\n      ],\n      \"constant\": /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n    });\n    Prism2.languages.insertBefore(\"javascript\", \"string\", {\n      \"hashbang\": {\n        pattern: /^#!.*/,\n        greedy: true,\n        alias: \"comment\"\n      },\n      \"template-string\": {\n        pattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n        greedy: true,\n        inside: {\n          \"template-punctuation\": {\n            pattern: /^`|`$/,\n            alias: \"string\"\n          },\n          \"interpolation\": {\n            pattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n            lookbehind: true,\n            inside: {\n              \"interpolation-punctuation\": {\n                pattern: /^\\$\\{|\\}$/,\n                alias: \"punctuation\"\n              },\n              rest: Prism2.languages.javascript\n            }\n          },\n          \"string\": /[\\s\\S]+/\n        }\n      },\n      \"string-property\": {\n        pattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n        lookbehind: true,\n        greedy: true,\n        alias: \"property\"\n      }\n    });\n    Prism2.languages.insertBefore(\"javascript\", \"operator\", {\n      \"literal-property\": {\n        pattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n        lookbehind: true,\n        alias: \"property\"\n      }\n    });\n    if (Prism2.languages.markup) {\n      Prism2.languages.markup.tag.addInlined(\"script\", \"javascript\");\n      Prism2.languages.markup.tag.addAttribute(\n        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,\n        \"javascript\"\n      );\n    }\n    Prism2.languages.js = Prism2.languages.javascript;\n    (function() {\n      if (typeof Prism2 === \"undefined\" || typeof document === \"undefined\") {\n        return;\n      }\n      if (!Element.prototype.matches) {\n        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n      }\n      var LOADING_MESSAGE = \"Loading\";\n      var FAILURE_MESSAGE = function(status, message) {\n        return \" Error \" + status + \" while fetching file: \" + message;\n      };\n      var FAILURE_EMPTY_MESSAGE = \" Error: File does not exist or is empty\";\n      var EXTENSIONS = {\n        \"js\": \"javascript\",\n        \"py\": \"python\",\n        \"rb\": \"ruby\",\n        \"ps1\": \"powershell\",\n        \"psm1\": \"powershell\",\n        \"sh\": \"bash\",\n        \"bat\": \"batch\",\n        \"h\": \"c\",\n        \"tex\": \"latex\"\n      };\n      var STATUS_ATTR = \"data-src-status\";\n      var STATUS_LOADING = \"loading\";\n      var STATUS_LOADED = \"loaded\";\n      var STATUS_FAILED = \"failed\";\n      var SELECTOR = \"pre[data-src]:not([\" + STATUS_ATTR + '=\"' + STATUS_LOADED + '\"]):not([' + STATUS_ATTR + '=\"' + STATUS_LOADING + '\"])';\n      function loadFile(src, success, error) {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", src, true);\n        xhr.onreadystatechange = function() {\n          if (xhr.readyState == 4) {\n            if (xhr.status < 400 && xhr.responseText) {\n              success(xhr.responseText);\n            } else {\n              if (xhr.status >= 400) {\n                error(FAILURE_MESSAGE(xhr.status, xhr.statusText));\n              } else {\n                error(FAILURE_EMPTY_MESSAGE);\n              }\n            }\n          }\n        };\n        xhr.send(null);\n      }\n      function parseRange(range) {\n        var m = /^\\s*(\\d+)\\s*(?:(,)\\s*(?:(\\d+)\\s*)?)?$/.exec(range || \"\");\n        if (m) {\n          var start = Number(m[1]);\n          var comma = m[2];\n          var end = m[3];\n          if (!comma) {\n            return [start, start];\n          }\n          if (!end) {\n            return [start, void 0];\n          }\n          return [start, Number(end)];\n        }\n        return void 0;\n      }\n      Prism2.hooks.add(\"before-highlightall\", function(env) {\n        env.selector += \", \" + SELECTOR;\n      });\n      Prism2.hooks.add(\"before-sanity-check\", function(env) {\n        var pre = (\n          /** @type {HTMLPreElement} */\n          env.element\n        );\n        if (pre.matches(SELECTOR)) {\n          env.code = \"\";\n          pre.setAttribute(STATUS_ATTR, STATUS_LOADING);\n          var code = pre.appendChild(document.createElement(\"CODE\"));\n          code.textContent = LOADING_MESSAGE;\n          var src = pre.getAttribute(\"data-src\");\n          var language = env.language;\n          if (language === \"none\") {\n            var extension = (/\\.(\\w+)$/.exec(src) || [, \"none\"])[1];\n            language = EXTENSIONS[extension] || extension;\n          }\n          Prism2.util.setLanguage(code, language);\n          Prism2.util.setLanguage(pre, language);\n          var autoloader = Prism2.plugins.autoloader;\n          if (autoloader) {\n            autoloader.loadLanguages(language);\n          }\n          loadFile(\n            src,\n            function(text) {\n              pre.setAttribute(STATUS_ATTR, STATUS_LOADED);\n              var range = parseRange(pre.getAttribute(\"data-range\"));\n              if (range) {\n                var lines = text.split(/\\r\\n?|\\n/g);\n                var start = range[0];\n                var end = range[1] == null ? lines.length : range[1];\n                if (start < 0) {\n                  start += lines.length;\n                }\n                start = Math.max(0, Math.min(start - 1, lines.length));\n                if (end < 0) {\n                  end += lines.length;\n                }\n                end = Math.max(0, Math.min(end, lines.length));\n                text = lines.slice(start, end).join(\"\\n\");\n                if (!pre.hasAttribute(\"data-start\")) {\n                  pre.setAttribute(\"data-start\", String(start + 1));\n                }\n              }\n              code.textContent = text;\n              Prism2.highlightElement(code);\n            },\n            function(error) {\n              pre.setAttribute(STATUS_ATTR, STATUS_FAILED);\n              code.textContent = error;\n            }\n          );\n        }\n      });\n      Prism2.plugins.fileHighlight = {\n        /**\n         * Executes the File Highlight plugin for all matching `pre` elements under the given container.\n         *\n         * Note: Elements which are already loaded or currently loading will not be touched by this method.\n         *\n         * @param {ParentNode} [container=document]\n         */\n        highlight: function highlight(container) {\n          var elements = (container || document).querySelectorAll(SELECTOR);\n          for (var i = 0, element; element = elements[i++]; ) {\n            Prism2.highlightElement(element);\n          }\n        }\n      };\n      var logged = false;\n      Prism2.fileHighlight = function() {\n        if (!logged) {\n          console.warn(\"Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.\");\n          logged = true;\n        }\n        Prism2.plugins.fileHighlight.highlight.apply(this, arguments);\n      };\n    })();\n  })(prism);\n  return prism.exports;\n}\nvar prismClike = {};\nvar hasRequiredPrismClike;\nfunction requirePrismClike() {\n  if (hasRequiredPrismClike)\n    return prismClike;\n  hasRequiredPrismClike = 1;\n  Prism.languages.clike = {\n    \"comment\": [\n      {\n        pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n        lookbehind: true,\n        greedy: true\n      },\n      {\n        pattern: /(^|[^\\\\:])\\/\\/.*/,\n        lookbehind: true,\n        greedy: true\n      }\n    ],\n    \"string\": {\n      pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n      greedy: true\n    },\n    \"class-name\": {\n      pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n      lookbehind: true,\n      inside: {\n        \"punctuation\": /[.\\\\]/\n      }\n    },\n    \"keyword\": /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n    \"boolean\": /\\b(?:false|true)\\b/,\n    \"function\": /\\b\\w+(?=\\()/,\n    \"number\": /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n    \"operator\": /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n    \"punctuation\": /[{}[\\];(),.:]/\n  };\n  return prismClike;\n}\nvar prismJavascript = {};\nvar hasRequiredPrismJavascript;\nfunction requirePrismJavascript() {\n  if (hasRequiredPrismJavascript)\n    return prismJavascript;\n  hasRequiredPrismJavascript = 1;\n  Prism.languages.javascript = Prism.languages.extend(\"clike\", {\n    \"class-name\": [\n      Prism.languages.clike[\"class-name\"],\n      {\n        pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n        lookbehind: true\n      }\n    ],\n    \"keyword\": [\n      {\n        pattern: /((?:^|\\})\\s*)catch\\b/,\n        lookbehind: true\n      },\n      {\n        pattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n        lookbehind: true\n      }\n    ],\n    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n    \"function\": /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n    \"number\": {\n      pattern: RegExp(\n        /(^|[^\\w$])/.source + \"(?:\" + // constant\n        (/NaN|Infinity/.source + \"|\" + // binary integer\n        /0[bB][01]+(?:_[01]+)*n?/.source + \"|\" + // octal integer\n        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + \"|\" + // hexadecimal integer\n        /0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source + \"|\" + // decimal bigint\n        /\\d+(?:_\\d+)*n/.source + \"|\" + // decimal number (integer or float) but no bigint\n        /(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source) + \")\" + /(?![\\w$])/.source\n      ),\n      lookbehind: true\n    },\n    \"operator\": /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n  });\n  Prism.languages.javascript[\"class-name\"][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\n  Prism.languages.insertBefore(\"javascript\", \"keyword\", {\n    \"regex\": {\n      pattern: RegExp(\n        // lookbehind\n        // eslint-disable-next-line regexp/no-dupe-characters-character-class\n        /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/.source + // Regex pattern:\n        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character\n        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible\n        // with the only syntax, so we have to define 2 different regex patterns.\n        /\\//.source + \"(?:\" + /(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}/.source + \"|\" + // `v` flag syntax. This supports 3 levels of nested character classes.\n        /(?:\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + \")\" + // lookahead\n        /(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/.source\n      ),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        \"regex-source\": {\n          pattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n          lookbehind: true,\n          alias: \"language-regex\",\n          inside: Prism.languages.regex\n        },\n        \"regex-delimiter\": /^\\/|\\/$/,\n        \"regex-flags\": /^[a-z]+$/\n      }\n    },\n    // This must be declared before keyword because we use \"function\" inside the look-forward\n    \"function-variable\": {\n      pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n      alias: \"function\"\n    },\n    \"parameter\": [\n      {\n        pattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n        lookbehind: true,\n        inside: Prism.languages.javascript\n      },\n      {\n        pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n        lookbehind: true,\n        inside: Prism.languages.javascript\n      },\n      {\n        pattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n        lookbehind: true,\n        inside: Prism.languages.javascript\n      },\n      {\n        pattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n        lookbehind: true,\n        inside: Prism.languages.javascript\n      }\n    ],\n    \"constant\": /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n  });\n  Prism.languages.insertBefore(\"javascript\", \"string\", {\n    \"hashbang\": {\n      pattern: /^#!.*/,\n      greedy: true,\n      alias: \"comment\"\n    },\n    \"template-string\": {\n      pattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n      greedy: true,\n      inside: {\n        \"template-punctuation\": {\n          pattern: /^`|`$/,\n          alias: \"string\"\n        },\n        \"interpolation\": {\n          pattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n          lookbehind: true,\n          inside: {\n            \"interpolation-punctuation\": {\n              pattern: /^\\$\\{|\\}$/,\n              alias: \"punctuation\"\n            },\n            rest: Prism.languages.javascript\n          }\n        },\n        \"string\": /[\\s\\S]+/\n      }\n    },\n    \"string-property\": {\n      pattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n      lookbehind: true,\n      greedy: true,\n      alias: \"property\"\n    }\n  });\n  Prism.languages.insertBefore(\"javascript\", \"operator\", {\n    \"literal-property\": {\n      pattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n      lookbehind: true,\n      alias: \"property\"\n    }\n  });\n  if (Prism.languages.markup) {\n    Prism.languages.markup.tag.addInlined(\"script\", \"javascript\");\n    Prism.languages.markup.tag.addAttribute(\n      /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,\n      \"javascript\"\n    );\n  }\n  Prism.languages.js = Prism.languages.javascript;\n  return prismJavascript;\n}\nvar prismMarkup = {};\nvar hasRequiredPrismMarkup;\nfunction requirePrismMarkup() {\n  if (hasRequiredPrismMarkup)\n    return prismMarkup;\n  hasRequiredPrismMarkup = 1;\n  Prism.languages.markup = {\n    \"comment\": {\n      pattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n      greedy: true\n    },\n    \"prolog\": {\n      pattern: /<\\?[\\s\\S]+?\\?>/,\n      greedy: true\n    },\n    \"doctype\": {\n      // https://www.w3.org/TR/xml/#NT-doctypedecl\n      pattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n      greedy: true,\n      inside: {\n        \"internal-subset\": {\n          pattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n          lookbehind: true,\n          greedy: true,\n          inside: null\n          // see below\n        },\n        \"string\": {\n          pattern: /\"[^\"]*\"|'[^']*'/,\n          greedy: true\n        },\n        \"punctuation\": /^<!|>$|[[\\]]/,\n        \"doctype-tag\": /^DOCTYPE/i,\n        \"name\": /[^\\s<>'\"]+/\n      }\n    },\n    \"cdata\": {\n      pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n      greedy: true\n    },\n    \"tag\": {\n      pattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n      greedy: true,\n      inside: {\n        \"tag\": {\n          pattern: /^<\\/?[^\\s>\\/]+/,\n          inside: {\n            \"punctuation\": /^<\\/?/,\n            \"namespace\": /^[^\\s>\\/:]+:/\n          }\n        },\n        \"special-attr\": [],\n        \"attr-value\": {\n          pattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n          inside: {\n            \"punctuation\": [\n              {\n                pattern: /^=/,\n                alias: \"attr-equals\"\n              },\n              {\n                pattern: /^(\\s*)[\"']|[\"']$/,\n                lookbehind: true\n              }\n            ]\n          }\n        },\n        \"punctuation\": /\\/?>/,\n        \"attr-name\": {\n          pattern: /[^\\s>\\/]+/,\n          inside: {\n            \"namespace\": /^[^\\s>\\/:]+:/\n          }\n        }\n      }\n    },\n    \"entity\": [\n      {\n        pattern: /&[\\da-z]{1,8};/i,\n        alias: \"named-entity\"\n      },\n      /&#x?[\\da-f]{1,8};/i\n    ]\n  };\n  Prism.languages.markup[\"tag\"].inside[\"attr-value\"].inside[\"entity\"] = Prism.languages.markup[\"entity\"];\n  Prism.languages.markup[\"doctype\"].inside[\"internal-subset\"].inside = Prism.languages.markup;\n  Prism.hooks.add(\"wrap\", function(env) {\n    if (env.type === \"entity\") {\n      env.attributes[\"title\"] = env.content.replace(/&amp;/, \"&\");\n    }\n  });\n  Object.defineProperty(Prism.languages.markup.tag, \"addInlined\", {\n    /**\n     * Adds an inlined language to markup.\n     *\n     * An example of an inlined language is CSS with `<style>` tags.\n     *\n     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n     * case insensitive.\n     * @param {string} lang The language key.\n     * @example\n     * addInlined('style', 'css');\n     */\n    value: function addInlined(tagName, lang) {\n      var includedCdataInside = {};\n      includedCdataInside[\"language-\" + lang] = {\n        pattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n        lookbehind: true,\n        inside: Prism.languages[lang]\n      };\n      includedCdataInside[\"cdata\"] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n      var inside = {\n        \"included-cdata\": {\n          pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n          inside: includedCdataInside\n        }\n      };\n      inside[\"language-\" + lang] = {\n        pattern: /[\\s\\S]+/,\n        inside: Prism.languages[lang]\n      };\n      var def = {};\n      def[tagName] = {\n        pattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function() {\n          return tagName;\n        }), \"i\"),\n        lookbehind: true,\n        greedy: true,\n        inside\n      };\n      Prism.languages.insertBefore(\"markup\", \"cdata\", def);\n    }\n  });\n  Object.defineProperty(Prism.languages.markup.tag, \"addAttribute\", {\n    /**\n     * Adds an pattern to highlight languages embedded in HTML attributes.\n     *\n     * An example of an inlined language is CSS with `style` attributes.\n     *\n     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n     * case insensitive.\n     * @param {string} lang The language key.\n     * @example\n     * addAttribute('style', 'css');\n     */\n    value: function(attrName, lang) {\n      Prism.languages.markup.tag.inside[\"special-attr\"].push({\n        pattern: RegExp(\n          /(^|[\"'\\s])/.source + \"(?:\" + attrName + \")\" + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source,\n          \"i\"\n        ),\n        lookbehind: true,\n        inside: {\n          \"attr-name\": /^[^\\s=]+/,\n          \"attr-value\": {\n            pattern: /=[\\s\\S]+/,\n            inside: {\n              \"value\": {\n                pattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n                lookbehind: true,\n                alias: [lang, \"language-\" + lang],\n                inside: Prism.languages[lang]\n              },\n              \"punctuation\": [\n                {\n                  pattern: /^=/,\n                  alias: \"attr-equals\"\n                },\n                /\"|'/\n              ]\n            }\n          }\n        }\n      });\n    }\n  });\n  Prism.languages.html = Prism.languages.markup;\n  Prism.languages.mathml = Prism.languages.markup;\n  Prism.languages.svg = Prism.languages.markup;\n  Prism.languages.xml = Prism.languages.extend(\"markup\", {});\n  Prism.languages.ssml = Prism.languages.xml;\n  Prism.languages.atom = Prism.languages.xml;\n  Prism.languages.rss = Prism.languages.xml;\n  return prismMarkup;\n}\nvar prismMarkdown = {};\nvar hasRequiredPrismMarkdown;\nfunction requirePrismMarkdown() {\n  if (hasRequiredPrismMarkdown)\n    return prismMarkdown;\n  hasRequiredPrismMarkdown = 1;\n  (function(Prism2) {\n    var inner = /(?:\\\\.|[^\\\\\\n\\r]|(?:\\n|\\r\\n?)(?![\\r\\n]))/.source;\n    function createInline(pattern) {\n      pattern = pattern.replace(/<inner>/g, function() {\n        return inner;\n      });\n      return RegExp(/((?:^|[^\\\\])(?:\\\\{2})*)/.source + \"(?:\" + pattern + \")\");\n    }\n    var tableCell = /(?:\\\\.|``(?:[^`\\r\\n]|`(?!`))+``|`[^`\\r\\n]+`|[^\\\\|\\r\\n`])+/.source;\n    var tableRow = /\\|?__(?:\\|__)+\\|?(?:(?:\\n|\\r\\n?)|(?![\\s\\S]))/.source.replace(/__/g, function() {\n      return tableCell;\n    });\n    var tableLine = /\\|?[ \\t]*:?-{3,}:?[ \\t]*(?:\\|[ \\t]*:?-{3,}:?[ \\t]*)+\\|?(?:\\n|\\r\\n?)/.source;\n    Prism2.languages.markdown = Prism2.languages.extend(\"markup\", {});\n    Prism2.languages.insertBefore(\"markdown\", \"prolog\", {\n      \"front-matter-block\": {\n        pattern: /(^(?:\\s*[\\r\\n])?)---(?!.)[\\s\\S]*?[\\r\\n]---(?!.)/,\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          \"punctuation\": /^---|---$/,\n          \"front-matter\": {\n            pattern: /\\S+(?:\\s+\\S+)*/,\n            alias: [\"yaml\", \"language-yaml\"],\n            inside: Prism2.languages.yaml\n          }\n        }\n      },\n      \"blockquote\": {\n        // > ...\n        pattern: /^>(?:[\\t ]*>)*/m,\n        alias: \"punctuation\"\n      },\n      \"table\": {\n        pattern: RegExp(\"^\" + tableRow + tableLine + \"(?:\" + tableRow + \")*\", \"m\"),\n        inside: {\n          \"table-data-rows\": {\n            pattern: RegExp(\"^(\" + tableRow + tableLine + \")(?:\" + tableRow + \")*$\"),\n            lookbehind: true,\n            inside: {\n              \"table-data\": {\n                pattern: RegExp(tableCell),\n                inside: Prism2.languages.markdown\n              },\n              \"punctuation\": /\\|/\n            }\n          },\n          \"table-line\": {\n            pattern: RegExp(\"^(\" + tableRow + \")\" + tableLine + \"$\"),\n            lookbehind: true,\n            inside: {\n              \"punctuation\": /\\||:?-{3,}:?/\n            }\n          },\n          \"table-header-row\": {\n            pattern: RegExp(\"^\" + tableRow + \"$\"),\n            inside: {\n              \"table-header\": {\n                pattern: RegExp(tableCell),\n                alias: \"important\",\n                inside: Prism2.languages.markdown\n              },\n              \"punctuation\": /\\|/\n            }\n          }\n        }\n      },\n      \"code\": [\n        {\n          // Prefixed by 4 spaces or 1 tab and preceded by an empty line\n          pattern: /((?:^|\\n)[ \\t]*\\n|(?:^|\\r\\n?)[ \\t]*\\r\\n?)(?: {4}|\\t).+(?:(?:\\n|\\r\\n?)(?: {4}|\\t).+)*/,\n          lookbehind: true,\n          alias: \"keyword\"\n        },\n        {\n          // ```optional language\n          // code block\n          // ```\n          pattern: /^```[\\s\\S]*?^```$/m,\n          greedy: true,\n          inside: {\n            \"code-block\": {\n              pattern: /^(```.*(?:\\n|\\r\\n?))[\\s\\S]+?(?=(?:\\n|\\r\\n?)^```$)/m,\n              lookbehind: true\n            },\n            \"code-language\": {\n              pattern: /^(```).+/,\n              lookbehind: true\n            },\n            \"punctuation\": /```/\n          }\n        }\n      ],\n      \"title\": [\n        {\n          // title 1\n          // =======\n          // title 2\n          // -------\n          pattern: /\\S.*(?:\\n|\\r\\n?)(?:==+|--+)(?=[ \\t]*$)/m,\n          alias: \"important\",\n          inside: {\n            punctuation: /==+$|--+$/\n          }\n        },\n        {\n          // # title 1\n          // ###### title 6\n          pattern: /(^\\s*)#.+/m,\n          lookbehind: true,\n          alias: \"important\",\n          inside: {\n            punctuation: /^#+|#+$/\n          }\n        }\n      ],\n      \"hr\": {\n        // ***\n        // ---\n        // * * *\n        // -----------\n        pattern: /(^\\s*)([*-])(?:[\\t ]*\\2){2,}(?=\\s*$)/m,\n        lookbehind: true,\n        alias: \"punctuation\"\n      },\n      \"list\": {\n        // * item\n        // + item\n        // - item\n        // 1. item\n        pattern: /(^\\s*)(?:[*+-]|\\d+\\.)(?=[\\t ].)/m,\n        lookbehind: true,\n        alias: \"punctuation\"\n      },\n      \"url-reference\": {\n        // [id]: http://example.com \"Optional title\"\n        // [id]: http://example.com 'Optional title'\n        // [id]: http://example.com (Optional title)\n        // [id]: <http://example.com> \"Optional title\"\n        pattern: /!?\\[[^\\]]+\\]:[\\t ]+(?:\\S+|<(?:\\\\.|[^>\\\\])+>)(?:[\\t ]+(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\)))?/,\n        inside: {\n          \"variable\": {\n            pattern: /^(!?\\[)[^\\]]+/,\n            lookbehind: true\n          },\n          \"string\": /(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\))$/,\n          \"punctuation\": /^[\\[\\]!:]|[<>]/\n        },\n        alias: \"url\"\n      },\n      \"bold\": {\n        // **strong**\n        // __strong__\n        // allow one nested instance of italic text using the same delimiter\n        pattern: createInline(/\\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\\b|\\*\\*(?:(?!\\*)<inner>|\\*(?:(?!\\*)<inner>)+\\*)+\\*\\*/.source),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          \"content\": {\n            pattern: /(^..)[\\s\\S]+(?=..$)/,\n            lookbehind: true,\n            inside: {}\n            // see below\n          },\n          \"punctuation\": /\\*\\*|__/\n        }\n      },\n      \"italic\": {\n        // *em*\n        // _em_\n        // allow one nested instance of bold text using the same delimiter\n        pattern: createInline(/\\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\\b|\\*(?:(?!\\*)<inner>|\\*\\*(?:(?!\\*)<inner>)+\\*\\*)+\\*/.source),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          \"content\": {\n            pattern: /(^.)[\\s\\S]+(?=.$)/,\n            lookbehind: true,\n            inside: {}\n            // see below\n          },\n          \"punctuation\": /[*_]/\n        }\n      },\n      \"strike\": {\n        // ~~strike through~~\n        // ~strike~\n        // eslint-disable-next-line regexp/strict\n        pattern: createInline(/(~~?)(?:(?!~)<inner>)+\\2/.source),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          \"content\": {\n            pattern: /(^~~?)[\\s\\S]+(?=\\1$)/,\n            lookbehind: true,\n            inside: {}\n            // see below\n          },\n          \"punctuation\": /~~?/\n        }\n      },\n      \"code-snippet\": {\n        // `code`\n        // ``code``\n        pattern: /(^|[^\\\\`])(?:``[^`\\r\\n]+(?:`[^`\\r\\n]+)*``(?!`)|`[^`\\r\\n]+`(?!`))/,\n        lookbehind: true,\n        greedy: true,\n        alias: [\"code\", \"keyword\"]\n      },\n      \"url\": {\n        // [example](http://example.com \"Optional title\")\n        // [example][id]\n        // [example] [id]\n        pattern: createInline(/!?\\[(?:(?!\\])<inner>)+\\](?:\\([^\\s)]+(?:[\\t ]+\"(?:\\\\.|[^\"\\\\])*\")?\\)|[ \\t]?\\[(?:(?!\\])<inner>)+\\])/.source),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          \"operator\": /^!/,\n          \"content\": {\n            pattern: /(^\\[)[^\\]]+(?=\\])/,\n            lookbehind: true,\n            inside: {}\n            // see below\n          },\n          \"variable\": {\n            pattern: /(^\\][ \\t]?\\[)[^\\]]+(?=\\]$)/,\n            lookbehind: true\n          },\n          \"url\": {\n            pattern: /(^\\]\\()[^\\s)]+/,\n            lookbehind: true\n          },\n          \"string\": {\n            pattern: /(^[ \\t]+)\"(?:\\\\.|[^\"\\\\])*\"(?=\\)$)/,\n            lookbehind: true\n          }\n        }\n      }\n    });\n    [\"url\", \"bold\", \"italic\", \"strike\"].forEach(function(token) {\n      [\"url\", \"bold\", \"italic\", \"strike\", \"code-snippet\"].forEach(function(inside) {\n        if (token !== inside) {\n          Prism2.languages.markdown[token].inside.content.inside[inside] = Prism2.languages.markdown[inside];\n        }\n      });\n    });\n    Prism2.hooks.add(\"after-tokenize\", function(env) {\n      if (env.language !== \"markdown\" && env.language !== \"md\") {\n        return;\n      }\n      function walkTokens(tokens) {\n        if (!tokens || typeof tokens === \"string\") {\n          return;\n        }\n        for (var i = 0, l = tokens.length; i < l; i++) {\n          var token = tokens[i];\n          if (token.type !== \"code\") {\n            walkTokens(token.content);\n            continue;\n          }\n          var codeLang = token.content[1];\n          var codeBlock = token.content[3];\n          if (codeLang && codeBlock && codeLang.type === \"code-language\" && codeBlock.type === \"code-block\" && typeof codeLang.content === \"string\") {\n            var lang = codeLang.content.replace(/\\b#/g, \"sharp\").replace(/\\b\\+\\+/g, \"pp\");\n            lang = (/[a-z][\\w-]*/i.exec(lang) || [\"\"])[0].toLowerCase();\n            var alias = \"language-\" + lang;\n            if (!codeBlock.alias) {\n              codeBlock.alias = [alias];\n            } else if (typeof codeBlock.alias === \"string\") {\n              codeBlock.alias = [codeBlock.alias, alias];\n            } else {\n              codeBlock.alias.push(alias);\n            }\n          }\n        }\n      }\n      walkTokens(env.tokens);\n    });\n    Prism2.hooks.add(\"wrap\", function(env) {\n      if (env.type !== \"code-block\") {\n        return;\n      }\n      var codeLang = \"\";\n      for (var i = 0, l = env.classes.length; i < l; i++) {\n        var cls = env.classes[i];\n        var match = /language-(.+)/.exec(cls);\n        if (match) {\n          codeLang = match[1];\n          break;\n        }\n      }\n      var grammar = Prism2.languages[codeLang];\n      if (!grammar) {\n        if (codeLang && codeLang !== \"none\" && Prism2.plugins.autoloader) {\n          var id = \"md-\" + (/* @__PURE__ */ new Date()).valueOf() + \"-\" + Math.floor(Math.random() * 1e16);\n          env.attributes[\"id\"] = id;\n          Prism2.plugins.autoloader.loadLanguages(codeLang, function() {\n            var ele = document.getElementById(id);\n            if (ele) {\n              ele.innerHTML = Prism2.highlight(ele.textContent, Prism2.languages[codeLang], codeLang);\n            }\n          });\n        }\n      } else {\n        env.content = Prism2.highlight(textContent(env.content), grammar, codeLang);\n      }\n    });\n    var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, \"gi\");\n    var KNOWN_ENTITY_NAMES = {\n      \"amp\": \"&\",\n      \"lt\": \"<\",\n      \"gt\": \">\",\n      \"quot\": '\"'\n    };\n    var fromCodePoint = String.fromCodePoint || String.fromCharCode;\n    function textContent(html) {\n      var text = html.replace(tagPattern, \"\");\n      text = text.replace(/&(\\w{1,8}|#x?[\\da-f]{1,8});/gi, function(m, code) {\n        code = code.toLowerCase();\n        if (code[0] === \"#\") {\n          var value2;\n          if (code[1] === \"x\") {\n            value2 = parseInt(code.slice(2), 16);\n          } else {\n            value2 = Number(code.slice(1));\n          }\n          return fromCodePoint(value2);\n        } else {\n          var known = KNOWN_ENTITY_NAMES[code];\n          if (known) {\n            return known;\n          }\n          return m;\n        }\n      });\n      return text;\n    }\n    Prism2.languages.md = Prism2.languages.markdown;\n  })(Prism);\n  return prismMarkdown;\n}\nvar prismC = {};\nvar hasRequiredPrismC;\nfunction requirePrismC() {\n  if (hasRequiredPrismC)\n    return prismC;\n  hasRequiredPrismC = 1;\n  Prism.languages.c = Prism.languages.extend(\"clike\", {\n    \"comment\": {\n      pattern: /\\/\\/(?:[^\\r\\n\\\\]|\\\\(?:\\r\\n?|\\n|(?![\\r\\n])))*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n      greedy: true\n    },\n    \"string\": {\n      // https://en.cppreference.com/w/c/language/string_literal\n      pattern: /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n      greedy: true\n    },\n    \"class-name\": {\n      pattern: /(\\b(?:enum|struct)\\s+(?:__attribute__\\s*\\(\\([\\s\\S]*?\\)\\)\\s*)?)\\w+|\\b[a-z]\\w*_t\\b/,\n      lookbehind: true\n    },\n    \"keyword\": /\\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b/,\n    \"function\": /\\b[a-z_]\\w*(?=\\s*\\()/i,\n    \"number\": /(?:\\b0x(?:[\\da-f]+(?:\\.[\\da-f]*)?|\\.[\\da-f]+)(?:p[+-]?\\d+)?|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)[ful]{0,4}/i,\n    \"operator\": />>=?|<<=?|->|([-+&|:])\\1|[?:~]|[-+*/%&|^!=<>]=?/\n  });\n  Prism.languages.insertBefore(\"c\", \"string\", {\n    \"char\": {\n      // https://en.cppreference.com/w/c/language/character_constant\n      pattern: /'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n]){0,32}'/,\n      greedy: true\n    }\n  });\n  Prism.languages.insertBefore(\"c\", \"string\", {\n    \"macro\": {\n      // allow for multiline macro definitions\n      // spaces after the # character compile fine with gcc\n      pattern: /(^[\\t ]*)#\\s*[a-z](?:[^\\r\\n\\\\/]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|\\\\(?:\\r\\n|[\\s\\S]))*/im,\n      lookbehind: true,\n      greedy: true,\n      alias: \"property\",\n      inside: {\n        \"string\": [\n          {\n            // highlight the path of the include statement as a string\n            pattern: /^(#\\s*include\\s*)<[^>]+>/,\n            lookbehind: true\n          },\n          Prism.languages.c[\"string\"]\n        ],\n        \"char\": Prism.languages.c[\"char\"],\n        \"comment\": Prism.languages.c[\"comment\"],\n        \"macro-name\": [\n          {\n            pattern: /(^#\\s*define\\s+)\\w+\\b(?!\\()/i,\n            lookbehind: true\n          },\n          {\n            pattern: /(^#\\s*define\\s+)\\w+\\b(?=\\()/i,\n            lookbehind: true,\n            alias: \"function\"\n          }\n        ],\n        // highlight macro directives as keywords\n        \"directive\": {\n          pattern: /^(#\\s*)[a-z]+/,\n          lookbehind: true,\n          alias: \"keyword\"\n        },\n        \"directive-hash\": /^#/,\n        \"punctuation\": /##|\\\\(?=[\\r\\n])/,\n        \"expression\": {\n          pattern: /\\S[\\s\\S]*/,\n          inside: Prism.languages.c\n        }\n      }\n    }\n  });\n  Prism.languages.insertBefore(\"c\", \"function\", {\n    // highlight predefined macros as constants\n    \"constant\": /\\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\\b/\n  });\n  delete Prism.languages.c[\"boolean\"];\n  return prismC;\n}\nvar prismCss = {};\nvar hasRequiredPrismCss;\nfunction requirePrismCss() {\n  if (hasRequiredPrismCss)\n    return prismCss;\n  hasRequiredPrismCss = 1;\n  (function(Prism2) {\n    var string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n    Prism2.languages.css = {\n      \"comment\": /\\/\\*[\\s\\S]*?\\*\\//,\n      \"atrule\": {\n        pattern: RegExp(\"@[\\\\w-](?:\" + /[^;{\\s\"']|\\s+(?!\\s)/.source + \"|\" + string.source + \")*?\" + /(?:;|(?=\\s*\\{))/.source),\n        inside: {\n          \"rule\": /^@[\\w-]+/,\n          \"selector-function-argument\": {\n            pattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n            lookbehind: true,\n            alias: \"selector\"\n          },\n          \"keyword\": {\n            pattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n            lookbehind: true\n          }\n          // See rest below\n        }\n      },\n      \"url\": {\n        // https://drafts.csswg.org/css-values-3/#urls\n        pattern: RegExp(\"\\\\burl\\\\((?:\" + string.source + \"|\" + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + \")\\\\)\", \"i\"),\n        greedy: true,\n        inside: {\n          \"function\": /^url/i,\n          \"punctuation\": /^\\(|\\)$/,\n          \"string\": {\n            pattern: RegExp(\"^\" + string.source + \"$\"),\n            alias: \"url\"\n          }\n        }\n      },\n      \"selector\": {\n        pattern: RegExp(`(^|[{}\\\\s])[^{}\\\\s](?:[^{};\"'\\\\s]|\\\\s+(?![\\\\s{])|` + string.source + \")*(?=\\\\s*\\\\{)\"),\n        lookbehind: true\n      },\n      \"string\": {\n        pattern: string,\n        greedy: true\n      },\n      \"property\": {\n        pattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n        lookbehind: true\n      },\n      \"important\": /!important\\b/i,\n      \"function\": {\n        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n        lookbehind: true\n      },\n      \"punctuation\": /[(){};:,]/\n    };\n    Prism2.languages.css[\"atrule\"].inside.rest = Prism2.languages.css;\n    var markup = Prism2.languages.markup;\n    if (markup) {\n      markup.tag.addInlined(\"style\", \"css\");\n      markup.tag.addAttribute(\"style\", \"css\");\n    }\n  })(Prism);\n  return prismCss;\n}\nvar prismObjectivec = {};\nvar hasRequiredPrismObjectivec;\nfunction requirePrismObjectivec() {\n  if (hasRequiredPrismObjectivec)\n    return prismObjectivec;\n  hasRequiredPrismObjectivec = 1;\n  Prism.languages.objectivec = Prism.languages.extend(\"c\", {\n    \"string\": {\n      pattern: /@?\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n      greedy: true\n    },\n    \"keyword\": /\\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\\b/,\n    \"operator\": /-[->]?|\\+\\+?|!=?|<<?=?|>>?=?|==?|&&?|\\|\\|?|[~^%?*\\/@]/\n  });\n  delete Prism.languages.objectivec[\"class-name\"];\n  Prism.languages.objc = Prism.languages.objectivec;\n  return prismObjectivec;\n}\nvar prismSql = {};\nvar hasRequiredPrismSql;\nfunction requirePrismSql() {\n  if (hasRequiredPrismSql)\n    return prismSql;\n  hasRequiredPrismSql = 1;\n  Prism.languages.sql = {\n    \"comment\": {\n      pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|(?:--|\\/\\/|#).*)/,\n      lookbehind: true\n    },\n    \"variable\": [\n      {\n        pattern: /@([\"'`])(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1/,\n        greedy: true\n      },\n      /@[\\w.$]+/\n    ],\n    \"string\": {\n      pattern: /(^|[^@\\\\])(\"|')(?:\\\\[\\s\\S]|(?!\\2)[^\\\\]|\\2\\2)*\\2/,\n      greedy: true,\n      lookbehind: true\n    },\n    \"identifier\": {\n      pattern: /(^|[^@\\\\])`(?:\\\\[\\s\\S]|[^`\\\\]|``)*`/,\n      greedy: true,\n      lookbehind: true,\n      inside: {\n        \"punctuation\": /^`|`$/\n      }\n    },\n    \"function\": /\\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\\s*\\()/i,\n    // Should we highlight user defined functions too?\n    \"keyword\": /\\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\\b/i,\n    \"boolean\": /\\b(?:FALSE|NULL|TRUE)\\b/i,\n    \"number\": /\\b0x[\\da-f]+\\b|\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+\\b/i,\n    \"operator\": /[-+*\\/=%^~]|&&?|\\|\\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\\b/i,\n    \"punctuation\": /[;[\\]()`,.]/\n  };\n  return prismSql;\n}\nvar prismPython = {};\nvar hasRequiredPrismPython;\nfunction requirePrismPython() {\n  if (hasRequiredPrismPython)\n    return prismPython;\n  hasRequiredPrismPython = 1;\n  Prism.languages.python = {\n    \"comment\": {\n      pattern: /(^|[^\\\\])#.*/,\n      lookbehind: true,\n      greedy: true\n    },\n    \"string-interpolation\": {\n      pattern: /(?:f|fr|rf)(?:(\"\"\"|''')[\\s\\S]*?\\1|(\"|')(?:\\\\.|(?!\\2)[^\\\\\\r\\n])*\\2)/i,\n      greedy: true,\n      inside: {\n        \"interpolation\": {\n          // \"{\" <expression> <optional \"!s\", \"!r\", or \"!a\"> <optional \":\" format specifier> \"}\"\n          pattern: /((?:^|[^{])(?:\\{\\{)*)\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}])+\\})+\\})+\\}/,\n          lookbehind: true,\n          inside: {\n            \"format-spec\": {\n              pattern: /(:)[^:(){}]+(?=\\}$)/,\n              lookbehind: true\n            },\n            \"conversion-option\": {\n              pattern: /![sra](?=[:}]$)/,\n              alias: \"punctuation\"\n            },\n            rest: null\n          }\n        },\n        \"string\": /[\\s\\S]+/\n      }\n    },\n    \"triple-quoted-string\": {\n      pattern: /(?:[rub]|br|rb)?(\"\"\"|''')[\\s\\S]*?\\1/i,\n      greedy: true,\n      alias: \"string\"\n    },\n    \"string\": {\n      pattern: /(?:[rub]|br|rb)?(\"|')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/i,\n      greedy: true\n    },\n    \"function\": {\n      pattern: /((?:^|\\s)def[ \\t]+)[a-zA-Z_]\\w*(?=\\s*\\()/g,\n      lookbehind: true\n    },\n    \"class-name\": {\n      pattern: /(\\bclass\\s+)\\w+/i,\n      lookbehind: true\n    },\n    \"decorator\": {\n      pattern: /(^[\\t ]*)@\\w+(?:\\.\\w+)*/m,\n      lookbehind: true,\n      alias: [\"annotation\", \"punctuation\"],\n      inside: {\n        \"punctuation\": /\\./\n      }\n    },\n    \"keyword\": /\\b(?:_(?=\\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\\b/,\n    \"builtin\": /\\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\\b/,\n    \"boolean\": /\\b(?:False|None|True)\\b/,\n    \"number\": /\\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\\b|(?:\\b\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\B\\.\\d+(?:_\\d+)*)(?:e[+-]?\\d+(?:_\\d+)*)?j?(?!\\w)/i,\n    \"operator\": /[-+%=]=?|!=|:=|\\*\\*?=?|\\/\\/?=?|<[<=>]?|>[=>]?|[&|^~]/,\n    \"punctuation\": /[{}[\\];(),.:]/\n  };\n  Prism.languages.python[\"string-interpolation\"].inside[\"interpolation\"].inside.rest = Prism.languages.python;\n  Prism.languages.py = Prism.languages.python;\n  return prismPython;\n}\nvar prismRust = {};\nvar hasRequiredPrismRust;\nfunction requirePrismRust() {\n  if (hasRequiredPrismRust)\n    return prismRust;\n  hasRequiredPrismRust = 1;\n  (function(Prism2) {\n    var multilineComment = /\\/\\*(?:[^*/]|\\*(?!\\/)|\\/(?!\\*)|<self>)*\\*\\//.source;\n    for (var i = 0; i < 2; i++) {\n      multilineComment = multilineComment.replace(/<self>/g, function() {\n        return multilineComment;\n      });\n    }\n    multilineComment = multilineComment.replace(/<self>/g, function() {\n      return /[^\\s\\S]/.source;\n    });\n    Prism2.languages.rust = {\n      \"comment\": [\n        {\n          pattern: RegExp(/(^|[^\\\\])/.source + multilineComment),\n          lookbehind: true,\n          greedy: true\n        },\n        {\n          pattern: /(^|[^\\\\:])\\/\\/.*/,\n          lookbehind: true,\n          greedy: true\n        }\n      ],\n      \"string\": {\n        pattern: /b?\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|b?r(#*)\"(?:[^\"]|\"(?!\\1))*\"\\1/,\n        greedy: true\n      },\n      \"char\": {\n        pattern: /b?'(?:\\\\(?:x[0-7][\\da-fA-F]|u\\{(?:[\\da-fA-F]_*){1,6}\\}|.)|[^\\\\\\r\\n\\t'])'/,\n        greedy: true\n      },\n      \"attribute\": {\n        pattern: /#!?\\[(?:[^\\[\\]\"]|\"(?:\\\\[\\s\\S]|[^\\\\\"])*\")*\\]/,\n        greedy: true,\n        alias: \"attr-name\",\n        inside: {\n          \"string\": null\n          // see below\n        }\n      },\n      // Closure params should not be confused with bitwise OR |\n      \"closure-params\": {\n        pattern: /([=(,:]\\s*|\\bmove\\s*)\\|[^|]*\\||\\|[^|]*\\|(?=\\s*(?:\\{|->))/,\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          \"closure-punctuation\": {\n            pattern: /^\\||\\|$/,\n            alias: \"punctuation\"\n          },\n          rest: null\n          // see below\n        }\n      },\n      \"lifetime-annotation\": {\n        pattern: /'\\w+/,\n        alias: \"symbol\"\n      },\n      \"fragment-specifier\": {\n        pattern: /(\\$\\w+:)[a-z]+/,\n        lookbehind: true,\n        alias: \"punctuation\"\n      },\n      \"variable\": /\\$\\w+/,\n      \"function-definition\": {\n        pattern: /(\\bfn\\s+)\\w+/,\n        lookbehind: true,\n        alias: \"function\"\n      },\n      \"type-definition\": {\n        pattern: /(\\b(?:enum|struct|trait|type|union)\\s+)\\w+/,\n        lookbehind: true,\n        alias: \"class-name\"\n      },\n      \"module-declaration\": [\n        {\n          pattern: /(\\b(?:crate|mod)\\s+)[a-z][a-z_\\d]*/,\n          lookbehind: true,\n          alias: \"namespace\"\n        },\n        {\n          pattern: /(\\b(?:crate|self|super)\\s*)::\\s*[a-z][a-z_\\d]*\\b(?:\\s*::(?:\\s*[a-z][a-z_\\d]*\\s*::)*)?/,\n          lookbehind: true,\n          alias: \"namespace\",\n          inside: {\n            \"punctuation\": /::/\n          }\n        }\n      ],\n      \"keyword\": [\n        // https://github.com/rust-lang/reference/blob/master/src/keywords.md\n        /\\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\\b/,\n        // primitives and str\n        // https://doc.rust-lang.org/stable/rust-by-example/primitives.html\n        /\\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\\b/\n      ],\n      // functions can technically start with an upper-case letter, but this will introduce a lot of false positives\n      // and Rust's naming conventions recommend snake_case anyway.\n      // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html\n      \"function\": /\\b[a-z_]\\w*(?=\\s*(?:::\\s*<|\\())/,\n      \"macro\": {\n        pattern: /\\b\\w+!/,\n        alias: \"property\"\n      },\n      \"constant\": /\\b[A-Z_][A-Z_\\d]+\\b/,\n      \"class-name\": /\\b[A-Z]\\w*\\b/,\n      \"namespace\": {\n        pattern: /(?:\\b[a-z][a-z_\\d]*\\s*::\\s*)*\\b[a-z][a-z_\\d]*\\s*::(?!\\s*<)/,\n        inside: {\n          \"punctuation\": /::/\n        }\n      },\n      // Hex, oct, bin, dec numbers with visual separators and type suffix\n      \"number\": /\\b(?:0x[\\dA-Fa-f](?:_?[\\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\\d(?:_?\\d)*)?\\.)?\\d(?:_?\\d)*(?:[Ee][+-]?\\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\\b/,\n      \"boolean\": /\\b(?:false|true)\\b/,\n      \"punctuation\": /->|\\.\\.=|\\.{1,3}|::|[{}[\\];(),:]/,\n      \"operator\": /[-+*\\/%!^]=?|=[=>]?|&[&=]?|\\|[|=]?|<<?=?|>>?=?|[@?]/\n    };\n    Prism2.languages.rust[\"closure-params\"].inside.rest = Prism2.languages.rust;\n    Prism2.languages.rust[\"attribute\"].inside[\"string\"] = Prism2.languages.rust[\"string\"];\n  })(Prism);\n  return prismRust;\n}\nvar prismSwift = {};\nvar hasRequiredPrismSwift;\nfunction requirePrismSwift() {\n  if (hasRequiredPrismSwift)\n    return prismSwift;\n  hasRequiredPrismSwift = 1;\n  Prism.languages.swift = {\n    \"comment\": {\n      // Nested comments are supported up to 2 levels\n      pattern: /(^|[^\\\\:])(?:\\/\\/.*|\\/\\*(?:[^/*]|\\/(?!\\*)|\\*(?!\\/)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*\\*\\/)/,\n      lookbehind: true,\n      greedy: true\n    },\n    \"string-literal\": [\n      // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html\n      {\n        pattern: RegExp(\n          /(^|[^\"#])/.source + \"(?:\" + /\"(?:\\\\(?:\\((?:[^()]|\\([^()]*\\))*\\)|\\r\\n|[^(])|[^\\\\\\r\\n\"])*\"/.source + \"|\" + /\"\"\"(?:\\\\(?:\\((?:[^()]|\\([^()]*\\))*\\)|[^(])|[^\\\\\"]|\"(?!\"\"))*\"\"\"/.source + \")\" + /(?![\"#])/.source\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          \"interpolation\": {\n            pattern: /(\\\\\\()(?:[^()]|\\([^()]*\\))*(?=\\))/,\n            lookbehind: true,\n            inside: null\n            // see below\n          },\n          \"interpolation-punctuation\": {\n            pattern: /^\\)|\\\\\\($/,\n            alias: \"punctuation\"\n          },\n          \"punctuation\": /\\\\(?=[\\r\\n])/,\n          \"string\": /[\\s\\S]+/\n        }\n      },\n      {\n        pattern: RegExp(\n          /(^|[^\"#])(#+)/.source + \"(?:\" + /\"(?:\\\\(?:#+\\((?:[^()]|\\([^()]*\\))*\\)|\\r\\n|[^#])|[^\\\\\\r\\n])*?\"/.source + \"|\" + /\"\"\"(?:\\\\(?:#+\\((?:[^()]|\\([^()]*\\))*\\)|[^#])|[^\\\\])*?\"\"\"/.source + \")\\\\2\"\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          \"interpolation\": {\n            pattern: /(\\\\#+\\()(?:[^()]|\\([^()]*\\))*(?=\\))/,\n            lookbehind: true,\n            inside: null\n            // see below\n          },\n          \"interpolation-punctuation\": {\n            pattern: /^\\)|\\\\#+\\($/,\n            alias: \"punctuation\"\n          },\n          \"string\": /[\\s\\S]+/\n        }\n      }\n    ],\n    \"directive\": {\n      // directives with conditions\n      pattern: RegExp(\n        /#/.source + \"(?:\" + (/(?:elseif|if)\\b/.source + \"(?:[ \t]*\" + /(?:![ \\t]*)?(?:\\b\\w+\\b(?:[ \\t]*\\((?:[^()]|\\([^()]*\\))*\\))?|\\((?:[^()]|\\([^()]*\\))*\\))(?:[ \\t]*(?:&&|\\|\\|))?/.source + \")+\") + \"|\" + /(?:else|endif)\\b/.source + \")\"\n      ),\n      alias: \"property\",\n      inside: {\n        \"directive-name\": /^#\\w+/,\n        \"boolean\": /\\b(?:false|true)\\b/,\n        \"number\": /\\b\\d+(?:\\.\\d+)*\\b/,\n        \"operator\": /!|&&|\\|\\||[<>]=?/,\n        \"punctuation\": /[(),]/\n      }\n    },\n    \"literal\": {\n      pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\\b/,\n      alias: \"constant\"\n    },\n    \"other-directive\": {\n      pattern: /#\\w+\\b/,\n      alias: \"property\"\n    },\n    \"attribute\": {\n      pattern: /@\\w+/,\n      alias: \"atrule\"\n    },\n    \"function-definition\": {\n      pattern: /(\\bfunc\\s+)\\w+/,\n      lookbehind: true,\n      alias: \"function\"\n    },\n    \"label\": {\n      // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141\n      pattern: /\\b(break|continue)\\s+\\w+|\\b[a-zA-Z_]\\w*(?=\\s*:\\s*(?:for|repeat|while)\\b)/,\n      lookbehind: true,\n      alias: \"important\"\n    },\n    \"keyword\": /\\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\\b/,\n    \"boolean\": /\\b(?:false|true)\\b/,\n    \"nil\": {\n      pattern: /\\bnil\\b/,\n      alias: \"constant\"\n    },\n    \"short-argument\": /\\$\\d+\\b/,\n    \"omit\": {\n      pattern: /\\b_\\b/,\n      alias: \"keyword\"\n    },\n    \"number\": /\\b(?:[\\d_]+(?:\\.[\\de_]+)?|0x[a-f0-9_]+(?:\\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\\b/i,\n    // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.\n    \"class-name\": /\\b[A-Z](?:[A-Z_\\d]*[a-z]\\w*)?\\b/,\n    \"function\": /\\b[a-z_]\\w*(?=\\s*\\()/i,\n    \"constant\": /\\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\\b/,\n    // Operators are generic in Swift. Developers can even create new operators (e.g. +++).\n    // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481\n    // This regex only supports ASCII operators.\n    \"operator\": /[-+*/%=!<>&|^~?]+|\\.[.\\-+*/%=!<>&|^~?]+/,\n    \"punctuation\": /[{}[\\]();,.:\\\\]/\n  };\n  Prism.languages.swift[\"string-literal\"].forEach(function(rule) {\n    rule.inside[\"interpolation\"].inside = Prism.languages.swift;\n  });\n  return prismSwift;\n}\nvar prismTypescript = {};\nvar hasRequiredPrismTypescript;\nfunction requirePrismTypescript() {\n  if (hasRequiredPrismTypescript)\n    return prismTypescript;\n  hasRequiredPrismTypescript = 1;\n  (function(Prism2) {\n    Prism2.languages.typescript = Prism2.languages.extend(\"javascript\", {\n      \"class-name\": {\n        pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|type)\\s+)(?!keyof\\b)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?:\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,\n        lookbehind: true,\n        greedy: true,\n        inside: null\n        // see below\n      },\n      \"builtin\": /\\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\\b/\n    });\n    Prism2.languages.typescript.keyword.push(\n      /\\b(?:abstract|declare|is|keyof|readonly|require)\\b/,\n      // keywords that have to be followed by an identifier\n      /\\b(?:asserts|infer|interface|module|namespace|type)\\b(?=\\s*(?:[{_$a-zA-Z\\xA0-\\uFFFF]|$))/,\n      // This is for `import type *, {}`\n      /\\btype\\b(?=\\s*(?:[\\{*]|$))/\n    );\n    delete Prism2.languages.typescript[\"parameter\"];\n    delete Prism2.languages.typescript[\"literal-property\"];\n    var typeInside = Prism2.languages.extend(\"typescript\", {});\n    delete typeInside[\"class-name\"];\n    Prism2.languages.typescript[\"class-name\"].inside = typeInside;\n    Prism2.languages.insertBefore(\"typescript\", \"function\", {\n      \"decorator\": {\n        pattern: /@[$\\w\\xA0-\\uFFFF]+/,\n        inside: {\n          \"at\": {\n            pattern: /^@/,\n            alias: \"operator\"\n          },\n          \"function\": /^[\\s\\S]+/\n        }\n      },\n      \"generic-function\": {\n        // e.g. foo<T extends \"bar\" | \"baz\">( ...\n        pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\\s*\\()/,\n        greedy: true,\n        inside: {\n          \"function\": /^#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/,\n          \"generic\": {\n            pattern: /<[\\s\\S]+/,\n            // everything after the first <\n            alias: \"class-name\",\n            inside: typeInside\n          }\n        }\n      }\n    });\n    Prism2.languages.ts = Prism2.languages.typescript;\n  })(Prism);\n  return prismTypescript;\n}\nvar prismJava = {};\nvar hasRequiredPrismJava;\nfunction requirePrismJava() {\n  if (hasRequiredPrismJava)\n    return prismJava;\n  hasRequiredPrismJava = 1;\n  (function(Prism2) {\n    var keywords = /\\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\\s*[(){}[\\]<>=%~.:,;?+\\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\\b/;\n    var classNamePrefix = /(?:[a-z]\\w*\\s*\\.\\s*)*(?:[A-Z]\\w*\\s*\\.\\s*)*/.source;\n    var className = {\n      pattern: RegExp(/(^|[^\\w.])/.source + classNamePrefix + /[A-Z](?:[\\d_A-Z]*[a-z]\\w*)?\\b/.source),\n      lookbehind: true,\n      inside: {\n        \"namespace\": {\n          pattern: /^[a-z]\\w*(?:\\s*\\.\\s*[a-z]\\w*)*(?:\\s*\\.)?/,\n          inside: {\n            \"punctuation\": /\\./\n          }\n        },\n        \"punctuation\": /\\./\n      }\n    };\n    Prism2.languages.java = Prism2.languages.extend(\"clike\", {\n      \"string\": {\n        pattern: /(^|[^\\\\])\"(?:\\\\.|[^\"\\\\\\r\\n])*\"/,\n        lookbehind: true,\n        greedy: true\n      },\n      \"class-name\": [\n        className,\n        {\n          // variables, parameters, and constructor references\n          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)\n          pattern: RegExp(/(^|[^\\w.])/.source + classNamePrefix + /[A-Z]\\w*(?=\\s+\\w+\\s*[;,=()]|\\s*(?:\\[[\\s,]*\\]\\s*)?::\\s*new\\b)/.source),\n          lookbehind: true,\n          inside: className.inside\n        },\n        {\n          // class names based on keyword\n          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)\n          pattern: RegExp(/(\\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\\s+)/.source + classNamePrefix + /[A-Z]\\w*\\b/.source),\n          lookbehind: true,\n          inside: className.inside\n        }\n      ],\n      \"keyword\": keywords,\n      \"function\": [\n        Prism2.languages.clike.function,\n        {\n          pattern: /(::\\s*)[a-z_]\\w*/,\n          lookbehind: true\n        }\n      ],\n      \"number\": /\\b0b[01][01_]*L?\\b|\\b0x(?:\\.[\\da-f_p+-]+|[\\da-f_]+(?:\\.[\\da-f_p+-]+)?)\\b|(?:\\b\\d[\\d_]*(?:\\.[\\d_]*)?|\\B\\.\\d[\\d_]*)(?:e[+-]?\\d[\\d_]*)?[dfl]?/i,\n      \"operator\": {\n        pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\\+\\+|&&|\\|\\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,\n        lookbehind: true\n      },\n      \"constant\": /\\b[A-Z][A-Z_\\d]+\\b/\n    });\n    Prism2.languages.insertBefore(\"java\", \"string\", {\n      \"triple-quoted-string\": {\n        // http://openjdk.java.net/jeps/355#Description\n        pattern: /\"\"\"[ \\t]*[\\r\\n](?:(?:\"|\"\")?(?:\\\\.|[^\"\\\\]))*\"\"\"/,\n        greedy: true,\n        alias: \"string\"\n      },\n      \"char\": {\n        pattern: /'(?:\\\\.|[^'\\\\\\r\\n]){1,6}'/,\n        greedy: true\n      }\n    });\n    Prism2.languages.insertBefore(\"java\", \"class-name\", {\n      \"annotation\": {\n        pattern: /(^|[^.])@\\w+(?:\\s*\\.\\s*\\w+)*/,\n        lookbehind: true,\n        alias: \"punctuation\"\n      },\n      \"generics\": {\n        pattern: /<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&))*>)*>)*>)*>/,\n        inside: {\n          \"class-name\": className,\n          \"keyword\": keywords,\n          \"punctuation\": /[<>(),.:]/,\n          \"operator\": /[?&|]/\n        }\n      },\n      \"import\": [\n        {\n          pattern: RegExp(/(\\bimport\\s+)/.source + classNamePrefix + /(?:[A-Z]\\w*|\\*)(?=\\s*;)/.source),\n          lookbehind: true,\n          inside: {\n            \"namespace\": className.inside.namespace,\n            \"punctuation\": /\\./,\n            \"operator\": /\\*/,\n            \"class-name\": /\\w+/\n          }\n        },\n        {\n          pattern: RegExp(/(\\bimport\\s+static\\s+)/.source + classNamePrefix + /(?:\\w+|\\*)(?=\\s*;)/.source),\n          lookbehind: true,\n          alias: \"static\",\n          inside: {\n            \"namespace\": className.inside.namespace,\n            \"static\": /\\b\\w+$/,\n            \"punctuation\": /\\./,\n            \"operator\": /\\*/,\n            \"class-name\": /\\w+/\n          }\n        }\n      ],\n      \"namespace\": {\n        pattern: RegExp(\n          /(\\b(?:exports|import(?:\\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\\s+)(?!<keyword>)[a-z]\\w*(?:\\.[a-z]\\w*)*\\.?/.source.replace(/<keyword>/g, function() {\n            return keywords.source;\n          })\n        ),\n        lookbehind: true,\n        inside: {\n          \"punctuation\": /\\./\n        }\n      }\n    });\n  })(Prism);\n  return prismJava;\n}\nvar prismCpp = {};\nvar hasRequiredPrismCpp;\nfunction requirePrismCpp() {\n  if (hasRequiredPrismCpp)\n    return prismCpp;\n  hasRequiredPrismCpp = 1;\n  (function(Prism2) {\n    var keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n    var modName = /\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g, function() {\n      return keyword.source;\n    });\n    Prism2.languages.cpp = Prism2.languages.extend(\"c\", {\n      \"class-name\": [\n        {\n          pattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source.replace(/<keyword>/g, function() {\n            return keyword.source;\n          })),\n          lookbehind: true\n        },\n        // This is intended to capture the class name of method implementations like:\n        //   void foo::bar() const {}\n        // However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n        // it starts with an uppercase letter. This approximation should give decent results.\n        /\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/,\n        // This will capture the class name before destructors like:\n        //   Foo::~Foo() {}\n        /\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i,\n        // This also intends to capture the class name of method implementations but here the class has template\n        // parameters, so it can't be a namespace (until C++ adds generic namespaces).\n        /\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/\n      ],\n      \"keyword\": keyword,\n      \"number\": {\n        pattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n        greedy: true\n      },\n      \"operator\": />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n      \"boolean\": /\\b(?:false|true)\\b/\n    });\n    Prism2.languages.insertBefore(\"cpp\", \"string\", {\n      \"module\": {\n        // https://en.cppreference.com/w/cpp/language/modules\n        pattern: RegExp(\n          /(\\b(?:import|module)\\s+)/.source + \"(?:\" + // header-name\n          /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source + \"|\" + // module name or partition or both\n          /<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g, function() {\n            return modName;\n          }) + \")\"\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          \"string\": /^[<\"][\\s\\S]+/,\n          \"operator\": /:/,\n          \"punctuation\": /\\./\n        }\n      },\n      \"raw-string\": {\n        pattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n        alias: \"string\",\n        greedy: true\n      }\n    });\n    Prism2.languages.insertBefore(\"cpp\", \"keyword\", {\n      \"generic-function\": {\n        pattern: /\\b(?!operator\\b)[a-z_]\\w*\\s*<(?:[^<>]|<[^<>]*>)*>(?=\\s*\\()/i,\n        inside: {\n          \"function\": /^\\w+/,\n          \"generic\": {\n            pattern: /<[\\s\\S]+/,\n            alias: \"class-name\",\n            inside: Prism2.languages.cpp\n          }\n        }\n      }\n    });\n    Prism2.languages.insertBefore(\"cpp\", \"operator\", {\n      \"double-colon\": {\n        pattern: /::/,\n        alias: \"punctuation\"\n      }\n    });\n    Prism2.languages.insertBefore(\"cpp\", \"class-name\", {\n      // the base clause is an optional list of parent classes\n      // https://en.cppreference.com/w/cpp/language/class\n      \"base-clause\": {\n        pattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n        lookbehind: true,\n        greedy: true,\n        inside: Prism2.languages.extend(\"cpp\", {})\n      }\n    });\n    Prism2.languages.insertBefore(\"inside\", \"double-colon\", {\n      // All untokenized words that are not namespaces should be class names\n      \"class-name\": /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n    }, Prism2.languages.cpp[\"base-clause\"]);\n  })(Prism);\n  return prismCpp;\n}\nvar LexicalUtils_dev = {};\nvar LexicalSelection_dev = {};\nvar hasRequiredLexicalSelection_dev;\nfunction requireLexicalSelection_dev() {\n  if (hasRequiredLexicalSelection_dev)\n    return LexicalSelection_dev;\n  hasRequiredLexicalSelection_dev = 1;\n  var lexical = require$$1;\n  const CSS_TO_STYLES = /* @__PURE__ */ new Map();\n  function getDOMTextNode(element) {\n    let node = element;\n    while (node != null) {\n      if (node.nodeType === Node.TEXT_NODE) {\n        return node;\n      }\n      node = node.firstChild;\n    }\n    return null;\n  }\n  function getDOMIndexWithinParent(node) {\n    const parent = node.parentNode;\n    if (parent == null) {\n      throw new Error(\"Should never happen\");\n    }\n    return [parent, Array.from(parent.childNodes).indexOf(node)];\n  }\n  function createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n    const anchorKey = anchorNode.getKey();\n    const focusKey = focusNode.getKey();\n    const range = document.createRange();\n    let anchorDOM = editor.getElementByKey(anchorKey);\n    let focusDOM = editor.getElementByKey(focusKey);\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    if (lexical.$isTextNode(anchorNode)) {\n      anchorDOM = getDOMTextNode(anchorDOM);\n    }\n    if (lexical.$isTextNode(focusNode)) {\n      focusDOM = getDOMTextNode(focusDOM);\n    }\n    if (anchorNode === void 0 || focusNode === void 0 || anchorDOM === null || focusDOM === null) {\n      return null;\n    }\n    if (anchorDOM.nodeName === \"BR\") {\n      [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n    }\n    if (focusDOM.nodeName === \"BR\") {\n      [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n    }\n    const firstChild = anchorDOM.firstChild;\n    if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === \"BR\" && anchorOffset === 0 && focusOffset === 0) {\n      focusOffset = 1;\n    }\n    try {\n      range.setStart(anchorDOM, anchorOffset);\n      range.setEnd(focusDOM, focusOffset);\n    } catch (e) {\n      return null;\n    }\n    if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n      range.setStart(focusDOM, focusOffset);\n      range.setEnd(anchorDOM, anchorOffset);\n    }\n    return range;\n  }\n  function createRectsFromDOMRange(editor, range) {\n    const rootElement = editor.getRootElement();\n    if (rootElement === null) {\n      return [];\n    }\n    const rootRect = rootElement.getBoundingClientRect();\n    const computedStyle = getComputedStyle(rootElement);\n    const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n    const selectionRects = Array.from(range.getClientRects());\n    let selectionRectsLength = selectionRects.length;\n    let prevRect;\n    for (let i = 0; i < selectionRectsLength; i++) {\n      const selectionRect = selectionRects[i];\n      const isDuplicateRect = prevRect && prevRect.top === selectionRect.top && prevRect.left === selectionRect.left && prevRect.width === selectionRect.width && prevRect.height === selectionRect.height;\n      const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n      if (isDuplicateRect || selectionSpansElement) {\n        selectionRects.splice(i--, 1);\n        selectionRectsLength--;\n        continue;\n      }\n      prevRect = selectionRect;\n    }\n    return selectionRects;\n  }\n  function getStyleObjectFromRawCSS(css) {\n    const styleObject = {};\n    const styles = css.split(\";\");\n    for (const style of styles) {\n      if (style !== \"\") {\n        const [key, value2] = style.split(/:([^]+)/);\n        styleObject[key.trim()] = value2.trim();\n      }\n    }\n    return styleObject;\n  }\n  function getStyleObjectFromCSS(css) {\n    let value2 = CSS_TO_STYLES.get(css);\n    if (value2 === void 0) {\n      value2 = getStyleObjectFromRawCSS(css);\n      CSS_TO_STYLES.set(css, value2);\n    }\n    return value2;\n  }\n  function getCSSFromStyleObject(styles) {\n    let css = \"\";\n    for (const style in styles) {\n      if (style) {\n        css += `${style}: ${styles[style]};`;\n      }\n    }\n    return css;\n  }\n  function $updateElementNodeProperties(target, source) {\n    target.__first = source.__first;\n    target.__last = source.__last;\n    target.__size = source.__size;\n    target.__format = source.__format;\n    target.__indent = source.__indent;\n    target.__dir = source.__dir;\n    return target;\n  }\n  function $updateTextNodeProperties(target, source) {\n    target.__format = source.__format;\n    target.__style = source.__style;\n    target.__mode = source.__mode;\n    target.__detail = source.__detail;\n    return target;\n  }\n  function $cloneWithProperties(node) {\n    const latest = node.getLatest();\n    const constructor = latest.constructor;\n    const clone = constructor.clone(latest);\n    clone.__parent = latest.__parent;\n    clone.__next = latest.__next;\n    clone.__prev = latest.__prev;\n    if (lexical.$isElementNode(latest) && lexical.$isElementNode(clone)) {\n      return $updateElementNodeProperties(clone, latest);\n    }\n    if (lexical.$isTextNode(latest) && lexical.$isTextNode(clone)) {\n      return $updateTextNodeProperties(clone, latest);\n    }\n    return clone;\n  }\n  function $sliceSelectedTextNodeContent(selection, textNode) {\n    if (textNode.isSelected() && !textNode.isSegmented() && !textNode.isToken() && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchor = textNode.is(anchorNode);\n      const isFocus = textNode.is(focusNode);\n      if (isAnchor || isFocus) {\n        const isBackward = selection.isBackward();\n        const [anchorOffset, focusOffset] = selection.getCharacterOffsets();\n        const isSame = anchorNode.is(focusNode);\n        const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n        const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n        let startOffset = 0;\n        let endOffset = void 0;\n        if (isSame) {\n          startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n          endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        } else if (isFirst) {\n          const offset = isBackward ? focusOffset : anchorOffset;\n          startOffset = offset;\n          endOffset = void 0;\n        } else if (isLast) {\n          const offset = isBackward ? anchorOffset : focusOffset;\n          startOffset = 0;\n          endOffset = offset;\n        }\n        textNode.__text = textNode.__text.slice(startOffset, endOffset);\n        return textNode;\n      }\n    }\n    return textNode;\n  }\n  function $isAtNodeEnd(point) {\n    if (point.type === \"text\") {\n      return point.offset === point.getNode().getTextContentSize();\n    }\n    return point.offset === point.getNode().getChildrenSize();\n  }\n  function trimTextContentFromAnchor(editor, anchor, delCount) {\n    let currentNode = anchor.getNode();\n    let remaining = delCount;\n    if (lexical.$isElementNode(currentNode)) {\n      const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n      if (descendantNode !== null) {\n        currentNode = descendantNode;\n      }\n    }\n    while (remaining > 0 && currentNode !== null) {\n      let nextNode = currentNode.getPreviousSibling();\n      let additionalElementWhitespace = 0;\n      if (nextNode === null) {\n        let parent = currentNode.getParentOrThrow();\n        let parentSibling = parent.getPreviousSibling();\n        while (parentSibling === null) {\n          parent = parent.getParent();\n          if (parent === null) {\n            nextNode = null;\n            break;\n          }\n          parentSibling = parent.getPreviousSibling();\n        }\n        if (parent !== null) {\n          additionalElementWhitespace = parent.isInline() ? 0 : 2;\n          if (lexical.$isElementNode(parentSibling)) {\n            nextNode = parentSibling.getLastDescendant();\n          } else {\n            nextNode = parentSibling;\n          }\n        }\n      }\n      let text = currentNode.getTextContent();\n      if (text === \"\" && lexical.$isElementNode(currentNode) && !currentNode.isInline()) {\n        text = \"\\n\\n\";\n      }\n      const textNodeSize = text.length;\n      const offset = textNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (!lexical.$isTextNode(currentNode) || remaining >= textNodeSize) {\n        const parent = currentNode.getParent();\n        currentNode.remove();\n        if (parent != null && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n        remaining -= textNodeSize + additionalElementWhitespace;\n        currentNode = nextNode;\n      } else {\n        const key = currentNode.getKey();\n        const prevTextContent = editor.getEditorState().read(() => {\n          const prevNode = lexical.$getNodeByKey(key);\n          if (lexical.$isTextNode(prevNode) && prevNode.isSimpleText()) {\n            return prevNode.getTextContent();\n          }\n          return null;\n        });\n        if (prevTextContent !== null && prevTextContent !== text) {\n          const prevSelection = lexical.$getPreviousSelection();\n          let target = currentNode;\n          if (!currentNode.isSimpleText()) {\n            const textNode = lexical.$createTextNode(prevTextContent);\n            currentNode.replace(textNode);\n            target = textNode;\n          } else {\n            currentNode.setTextContent(prevTextContent);\n          }\n          if (lexical.$isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n            const prevOffset = prevSelection.anchor.offset;\n            target.select(prevOffset, prevOffset);\n          }\n        } else if (currentNode.isSimpleText()) {\n          const isSelected = anchor.key === key;\n          let anchorOffset = anchor.offset;\n          if (anchorOffset < remaining) {\n            anchorOffset = textNodeSize;\n          }\n          const splitStart = isSelected ? anchorOffset - remaining : 0;\n          const splitEnd = isSelected ? anchorOffset : offset;\n          if (isSelected && splitStart === 0) {\n            const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n            excessNode.remove();\n          } else {\n            const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n            excessNode.remove();\n          }\n        } else {\n          const textNode = lexical.$createTextNode(slicedText);\n          currentNode.replace(textNode);\n        }\n        remaining = 0;\n      }\n    }\n  }\n  function $addNodeStyle(node) {\n    const CSSText = node.getStyle();\n    const styles = getStyleObjectFromRawCSS(CSSText);\n    CSS_TO_STYLES.set(CSSText, styles);\n  }\n  function $patchStyle(target, patch) {\n    const prevStyles = getStyleObjectFromCSS(\"getStyle\" in target ? target.getStyle() : target.style);\n    const newStyles = Object.entries(patch).reduce((styles, [key, value2]) => {\n      if (value2 === null) {\n        delete styles[key];\n      } else {\n        styles[key] = value2;\n      }\n      return styles;\n    }, {\n      ...prevStyles\n    });\n    const newCSSText = getCSSFromStyleObject(newStyles);\n    target.setStyle(newCSSText);\n    CSS_TO_STYLES.set(newCSSText, newStyles);\n  }\n  function $patchStyleText(selection, patch) {\n    const selectedNodes = selection.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    if (selection.isCollapsed()) {\n      $patchStyle(selection, patch);\n      return;\n    }\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const focusOffset = focus.offset;\n    let anchorOffset = anchor.offset;\n    const isBefore = anchor.isBefore(focus);\n    let startOffset = isBefore ? anchorOffset : focusOffset;\n    let endOffset = isBefore ? focusOffset : anchorOffset;\n    const startType = isBefore ? anchor.type : focus.type;\n    const endType = isBefore ? focus.type : anchor.type;\n    const endKey = isBefore ? focus.key : anchor.key;\n    if (lexical.$isTextNode(firstNode) && startOffset === firstNodeTextLength) {\n      const nextSibling = firstNode.getNextSibling();\n      if (lexical.$isTextNode(nextSibling)) {\n        anchorOffset = 0;\n        startOffset = 0;\n        firstNode = nextSibling;\n      }\n    }\n    if (firstNode.is(lastNode)) {\n      if (lexical.$isTextNode(firstNode)) {\n        startOffset = startType === \"element\" ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = endType === \"element\" ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        if (startOffset === endOffset) {\n          return;\n        }\n        if (startOffset === 0 && endOffset === firstNodeTextLength) {\n          $patchStyle(firstNode, patch);\n          firstNode.select(startOffset, endOffset);\n        } else {\n          const splitNodes = firstNode.splitText(startOffset, endOffset);\n          const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n          $patchStyle(replacement, patch);\n          replacement.select(0, endOffset - startOffset);\n        }\n      }\n    } else {\n      if (lexical.$isTextNode(firstNode) && startOffset < firstNode.getTextContentSize()) {\n        if (startOffset !== 0) {\n          firstNode = firstNode.splitText(startOffset)[1];\n          startOffset = 0;\n        }\n        $patchStyle(firstNode, patch);\n      }\n      if (lexical.$isTextNode(lastNode)) {\n        const lastNodeText = lastNode.getTextContent();\n        const lastNodeTextLength = lastNodeText.length;\n        if (lastNode.__key !== endKey && endOffset !== 0) {\n          endOffset = lastNodeTextLength;\n        }\n        if (endOffset !== lastNodeTextLength) {\n          [lastNode] = lastNode.splitText(endOffset);\n        }\n        if (endOffset !== 0) {\n          $patchStyle(lastNode, patch);\n        }\n      }\n      for (let i = 1; i < lastIndex; i++) {\n        const selectedNode = selectedNodes[i];\n        const selectedNodeKey = selectedNode.getKey();\n        if (lexical.$isTextNode(selectedNode) && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n          $patchStyle(selectedNode, patch);\n        }\n      }\n    }\n  }\n  function $setBlocksType_experimental(selection, createElement2) {\n    if (selection.anchor.key === \"root\") {\n      const element = createElement2();\n      const root = lexical.$getRoot();\n      const firstChild = root.getFirstChild();\n      if (firstChild)\n        firstChild.replace(element, true);\n      else\n        root.append(element);\n      return;\n    }\n    const nodes = selection.getNodes();\n    if (selection.anchor.type === \"text\") {\n      let firstBlock = selection.anchor.getNode().getParent();\n      firstBlock = firstBlock.isInline() ? firstBlock.getParent() : firstBlock;\n      if (nodes.indexOf(firstBlock) === -1)\n        nodes.push(firstBlock);\n    }\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (!isBlock(node))\n        continue;\n      const targetElement = createElement2();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      node.replace(targetElement, true);\n    }\n  }\n  function isBlock(node) {\n    return lexical.$isElementNode(node) && !lexical.$isRootOrShadowRoot(node) && !node.isInline();\n  }\n  function isPointAttached(point) {\n    return point.getNode().isAttached();\n  }\n  function $removeParentEmptyElements(startingNode) {\n    let node = startingNode;\n    while (node !== null && !lexical.$isRootOrShadowRoot(node)) {\n      const latest = node.getLatest();\n      const parentNode = node.getParent();\n      if (latest.getChildrenSize() === 0) {\n        node.remove(true);\n      }\n      node = parentNode;\n    }\n  }\n  function $wrapNodes(selection, createElement2, wrappingElement = null) {\n    const nodes = selection.getNodes();\n    const nodesLength = nodes.length;\n    const anchor = selection.anchor;\n    if (nodesLength === 0 || nodesLength === 1 && anchor.type === \"element\" && anchor.getNode().getChildrenSize() === 0) {\n      const target = anchor.type === \"text\" ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n      const children = target.getChildren();\n      let element = createElement2();\n      element.setFormat(target.getFormatType());\n      element.setIndent(target.getIndent());\n      children.forEach((child) => element.append(child));\n      if (wrappingElement) {\n        element = wrappingElement.append(element);\n      }\n      target.replace(element);\n      return;\n    }\n    let topLevelNode = null;\n    let descendants = [];\n    for (let i = 0; i < nodesLength; i++) {\n      const node = nodes[i];\n      if (lexical.$isRootOrShadowRoot(node)) {\n        $wrapNodesImpl(selection, descendants, descendants.length, createElement2, wrappingElement);\n        descendants = [];\n        topLevelNode = node;\n      } else if (topLevelNode === null || topLevelNode !== null && lexical.$hasAncestor(node, topLevelNode)) {\n        descendants.push(node);\n      } else {\n        $wrapNodesImpl(selection, descendants, descendants.length, createElement2, wrappingElement);\n        descendants = [node];\n      }\n    }\n    $wrapNodesImpl(selection, descendants, descendants.length, createElement2, wrappingElement);\n  }\n  function $wrapNodesImpl(selection, nodes, nodesLength, createElement2, wrappingElement = null) {\n    if (nodes.length === 0) {\n      return;\n    }\n    const firstNode = nodes[0];\n    const elementMapping = /* @__PURE__ */ new Map();\n    const elements = [];\n    let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n    if (target.isInline()) {\n      target = target.getParentOrThrow();\n    }\n    let targetIsPrevSibling = false;\n    while (target !== null) {\n      const prevSibling = target.getPreviousSibling();\n      if (prevSibling !== null) {\n        target = prevSibling;\n        targetIsPrevSibling = true;\n        break;\n      }\n      target = target.getParentOrThrow();\n      if (lexical.$isRootOrShadowRoot(target)) {\n        break;\n      }\n    }\n    const emptyElements = /* @__PURE__ */ new Set();\n    for (let i = 0; i < nodesLength; i++) {\n      const node = nodes[i];\n      if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {\n        emptyElements.add(node.getKey());\n      }\n    }\n    const movedNodes = /* @__PURE__ */ new Set();\n    for (let i = 0; i < nodesLength; i++) {\n      const node = nodes[i];\n      let parent = node.getParent();\n      if (parent !== null && parent.isInline()) {\n        parent = parent.getParent();\n      }\n      if (parent !== null && lexical.$isLeafNode(node) && !movedNodes.has(node.getKey())) {\n        const parentKey = parent.getKey();\n        if (elementMapping.get(parentKey) === void 0) {\n          const targetElement = createElement2();\n          targetElement.setFormat(parent.getFormatType());\n          targetElement.setIndent(parent.getIndent());\n          elements.push(targetElement);\n          elementMapping.set(parentKey, targetElement);\n          parent.getChildren().forEach((child) => {\n            targetElement.append(child);\n            movedNodes.add(child.getKey());\n            if (lexical.$isElementNode(child)) {\n              child.getChildrenKeys().forEach((key) => movedNodes.add(key));\n            }\n          });\n          $removeParentEmptyElements(parent);\n        }\n      } else if (emptyElements.has(node.getKey())) {\n        const targetElement = createElement2();\n        targetElement.setFormat(node.getFormatType());\n        targetElement.setIndent(node.getIndent());\n        elements.push(targetElement);\n        node.remove(true);\n      }\n    }\n    if (wrappingElement !== null) {\n      for (let i = 0; i < elements.length; i++) {\n        const element = elements[i];\n        wrappingElement.append(element);\n      }\n    }\n    let lastElement = null;\n    if (lexical.$isRootOrShadowRoot(target)) {\n      if (targetIsPrevSibling) {\n        if (wrappingElement !== null) {\n          target.insertAfter(wrappingElement);\n        } else {\n          for (let i = elements.length - 1; i >= 0; i--) {\n            const element = elements[i];\n            target.insertAfter(element);\n          }\n        }\n      } else {\n        const firstChild = target.getFirstChild();\n        if (lexical.$isElementNode(firstChild)) {\n          target = firstChild;\n        }\n        if (firstChild === null) {\n          if (wrappingElement) {\n            target.append(wrappingElement);\n          } else {\n            for (let i = 0; i < elements.length; i++) {\n              const element = elements[i];\n              target.append(element);\n              lastElement = element;\n            }\n          }\n        } else {\n          if (wrappingElement !== null) {\n            firstChild.insertBefore(wrappingElement);\n          } else {\n            for (let i = 0; i < elements.length; i++) {\n              const element = elements[i];\n              firstChild.insertBefore(element);\n              lastElement = element;\n            }\n          }\n        }\n      }\n    } else {\n      if (wrappingElement) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n          lastElement = element;\n        }\n      }\n    }\n    const prevSelection = lexical.$getPreviousSelection();\n    if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n      lexical.$setSelection(prevSelection.clone());\n    } else if (lastElement !== null) {\n      lastElement.selectEnd();\n    } else {\n      selection.dirty = true;\n    }\n  }\n  function $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n    const possibleNode = lexical.$getAdjacentNode(selection.focus, isBackward);\n    return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\n  }\n  function $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n    selection.modify(isHoldingShift ? \"extend\" : \"move\", isBackward, granularity);\n  }\n  function $isParentElementRTL(selection) {\n    const anchorNode = selection.anchor.getNode();\n    const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n    return parent.getDirection() === \"rtl\";\n  }\n  function $moveCharacter(selection, isHoldingShift, isBackward) {\n    const isRTL = $isParentElementRTL(selection);\n    $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, \"character\");\n  }\n  function $selectAll(selection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const topParent = anchorNode.getTopLevelElementOrThrow();\n    const root = topParent.getParentOrThrow();\n    let firstNode = root.getFirstDescendant();\n    let lastNode = root.getLastDescendant();\n    let firstType = \"element\";\n    let lastType = \"element\";\n    let lastOffset = 0;\n    if (lexical.$isTextNode(firstNode)) {\n      firstType = \"text\";\n    } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {\n      firstNode = firstNode.getParentOrThrow();\n    }\n    if (lexical.$isTextNode(lastNode)) {\n      lastType = \"text\";\n      lastOffset = lastNode.getTextContentSize();\n    } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {\n      lastNode = lastNode.getParentOrThrow();\n    }\n    if (firstNode && lastNode) {\n      anchor.set(firstNode.getKey(), 0, firstType);\n      focus.set(lastNode.getKey(), lastOffset, lastType);\n    }\n  }\n  function $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n    const css = node.getStyle();\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null) {\n      return styleObject[styleProperty] || defaultValue;\n    }\n    return defaultValue;\n  }\n  function $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = \"\") {\n    let styleValue = null;\n    const nodes = selection.getNodes();\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const isBackward = selection.isBackward();\n    const endOffset = isBackward ? focus.offset : anchor.offset;\n    const endNode = isBackward ? focus.getNode() : anchor.getNode();\n    if (selection.style !== \"\") {\n      const css = selection.style;\n      const styleObject = getStyleObjectFromCSS(css);\n      if (styleObject !== null && styleProperty in styleObject) {\n        return styleObject[styleProperty];\n      }\n    }\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n        continue;\n      }\n      if (lexical.$isTextNode(node)) {\n        const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n        if (styleValue === null) {\n          styleValue = nodeStyleValue;\n        } else if (styleValue !== nodeStyleValue) {\n          styleValue = \"\";\n          break;\n        }\n      }\n    }\n    return styleValue === null ? defaultValue : styleValue;\n  }\n  LexicalSelection_dev.$addNodeStyle = $addNodeStyle;\n  LexicalSelection_dev.$cloneWithProperties = $cloneWithProperties;\n  LexicalSelection_dev.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;\n  LexicalSelection_dev.$isAtNodeEnd = $isAtNodeEnd;\n  LexicalSelection_dev.$isParentElementRTL = $isParentElementRTL;\n  LexicalSelection_dev.$moveCaretSelection = $moveCaretSelection;\n  LexicalSelection_dev.$moveCharacter = $moveCharacter;\n  LexicalSelection_dev.$patchStyleText = $patchStyleText;\n  LexicalSelection_dev.$selectAll = $selectAll;\n  LexicalSelection_dev.$setBlocksType_experimental = $setBlocksType_experimental;\n  LexicalSelection_dev.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;\n  LexicalSelection_dev.$sliceSelectedTextNodeContent = $sliceSelectedTextNodeContent;\n  LexicalSelection_dev.$wrapNodes = $wrapNodes;\n  LexicalSelection_dev.createDOMRange = createDOMRange;\n  LexicalSelection_dev.createRectsFromDOMRange = createRectsFromDOMRange;\n  LexicalSelection_dev.getStyleObjectFromCSS = getStyleObjectFromCSS;\n  LexicalSelection_dev.trimTextContentFromAnchor = trimTextContentFromAnchor;\n  return LexicalSelection_dev;\n}\nvar LexicalSelection_prod = {};\nvar hasRequiredLexicalSelection_prod;\nfunction requireLexicalSelection_prod() {\n  if (hasRequiredLexicalSelection_prod)\n    return LexicalSelection_prod;\n  hasRequiredLexicalSelection_prod = 1;\n  var l = require$$1;\n  let u = /* @__PURE__ */ new Map();\n  function v(a) {\n    for (; null != a; ) {\n      if (a.nodeType === Node.TEXT_NODE)\n        return a;\n      a = a.firstChild;\n    }\n    return null;\n  }\n  function w(a) {\n    let b = a.parentNode;\n    if (null == b)\n      throw Error(\"Should never happen\");\n    return [b, Array.from(b.childNodes).indexOf(a)];\n  }\n  function y(a) {\n    let b = {};\n    a = a.split(\";\");\n    for (let c of a)\n      if (\"\" !== c) {\n        let [f, d] = c.split(/:([^]+)/);\n        b[f.trim()] = d.trim();\n      }\n    return b;\n  }\n  function z(a) {\n    let b = u.get(a);\n    void 0 === b && (b = y(a), u.set(a, b));\n    return b;\n  }\n  function A(a) {\n    let b = \"\";\n    for (let c in a)\n      c && (b += `${c}: ${a[c]};`);\n    return b;\n  }\n  function B(a, b) {\n    var c = z(\"getStyle\" in a ? a.getStyle() : a.style);\n    b = Object.entries(b).reduce((f, [d, e]) => {\n      null === e ? delete f[d] : f[d] = e;\n      return f;\n    }, { ...c });\n    c = A(b);\n    a.setStyle(c);\n    u.set(c, b);\n  }\n  function C(a) {\n    for (; null !== a && !l.$isRootOrShadowRoot(a); ) {\n      let b = a.getLatest(), c = a.getParent();\n      0 === b.getChildrenSize() && a.remove(true);\n      a = c;\n    }\n  }\n  function D(a, b, c, f, d = null) {\n    if (0 !== b.length) {\n      var e = b[0], h = /* @__PURE__ */ new Map(), g = [];\n      e = l.$isElementNode(e) ? e : e.getParentOrThrow();\n      e.isInline() && (e = e.getParentOrThrow());\n      for (var k = false; null !== e; ) {\n        var m = e.getPreviousSibling();\n        if (null !== m) {\n          e = m;\n          k = true;\n          break;\n        }\n        e = e.getParentOrThrow();\n        if (l.$isRootOrShadowRoot(e))\n          break;\n      }\n      m = /* @__PURE__ */ new Set();\n      for (var q = 0; q < c; q++) {\n        var n = b[q];\n        l.$isElementNode(n) && 0 === n.getChildrenSize() && m.add(n.getKey());\n      }\n      var p = /* @__PURE__ */ new Set();\n      for (q = 0; q < c; q++) {\n        n = b[q];\n        var r = n.getParent();\n        null !== r && r.isInline() && (r = r.getParent());\n        if (null !== r && l.$isLeafNode(n) && !p.has(n.getKey())) {\n          if (n = r.getKey(), void 0 === h.get(n)) {\n            let t = f();\n            t.setFormat(r.getFormatType());\n            t.setIndent(r.getIndent());\n            g.push(t);\n            h.set(n, t);\n            r.getChildren().forEach((x) => {\n              t.append(x);\n              p.add(x.getKey());\n              l.$isElementNode(x) && x.getChildrenKeys().forEach((G) => p.add(G));\n            });\n            C(r);\n          }\n        } else\n          m.has(n.getKey()) && (r = f(), r.setFormat(n.getFormatType()), r.setIndent(n.getIndent()), g.push(r), n.remove(true));\n      }\n      if (null !== d)\n        for (b = 0; b < g.length; b++)\n          d.append(g[b]);\n      b = null;\n      if (l.$isRootOrShadowRoot(e))\n        if (k)\n          if (null !== d)\n            e.insertAfter(d);\n          else\n            for (d = g.length - 1; 0 <= d; d--)\n              e.insertAfter(g[d]);\n        else if (k = e.getFirstChild(), l.$isElementNode(k) && (e = k), null === k)\n          if (d)\n            e.append(d);\n          else\n            for (d = 0; d < g.length; d++)\n              k = g[d], e.append(k), b = k;\n        else if (null !== d)\n          k.insertBefore(d);\n        else\n          for (e = 0; e < g.length; e++)\n            d = g[e], k.insertBefore(d), b = d;\n      else if (d)\n        e.insertAfter(d);\n      else\n        for (d = g.length - 1; 0 <= d; d--)\n          k = g[d], e.insertAfter(k), b = k;\n      g = l.$getPreviousSelection();\n      l.$isRangeSelection(g) && g.anchor.getNode().isAttached() && g.focus.getNode().isAttached() ? l.$setSelection(g.clone()) : null !== b ? b.selectEnd() : a.dirty = true;\n    }\n  }\n  function E(a, b, c, f) {\n    a.modify(b ? \"extend\" : \"move\", c, f);\n  }\n  function F(a) {\n    a = a.anchor.getNode();\n    return \"rtl\" === (l.$isRootNode(a) ? a : a.getParentOrThrow()).getDirection();\n  }\n  LexicalSelection_prod.$addNodeStyle = function(a) {\n    a = a.getStyle();\n    let b = y(a);\n    u.set(a, b);\n  };\n  LexicalSelection_prod.$cloneWithProperties = function(a) {\n    a = a.getLatest();\n    let b = a.constructor.clone(a);\n    b.__parent = a.__parent;\n    b.__next = a.__next;\n    b.__prev = a.__prev;\n    if (l.$isElementNode(a) && l.$isElementNode(b))\n      return b.__first = a.__first, b.__last = a.__last, b.__size = a.__size, b.__format = a.__format, b.__indent = a.__indent, b.__dir = a.__dir, b;\n    l.$isTextNode(a) && l.$isTextNode(b) && (b.__format = a.__format, b.__style = a.__style, b.__mode = a.__mode, b.__detail = a.__detail);\n    return b;\n  };\n  LexicalSelection_prod.$getSelectionStyleValueForProperty = function(a, b, c = \"\") {\n    let f = null, d = a.getNodes();\n    var e = a.anchor, h = a.focus, g = a.isBackward();\n    let k = g ? h.offset : e.offset;\n    e = g ? h.getNode() : e.getNode();\n    if (\"\" !== a.style && (a = z(a.style), null !== a && b in a))\n      return a[b];\n    for (a = 0; a < d.length; a++) {\n      var m = d[a];\n      if ((0 === a || 0 !== k || !m.is(e)) && l.$isTextNode(m)) {\n        if (h = b, g = c, m = m.getStyle(), m = z(m), h = null !== m ? m[h] || g : g, null === f)\n          f = h;\n        else if (f !== h) {\n          f = \"\";\n          break;\n        }\n      }\n    }\n    return null === f ? c : f;\n  };\n  LexicalSelection_prod.$isAtNodeEnd = function(a) {\n    return \"text\" === a.type ? a.offset === a.getNode().getTextContentSize() : a.offset === a.getNode().getChildrenSize();\n  };\n  LexicalSelection_prod.$isParentElementRTL = F;\n  LexicalSelection_prod.$moveCaretSelection = E;\n  LexicalSelection_prod.$moveCharacter = function(a, b, c) {\n    let f = F(a);\n    E(a, b, c ? !f : f, \"character\");\n  };\n  LexicalSelection_prod.$patchStyleText = function(a, b) {\n    var c = a.getNodes();\n    let f = c.length - 1, d = c[0], e = c[f];\n    if (a.isCollapsed())\n      B(a, b);\n    else {\n      var h = a.anchor, g = a.focus, k = d.getTextContent().length, m = g.offset, q = h.offset, n = h.isBefore(g), p = n ? q : m;\n      a = n ? m : q;\n      var r = n ? h.type : g.type, t = n ? g.type : h.type;\n      h = n ? g.key : h.key;\n      l.$isTextNode(d) && p === k && (g = d.getNextSibling(), l.$isTextNode(g) && (p = q = 0, d = g));\n      if (d.is(e))\n        l.$isTextNode(d) && (p = \"element\" === r ? 0 : q > m ? m : q, a = \"element\" === t ? k : q > m ? q : m, p !== a && (0 === p && a === k ? (B(d, b), d.select(p, a)) : (c = d.splitText(\n          p,\n          a\n        ), c = 0 === p ? c[0] : c[1], B(c, b), c.select(0, a - p))));\n      else\n        for (l.$isTextNode(d) && p < d.getTextContentSize() && (0 !== p && (d = d.splitText(p)[1]), B(d, b)), l.$isTextNode(e) && (p = e.getTextContent().length, e.__key !== h && 0 !== a && (a = p), a !== p && ([e] = e.splitText(a)), 0 !== a && B(e, b)), a = 1; a < f; a++)\n          p = c[a], k = p.getKey(), l.$isTextNode(p) && k !== d.getKey() && k !== e.getKey() && !p.isToken() && B(p, b);\n    }\n  };\n  LexicalSelection_prod.$selectAll = function(a) {\n    let b = a.anchor;\n    a = a.focus;\n    var c = b.getNode().getTopLevelElementOrThrow().getParentOrThrow();\n    let f = c.getFirstDescendant();\n    c = c.getLastDescendant();\n    let d = \"element\", e = \"element\", h = 0;\n    l.$isTextNode(f) ? d = \"text\" : l.$isElementNode(f) || null === f || (f = f.getParentOrThrow());\n    l.$isTextNode(c) ? (e = \"text\", h = c.getTextContentSize()) : l.$isElementNode(c) || null === c || (c = c.getParentOrThrow());\n    f && c && (b.set(f.getKey(), 0, d), a.set(c.getKey(), h, e));\n  };\n  LexicalSelection_prod.$setBlocksType_experimental = function(a, b) {\n    if (\"root\" === a.anchor.key) {\n      b = b();\n      var c = l.$getRoot();\n      (a = c.getFirstChild()) ? a.replace(b, true) : c.append(b);\n    } else\n      for (c = a.getNodes(), \"text\" === a.anchor.type && (a = a.anchor.getNode().getParent(), a = a.isInline() ? a.getParent() : a, -1 === c.indexOf(a) && c.push(a)), a = 0; a < c.length; a++) {\n        let d = c[a];\n        var f = d;\n        !l.$isElementNode(f) || l.$isRootOrShadowRoot(f) || f.isInline() || (f = b(), f.setFormat(d.getFormatType()), f.setIndent(d.getIndent()), d.replace(f, true));\n      }\n  };\n  LexicalSelection_prod.$shouldOverrideDefaultCharacterSelection = function(a, b) {\n    a = l.$getAdjacentNode(a.focus, b);\n    return l.$isDecoratorNode(a) && !a.isIsolated() || l.$isElementNode(a) && !a.isInline() && !a.canBeEmpty();\n  };\n  LexicalSelection_prod.$sliceSelectedTextNodeContent = function(a, b) {\n    if (b.isSelected() && !b.isSegmented() && !b.isToken() && (l.$isRangeSelection(a) || l.DEPRECATED_$isGridSelection(a))) {\n      var c = a.anchor.getNode(), f = a.focus.getNode(), d = b.is(c), e = b.is(f);\n      if (d || e) {\n        d = a.isBackward();\n        let [h, g] = a.getCharacterOffsets();\n        a = c.is(f);\n        e = b.is(d ? f : c);\n        f = b.is(d ? c : f);\n        c = 0;\n        let k = void 0;\n        a ? (c = h > g ? g : h, k = h > g ? h : g) : e ? (c = d ? g : h, k = void 0) : f && (d = d ? h : g, c = 0, k = d);\n        b.__text = b.__text.slice(c, k);\n      }\n    }\n    return b;\n  };\n  LexicalSelection_prod.$wrapNodes = function(a, b, c = null) {\n    var f = a.getNodes();\n    let d = f.length;\n    var e = a.anchor;\n    if (0 === d || 1 === d && \"element\" === e.type && 0 === e.getNode().getChildrenSize()) {\n      a = \"text\" === e.type ? e.getNode().getParentOrThrow() : e.getNode();\n      f = a.getChildren();\n      let g = b();\n      g.setFormat(a.getFormatType());\n      g.setIndent(a.getIndent());\n      f.forEach((k) => g.append(k));\n      c && (g = c.append(g));\n      a.replace(g);\n    } else {\n      e = null;\n      var h = [];\n      for (let g = 0; g < d; g++) {\n        let k = f[g];\n        l.$isRootOrShadowRoot(k) ? (D(a, h, h.length, b, c), h = [], e = k) : null === e || null !== e && l.$hasAncestor(\n          k,\n          e\n        ) ? h.push(k) : (D(a, h, h.length, b, c), h = [k]);\n      }\n      D(a, h, h.length, b, c);\n    }\n  };\n  LexicalSelection_prod.createDOMRange = function(a, b, c, f, d) {\n    let e = b.getKey(), h = f.getKey(), g = document.createRange(), k = a.getElementByKey(e);\n    a = a.getElementByKey(h);\n    l.$isTextNode(b) && (k = v(k));\n    l.$isTextNode(f) && (a = v(a));\n    if (void 0 === b || void 0 === f || null === k || null === a)\n      return null;\n    \"BR\" === k.nodeName && ([k, c] = w(k));\n    \"BR\" === a.nodeName && ([a, d] = w(a));\n    b = k.firstChild;\n    k === a && null != b && \"BR\" === b.nodeName && 0 === c && 0 === d && (d = 1);\n    try {\n      g.setStart(k, c), g.setEnd(a, d);\n    } catch (m) {\n      return null;\n    }\n    !g.collapsed || c === d && e === h || (g.setStart(a, d), g.setEnd(\n      k,\n      c\n    ));\n    return g;\n  };\n  LexicalSelection_prod.createRectsFromDOMRange = function(a, b) {\n    var c = a.getRootElement();\n    if (null === c)\n      return [];\n    a = c.getBoundingClientRect();\n    c = getComputedStyle(c);\n    c = parseFloat(c.paddingLeft) + parseFloat(c.paddingRight);\n    b = Array.from(b.getClientRects());\n    let f = b.length, d;\n    for (let e = 0; e < f; e++) {\n      let h = b[e], g = h.width + c === a.width;\n      d && d.top === h.top && d.left === h.left && d.width === h.width && d.height === h.height || g ? (b.splice(e--, 1), f--) : d = h;\n    }\n    return b;\n  };\n  LexicalSelection_prod.getStyleObjectFromCSS = z;\n  LexicalSelection_prod.trimTextContentFromAnchor = function(a, b, c) {\n    let f = b.getNode();\n    if (l.$isElementNode(f)) {\n      var d = f.getDescendantByIndex(b.offset);\n      null !== d && (f = d);\n    }\n    for (; 0 < c && null !== f; ) {\n      var e = f.getPreviousSibling(), h = 0;\n      if (null === e) {\n        d = f.getParentOrThrow();\n        for (var g = d.getPreviousSibling(); null === g; ) {\n          d = d.getParent();\n          if (null === d) {\n            e = null;\n            break;\n          }\n          g = d.getPreviousSibling();\n        }\n        null !== d && (h = d.isInline() ? 0 : 2, e = l.$isElementNode(g) ? g.getLastDescendant() : g);\n      }\n      let k = f.getTextContent();\n      \"\" === k && l.$isElementNode(f) && !f.isInline() && (k = \"\\n\\n\");\n      d = k.length;\n      g = d - c;\n      let m = k.slice(0, g);\n      if (!l.$isTextNode(f) || c >= d)\n        g = f.getParent(), f.remove(), null != g && 0 === g.getChildrenSize() && g.remove(), c -= d + h, f = e;\n      else {\n        let q = f.getKey();\n        e = a.getEditorState().read(() => {\n          const n = l.$getNodeByKey(q);\n          return l.$isTextNode(n) && n.isSimpleText() ? n.getTextContent() : null;\n        });\n        null !== e && e !== k ? (c = l.$getPreviousSelection(), d = f, f.isSimpleText() ? f.setTextContent(e) : (d = l.$createTextNode(e), f.replace(d)), l.$isRangeSelection(c) && c.isCollapsed() && (c = c.anchor.offset, d.select(c, c))) : f.isSimpleText() ? (e = b.key === q, h = b.offset, h < c && (h = d), c = e ? h - c : 0, d = e ? h : g, e && 0 === c ? ([c] = f.splitText(c, d), c.remove()) : ([, c] = f.splitText(c, d), c.remove())) : (c = l.$createTextNode(m), f.replace(c));\n        c = 0;\n      }\n    }\n  };\n  return LexicalSelection_prod;\n}\nvar LexicalSelection_1;\nvar hasRequiredLexicalSelection;\nfunction requireLexicalSelection() {\n  if (hasRequiredLexicalSelection)\n    return LexicalSelection_1;\n  hasRequiredLexicalSelection = 1;\n  const LexicalSelection = process.env.NODE_ENV === \"development\" ? requireLexicalSelection_dev() : requireLexicalSelection_prod();\n  LexicalSelection_1 = LexicalSelection;\n  return LexicalSelection_1;\n}\nvar hasRequiredLexicalUtils_dev;\nfunction requireLexicalUtils_dev() {\n  if (hasRequiredLexicalUtils_dev)\n    return LexicalUtils_dev;\n  hasRequiredLexicalUtils_dev = 1;\n  var selection = requireLexicalSelection();\n  var lexical = require$$1;\n  function addClassNamesToElement(element, ...classNames) {\n    classNames.forEach((className) => {\n      if (typeof className === \"string\") {\n        const classesToAdd = className.split(\" \").filter((n) => n !== \"\");\n        element.classList.add(...classesToAdd);\n      }\n    });\n  }\n  function removeClassNamesFromElement(element, ...classNames) {\n    classNames.forEach((className) => {\n      if (typeof className === \"string\") {\n        element.classList.remove(...className.split(\" \"));\n      }\n    });\n  }\n  function isMimeType(file, acceptableMimeTypes) {\n    for (const acceptableType of acceptableMimeTypes) {\n      if (file.type.startsWith(acceptableType)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function mediaFileReader(files, acceptableMimeTypes) {\n    const filesIterator = files[Symbol.iterator]();\n    return new Promise((resolve, reject) => {\n      const processed = [];\n      const handleNextFile = () => {\n        const {\n          done,\n          value: file\n        } = filesIterator.next();\n        if (done) {\n          return resolve(processed);\n        }\n        const fileReader = new FileReader();\n        fileReader.addEventListener(\"error\", reject);\n        fileReader.addEventListener(\"load\", () => {\n          const result = fileReader.result;\n          if (typeof result === \"string\") {\n            processed.push({\n              file,\n              result\n            });\n          }\n          handleNextFile();\n        });\n        if (isMimeType(file, acceptableMimeTypes)) {\n          fileReader.readAsDataURL(file);\n        } else {\n          handleNextFile();\n        }\n      };\n      handleNextFile();\n    });\n  }\n  function $dfs(startingNode, endingNode) {\n    const nodes = [];\n    const start = (startingNode || lexical.$getRoot()).getLatest();\n    const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\n    let node = start;\n    let depth = $getDepth(node);\n    while (node !== null && !node.is(end)) {\n      nodes.push({\n        depth,\n        node\n      });\n      if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\n        node = node.getFirstChild();\n        depth++;\n      } else {\n        let sibling = null;\n        while (sibling === null && node !== null) {\n          sibling = node.getNextSibling();\n          if (sibling === null) {\n            node = node.getParent();\n            depth--;\n          } else {\n            node = sibling;\n          }\n        }\n      }\n    }\n    if (node !== null && node.is(end)) {\n      nodes.push({\n        depth,\n        node\n      });\n    }\n    return nodes;\n  }\n  function $getDepth(node) {\n    let innerNode = node;\n    let depth = 0;\n    while ((innerNode = innerNode.getParent()) !== null) {\n      depth++;\n    }\n    return depth;\n  }\n  function $getNearestNodeOfType(node, klass) {\n    let parent = node;\n    while (parent != null) {\n      if (parent instanceof klass) {\n        return parent;\n      }\n      parent = parent.getParent();\n    }\n    return null;\n  }\n  function $getNearestBlockElementAncestorOrThrow(startNode) {\n    const blockNode = $findMatchingParent(startNode, (node) => lexical.$isElementNode(node) && !node.isInline());\n    if (!lexical.$isElementNode(blockNode)) {\n      {\n        throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n      }\n    }\n    return blockNode;\n  }\n  function $findMatchingParent(startingNode, findFn) {\n    let curr = startingNode;\n    while (curr !== lexical.$getRoot() && curr != null) {\n      if (findFn(curr)) {\n        return curr;\n      }\n      curr = curr.getParent();\n    }\n    return null;\n  }\n  function mergeRegister(...func) {\n    return () => {\n      func.forEach((f) => f());\n    };\n  }\n  function registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n    const $isTargetNode = (node) => {\n      return node instanceof targetNode;\n    };\n    const $findMatch = (node) => {\n      const children = node.getChildren();\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if ($isTargetNode(child)) {\n          return null;\n        }\n      }\n      let parentNode = node;\n      let childNode = node;\n      while (parentNode !== null) {\n        childNode = parentNode;\n        parentNode = parentNode.getParent();\n        if ($isTargetNode(parentNode)) {\n          return {\n            child: childNode,\n            parent: parentNode\n          };\n        }\n      }\n      return null;\n    };\n    const elementNodeTransform = (node) => {\n      const match = $findMatch(node);\n      if (match !== null) {\n        const {\n          child,\n          parent\n        } = match;\n        if (child.is(node)) {\n          handleOverlap(parent, node);\n          const nextSiblings = child.getNextSiblings();\n          const nextSiblingsLength = nextSiblings.length;\n          parent.insertAfter(child);\n          if (nextSiblingsLength !== 0) {\n            const newParent = cloneNode(parent);\n            child.insertAfter(newParent);\n            for (let i = 0; i < nextSiblingsLength; i++) {\n              newParent.append(nextSiblings[i]);\n            }\n          }\n          if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n            parent.remove();\n          }\n        }\n      }\n    };\n    return editor.registerNodeTransform(targetNode, elementNodeTransform);\n  }\n  function $restoreEditorState(editor, editorState) {\n    const FULL_RECONCILE = 2;\n    const nodeMap = /* @__PURE__ */ new Map();\n    const activeEditorState = editor._pendingEditorState;\n    for (const [key, node] of editorState._nodeMap) {\n      const clone = selection.$cloneWithProperties(node);\n      if (lexical.$isTextNode(clone)) {\n        clone.__text = node.__text;\n      }\n      nodeMap.set(key, clone);\n    }\n    if (activeEditorState) {\n      activeEditorState._nodeMap = nodeMap;\n    }\n    editor._dirtyType = FULL_RECONCILE;\n    const selection$1 = editorState._selection;\n    lexical.$setSelection(selection$1 === null ? null : selection$1.clone());\n  }\n  function $insertNodeToNearestRoot(node) {\n    const selection2 = lexical.$getSelection();\n    if (lexical.$isRangeSelection(selection2)) {\n      const {\n        focus\n      } = selection2;\n      const focusNode = focus.getNode();\n      const focusOffset = focus.offset;\n      if (lexical.$isRootOrShadowRoot(focusNode)) {\n        const focusChild = focusNode.getChildAtIndex(focusOffset);\n        if (focusChild == null) {\n          focusNode.append(node);\n        } else {\n          focusChild.insertBefore(node);\n        }\n        node.selectNext();\n      } else {\n        let splitNode;\n        let splitOffset;\n        if (lexical.$isTextNode(focusNode)) {\n          splitNode = focusNode.getParentOrThrow();\n          splitOffset = focusNode.getIndexWithinParent();\n          if (focusOffset > 0) {\n            splitOffset += 1;\n            focusNode.splitText(focusOffset);\n          }\n        } else {\n          splitNode = focusNode;\n          splitOffset = focusOffset;\n        }\n        const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);\n        rightTree.insertBefore(node);\n        rightTree.selectStart();\n      }\n    } else {\n      if (lexical.$isNodeSelection(selection2) || lexical.DEPRECATED_$isGridSelection(selection2)) {\n        const nodes = selection2.getNodes();\n        nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n      } else {\n        const root = lexical.$getRoot();\n        root.append(node);\n      }\n      const paragraphNode = lexical.$createParagraphNode();\n      node.insertAfter(paragraphNode);\n      paragraphNode.select();\n    }\n    return node.getLatest();\n  }\n  function $wrapNodeInElement(node, createElementNode) {\n    const elementNode = createElementNode();\n    node.replace(elementNode);\n    elementNode.append(node);\n    return elementNode;\n  }\n  function isHTMLAnchorElement(x) {\n    return isHTMLElement(x) && x.tagName === \"A\";\n  }\n  function isHTMLElement(x) {\n    return x.nodeType === 1;\n  }\n  LexicalUtils_dev.$splitNode = lexical.$splitNode;\n  LexicalUtils_dev.$dfs = $dfs;\n  LexicalUtils_dev.$findMatchingParent = $findMatchingParent;\n  LexicalUtils_dev.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\n  LexicalUtils_dev.$getNearestNodeOfType = $getNearestNodeOfType;\n  LexicalUtils_dev.$insertNodeToNearestRoot = $insertNodeToNearestRoot;\n  LexicalUtils_dev.$restoreEditorState = $restoreEditorState;\n  LexicalUtils_dev.$wrapNodeInElement = $wrapNodeInElement;\n  LexicalUtils_dev.addClassNamesToElement = addClassNamesToElement;\n  LexicalUtils_dev.isHTMLAnchorElement = isHTMLAnchorElement;\n  LexicalUtils_dev.isHTMLElement = isHTMLElement;\n  LexicalUtils_dev.isMimeType = isMimeType;\n  LexicalUtils_dev.mediaFileReader = mediaFileReader;\n  LexicalUtils_dev.mergeRegister = mergeRegister;\n  LexicalUtils_dev.registerNestedElementResolver = registerNestedElementResolver;\n  LexicalUtils_dev.removeClassNamesFromElement = removeClassNamesFromElement;\n  return LexicalUtils_dev;\n}\nvar LexicalUtils_prod = {};\nvar hasRequiredLexicalUtils_prod;\nfunction requireLexicalUtils_prod() {\n  if (hasRequiredLexicalUtils_prod)\n    return LexicalUtils_prod;\n  hasRequiredLexicalUtils_prod = 1;\n  var g = requireLexicalSelection(), n = require$$1;\n  function p(a, b) {\n    for (let c of b)\n      if (a.type.startsWith(c))\n        return true;\n    return false;\n  }\n  function q(a, b) {\n    for (; a !== n.$getRoot() && null != a; ) {\n      if (b(a))\n        return a;\n      a = a.getParent();\n    }\n    return null;\n  }\n  function t(a) {\n    return 1 === a.nodeType;\n  }\n  LexicalUtils_prod.$splitNode = n.$splitNode;\n  LexicalUtils_prod.$dfs = function(a, b) {\n    let c = [];\n    a = (a || n.$getRoot()).getLatest();\n    b = b || (n.$isElementNode(a) ? a.getLastDescendant() : a);\n    for (var f = a, d = 0; null !== (f = f.getParent()); )\n      d++;\n    for (f = d; null !== a && !a.is(b); )\n      if (c.push({ depth: f, node: a }), n.$isElementNode(a) && 0 < a.getChildrenSize())\n        a = a.getFirstChild(), f++;\n      else\n        for (d = null; null === d && null !== a; )\n          d = a.getNextSibling(), null === d ? (a = a.getParent(), f--) : a = d;\n    null !== a && a.is(b) && c.push({ depth: f, node: a });\n    return c;\n  };\n  LexicalUtils_prod.$findMatchingParent = q;\n  LexicalUtils_prod.$getNearestBlockElementAncestorOrThrow = function(a) {\n    a = q(a, (b) => n.$isElementNode(b) && !b.isInline());\n    if (!n.$isElementNode(a))\n      throw Error(\"Minified Lexical error #4; visit https://lexical.dev/docs/error?code=4 for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\");\n    return a;\n  };\n  LexicalUtils_prod.$getNearestNodeOfType = function(a, b) {\n    for (; null != a; ) {\n      if (a instanceof b)\n        return a;\n      a = a.getParent();\n    }\n    return null;\n  };\n  LexicalUtils_prod.$insertNodeToNearestRoot = function(a) {\n    var b = n.$getSelection();\n    if (n.$isRangeSelection(b)) {\n      var { focus: c } = b;\n      b = c.getNode();\n      c = c.offset;\n      if (n.$isRootOrShadowRoot(b))\n        c = b.getChildAtIndex(c), null == c ? b.append(a) : c.insertBefore(a), a.selectNext();\n      else {\n        let f, d;\n        n.$isTextNode(b) ? (f = b.getParentOrThrow(), d = b.getIndexWithinParent(), 0 < c && (d += 1, b.splitText(c))) : (f = b, d = c);\n        [, b] = n.$splitNode(f, d);\n        b.insertBefore(a);\n        b.selectStart();\n      }\n    } else\n      n.$isNodeSelection(b) || n.DEPRECATED_$isGridSelection(b) ? (b = b.getNodes(), b[b.length - 1].getTopLevelElementOrThrow().insertAfter(a)) : n.$getRoot().append(a), b = n.$createParagraphNode(), a.insertAfter(b), b.select();\n    return a.getLatest();\n  };\n  LexicalUtils_prod.$restoreEditorState = function(a, b) {\n    let c = /* @__PURE__ */ new Map(), f = a._pendingEditorState;\n    for (let [d, e] of b._nodeMap) {\n      let h = g.$cloneWithProperties(e);\n      n.$isTextNode(h) && (h.__text = e.__text);\n      c.set(d, h);\n    }\n    f && (f._nodeMap = c);\n    a._dirtyType = 2;\n    a = b._selection;\n    n.$setSelection(null === a ? null : a.clone());\n  };\n  LexicalUtils_prod.$wrapNodeInElement = function(a, b) {\n    b = b();\n    a.replace(b);\n    b.append(a);\n    return b;\n  };\n  LexicalUtils_prod.addClassNamesToElement = function(a, ...b) {\n    b.forEach((c) => {\n      \"string\" === typeof c && (c = c.split(\" \").filter((f) => \"\" !== f), a.classList.add(...c));\n    });\n  };\n  LexicalUtils_prod.isHTMLAnchorElement = function(a) {\n    return t(a) && \"A\" === a.tagName;\n  };\n  LexicalUtils_prod.isHTMLElement = t;\n  LexicalUtils_prod.isMimeType = p;\n  LexicalUtils_prod.mediaFileReader = function(a, b) {\n    let c = a[Symbol.iterator]();\n    return new Promise((f, d) => {\n      let e = [], h = () => {\n        const { done: m, value: k } = c.next();\n        if (m)\n          return f(e);\n        const l = new FileReader();\n        l.addEventListener(\"error\", d);\n        l.addEventListener(\"load\", () => {\n          const r = l.result;\n          \"string\" === typeof r && e.push({ file: k, result: r });\n          h();\n        });\n        p(k, b) ? l.readAsDataURL(k) : h();\n      };\n      h();\n    });\n  };\n  LexicalUtils_prod.mergeRegister = function(...a) {\n    return () => {\n      a.forEach((b) => b());\n    };\n  };\n  LexicalUtils_prod.registerNestedElementResolver = function(a, b, c, f) {\n    return a.registerNodeTransform(b, (d) => {\n      a: {\n        var e = d.getChildren();\n        for (var h = 0; h < e.length; h++)\n          if (e[h] instanceof b) {\n            e = null;\n            break a;\n          }\n        for (e = d; null !== e; )\n          if (h = e, e = e.getParent(), e instanceof b) {\n            e = { child: h, parent: e };\n            break a;\n          }\n        e = null;\n      }\n      if (null !== e) {\n        const { child: m, parent: k } = e;\n        if (m.is(d)) {\n          f(k, d);\n          d = m.getNextSiblings();\n          e = d.length;\n          k.insertAfter(m);\n          if (0 !== e) {\n            h = c(k);\n            m.insertAfter(h);\n            for (let l = 0; l < e; l++)\n              h.append(d[l]);\n          }\n          k.canBeEmpty() || 0 !== k.getChildrenSize() || k.remove();\n        }\n      }\n    });\n  };\n  LexicalUtils_prod.removeClassNamesFromElement = function(a, ...b) {\n    b.forEach((c) => {\n      \"string\" === typeof c && a.classList.remove(...c.split(\" \"));\n    });\n  };\n  return LexicalUtils_prod;\n}\nvar LexicalUtils_1;\nvar hasRequiredLexicalUtils;\nfunction requireLexicalUtils() {\n  if (hasRequiredLexicalUtils)\n    return LexicalUtils_1;\n  hasRequiredLexicalUtils = 1;\n  const LexicalUtils = process.env.NODE_ENV === \"development\" ? requireLexicalUtils_dev() : requireLexicalUtils_prod();\n  LexicalUtils_1 = LexicalUtils;\n  return LexicalUtils_1;\n}\nvar hasRequiredLexicalCode_dev;\nfunction requireLexicalCode_dev() {\n  if (hasRequiredLexicalCode_dev)\n    return LexicalCode_dev;\n  hasRequiredLexicalCode_dev = 1;\n  var Prism2 = requirePrism();\n  requirePrismClike();\n  requirePrismJavascript();\n  requirePrismMarkup();\n  requirePrismMarkdown();\n  requirePrismC();\n  requirePrismCss();\n  requirePrismObjectivec();\n  requirePrismSql();\n  requirePrismPython();\n  requirePrismRust();\n  requirePrismSwift();\n  requirePrismTypescript();\n  requirePrismJava();\n  requirePrismCpp();\n  var utils = requireLexicalUtils();\n  var lexical = require$$1;\n  const mapToPrismLanguage = (language) => {\n    return language != null && Prism2.languages.hasOwnProperty(language) ? language : void 0;\n  };\n  function hasChildDOMNodeTag(node, tagName) {\n    for (const child of node.childNodes) {\n      if (utils.isHTMLElement(child) && child.tagName === tagName) {\n        return true;\n      }\n      hasChildDOMNodeTag(child, tagName);\n    }\n    return false;\n  }\n  const LANGUAGE_DATA_ATTRIBUTE = \"data-highlight-language\";\n  class CodeNode extends lexical.ElementNode {\n    /** @internal */\n    static getType() {\n      return \"code\";\n    }\n    static clone(node) {\n      return new CodeNode(node.__language, node.__key);\n    }\n    constructor(language, key) {\n      super(key);\n      this.__language = mapToPrismLanguage(language);\n    }\n    // View\n    createDOM(config) {\n      const element = document.createElement(\"code\");\n      utils.addClassNamesToElement(element, config.theme.code);\n      element.setAttribute(\"spellcheck\", \"false\");\n      const language = this.getLanguage();\n      if (language) {\n        element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n      return element;\n    }\n    updateDOM(prevNode, dom, config) {\n      const language = this.__language;\n      const prevLanguage = prevNode.__language;\n      if (language) {\n        if (language !== prevLanguage) {\n          dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n        }\n      } else if (prevLanguage) {\n        dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);\n      }\n      return false;\n    }\n    static importDOM() {\n      return {\n        // Typically <pre> is used for code blocks, and <code> for inline code styles\n        // but if it's a multi line <code> we'll create a block. Pass through to\n        // inline format handled by TextNode otherwise.\n        code: (node) => {\n          const isMultiLine = node.textContent != null && (/\\r?\\n/.test(node.textContent) || hasChildDOMNodeTag(node, \"BR\"));\n          return isMultiLine ? {\n            conversion: convertPreElement,\n            priority: 1\n          } : null;\n        },\n        div: (node) => ({\n          conversion: convertDivElement,\n          priority: 1\n        }),\n        pre: (node) => ({\n          conversion: convertPreElement,\n          priority: 0\n        }),\n        table: (node) => {\n          const table = node;\n          if (isGitHubCodeTable(table)) {\n            return {\n              conversion: convertTableElement,\n              priority: 3\n            };\n          }\n          return null;\n        },\n        td: (node) => {\n          const td = node;\n          const table = td.closest(\"table\");\n          if (isGitHubCodeCell(td)) {\n            return {\n              conversion: convertTableCellElement,\n              priority: 3\n            };\n          }\n          if (table && isGitHubCodeTable(table)) {\n            return {\n              conversion: convertCodeNoop,\n              priority: 3\n            };\n          }\n          return null;\n        },\n        tr: (node) => {\n          const tr = node;\n          const table = tr.closest(\"table\");\n          if (table && isGitHubCodeTable(table)) {\n            return {\n              conversion: convertCodeNoop,\n              priority: 3\n            };\n          }\n          return null;\n        }\n      };\n    }\n    static importJSON(serializedNode) {\n      const node = $createCodeNode(serializedNode.language);\n      node.setFormat(serializedNode.format);\n      node.setIndent(serializedNode.indent);\n      node.setDirection(serializedNode.direction);\n      return node;\n    }\n    exportJSON() {\n      return {\n        ...super.exportJSON(),\n        language: this.getLanguage(),\n        type: \"code\",\n        version: 1\n      };\n    }\n    // Mutation\n    insertNewAfter(selection, restoreSelection = true) {\n      const children = this.getChildren();\n      const childrenLength = children.length;\n      if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === \"\\n\" && children[childrenLength - 2].getTextContent() === \"\\n\" && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {\n        children[childrenLength - 1].remove();\n        children[childrenLength - 2].remove();\n        const newElement = lexical.$createParagraphNode();\n        this.insertAfter(newElement, restoreSelection);\n        return newElement;\n      }\n      const anchor = selection.anchor.getNode();\n      const firstNode = getFirstCodeHighlightNodeOfLine(anchor);\n      if (firstNode != null) {\n        let leadingWhitespace = 0;\n        const firstNodeText = firstNode.getTextContent();\n        while (leadingWhitespace < firstNodeText.length && /[\\t ]/.test(firstNodeText[leadingWhitespace])) {\n          leadingWhitespace += 1;\n        }\n        if (leadingWhitespace > 0) {\n          const whitespace = firstNodeText.substring(0, leadingWhitespace);\n          const indentedChild = $createCodeHighlightNode(whitespace);\n          anchor.insertAfter(indentedChild);\n          selection.insertNodes([lexical.$createLineBreakNode()]);\n          indentedChild.select();\n          return indentedChild;\n        }\n      }\n      return null;\n    }\n    canInsertTab() {\n      const selection = lexical.$getSelection();\n      if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n        return false;\n      }\n      return true;\n    }\n    canIndent() {\n      return false;\n    }\n    collapseAtStart() {\n      const paragraph = lexical.$createParagraphNode();\n      const children = this.getChildren();\n      children.forEach((child) => paragraph.append(child));\n      this.replace(paragraph);\n      return true;\n    }\n    setLanguage(language) {\n      const writable = this.getWritable();\n      writable.__language = mapToPrismLanguage(language);\n    }\n    getLanguage() {\n      return this.getLatest().__language;\n    }\n  }\n  function $createCodeNode(language) {\n    return lexical.$applyNodeReplacement(new CodeNode(language));\n  }\n  function $isCodeNode(node) {\n    return node instanceof CodeNode;\n  }\n  function convertPreElement(domNode) {\n    return {\n      node: $createCodeNode(),\n      preformatted: true\n    };\n  }\n  function convertDivElement(domNode) {\n    const div = domNode;\n    const isCode = isCodeElement(div);\n    if (!isCode && !isCodeChildElement(div)) {\n      return {\n        node: null\n      };\n    }\n    return {\n      after: (childLexicalNodes) => {\n        const domParent = domNode.parentNode;\n        if (domParent != null && domNode !== domParent.lastChild) {\n          childLexicalNodes.push(lexical.$createLineBreakNode());\n        }\n        return childLexicalNodes;\n      },\n      node: isCode ? $createCodeNode() : null,\n      preformatted: isCode\n    };\n  }\n  function convertTableElement() {\n    return {\n      node: $createCodeNode(),\n      preformatted: true\n    };\n  }\n  function convertCodeNoop() {\n    return {\n      node: null\n    };\n  }\n  function convertTableCellElement(domNode) {\n    const cell = domNode;\n    return {\n      after: (childLexicalNodes) => {\n        if (cell.parentNode && cell.parentNode.nextSibling) {\n          childLexicalNodes.push(lexical.$createLineBreakNode());\n        }\n        return childLexicalNodes;\n      },\n      node: null\n    };\n  }\n  function isCodeElement(div) {\n    return div.style.fontFamily.match(\"monospace\") !== null;\n  }\n  function isCodeChildElement(node) {\n    let parent = node.parentElement;\n    while (parent !== null) {\n      if (isCodeElement(parent)) {\n        return true;\n      }\n      parent = parent.parentElement;\n    }\n    return false;\n  }\n  function isGitHubCodeCell(cell) {\n    return cell.classList.contains(\"js-file-line\");\n  }\n  function isGitHubCodeTable(table) {\n    return table.classList.contains(\"js-file-line-container\");\n  }\n  const DEFAULT_CODE_LANGUAGE = \"javascript\";\n  const CODE_LANGUAGE_FRIENDLY_NAME_MAP = {\n    c: \"C\",\n    clike: \"C-like\",\n    cpp: \"C++\",\n    css: \"CSS\",\n    html: \"HTML\",\n    java: \"Java\",\n    js: \"JavaScript\",\n    markdown: \"Markdown\",\n    objc: \"Objective-C\",\n    plain: \"Plain Text\",\n    py: \"Python\",\n    rust: \"Rust\",\n    sql: \"SQL\",\n    swift: \"Swift\",\n    typescript: \"TypeScript\",\n    xml: \"XML\"\n  };\n  const CODE_LANGUAGE_MAP = {\n    cpp: \"cpp\",\n    java: \"java\",\n    javascript: \"js\",\n    md: \"markdown\",\n    plaintext: \"plain\",\n    python: \"py\",\n    text: \"plain\",\n    ts: \"typescript\"\n  };\n  function normalizeCodeLang(lang) {\n    return CODE_LANGUAGE_MAP[lang] || lang;\n  }\n  function getLanguageFriendlyName(lang) {\n    const _lang = normalizeCodeLang(lang);\n    return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;\n  }\n  const getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;\n  const getCodeLanguages = () => Object.keys(Prism2.languages).filter(\n    // Prism has several language helpers mixed into languages object\n    // so filtering them out here to get langs list\n    (language) => typeof Prism2.languages[language] !== \"function\"\n  ).sort();\n  class CodeHighlightNode extends lexical.TextNode {\n    /** @internal */\n    constructor(text, highlightType, key) {\n      super(text, key);\n      this.__highlightType = highlightType;\n    }\n    static getType() {\n      return \"code-highlight\";\n    }\n    static clone(node) {\n      return new CodeHighlightNode(node.__text, node.__highlightType || void 0, node.__key);\n    }\n    getHighlightType() {\n      const self2 = this.getLatest();\n      return self2.__highlightType;\n    }\n    createDOM(config) {\n      const element = super.createDOM(config);\n      const className = getHighlightThemeClass(config.theme, this.__highlightType);\n      utils.addClassNamesToElement(element, className);\n      return element;\n    }\n    updateDOM(prevNode, dom, config) {\n      const update = super.updateDOM(prevNode, dom, config);\n      const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);\n      const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);\n      if (prevClassName !== nextClassName) {\n        if (prevClassName) {\n          utils.removeClassNamesFromElement(dom, prevClassName);\n        }\n        if (nextClassName) {\n          utils.addClassNamesToElement(dom, nextClassName);\n        }\n      }\n      return update;\n    }\n    static importJSON(serializedNode) {\n      const node = $createCodeHighlightNode(serializedNode.text, serializedNode.highlightType);\n      node.setFormat(serializedNode.format);\n      node.setDetail(serializedNode.detail);\n      node.setMode(serializedNode.mode);\n      node.setStyle(serializedNode.style);\n      return node;\n    }\n    exportJSON() {\n      return {\n        ...super.exportJSON(),\n        highlightType: this.getHighlightType(),\n        type: \"code-highlight\",\n        version: 1\n      };\n    }\n    // Prevent formatting (bold, underline, etc)\n    setFormat(format) {\n      return this;\n    }\n    isParentRequired() {\n      return true;\n    }\n    createParentElementNode() {\n      return $createCodeNode();\n    }\n  }\n  function getHighlightThemeClass(theme, highlightType) {\n    return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];\n  }\n  function $createCodeHighlightNode(text, highlightType) {\n    return lexical.$applyNodeReplacement(new CodeHighlightNode(text, highlightType));\n  }\n  function $isCodeHighlightNode(node) {\n    return node instanceof CodeHighlightNode;\n  }\n  function getFirstCodeHighlightNodeOfLine(anchor) {\n    let currentNode = null;\n    const previousSiblings = anchor.getPreviousSiblings();\n    previousSiblings.push(anchor);\n    while (previousSiblings.length > 0) {\n      const node = previousSiblings.pop();\n      if ($isCodeHighlightNode(node)) {\n        currentNode = node;\n      }\n      if (lexical.$isLineBreakNode(node)) {\n        break;\n      }\n    }\n    return currentNode;\n  }\n  function getLastCodeHighlightNodeOfLine(anchor) {\n    let currentNode = null;\n    const nextSiblings = anchor.getNextSiblings();\n    nextSiblings.unshift(anchor);\n    while (nextSiblings.length > 0) {\n      const node = nextSiblings.shift();\n      if ($isCodeHighlightNode(node)) {\n        currentNode = node;\n      }\n      if (lexical.$isLineBreakNode(node)) {\n        break;\n      }\n    }\n    return currentNode;\n  }\n  const PrismTokenizer = {\n    defaultLanguage: DEFAULT_CODE_LANGUAGE,\n    tokenize(code, language) {\n      return Prism2.tokenize(code, Prism2.languages[language || \"\"] || Prism2.languages[this.defaultLanguage]);\n    }\n  };\n  function isSpaceOrTabChar(char) {\n    return char === \" \" || char === \"\t\";\n  }\n  function findFirstNotSpaceOrTabCharAtText(text, isForward) {\n    const length = text.length;\n    let offset = -1;\n    if (isForward) {\n      for (let i = 0; i < length; i++) {\n        const char = text[i];\n        if (!isSpaceOrTabChar(char)) {\n          offset = i;\n          break;\n        }\n      }\n    } else {\n      for (let i = length - 1; i > -1; i--) {\n        const char = text[i];\n        if (!isSpaceOrTabChar(char)) {\n          offset = i;\n          break;\n        }\n      }\n    }\n    return offset;\n  }\n  function getStartOfCodeInLine(anchor) {\n    let currentNode = null;\n    let currentNodeOffset = -1;\n    const previousSiblings = anchor.getPreviousSiblings();\n    previousSiblings.push(anchor);\n    while (previousSiblings.length > 0) {\n      const node = previousSiblings.pop();\n      if ($isCodeHighlightNode(node)) {\n        const text = node.getTextContent();\n        const offset = findFirstNotSpaceOrTabCharAtText(text, true);\n        if (offset !== -1) {\n          currentNode = node;\n          currentNodeOffset = offset;\n        }\n      }\n      if (lexical.$isLineBreakNode(node)) {\n        break;\n      }\n    }\n    if (currentNode === null) {\n      const nextSiblings = anchor.getNextSiblings();\n      while (nextSiblings.length > 0) {\n        const node = nextSiblings.shift();\n        if ($isCodeHighlightNode(node)) {\n          const text = node.getTextContent();\n          const offset = findFirstNotSpaceOrTabCharAtText(text, true);\n          if (offset !== -1) {\n            currentNode = node;\n            currentNodeOffset = offset;\n            break;\n          }\n        }\n        if (lexical.$isLineBreakNode(node)) {\n          break;\n        }\n      }\n    }\n    return {\n      node: currentNode,\n      offset: currentNodeOffset\n    };\n  }\n  function getEndOfCodeInLine(anchor) {\n    let currentNode = null;\n    let currentNodeOffset = -1;\n    const nextSiblings = anchor.getNextSiblings();\n    nextSiblings.unshift(anchor);\n    while (nextSiblings.length > 0) {\n      const node = nextSiblings.shift();\n      if ($isCodeHighlightNode(node)) {\n        const text = node.getTextContent();\n        const offset = findFirstNotSpaceOrTabCharAtText(text, false);\n        if (offset !== -1) {\n          currentNode = node;\n          currentNodeOffset = offset + 1;\n        }\n      }\n      if (lexical.$isLineBreakNode(node)) {\n        break;\n      }\n    }\n    if (currentNode === null) {\n      const previousSiblings = anchor.getPreviousSiblings();\n      while (previousSiblings.length > 0) {\n        const node = previousSiblings.pop();\n        if ($isCodeHighlightNode(node)) {\n          const text = node.getTextContent();\n          const offset = findFirstNotSpaceOrTabCharAtText(text, false);\n          if (offset !== -1) {\n            currentNode = node;\n            currentNodeOffset = offset + 1;\n            break;\n          }\n        }\n        if (lexical.$isLineBreakNode(node)) {\n          break;\n        }\n      }\n    }\n    return {\n      node: currentNode,\n      offset: currentNodeOffset\n    };\n  }\n  function textNodeTransform(node, editor, tokenizer) {\n    const parentNode = node.getParent();\n    if ($isCodeNode(parentNode)) {\n      codeNodeTransform(parentNode, editor, tokenizer);\n    } else if ($isCodeHighlightNode(node)) {\n      node.replace(lexical.$createTextNode(node.__text));\n    }\n  }\n  function updateCodeGutter(node, editor) {\n    const codeElement = editor.getElementByKey(node.getKey());\n    if (codeElement === null) {\n      return;\n    }\n    const children = node.getChildren();\n    const childrenLength = children.length;\n    if (childrenLength === codeElement.__cachedChildrenLength) {\n      return;\n    }\n    codeElement.__cachedChildrenLength = childrenLength;\n    let gutter = \"1\";\n    let count = 1;\n    for (let i = 0; i < childrenLength; i++) {\n      if (lexical.$isLineBreakNode(children[i])) {\n        gutter += \"\\n\" + ++count;\n      }\n    }\n    codeElement.setAttribute(\"data-gutter\", gutter);\n  }\n  const nodesCurrentlyHighlighting = /* @__PURE__ */ new Set();\n  function codeNodeTransform(node, editor, tokenizer) {\n    const nodeKey = node.getKey();\n    if (nodesCurrentlyHighlighting.has(nodeKey)) {\n      return;\n    }\n    nodesCurrentlyHighlighting.add(nodeKey);\n    if (node.getLanguage() === void 0) {\n      node.setLanguage(tokenizer.defaultLanguage);\n    }\n    editor.update(() => {\n      updateAndRetainSelection(nodeKey, () => {\n        const currentNode = lexical.$getNodeByKey(nodeKey);\n        if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {\n          return false;\n        }\n        const code = currentNode.getTextContent();\n        const tokens = tokenizer.tokenize(code, currentNode.getLanguage() || tokenizer.defaultLanguage);\n        const highlightNodes = getHighlightNodes(tokens);\n        const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);\n        const {\n          from,\n          to,\n          nodesForReplacement\n        } = diffRange;\n        if (from !== to || nodesForReplacement.length) {\n          node.splice(from, to - from, nodesForReplacement);\n          return true;\n        }\n        return false;\n      });\n    }, {\n      onUpdate: () => {\n        nodesCurrentlyHighlighting.delete(nodeKey);\n      },\n      skipTransforms: true\n    });\n  }\n  function getHighlightNodes(tokens) {\n    const nodes = [];\n    tokens.forEach((token) => {\n      if (typeof token === \"string\") {\n        const partials = token.split(\"\\n\");\n        for (let i = 0; i < partials.length; i++) {\n          const text = partials[i];\n          if (text.length) {\n            nodes.push($createCodeHighlightNode(text));\n          }\n          if (i < partials.length - 1) {\n            nodes.push(lexical.$createLineBreakNode());\n          }\n        }\n      } else {\n        const {\n          content\n        } = token;\n        if (typeof content === \"string\") {\n          nodes.push($createCodeHighlightNode(content, token.type));\n        } else if (Array.isArray(content) && content.length === 1 && typeof content[0] === \"string\") {\n          nodes.push($createCodeHighlightNode(content[0], token.type));\n        } else if (Array.isArray(content)) {\n          nodes.push(...getHighlightNodes(content));\n        }\n      }\n    });\n    return nodes;\n  }\n  function updateAndRetainSelection(nodeKey, updateFn) {\n    const node = lexical.$getNodeByKey(nodeKey);\n    if (!$isCodeNode(node) || !node.isAttached()) {\n      return;\n    }\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      updateFn();\n      return;\n    }\n    const anchor = selection.anchor;\n    const anchorOffset = anchor.offset;\n    const isNewLineAnchor = anchor.type === \"element\" && lexical.$isLineBreakNode(node.getChildAtIndex(anchor.offset - 1));\n    let textOffset = 0;\n    if (!isNewLineAnchor) {\n      const anchorNode = anchor.getNode();\n      textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {\n        return offset + _node.getTextContentSize();\n      }, 0);\n    }\n    const hasChanges = updateFn();\n    if (!hasChanges) {\n      return;\n    }\n    if (isNewLineAnchor) {\n      anchor.getNode().select(anchorOffset, anchorOffset);\n      return;\n    }\n    node.getChildren().some((_node) => {\n      const isText = lexical.$isTextNode(_node);\n      if (isText || lexical.$isLineBreakNode(_node)) {\n        const textContentSize = _node.getTextContentSize();\n        if (isText && textContentSize >= textOffset) {\n          _node.select(textOffset, textOffset);\n          return true;\n        }\n        textOffset -= textContentSize;\n      }\n      return false;\n    });\n  }\n  function getDiffRange(prevNodes, nextNodes) {\n    let leadingMatch = 0;\n    while (leadingMatch < prevNodes.length) {\n      if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {\n        break;\n      }\n      leadingMatch++;\n    }\n    const prevNodesLength = prevNodes.length;\n    const nextNodesLength = nextNodes.length;\n    const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;\n    let trailingMatch = 0;\n    while (trailingMatch < maxTrailingMatch) {\n      trailingMatch++;\n      if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {\n        trailingMatch--;\n        break;\n      }\n    }\n    const from = leadingMatch;\n    const to = prevNodesLength - trailingMatch;\n    const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);\n    return {\n      from,\n      nodesForReplacement,\n      to\n    };\n  }\n  function isEqual(nodeA, nodeB) {\n    if ($isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB)) {\n      return nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType;\n    }\n    if (lexical.$isLineBreakNode(nodeA) && lexical.$isLineBreakNode(nodeB)) {\n      return true;\n    }\n    return false;\n  }\n  function handleMultilineIndent(type) {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection) || selection.isCollapsed()) {\n      return false;\n    }\n    const nodes = selection.getNodes();\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (!$isCodeHighlightNode(node) && !lexical.$isLineBreakNode(node)) {\n        return false;\n      }\n    }\n    const startOfLine = getFirstCodeHighlightNodeOfLine(nodes[0]);\n    if (startOfLine != null) {\n      doIndent(startOfLine, type);\n    }\n    for (let i = 1; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (lexical.$isLineBreakNode(nodes[i - 1]) && $isCodeHighlightNode(node)) {\n        doIndent(node, type);\n      }\n    }\n    return true;\n  }\n  function doIndent(node, type) {\n    const text = node.getTextContent();\n    if (type === lexical.INDENT_CONTENT_COMMAND) {\n      if (text.length > 0 && /\\s/.test(text[0])) {\n        node.setTextContent(\"\t\" + text);\n      } else {\n        const indentNode = $createCodeHighlightNode(\"\t\");\n        node.insertBefore(indentNode);\n      }\n    } else {\n      if (text.indexOf(\"\t\") === 0) {\n        if (text.length === 1) {\n          node.remove();\n        } else {\n          node.setTextContent(text.substring(1));\n        }\n      }\n    }\n  }\n  function handleShiftLines(type, event) {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const arrowIsUp = type === lexical.KEY_ARROW_UP_COMMAND;\n    if (!$isCodeHighlightNode(anchorNode) || !$isCodeHighlightNode(focusNode)) {\n      return false;\n    }\n    if (!event.altKey) {\n      if (selection.isCollapsed()) {\n        const codeNode = anchorNode.getParentOrThrow();\n        if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {\n          const codeNodeSibling = codeNode.getPreviousSibling();\n          if (codeNodeSibling === null) {\n            codeNode.selectPrevious();\n            event.preventDefault();\n            return true;\n          }\n        } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {\n          const codeNodeSibling = codeNode.getNextSibling();\n          if (codeNodeSibling === null) {\n            codeNode.selectNext();\n            event.preventDefault();\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n    const start = getFirstCodeHighlightNodeOfLine(anchorNode);\n    const end = getLastCodeHighlightNodeOfLine(focusNode);\n    if (start == null || end == null) {\n      return false;\n    }\n    const range = start.getNodesBetween(end);\n    for (let i = 0; i < range.length; i++) {\n      const node = range[i];\n      if (!$isCodeHighlightNode(node) && !lexical.$isLineBreakNode(node)) {\n        return false;\n      }\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();\n    if (!lexical.$isLineBreakNode(linebreak)) {\n      return true;\n    }\n    const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();\n    if (sibling == null) {\n      return true;\n    }\n    const maybeInsertionPoint = arrowIsUp ? getFirstCodeHighlightNodeOfLine(sibling) : getLastCodeHighlightNodeOfLine(sibling);\n    let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;\n    linebreak.remove();\n    range.forEach((node) => node.remove());\n    if (type === lexical.KEY_ARROW_UP_COMMAND) {\n      range.forEach((node) => insertionPoint.insertBefore(node));\n      insertionPoint.insertBefore(linebreak);\n    } else {\n      insertionPoint.insertAfter(linebreak);\n      insertionPoint = linebreak;\n      range.forEach((node) => {\n        insertionPoint.insertAfter(node);\n        insertionPoint = node;\n      });\n    }\n    selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);\n    return true;\n  }\n  function handleMoveTo(type, event) {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isMoveToStart = type === lexical.MOVE_TO_START;\n    if (!$isCodeHighlightNode(anchorNode) || !$isCodeHighlightNode(focusNode)) {\n      return false;\n    }\n    let node;\n    let offset;\n    if (isMoveToStart) {\n      ({\n        node,\n        offset\n      } = getStartOfCodeInLine(focusNode));\n    } else {\n      ({\n        node,\n        offset\n      } = getEndOfCodeInLine(focusNode));\n    }\n    if (node !== null && offset !== -1) {\n      selection.setTextNodeRange(node, offset, node, offset);\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    return true;\n  }\n  function registerCodeHighlighting(editor, tokenizer) {\n    if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {\n      throw new Error(\"CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor\");\n    }\n    if (tokenizer == null) {\n      tokenizer = PrismTokenizer;\n    }\n    return utils.mergeRegister(editor.registerMutationListener(CodeNode, (mutations) => {\n      editor.update(() => {\n        for (const [key, type] of mutations) {\n          if (type !== \"destroyed\") {\n            const node = lexical.$getNodeByKey(key);\n            if (node !== null) {\n              updateCodeGutter(node, editor);\n            }\n          }\n        }\n      });\n    }), editor.registerNodeTransform(CodeNode, (node) => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(lexical.TextNode, (node) => textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, (node) => textNodeTransform(node, editor, tokenizer)), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, (payload) => handleMultilineIndent(lexical.INDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, (payload) => handleMultilineIndent(lexical.OUTDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, (payload) => handleShiftLines(lexical.KEY_ARROW_UP_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, (payload) => handleShiftLines(lexical.KEY_ARROW_DOWN_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_END, (payload) => handleMoveTo(lexical.MOVE_TO_END, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_START, (payload) => handleMoveTo(lexical.MOVE_TO_START, payload), lexical.COMMAND_PRIORITY_LOW));\n  }\n  LexicalCode_dev.$createCodeHighlightNode = $createCodeHighlightNode;\n  LexicalCode_dev.$createCodeNode = $createCodeNode;\n  LexicalCode_dev.$isCodeHighlightNode = $isCodeHighlightNode;\n  LexicalCode_dev.$isCodeNode = $isCodeNode;\n  LexicalCode_dev.CODE_LANGUAGE_FRIENDLY_NAME_MAP = CODE_LANGUAGE_FRIENDLY_NAME_MAP;\n  LexicalCode_dev.CODE_LANGUAGE_MAP = CODE_LANGUAGE_MAP;\n  LexicalCode_dev.CodeHighlightNode = CodeHighlightNode;\n  LexicalCode_dev.CodeNode = CodeNode;\n  LexicalCode_dev.DEFAULT_CODE_LANGUAGE = DEFAULT_CODE_LANGUAGE;\n  LexicalCode_dev.PrismTokenizer = PrismTokenizer;\n  LexicalCode_dev.getCodeLanguages = getCodeLanguages;\n  LexicalCode_dev.getDefaultCodeLanguage = getDefaultCodeLanguage;\n  LexicalCode_dev.getEndOfCodeInLine = getEndOfCodeInLine;\n  LexicalCode_dev.getFirstCodeHighlightNodeOfLine = getFirstCodeHighlightNodeOfLine;\n  LexicalCode_dev.getLanguageFriendlyName = getLanguageFriendlyName;\n  LexicalCode_dev.getLastCodeHighlightNodeOfLine = getLastCodeHighlightNodeOfLine;\n  LexicalCode_dev.getStartOfCodeInLine = getStartOfCodeInLine;\n  LexicalCode_dev.normalizeCodeLang = normalizeCodeLang;\n  LexicalCode_dev.registerCodeHighlighting = registerCodeHighlighting;\n  return LexicalCode_dev;\n}\nvar LexicalCode_prod = {};\nvar hasRequiredLexicalCode_prod;\nfunction requireLexicalCode_prod() {\n  if (hasRequiredLexicalCode_prod)\n    return LexicalCode_prod;\n  hasRequiredLexicalCode_prod = 1;\n  var e = requirePrism();\n  requirePrismClike();\n  requirePrismJavascript();\n  requirePrismMarkup();\n  requirePrismMarkdown();\n  requirePrismC();\n  requirePrismCss();\n  requirePrismObjectivec();\n  requirePrismSql();\n  requirePrismPython();\n  requirePrismRust();\n  requirePrismSwift();\n  requirePrismTypescript();\n  requirePrismJava();\n  requirePrismCpp();\n  var n = requireLexicalUtils(), u = require$$1;\n  let v = (a) => null != a && e.languages.hasOwnProperty(a) ? a : void 0;\n  function x(a, b) {\n    for (let c of a.childNodes) {\n      if (n.isHTMLElement(c) && c.tagName === b)\n        return true;\n      x(c, b);\n    }\n    return false;\n  }\n  class y extends u.ElementNode {\n    static getType() {\n      return \"code\";\n    }\n    static clone(a) {\n      return new y(a.__language, a.__key);\n    }\n    constructor(a, b) {\n      super(b);\n      this.__language = v(a);\n    }\n    createDOM(a) {\n      let b = document.createElement(\"code\");\n      n.addClassNamesToElement(b, a.theme.code);\n      b.setAttribute(\"spellcheck\", \"false\");\n      (a = this.getLanguage()) && b.setAttribute(\"data-highlight-language\", a);\n      return b;\n    }\n    updateDOM(a, b) {\n      let c = this.__language;\n      a = a.__language;\n      c ? c !== a && b.setAttribute(\"data-highlight-language\", c) : a && b.removeAttribute(\"data-highlight-language\");\n      return false;\n    }\n    static importDOM() {\n      return { code: (a) => null != a.textContent && (/\\r?\\n/.test(a.textContent) || x(a, \"BR\")) ? { conversion: z, priority: 1 } : null, div: () => ({ conversion: aa, priority: 1 }), pre: () => ({ conversion: z, priority: 0 }), table: (a) => A(a) ? { conversion: ba, priority: 3 } : null, td: (a) => {\n        let b = a.closest(\"table\");\n        return a.classList.contains(\"js-file-line\") ? { conversion: ca, priority: 3 } : b && A(b) ? { conversion: B, priority: 3 } : null;\n      }, tr: (a) => (a = a.closest(\"table\")) && A(a) ? { conversion: B, priority: 3 } : null };\n    }\n    static importJSON(a) {\n      let b = C(a.language);\n      b.setFormat(a.format);\n      b.setIndent(a.indent);\n      b.setDirection(a.direction);\n      return b;\n    }\n    exportJSON() {\n      return { ...super.exportJSON(), language: this.getLanguage(), type: \"code\", version: 1 };\n    }\n    insertNewAfter(a, b = true) {\n      var c = this.getChildren(), d = c.length;\n      if (2 <= d && \"\\n\" === c[d - 1].getTextContent() && \"\\n\" === c[d - 2].getTextContent() && a.isCollapsed() && a.anchor.key === this.__key && a.anchor.offset === d)\n        return c[d - 1].remove(), c[d - 2].remove(), a = u.$createParagraphNode(), this.insertAfter(a, b), a;\n      b = a.anchor.getNode();\n      d = D(b);\n      if (null != d) {\n        c = 0;\n        for (d = d.getTextContent(); c < d.length && /[\\t ]/.test(d[c]); )\n          c += 1;\n        if (0 < c)\n          return c = d.substring(0, c), c = E(c), b.insertAfter(c), a.insertNodes([u.$createLineBreakNode()]), c.select(), c;\n      }\n      return null;\n    }\n    canInsertTab() {\n      let a = u.$getSelection();\n      return u.$isRangeSelection(a) && a.isCollapsed() ? true : false;\n    }\n    canIndent() {\n      return false;\n    }\n    collapseAtStart() {\n      let a = u.$createParagraphNode();\n      this.getChildren().forEach((b) => a.append(b));\n      this.replace(a);\n      return true;\n    }\n    setLanguage(a) {\n      this.getWritable().__language = v(a);\n    }\n    getLanguage() {\n      return this.getLatest().__language;\n    }\n  }\n  function C(a) {\n    return u.$applyNodeReplacement(new y(a));\n  }\n  function F(a) {\n    return a instanceof y;\n  }\n  function z() {\n    return { node: C(), preformatted: true };\n  }\n  function aa(a) {\n    let b = null !== a.style.fontFamily.match(\"monospace\");\n    return b || da(a) ? { after: (c) => {\n      let d = a.parentNode;\n      null != d && a !== d.lastChild && c.push(u.$createLineBreakNode());\n      return c;\n    }, node: b ? C() : null, preformatted: b } : { node: null };\n  }\n  function ba() {\n    return { node: C(), preformatted: true };\n  }\n  function B() {\n    return { node: null };\n  }\n  function ca(a) {\n    return { after: (b) => {\n      a.parentNode && a.parentNode.nextSibling && b.push(u.$createLineBreakNode());\n      return b;\n    }, node: null };\n  }\n  function da(a) {\n    for (a = a.parentElement; null !== a; ) {\n      if (null !== a.style.fontFamily.match(\"monospace\"))\n        return true;\n      a = a.parentElement;\n    }\n    return false;\n  }\n  function A(a) {\n    return a.classList.contains(\"js-file-line-container\");\n  }\n  let G = { c: \"C\", clike: \"C-like\", cpp: \"C++\", css: \"CSS\", html: \"HTML\", java: \"Java\", js: \"JavaScript\", markdown: \"Markdown\", objc: \"Objective-C\", plain: \"Plain Text\", py: \"Python\", rust: \"Rust\", sql: \"SQL\", swift: \"Swift\", typescript: \"TypeScript\", xml: \"XML\" }, H = { cpp: \"cpp\", java: \"java\", javascript: \"js\", md: \"markdown\", plaintext: \"plain\", python: \"py\", text: \"plain\", ts: \"typescript\" };\n  function I(a) {\n    return H[a] || a;\n  }\n  class J extends u.TextNode {\n    constructor(a, b, c) {\n      super(a, c);\n      this.__highlightType = b;\n    }\n    static getType() {\n      return \"code-highlight\";\n    }\n    static clone(a) {\n      return new J(a.__text, a.__highlightType || void 0, a.__key);\n    }\n    getHighlightType() {\n      return this.getLatest().__highlightType;\n    }\n    createDOM(a) {\n      let b = super.createDOM(a);\n      a = K(a.theme, this.__highlightType);\n      n.addClassNamesToElement(b, a);\n      return b;\n    }\n    updateDOM(a, b, c) {\n      let d = super.updateDOM(a, b, c);\n      a = K(c.theme, a.__highlightType);\n      c = K(c.theme, this.__highlightType);\n      a !== c && (a && n.removeClassNamesFromElement(\n        b,\n        a\n      ), c && n.addClassNamesToElement(b, c));\n      return d;\n    }\n    static importJSON(a) {\n      let b = E(a.text, a.highlightType);\n      b.setFormat(a.format);\n      b.setDetail(a.detail);\n      b.setMode(a.mode);\n      b.setStyle(a.style);\n      return b;\n    }\n    exportJSON() {\n      return { ...super.exportJSON(), highlightType: this.getHighlightType(), type: \"code-highlight\", version: 1 };\n    }\n    setFormat() {\n      return this;\n    }\n    isParentRequired() {\n      return true;\n    }\n    createParentElementNode() {\n      return C();\n    }\n  }\n  function K(a, b) {\n    return b && a && a.codeHighlight && a.codeHighlight[b];\n  }\n  function E(a, b) {\n    return u.$applyNodeReplacement(new J(a, b));\n  }\n  function L(a) {\n    return a instanceof J;\n  }\n  function D(a) {\n    let b = null, c = a.getPreviousSiblings();\n    for (c.push(a); 0 < c.length && (a = c.pop(), L(a) && (b = a), !u.$isLineBreakNode(a)); )\n      ;\n    return b;\n  }\n  function M(a) {\n    let b = null, c = a.getNextSiblings();\n    for (c.unshift(a); 0 < c.length && (a = c.shift(), L(a) && (b = a), !u.$isLineBreakNode(a)); )\n      ;\n    return b;\n  }\n  let N = { defaultLanguage: \"javascript\", tokenize(a, b) {\n    return e.tokenize(a, e.languages[b || \"\"] || e.languages[this.defaultLanguage]);\n  } };\n  function O(a, b) {\n    var c = a.length;\n    let d = -1;\n    if (b)\n      for (b = 0; b < c; b++) {\n        let f = a[b];\n        if (\" \" !== f && \"\t\" !== f) {\n          d = b;\n          break;\n        }\n      }\n    else\n      for (--c; -1 < c; c--)\n        if (b = a[c], \" \" !== b && \"\t\" !== b) {\n          d = c;\n          break;\n        }\n    return d;\n  }\n  function P(a) {\n    let b = null, c = -1;\n    var d = a.getPreviousSiblings();\n    for (d.push(a); 0 < d.length; ) {\n      var f = d.pop();\n      if (L(f)) {\n        var g = f.getTextContent();\n        g = O(g, true);\n        -1 !== g && (b = f, c = g);\n      }\n      if (u.$isLineBreakNode(f))\n        break;\n    }\n    if (null === b)\n      for (a = a.getNextSiblings(); 0 < a.length; ) {\n        d = a.shift();\n        if (L(d) && (f = d.getTextContent(), f = O(f, true), -1 !== f)) {\n          b = d;\n          c = f;\n          break;\n        }\n        if (u.$isLineBreakNode(d))\n          break;\n      }\n    return { node: b, offset: c };\n  }\n  function Q(a) {\n    let b = null, c = -1;\n    var d = a.getNextSiblings();\n    for (d.unshift(a); 0 < d.length; ) {\n      var f = d.shift();\n      if (L(f)) {\n        var g = f.getTextContent();\n        g = O(g, false);\n        -1 !== g && (b = f, c = g + 1);\n      }\n      if (u.$isLineBreakNode(f))\n        break;\n    }\n    if (null === b)\n      for (a = a.getPreviousSiblings(); 0 < a.length; ) {\n        d = a.pop();\n        if (L(d) && (f = d.getTextContent(), f = O(f, false), -1 !== f)) {\n          b = d;\n          c = f + 1;\n          break;\n        }\n        if (u.$isLineBreakNode(d))\n          break;\n      }\n    return { node: b, offset: c };\n  }\n  function R(a, b, c) {\n    let d = a.getParent();\n    F(d) ? S(d, b, c) : L(a) && a.replace(u.$createTextNode(a.__text));\n  }\n  let T = /* @__PURE__ */ new Set();\n  function S(a, b, c) {\n    let d = a.getKey();\n    T.has(d) || (T.add(d), void 0 === a.getLanguage() && a.setLanguage(c.defaultLanguage), b.update(() => {\n      ea(d, () => {\n        var f = u.$getNodeByKey(d);\n        if (!F(f) || !f.isAttached())\n          return false;\n        var g = f.getTextContent();\n        g = c.tokenize(g, f.getLanguage() || c.defaultLanguage);\n        g = U(g);\n        var k = f.getChildren();\n        for (f = 0; f < k.length && V(k[f], g[f]); )\n          f++;\n        var h = k.length;\n        let l = g.length, p = Math.min(h, l) - f, m = 0;\n        for (; m < p; )\n          if (m++, !V(k[h - m], g[l - m])) {\n            m--;\n            break;\n          }\n        k = f;\n        h -= m;\n        g = g.slice(f, l - m);\n        let { from: w, to: t, nodesForReplacement: r } = { from: k, nodesForReplacement: g, to: h };\n        return w !== t || r.length ? (a.splice(w, t - w, r), true) : false;\n      });\n    }, { onUpdate: () => {\n      T.delete(d);\n    }, skipTransforms: true }));\n  }\n  function U(a) {\n    let b = [];\n    a.forEach((c) => {\n      if (\"string\" === typeof c) {\n        c = c.split(\"\\n\");\n        for (var d = 0; d < c.length; d++) {\n          let f = c[d];\n          f.length && b.push(E(f));\n          d < c.length - 1 && b.push(u.$createLineBreakNode());\n        }\n      } else\n        ({ content: d } = c), \"string\" === typeof d ? b.push(E(d, c.type)) : Array.isArray(d) && 1 === d.length && \"string\" === typeof d[0] ? b.push(E(d[0], c.type)) : Array.isArray(d) && b.push(...U(d));\n    });\n    return b;\n  }\n  function ea(a, b) {\n    a = u.$getNodeByKey(a);\n    if (F(a) && a.isAttached()) {\n      var c = u.$getSelection();\n      if (u.$isRangeSelection(c)) {\n        c = c.anchor;\n        var d = c.offset, f = \"element\" === c.type && u.$isLineBreakNode(a.getChildAtIndex(c.offset - 1)), g = 0;\n        if (!f) {\n          let k = c.getNode();\n          g = d + k.getPreviousSiblings().reduce((h, l) => h + l.getTextContentSize(), 0);\n        }\n        b() && (f ? c.getNode().select(d, d) : a.getChildren().some((k) => {\n          let h = u.$isTextNode(k);\n          if (h || u.$isLineBreakNode(k)) {\n            let l = k.getTextContentSize();\n            if (h && l >= g)\n              return k.select(g, g), true;\n            g -= l;\n          }\n          return false;\n        }));\n      } else\n        b();\n    }\n  }\n  function V(a, b) {\n    return L(a) && L(b) ? a.__text === b.__text && a.__highlightType === b.__highlightType : u.$isLineBreakNode(a) && u.$isLineBreakNode(b) ? true : false;\n  }\n  function W(a) {\n    var b = u.$getSelection();\n    if (!u.$isRangeSelection(b) || b.isCollapsed())\n      return false;\n    b = b.getNodes();\n    for (var c = 0; c < b.length; c++) {\n      var d = b[c];\n      if (!L(d) && !u.$isLineBreakNode(d))\n        return false;\n    }\n    c = D(b[0]);\n    null != c && X(c, a);\n    for (c = 1; c < b.length; c++)\n      d = b[c], u.$isLineBreakNode(b[c - 1]) && L(d) && X(d, a);\n    return true;\n  }\n  function X(a, b) {\n    let c = a.getTextContent();\n    b === u.INDENT_CONTENT_COMMAND ? 0 < c.length && /\\s/.test(c[0]) ? a.setTextContent(\"\t\" + c) : (b = E(\"\t\"), a.insertBefore(b)) : 0 === c.indexOf(\"\t\") && (1 === c.length ? a.remove() : a.setTextContent(c.substring(1)));\n  }\n  function Y(a, b) {\n    let c = u.$getSelection();\n    if (!u.$isRangeSelection(c))\n      return false;\n    let { anchor: d, focus: f } = c, g = d.offset, k = f.offset, h = d.getNode(), l = f.getNode();\n    var p = a === u.KEY_ARROW_UP_COMMAND;\n    if (!L(h) || !L(l))\n      return false;\n    if (!b.altKey) {\n      if (c.isCollapsed()) {\n        if (a = h.getParentOrThrow(), p && 0 === g && null === h.getPreviousSibling()) {\n          if (null === a.getPreviousSibling())\n            return a.selectPrevious(), b.preventDefault(), true;\n        } else if (!p && g === h.getTextContentSize() && null === h.getNextSibling() && null === a.getNextSibling())\n          return a.selectNext(), b.preventDefault(), true;\n      }\n      return false;\n    }\n    var m = D(h);\n    let w = M(l);\n    if (null == m || null == w)\n      return false;\n    let t = m.getNodesBetween(w);\n    for (let q = 0; q < t.length; q++) {\n      let Z = t[q];\n      if (!L(Z) && !u.$isLineBreakNode(Z))\n        return false;\n    }\n    b.preventDefault();\n    b.stopPropagation();\n    b = p ? m.getPreviousSibling() : w.getNextSibling();\n    if (!u.$isLineBreakNode(b))\n      return true;\n    m = p ? b.getPreviousSibling() : b.getNextSibling();\n    if (null == m)\n      return true;\n    p = p ? D(m) : M(m);\n    let r = null != p ? p : m;\n    b.remove();\n    t.forEach((q) => q.remove());\n    a === u.KEY_ARROW_UP_COMMAND ? (t.forEach((q) => r.insertBefore(q)), r.insertBefore(b)) : (r.insertAfter(b), r = b, t.forEach((q) => {\n      r.insertAfter(q);\n      r = q;\n    }));\n    c.setTextNodeRange(h, g, l, k);\n    return true;\n  }\n  function fa(a, b) {\n    let c = u.$getSelection();\n    if (!u.$isRangeSelection(c))\n      return false;\n    let { anchor: d, focus: f } = c, g = d.getNode(), k = f.getNode();\n    a = a === u.MOVE_TO_START;\n    if (!L(g) || !L(k))\n      return false;\n    let h, l;\n    a ? { node: h, offset: l } = P(k) : { node: h, offset: l } = Q(k);\n    null !== h && -1 !== l && c.setTextNodeRange(h, l, h, l);\n    b.preventDefault();\n    b.stopPropagation();\n    return true;\n  }\n  LexicalCode_prod.$createCodeHighlightNode = E;\n  LexicalCode_prod.$createCodeNode = C;\n  LexicalCode_prod.$isCodeHighlightNode = L;\n  LexicalCode_prod.$isCodeNode = F;\n  LexicalCode_prod.CODE_LANGUAGE_FRIENDLY_NAME_MAP = G;\n  LexicalCode_prod.CODE_LANGUAGE_MAP = H;\n  LexicalCode_prod.CodeHighlightNode = J;\n  LexicalCode_prod.CodeNode = y;\n  LexicalCode_prod.DEFAULT_CODE_LANGUAGE = \"javascript\";\n  LexicalCode_prod.PrismTokenizer = N;\n  LexicalCode_prod.getCodeLanguages = () => Object.keys(e.languages).filter((a) => \"function\" !== typeof e.languages[a]).sort();\n  LexicalCode_prod.getDefaultCodeLanguage = () => \"javascript\";\n  LexicalCode_prod.getEndOfCodeInLine = Q;\n  LexicalCode_prod.getFirstCodeHighlightNodeOfLine = D;\n  LexicalCode_prod.getLanguageFriendlyName = function(a) {\n    a = I(a);\n    return G[a] || a;\n  };\n  LexicalCode_prod.getLastCodeHighlightNodeOfLine = M;\n  LexicalCode_prod.getStartOfCodeInLine = P;\n  LexicalCode_prod.normalizeCodeLang = I;\n  LexicalCode_prod.registerCodeHighlighting = function(a, b) {\n    if (!a.hasNodes([y, J]))\n      throw Error(\"CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor\");\n    null == b && (b = N);\n    return n.mergeRegister(\n      a.registerMutationListener(y, (c) => {\n        a.update(() => {\n          for (let [g, k] of c)\n            if (\"destroyed\" !== k) {\n              var d = u.$getNodeByKey(g);\n              if (null !== d)\n                a: {\n                  var f = d;\n                  d = a.getElementByKey(f.getKey());\n                  if (null === d)\n                    break a;\n                  f = f.getChildren();\n                  let h = f.length;\n                  if (h === d.__cachedChildrenLength)\n                    break a;\n                  d.__cachedChildrenLength = h;\n                  let l = \"1\", p = 1;\n                  for (let m = 0; m < h; m++)\n                    u.$isLineBreakNode(f[m]) && (l += \"\\n\" + ++p);\n                  d.setAttribute(\"data-gutter\", l);\n                }\n            }\n        });\n      }),\n      a.registerNodeTransform(y, (c) => S(c, a, b)),\n      a.registerNodeTransform(u.TextNode, (c) => R(c, a, b)),\n      a.registerNodeTransform(J, (c) => R(c, a, b)),\n      a.registerCommand(u.INDENT_CONTENT_COMMAND, () => W(u.INDENT_CONTENT_COMMAND), u.COMMAND_PRIORITY_LOW),\n      a.registerCommand(u.OUTDENT_CONTENT_COMMAND, () => W(u.OUTDENT_CONTENT_COMMAND), u.COMMAND_PRIORITY_LOW),\n      a.registerCommand(u.KEY_ARROW_UP_COMMAND, (c) => Y(u.KEY_ARROW_UP_COMMAND, c), u.COMMAND_PRIORITY_LOW),\n      a.registerCommand(u.KEY_ARROW_DOWN_COMMAND, (c) => Y(u.KEY_ARROW_DOWN_COMMAND, c), u.COMMAND_PRIORITY_LOW),\n      a.registerCommand(u.MOVE_TO_END, (c) => fa(u.MOVE_TO_END, c), u.COMMAND_PRIORITY_LOW),\n      a.registerCommand(u.MOVE_TO_START, (c) => fa(u.MOVE_TO_START, c), u.COMMAND_PRIORITY_LOW)\n    );\n  };\n  return LexicalCode_prod;\n}\nconst LexicalCode = process.env.NODE_ENV === \"development\" ? requireLexicalCode_dev() : requireLexicalCode_prod();\nvar LexicalCode_1 = LexicalCode;\nvar LexicalLink_dev = {};\nvar hasRequiredLexicalLink_dev;\nfunction requireLexicalLink_dev() {\n  if (hasRequiredLexicalLink_dev)\n    return LexicalLink_dev;\n  hasRequiredLexicalLink_dev = 1;\n  var utils = requireLexicalUtils();\n  var lexical = require$$1;\n  class LinkNode extends lexical.ElementNode {\n    /** @internal */\n    /** @internal */\n    /** @internal */\n    static getType() {\n      return \"link\";\n    }\n    static clone(node) {\n      return new LinkNode(node.__url, {\n        rel: node.__rel,\n        target: node.__target\n      }, node.__key);\n    }\n    constructor(url, attributes = {}, key) {\n      super(key);\n      const {\n        target = null,\n        rel = null\n      } = attributes;\n      this.__url = url;\n      this.__target = target;\n      this.__rel = rel;\n    }\n    createDOM(config) {\n      const element = document.createElement(\"a\");\n      element.href = this.__url;\n      if (this.__target !== null) {\n        element.target = this.__target;\n      }\n      if (this.__rel !== null) {\n        element.rel = this.__rel;\n      }\n      utils.addClassNamesToElement(element, config.theme.link);\n      return element;\n    }\n    updateDOM(prevNode, anchor, config) {\n      const url = this.__url;\n      const target = this.__target;\n      const rel = this.__rel;\n      if (url !== prevNode.__url) {\n        anchor.href = url;\n      }\n      if (target !== prevNode.__target) {\n        if (target) {\n          anchor.target = target;\n        } else {\n          anchor.removeAttribute(\"target\");\n        }\n      }\n      if (rel !== prevNode.__rel) {\n        if (rel) {\n          anchor.rel = rel;\n        } else {\n          anchor.removeAttribute(\"rel\");\n        }\n      }\n      return false;\n    }\n    static importDOM() {\n      return {\n        a: (node) => ({\n          conversion: convertAnchorElement,\n          priority: 1\n        })\n      };\n    }\n    static importJSON(serializedNode) {\n      const node = $createLinkNode(serializedNode.url, {\n        rel: serializedNode.rel,\n        target: serializedNode.target\n      });\n      node.setFormat(serializedNode.format);\n      node.setIndent(serializedNode.indent);\n      node.setDirection(serializedNode.direction);\n      return node;\n    }\n    exportJSON() {\n      return {\n        ...super.exportJSON(),\n        rel: this.getRel(),\n        target: this.getTarget(),\n        type: \"link\",\n        url: this.getURL(),\n        version: 1\n      };\n    }\n    getURL() {\n      return this.getLatest().__url;\n    }\n    setURL(url) {\n      const writable = this.getWritable();\n      writable.__url = url;\n    }\n    getTarget() {\n      return this.getLatest().__target;\n    }\n    setTarget(target) {\n      const writable = this.getWritable();\n      writable.__target = target;\n    }\n    getRel() {\n      return this.getLatest().__rel;\n    }\n    setRel(rel) {\n      const writable = this.getWritable();\n      writable.__rel = rel;\n    }\n    insertNewAfter(selection, restoreSelection = true) {\n      const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n      if (lexical.$isElementNode(element)) {\n        const linkNode = $createLinkNode(this.__url, {\n          rel: this.__rel,\n          target: this.__target\n        });\n        element.append(linkNode);\n        return linkNode;\n      }\n      return null;\n    }\n    canInsertTextBefore() {\n      return false;\n    }\n    canInsertTextAfter() {\n      return false;\n    }\n    canBeEmpty() {\n      return false;\n    }\n    isInline() {\n      return true;\n    }\n    extractWithChild(child, selection, destination) {\n      if (!lexical.$isRangeSelection(selection)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n    }\n  }\n  function convertAnchorElement(domNode) {\n    let node = null;\n    if (utils.isHTMLAnchorElement(domNode)) {\n      const content = domNode.textContent;\n      if (content !== null && content !== \"\") {\n        node = $createLinkNode(domNode.getAttribute(\"href\") || \"\", {\n          rel: domNode.getAttribute(\"rel\"),\n          target: domNode.getAttribute(\"target\")\n        });\n      }\n    }\n    return {\n      node\n    };\n  }\n  function $createLinkNode(url, attributes) {\n    return lexical.$applyNodeReplacement(new LinkNode(url, attributes));\n  }\n  function $isLinkNode(node) {\n    return node instanceof LinkNode;\n  }\n  class AutoLinkNode extends LinkNode {\n    static getType() {\n      return \"autolink\";\n    }\n    static clone(node) {\n      return new AutoLinkNode(node.__url, {\n        rel: node.__rel,\n        target: node.__target\n      }, node.__key);\n    }\n    static importJSON(serializedNode) {\n      const node = $createAutoLinkNode(serializedNode.url, {\n        rel: serializedNode.rel,\n        target: serializedNode.target\n      });\n      node.setFormat(serializedNode.format);\n      node.setIndent(serializedNode.indent);\n      node.setDirection(serializedNode.direction);\n      return node;\n    }\n    static importDOM() {\n      return null;\n    }\n    exportJSON() {\n      return {\n        ...super.exportJSON(),\n        type: \"autolink\",\n        version: 1\n      };\n    }\n    insertNewAfter(selection, restoreSelection = true) {\n      const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n      if (lexical.$isElementNode(element)) {\n        const linkNode = $createAutoLinkNode(this.__url, {\n          rel: this._rel,\n          target: this.__target\n        });\n        element.append(linkNode);\n        return linkNode;\n      }\n      return null;\n    }\n  }\n  function $createAutoLinkNode(url, attributes) {\n    return lexical.$applyNodeReplacement(new AutoLinkNode(url, attributes));\n  }\n  function $isAutoLinkNode(node) {\n    return node instanceof AutoLinkNode;\n  }\n  const TOGGLE_LINK_COMMAND = lexical.createCommand(\"TOGGLE_LINK_COMMAND\");\n  function toggleLink(url, attributes = {}) {\n    const {\n      target\n    } = attributes;\n    const rel = attributes.rel === void 0 ? \"noopener\" : attributes.rel;\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return;\n    }\n    const nodes = selection.extract();\n    if (url === null) {\n      nodes.forEach((node) => {\n        const parent = node.getParent();\n        if ($isLinkNode(parent)) {\n          const children = parent.getChildren();\n          for (let i = 0; i < children.length; i++) {\n            parent.insertBefore(children[i]);\n          }\n          parent.remove();\n        }\n      });\n    } else {\n      if (nodes.length === 1) {\n        const firstNode = nodes[0];\n        const linkNode2 = $isLinkNode(firstNode) ? firstNode : $getLinkAncestor(firstNode);\n        if (linkNode2 !== null) {\n          linkNode2.setURL(url);\n          if (target !== void 0) {\n            linkNode2.setTarget(target);\n          }\n          if (rel !== null) {\n            linkNode2.setRel(rel);\n          }\n          return;\n        }\n      }\n      let prevParent = null;\n      let linkNode = null;\n      nodes.forEach((node) => {\n        const parent = node.getParent();\n        if (parent === linkNode || parent === null || lexical.$isElementNode(node) && !node.isInline()) {\n          return;\n        }\n        if ($isLinkNode(parent)) {\n          linkNode = parent;\n          parent.setURL(url);\n          if (target !== void 0) {\n            parent.setTarget(target);\n          }\n          if (rel !== null) {\n            linkNode.setRel(rel);\n          }\n          return;\n        }\n        if (!parent.is(prevParent)) {\n          prevParent = parent;\n          linkNode = $createLinkNode(url, {\n            rel,\n            target\n          });\n          if ($isLinkNode(parent)) {\n            if (node.getPreviousSibling() === null) {\n              parent.insertBefore(linkNode);\n            } else {\n              parent.insertAfter(linkNode);\n            }\n          } else {\n            node.insertBefore(linkNode);\n          }\n        }\n        if ($isLinkNode(node)) {\n          if (node.is(linkNode)) {\n            return;\n          }\n          if (linkNode !== null) {\n            const children = node.getChildren();\n            for (let i = 0; i < children.length; i++) {\n              linkNode.append(children[i]);\n            }\n          }\n          node.remove();\n          return;\n        }\n        if (linkNode !== null) {\n          linkNode.append(node);\n        }\n      });\n    }\n  }\n  function $getLinkAncestor(node) {\n    return $getAncestor(node, (ancestor) => $isLinkNode(ancestor));\n  }\n  function $getAncestor(node, predicate) {\n    let parent = node;\n    while (parent !== null && (parent = parent.getParent()) !== null && !predicate(parent))\n      ;\n    return parent;\n  }\n  LexicalLink_dev.$createAutoLinkNode = $createAutoLinkNode;\n  LexicalLink_dev.$createLinkNode = $createLinkNode;\n  LexicalLink_dev.$isAutoLinkNode = $isAutoLinkNode;\n  LexicalLink_dev.$isLinkNode = $isLinkNode;\n  LexicalLink_dev.AutoLinkNode = AutoLinkNode;\n  LexicalLink_dev.LinkNode = LinkNode;\n  LexicalLink_dev.TOGGLE_LINK_COMMAND = TOGGLE_LINK_COMMAND;\n  LexicalLink_dev.toggleLink = toggleLink;\n  return LexicalLink_dev;\n}\nvar LexicalLink_prod = {};\nvar hasRequiredLexicalLink_prod;\nfunction requireLexicalLink_prod() {\n  if (hasRequiredLexicalLink_prod)\n    return LexicalLink_prod;\n  hasRequiredLexicalLink_prod = 1;\n  var k = requireLexicalUtils(), m = require$$1;\n  class n extends m.ElementNode {\n    static getType() {\n      return \"link\";\n    }\n    static clone(a) {\n      return new n(a.__url, { rel: a.__rel, target: a.__target }, a.__key);\n    }\n    constructor(a, b = {}, c) {\n      super(c);\n      let { target: h = null, rel: e = null } = b;\n      this.__url = a;\n      this.__target = h;\n      this.__rel = e;\n    }\n    createDOM(a) {\n      let b = document.createElement(\"a\");\n      b.href = this.__url;\n      null !== this.__target && (b.target = this.__target);\n      null !== this.__rel && (b.rel = this.__rel);\n      k.addClassNamesToElement(b, a.theme.link);\n      return b;\n    }\n    updateDOM(a, b) {\n      let c = this.__url, h = this.__target, e = this.__rel;\n      c !== a.__url && (b.href = c);\n      h !== a.__target && (h ? b.target = h : b.removeAttribute(\"target\"));\n      e !== a.__rel && (e ? b.rel = e : b.removeAttribute(\"rel\"));\n      return false;\n    }\n    static importDOM() {\n      return { a: () => ({ conversion: p, priority: 1 }) };\n    }\n    static importJSON(a) {\n      let b = q(a.url, { rel: a.rel, target: a.target });\n      b.setFormat(a.format);\n      b.setIndent(a.indent);\n      b.setDirection(a.direction);\n      return b;\n    }\n    exportJSON() {\n      return { ...super.exportJSON(), rel: this.getRel(), target: this.getTarget(), type: \"link\", url: this.getURL(), version: 1 };\n    }\n    getURL() {\n      return this.getLatest().__url;\n    }\n    setURL(a) {\n      this.getWritable().__url = a;\n    }\n    getTarget() {\n      return this.getLatest().__target;\n    }\n    setTarget(a) {\n      this.getWritable().__target = a;\n    }\n    getRel() {\n      return this.getLatest().__rel;\n    }\n    setRel(a) {\n      this.getWritable().__rel = a;\n    }\n    insertNewAfter(a, b = true) {\n      a = this.getParentOrThrow().insertNewAfter(a, b);\n      return m.$isElementNode(a) ? (b = q(this.__url, { rel: this.__rel, target: this.__target }), a.append(b), b) : null;\n    }\n    canInsertTextBefore() {\n      return false;\n    }\n    canInsertTextAfter() {\n      return false;\n    }\n    canBeEmpty() {\n      return false;\n    }\n    isInline() {\n      return true;\n    }\n    extractWithChild(a, b) {\n      if (!m.$isRangeSelection(b))\n        return false;\n      a = b.anchor.getNode();\n      let c = b.focus.getNode();\n      return this.isParentOf(a) && this.isParentOf(c) && 0 < b.getTextContent().length;\n    }\n  }\n  function p(a) {\n    let b = null;\n    if (k.isHTMLAnchorElement(a)) {\n      let c = a.textContent;\n      null !== c && \"\" !== c && (b = q(a.getAttribute(\"href\") || \"\", { rel: a.getAttribute(\"rel\"), target: a.getAttribute(\"target\") }));\n    }\n    return { node: b };\n  }\n  function q(a, b) {\n    return m.$applyNodeReplacement(new n(a, b));\n  }\n  function r(a) {\n    return a instanceof n;\n  }\n  class u extends n {\n    static getType() {\n      return \"autolink\";\n    }\n    static clone(a) {\n      return new u(a.__url, { rel: a.__rel, target: a.__target }, a.__key);\n    }\n    static importJSON(a) {\n      let b = v(a.url, { rel: a.rel, target: a.target });\n      b.setFormat(a.format);\n      b.setIndent(a.indent);\n      b.setDirection(a.direction);\n      return b;\n    }\n    static importDOM() {\n      return null;\n    }\n    exportJSON() {\n      return { ...super.exportJSON(), type: \"autolink\", version: 1 };\n    }\n    insertNewAfter(a, b = true) {\n      a = this.getParentOrThrow().insertNewAfter(a, b);\n      return m.$isElementNode(a) ? (b = v(this.__url, {\n        rel: this._rel,\n        target: this.__target\n      }), a.append(b), b) : null;\n    }\n  }\n  function v(a, b) {\n    return m.$applyNodeReplacement(new u(a, b));\n  }\n  let w = m.createCommand(\"TOGGLE_LINK_COMMAND\");\n  function x(a) {\n    return y(a, (b) => r(b));\n  }\n  function y(a, b) {\n    for (; null !== a && null !== (a = a.getParent()) && !b(a); )\n      ;\n    return a;\n  }\n  LexicalLink_prod.$createAutoLinkNode = v;\n  LexicalLink_prod.$createLinkNode = q;\n  LexicalLink_prod.$isAutoLinkNode = function(a) {\n    return a instanceof u;\n  };\n  LexicalLink_prod.$isLinkNode = r;\n  LexicalLink_prod.AutoLinkNode = u;\n  LexicalLink_prod.LinkNode = n;\n  LexicalLink_prod.TOGGLE_LINK_COMMAND = w;\n  LexicalLink_prod.toggleLink = function(a, b = {}) {\n    let { target: c } = b, h = void 0 === b.rel ? \"noopener\" : b.rel;\n    b = m.$getSelection();\n    if (m.$isRangeSelection(b))\n      if (b = b.extract(), null === a)\n        b.forEach((l) => {\n          l = l.getParent();\n          if (r(l)) {\n            let d = l.getChildren();\n            for (let f = 0; f < d.length; f++)\n              l.insertBefore(d[f]);\n            l.remove();\n          }\n        });\n      else {\n        if (1 === b.length) {\n          var e = b[0];\n          e = r(e) ? e : x(e);\n          if (null !== e) {\n            e.setURL(a);\n            void 0 !== c && e.setTarget(c);\n            null !== h && e.setRel(h);\n            return;\n          }\n        }\n        let l = null, d = null;\n        b.forEach((f) => {\n          var g = f.getParent();\n          if (g !== d && null !== g && (!m.$isElementNode(f) || f.isInline()))\n            if (r(g))\n              d = g, g.setURL(a), void 0 !== c && g.setTarget(c), null !== h && d.setRel(h);\n            else if (g.is(l) || (l = g, d = q(a, { rel: h, target: c }), r(g) ? null === f.getPreviousSibling() ? g.insertBefore(d) : g.insertAfter(d) : f.insertBefore(d)), r(f)) {\n              if (!f.is(d)) {\n                if (null !== d) {\n                  g = f.getChildren();\n                  for (let t = 0; t < g.length; t++)\n                    d.append(g[t]);\n                }\n                f.remove();\n              }\n            } else\n              null !== d && d.append(f);\n        });\n      }\n  };\n  return LexicalLink_prod;\n}\nconst LexicalLink = process.env.NODE_ENV === \"development\" ? requireLexicalLink_dev() : requireLexicalLink_prod();\nvar LexicalLink_1 = LexicalLink;\nvar LexicalList_dev = {};\nvar hasRequiredLexicalList_dev;\nfunction requireLexicalList_dev() {\n  if (hasRequiredLexicalList_dev)\n    return LexicalList_dev;\n  hasRequiredLexicalList_dev = 1;\n  var lexical = require$$1;\n  var utils = requireLexicalUtils();\n  function $getListDepth(listNode) {\n    let depth = 1;\n    let parent = listNode.getParent();\n    while (parent != null) {\n      if ($isListItemNode(parent)) {\n        const parentList = parent.getParent();\n        if ($isListNode(parentList)) {\n          depth++;\n          parent = parentList.getParent();\n          continue;\n        }\n        {\n          throw Error(`A ListItemNode must have a ListNode for a parent.`);\n        }\n      }\n      return depth;\n    }\n    return depth;\n  }\n  function $getTopListNode(listItem) {\n    let list = listItem.getParent();\n    if (!$isListNode(list)) {\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    let parent = list;\n    while (parent !== null) {\n      parent = parent.getParent();\n      if ($isListNode(parent)) {\n        list = parent;\n      }\n    }\n    return list;\n  }\n  function $getAllListItems(node) {\n    let listItemNodes = [];\n    const listChildren = node.getChildren().filter($isListItemNode);\n    for (let i = 0; i < listChildren.length; i++) {\n      const listItemNode = listChildren[i];\n      const firstChild = listItemNode.getFirstChild();\n      if ($isListNode(firstChild)) {\n        listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n      } else {\n        listItemNodes.push(listItemNode);\n      }\n    }\n    return listItemNodes;\n  }\n  function isNestedListNode(node) {\n    return $isListItemNode(node) && $isListNode(node.getFirstChild());\n  }\n  function $removeHighestEmptyListParent(sublist) {\n    let emptyListPtr = sublist;\n    while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n      const parent = emptyListPtr.getParent();\n      if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n        break;\n      }\n      emptyListPtr = parent;\n    }\n    emptyListPtr.remove();\n  }\n  function wrapInListItem(node) {\n    const listItemWrapper = $createListItemNode();\n    return listItemWrapper.append(node);\n  }\n  function $isSelectingEmptyListItem(anchorNode, nodes) {\n    return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n  }\n  function $getListItemValue(listItem) {\n    const list = listItem.getParent();\n    let value2 = 1;\n    if (list != null) {\n      if (!$isListNode(list)) {\n        {\n          throw Error(`$getListItemValue: list node is not parent of list item node`);\n        }\n      } else {\n        value2 = list.getStart();\n      }\n    }\n    const siblings = listItem.getPreviousSiblings();\n    for (let i = 0; i < siblings.length; i++) {\n      const sibling = siblings[i];\n      if ($isListItemNode(sibling) && !$isListNode(sibling.getFirstChild())) {\n        value2++;\n      }\n    }\n    return value2;\n  }\n  function insertList(editor, listType) {\n    editor.update(() => {\n      const selection = lexical.$getSelection();\n      if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n        const nodes = selection.getNodes();\n        const anchor = selection.anchor;\n        const anchorNode = anchor.getNode();\n        const anchorNodeParent = anchorNode.getParent();\n        if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n          const list = $createListNode(listType);\n          if (lexical.$isRootOrShadowRoot(anchorNodeParent)) {\n            anchorNode.replace(list);\n            const listItem = $createListItemNode();\n            if (lexical.$isElementNode(anchorNode)) {\n              listItem.setFormat(anchorNode.getFormatType());\n              listItem.setIndent(anchorNode.getIndent());\n            }\n            list.append(listItem);\n          } else if ($isListItemNode(anchorNode)) {\n            const parent = anchorNode.getParentOrThrow();\n            append(list, parent.getChildren());\n            parent.replace(list);\n          }\n          return;\n        } else {\n          const handled = /* @__PURE__ */ new Set();\n          for (let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (lexical.$isElementNode(node) && node.isEmpty() && !handled.has(node.getKey())) {\n              createListOrMerge(node, listType);\n              continue;\n            }\n            if (lexical.$isLeafNode(node)) {\n              let parent = node.getParent();\n              while (parent != null) {\n                const parentKey = parent.getKey();\n                if ($isListNode(parent)) {\n                  if (!handled.has(parentKey)) {\n                    const newListNode = $createListNode(listType);\n                    append(newListNode, parent.getChildren());\n                    parent.replace(newListNode);\n                    updateChildrenListItemValue(newListNode);\n                    handled.add(parentKey);\n                  }\n                  break;\n                } else {\n                  const nextParent = parent.getParent();\n                  if (lexical.$isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                    handled.add(parentKey);\n                    createListOrMerge(parent, listType);\n                    break;\n                  }\n                  parent = nextParent;\n                }\n              }\n            }\n          }\n        }\n      }\n    });\n  }\n  function append(node, nodesToAppend) {\n    node.splice(node.getChildrenSize(), 0, nodesToAppend);\n  }\n  function createListOrMerge(node, listType) {\n    if ($isListNode(node)) {\n      return node;\n    }\n    const previousSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling();\n    const listItem = $createListItemNode();\n    listItem.setFormat(node.getFormatType());\n    listItem.setIndent(node.getIndent());\n    append(listItem, node.getChildren());\n    if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n      previousSibling.append(listItem);\n      node.remove();\n      if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n        append(previousSibling, nextSibling.getChildren());\n        nextSibling.remove();\n      }\n      return previousSibling;\n    } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n      node.remove();\n      return nextSibling;\n    } else {\n      const list = $createListNode(listType);\n      list.append(listItem);\n      node.replace(list);\n      updateChildrenListItemValue(list);\n      return list;\n    }\n  }\n  function removeList(editor) {\n    editor.update(() => {\n      const selection = lexical.$getSelection();\n      if (lexical.$isRangeSelection(selection)) {\n        const listNodes = /* @__PURE__ */ new Set();\n        const nodes = selection.getNodes();\n        const anchorNode = selection.anchor.getNode();\n        if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n          listNodes.add($getTopListNode(anchorNode));\n        } else {\n          for (let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (lexical.$isLeafNode(node)) {\n              const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode);\n              if (listItemNode != null) {\n                listNodes.add($getTopListNode(listItemNode));\n              }\n            }\n          }\n        }\n        for (const listNode of listNodes) {\n          let insertionPoint = listNode;\n          const listItems = $getAllListItems(listNode);\n          for (const listItemNode of listItems) {\n            const paragraph = lexical.$createParagraphNode();\n            append(paragraph, listItemNode.getChildren());\n            insertionPoint.insertAfter(paragraph);\n            insertionPoint = paragraph;\n            if (listItemNode.__key === selection.anchor.key) {\n              selection.anchor.set(paragraph.getKey(), 0, \"element\");\n            }\n            if (listItemNode.__key === selection.focus.key) {\n              selection.focus.set(paragraph.getKey(), 0, \"element\");\n            }\n            listItemNode.remove();\n          }\n          listNode.remove();\n        }\n      }\n    });\n  }\n  function updateChildrenListItemValue(list, children) {\n    const childrenOrExisting = children || list.getChildren();\n    if (childrenOrExisting !== void 0) {\n      for (let i = 0; i < childrenOrExisting.length; i++) {\n        const child = childrenOrExisting[i];\n        if ($isListItemNode(child)) {\n          const prevValue = child.getValue();\n          const nextValue = $getListItemValue(child);\n          if (prevValue !== nextValue) {\n            child.setValue(nextValue);\n          }\n        }\n      }\n    }\n  }\n  function $handleIndent(listItemNode) {\n    const removed = /* @__PURE__ */ new Set();\n    if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n      return;\n    }\n    const parent = listItemNode.getParent();\n    const nextSibling = listItemNode.getNextSibling();\n    const previousSibling = listItemNode.getPreviousSibling();\n    if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n      const innerList = previousSibling.getFirstChild();\n      if ($isListNode(innerList)) {\n        innerList.append(listItemNode);\n        const nextInnerList = nextSibling.getFirstChild();\n        if ($isListNode(nextInnerList)) {\n          const children = nextInnerList.getChildren();\n          append(innerList, children);\n          nextSibling.remove();\n          removed.add(nextSibling.getKey());\n        }\n        updateChildrenListItemValue(innerList);\n      }\n    } else if (isNestedListNode(nextSibling)) {\n      const innerList = nextSibling.getFirstChild();\n      if ($isListNode(innerList)) {\n        const firstChild = innerList.getFirstChild();\n        if (firstChild !== null) {\n          firstChild.insertBefore(listItemNode);\n        }\n        updateChildrenListItemValue(innerList);\n      }\n    } else if (isNestedListNode(previousSibling)) {\n      const innerList = previousSibling.getFirstChild();\n      if ($isListNode(innerList)) {\n        innerList.append(listItemNode);\n        updateChildrenListItemValue(innerList);\n      }\n    } else {\n      if ($isListNode(parent)) {\n        const newListItem = $createListItemNode();\n        const newList = $createListNode(parent.getListType());\n        newListItem.append(newList);\n        newList.append(listItemNode);\n        if (previousSibling) {\n          previousSibling.insertAfter(newListItem);\n        } else if (nextSibling) {\n          nextSibling.insertBefore(newListItem);\n        } else {\n          parent.append(newListItem);\n        }\n      }\n    }\n    if ($isListNode(parent)) {\n      updateChildrenListItemValue(parent);\n    }\n  }\n  function $handleOutdent(listItemNode) {\n    if (isNestedListNode(listItemNode)) {\n      return;\n    }\n    const parentList = listItemNode.getParent();\n    const grandparentListItem = parentList ? parentList.getParent() : void 0;\n    const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : void 0;\n    if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n      const firstChild = parentList ? parentList.getFirstChild() : void 0;\n      const lastChild = parentList ? parentList.getLastChild() : void 0;\n      if (listItemNode.is(firstChild)) {\n        grandparentListItem.insertBefore(listItemNode);\n        if (parentList.isEmpty()) {\n          grandparentListItem.remove();\n        }\n      } else if (listItemNode.is(lastChild)) {\n        grandparentListItem.insertAfter(listItemNode);\n        if (parentList.isEmpty()) {\n          grandparentListItem.remove();\n        }\n      } else {\n        const listType = parentList.getListType();\n        const previousSiblingsListItem = $createListItemNode();\n        const previousSiblingsList = $createListNode(listType);\n        previousSiblingsListItem.append(previousSiblingsList);\n        listItemNode.getPreviousSiblings().forEach((sibling) => previousSiblingsList.append(sibling));\n        const nextSiblingsListItem = $createListItemNode();\n        const nextSiblingsList = $createListNode(listType);\n        nextSiblingsListItem.append(nextSiblingsList);\n        append(nextSiblingsList, listItemNode.getNextSiblings());\n        grandparentListItem.insertBefore(previousSiblingsListItem);\n        grandparentListItem.insertAfter(nextSiblingsListItem);\n        grandparentListItem.replace(listItemNode);\n      }\n      updateChildrenListItemValue(parentList);\n      updateChildrenListItemValue(greatGrandparentList);\n    }\n  }\n  function $handleListInsertParagraph() {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n      return false;\n    }\n    const anchor = selection.anchor.getNode();\n    if (!$isListItemNode(anchor) || anchor.getTextContent() !== \"\") {\n      return false;\n    }\n    const topListNode = $getTopListNode(anchor);\n    const parent = anchor.getParent();\n    if (!$isListNode(parent)) {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n    const grandparent = parent.getParent();\n    let replacementNode;\n    if (lexical.$isRootOrShadowRoot(grandparent)) {\n      replacementNode = lexical.$createParagraphNode();\n      topListNode.insertAfter(replacementNode);\n    } else if ($isListItemNode(grandparent)) {\n      replacementNode = $createListItemNode();\n      grandparent.insertAfter(replacementNode);\n    } else {\n      return false;\n    }\n    replacementNode.select();\n    const nextSiblings = anchor.getNextSiblings();\n    if (nextSiblings.length > 0) {\n      const newList = $createListNode(parent.getListType());\n      if (lexical.$isParagraphNode(replacementNode)) {\n        replacementNode.insertAfter(newList);\n      } else {\n        const newListItem = $createListItemNode();\n        newListItem.append(newList);\n        replacementNode.insertAfter(newListItem);\n      }\n      nextSiblings.forEach((sibling) => {\n        sibling.remove();\n        newList.append(sibling);\n      });\n    }\n    $removeHighestEmptyListParent(anchor);\n    return true;\n  }\n  class ListItemNode extends lexical.ElementNode {\n    /** @internal */\n    /** @internal */\n    static getType() {\n      return \"listitem\";\n    }\n    static clone(node) {\n      return new ListItemNode(node.__value, node.__checked, node.__key);\n    }\n    constructor(value2, checked, key) {\n      super(key);\n      this.__value = value2 === void 0 ? 1 : value2;\n      this.__checked = checked;\n    }\n    createDOM(config) {\n      const element = document.createElement(\"li\");\n      const parent = this.getParent();\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n        updateListItemChecked(element, this, null, parent);\n      }\n      element.value = this.__value;\n      $setListItemThemeClassNames(element, config.theme, this);\n      return element;\n    }\n    updateDOM(prevNode, dom, config) {\n      const parent = this.getParent();\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n        updateListItemChecked(dom, this, prevNode, parent);\n      }\n      dom.value = this.__value;\n      $setListItemThemeClassNames(dom, config.theme, this);\n      return false;\n    }\n    static importDOM() {\n      return {\n        li: (node) => ({\n          conversion: convertListItemElement,\n          priority: 0\n        })\n      };\n    }\n    static importJSON(serializedNode) {\n      const node = new ListItemNode(serializedNode.value, serializedNode.checked);\n      node.setFormat(serializedNode.format);\n      node.setIndent(serializedNode.indent);\n      node.setDirection(serializedNode.direction);\n      return node;\n    }\n    exportJSON() {\n      return {\n        ...super.exportJSON(),\n        checked: this.getChecked(),\n        type: \"listitem\",\n        value: this.getValue(),\n        version: 1\n      };\n    }\n    append(...nodes) {\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (lexical.$isElementNode(node) && this.canMergeWith(node)) {\n          const children = node.getChildren();\n          this.append(...children);\n          node.remove();\n        } else {\n          super.append(node);\n        }\n      }\n      return this;\n    }\n    replace(replaceWithNode, includeChildren) {\n      if ($isListItemNode(replaceWithNode)) {\n        return super.replace(replaceWithNode);\n      }\n      const list = this.getParentOrThrow();\n      if ($isListNode(list)) {\n        const childrenKeys = list.getChildrenKeys();\n        const childrenLength = childrenKeys.length;\n        const index = childrenKeys.indexOf(this.__key);\n        if (index === 0) {\n          list.insertBefore(replaceWithNode);\n        } else if (index === childrenLength - 1) {\n          list.insertAfter(replaceWithNode);\n        } else {\n          const newList = $createListNode(list.getListType());\n          const children = list.getChildren();\n          for (let i = index + 1; i < childrenLength; i++) {\n            const child = children[i];\n            newList.append(child);\n          }\n          list.insertAfter(replaceWithNode);\n          replaceWithNode.insertAfter(newList);\n        }\n        if (includeChildren) {\n          this.getChildren().forEach((child) => {\n            replaceWithNode.append(child);\n          });\n        }\n        this.remove();\n        if (childrenLength === 1) {\n          list.remove();\n        }\n      }\n      return replaceWithNode;\n    }\n    insertAfter(node, restoreSelection = true) {\n      const listNode = this.getParentOrThrow();\n      if (!$isListNode(listNode)) {\n        {\n          throw Error(`insertAfter: list node is not parent of list item node`);\n        }\n      }\n      const siblings = this.getNextSiblings();\n      if ($isListItemNode(node)) {\n        const after = super.insertAfter(node, restoreSelection);\n        const afterListNode = node.getParentOrThrow();\n        if ($isListNode(afterListNode)) {\n          updateChildrenListItemValue(afterListNode);\n        }\n        return after;\n      }\n      if ($isListNode(node) && node.getListType() === listNode.getListType()) {\n        let child = node;\n        const children = node.getChildren();\n        for (let i = children.length - 1; i >= 0; i--) {\n          child = children[i];\n          this.insertAfter(child, restoreSelection);\n        }\n        return child;\n      }\n      listNode.insertAfter(node, restoreSelection);\n      if (siblings.length !== 0) {\n        const newListNode = $createListNode(listNode.getListType());\n        siblings.forEach((sibling) => newListNode.append(sibling));\n        node.insertAfter(newListNode, restoreSelection);\n      }\n      return node;\n    }\n    remove(preserveEmptyParent) {\n      const nextSibling = this.getNextSibling();\n      super.remove(preserveEmptyParent);\n      if (nextSibling !== null) {\n        const parent = nextSibling.getParent();\n        if ($isListNode(parent)) {\n          updateChildrenListItemValue(parent);\n        }\n      }\n    }\n    insertNewAfter(_, restoreSelection = true) {\n      const newElement = $createListItemNode(this.__checked == null ? void 0 : false);\n      this.insertAfter(newElement, restoreSelection);\n      return newElement;\n    }\n    collapseAtStart(selection) {\n      const paragraph = lexical.$createParagraphNode();\n      const children = this.getChildren();\n      children.forEach((child) => paragraph.append(child));\n      const listNode = this.getParentOrThrow();\n      const listNodeParent = listNode.getParentOrThrow();\n      const isIndented = $isListItemNode(listNodeParent);\n      if (listNode.getChildrenSize() === 1) {\n        if (isIndented) {\n          listNode.remove();\n          listNodeParent.select();\n        } else {\n          listNode.insertBefore(paragraph);\n          listNode.remove();\n          const anchor = selection.anchor;\n          const focus = selection.focus;\n          const key = paragraph.getKey();\n          if (anchor.type === \"element\" && anchor.getNode().is(this)) {\n            anchor.set(key, anchor.offset, \"element\");\n          }\n          if (focus.type === \"element\" && focus.getNode().is(this)) {\n            focus.set(key, focus.offset, \"element\");\n          }\n        }\n      } else {\n        listNode.insertBefore(paragraph);\n        this.remove();\n      }\n      return true;\n    }\n    getValue() {\n      const self2 = this.getLatest();\n      return self2.__value;\n    }\n    setValue(value2) {\n      const self2 = this.getWritable();\n      self2.__value = value2;\n    }\n    getChecked() {\n      const self2 = this.getLatest();\n      return self2.__checked;\n    }\n    setChecked(checked) {\n      const self2 = this.getWritable();\n      self2.__checked = checked;\n    }\n    toggleChecked() {\n      this.setChecked(!this.__checked);\n    }\n    getIndent() {\n      const parent = this.getParent();\n      if (parent === null) {\n        return this.getLatest().__indent;\n      }\n      let listNodeParent = parent.getParentOrThrow();\n      let indentLevel = 0;\n      while ($isListItemNode(listNodeParent)) {\n        listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n        indentLevel++;\n      }\n      return indentLevel;\n    }\n    setIndent(indent) {\n      let currentIndent = this.getIndent();\n      while (currentIndent !== indent) {\n        if (currentIndent < indent) {\n          $handleIndent(this);\n          currentIndent++;\n        } else {\n          $handleOutdent(this);\n          currentIndent--;\n        }\n      }\n      return this;\n    }\n    insertBefore(nodeToInsert) {\n      if ($isListItemNode(nodeToInsert)) {\n        const parent = this.getParentOrThrow();\n        if ($isListNode(parent)) {\n          const siblings = this.getNextSiblings();\n          updateChildrenListItemValue(parent, siblings);\n        }\n      }\n      return super.insertBefore(nodeToInsert);\n    }\n    canInsertAfter(node) {\n      return $isListItemNode(node);\n    }\n    canReplaceWith(replacement) {\n      return $isListItemNode(replacement);\n    }\n    canMergeWith(node) {\n      return lexical.$isParagraphNode(node) || $isListItemNode(node);\n    }\n    extractWithChild(child, selection) {\n      if (!lexical.$isRangeSelection(selection)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n    }\n    isParentRequired() {\n      return true;\n    }\n    createParentElementNode() {\n      return $createListNode(\"bullet\");\n    }\n  }\n  function $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n    const classesToAdd = [];\n    const classesToRemove = [];\n    const listTheme = editorThemeClasses.list;\n    const listItemClassName = listTheme ? listTheme.listitem : void 0;\n    let nestedListItemClassName;\n    if (listTheme && listTheme.nested) {\n      nestedListItemClassName = listTheme.nested.listitem;\n    }\n    if (listItemClassName !== void 0) {\n      const listItemClasses = listItemClassName.split(\" \");\n      classesToAdd.push(...listItemClasses);\n    }\n    if (listTheme) {\n      const parentNode = node.getParent();\n      const isCheckList = $isListNode(parentNode) && parentNode.getListType() === \"check\";\n      const checked = node.getChecked();\n      if (!isCheckList || checked) {\n        classesToRemove.push(listTheme.listitemUnchecked);\n      }\n      if (!isCheckList || !checked) {\n        classesToRemove.push(listTheme.listitemChecked);\n      }\n      if (isCheckList) {\n        classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n      }\n    }\n    if (nestedListItemClassName !== void 0) {\n      const nestedListItemClasses = nestedListItemClassName.split(\" \");\n      if (node.getChildren().some((child) => $isListNode(child))) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n    if (classesToRemove.length > 0) {\n      utils.removeClassNamesFromElement(dom, ...classesToRemove);\n    }\n    if (classesToAdd.length > 0) {\n      utils.addClassNamesToElement(dom, ...classesToAdd);\n    }\n  }\n  function updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n    const isCheckList = listNode.getListType() === \"check\";\n    if (isCheckList) {\n      if ($isListNode(listItemNode.getFirstChild())) {\n        dom.removeAttribute(\"role\");\n        dom.removeAttribute(\"tabIndex\");\n        dom.removeAttribute(\"aria-checked\");\n      } else {\n        dom.setAttribute(\"role\", \"checkbox\");\n        dom.setAttribute(\"tabIndex\", \"-1\");\n        if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n          dom.setAttribute(\"aria-checked\", listItemNode.getChecked() ? \"true\" : \"false\");\n        }\n      }\n    } else {\n      if (listItemNode.getChecked() != null) {\n        listItemNode.setChecked(void 0);\n      }\n    }\n  }\n  function convertListItemElement(domNode) {\n    const checked = utils.isHTMLElement(domNode) && domNode.getAttribute(\"aria-checked\") === \"true\";\n    return {\n      node: $createListItemNode(checked)\n    };\n  }\n  function $createListItemNode(checked) {\n    return lexical.$applyNodeReplacement(new ListItemNode(void 0, checked));\n  }\n  function $isListItemNode(node) {\n    return node instanceof ListItemNode;\n  }\n  class ListNode extends lexical.ElementNode {\n    /** @internal */\n    /** @internal */\n    /** @internal */\n    static getType() {\n      return \"list\";\n    }\n    static clone(node) {\n      const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n      return new ListNode(listType, node.__start, node.__key);\n    }\n    constructor(listType, start, key) {\n      super(key);\n      const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n      this.__listType = _listType;\n      this.__tag = _listType === \"number\" ? \"ol\" : \"ul\";\n      this.__start = start;\n    }\n    getTag() {\n      return this.__tag;\n    }\n    getListType() {\n      return this.__listType;\n    }\n    getStart() {\n      return this.__start;\n    }\n    // View\n    createDOM(config, _editor) {\n      const tag = this.__tag;\n      const dom = document.createElement(tag);\n      if (this.__start !== 1) {\n        dom.setAttribute(\"start\", String(this.__start));\n      }\n      dom.__lexicalListType = this.__listType;\n      setListThemeClassNames(dom, config.theme, this);\n      return dom;\n    }\n    updateDOM(prevNode, dom, config) {\n      if (prevNode.__tag !== this.__tag) {\n        return true;\n      }\n      setListThemeClassNames(dom, config.theme, this);\n      return false;\n    }\n    static importDOM() {\n      return {\n        ol: (node) => ({\n          conversion: convertListNode,\n          priority: 0\n        }),\n        ul: (node) => ({\n          conversion: convertListNode,\n          priority: 0\n        })\n      };\n    }\n    static importJSON(serializedNode) {\n      const node = $createListNode(serializedNode.listType, serializedNode.start);\n      node.setFormat(serializedNode.format);\n      node.setIndent(serializedNode.indent);\n      node.setDirection(serializedNode.direction);\n      return node;\n    }\n    exportDOM(editor) {\n      const {\n        element\n      } = super.exportDOM(editor);\n      if (element) {\n        if (this.__start !== 1) {\n          element.setAttribute(\"start\", String(this.__start));\n        }\n        if (this.__listType === \"check\") {\n          element.setAttribute(\"__lexicalListType\", \"check\");\n        }\n      }\n      return {\n        element\n      };\n    }\n    exportJSON() {\n      return {\n        ...super.exportJSON(),\n        listType: this.getListType(),\n        start: this.getStart(),\n        tag: this.getTag(),\n        type: \"list\",\n        version: 1\n      };\n    }\n    canBeEmpty() {\n      return false;\n    }\n    canIndent() {\n      return false;\n    }\n    append(...nodesToAppend) {\n      for (let i = 0; i < nodesToAppend.length; i++) {\n        const currentNode = nodesToAppend[i];\n        if ($isListItemNode(currentNode)) {\n          super.append(currentNode);\n        } else {\n          const listItemNode = $createListItemNode();\n          if ($isListNode(currentNode)) {\n            listItemNode.append(currentNode);\n          } else if (lexical.$isElementNode(currentNode)) {\n            const textNode = lexical.$createTextNode(currentNode.getTextContent());\n            listItemNode.append(textNode);\n          } else {\n            listItemNode.append(currentNode);\n          }\n          super.append(listItemNode);\n        }\n      }\n      return this;\n    }\n    extractWithChild(child) {\n      return $isListItemNode(child);\n    }\n  }\n  function setListThemeClassNames(dom, editorThemeClasses, node) {\n    const classesToAdd = [];\n    const classesToRemove = [];\n    const listTheme = editorThemeClasses.list;\n    if (listTheme !== void 0) {\n      const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n      const listDepth = $getListDepth(node) - 1;\n      const normalizedListDepth = listDepth % listLevelsClassNames.length;\n      const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n      const listClassName = listTheme[node.__tag];\n      let nestedListClassName;\n      const nestedListTheme = listTheme.nested;\n      if (nestedListTheme !== void 0 && nestedListTheme.list) {\n        nestedListClassName = nestedListTheme.list;\n      }\n      if (listClassName !== void 0) {\n        classesToAdd.push(listClassName);\n      }\n      if (listLevelClassName !== void 0) {\n        const listItemClasses = listLevelClassName.split(\" \");\n        classesToAdd.push(...listItemClasses);\n        for (let i = 0; i < listLevelsClassNames.length; i++) {\n          if (i !== normalizedListDepth) {\n            classesToRemove.push(node.__tag + i);\n          }\n        }\n      }\n      if (nestedListClassName !== void 0) {\n        const nestedListItemClasses = nestedListClassName.split(\" \");\n        if (listDepth > 1) {\n          classesToAdd.push(...nestedListItemClasses);\n        } else {\n          classesToRemove.push(...nestedListItemClasses);\n        }\n      }\n    }\n    if (classesToRemove.length > 0) {\n      utils.removeClassNamesFromElement(dom, ...classesToRemove);\n    }\n    if (classesToAdd.length > 0) {\n      utils.addClassNamesToElement(dom, ...classesToAdd);\n    }\n  }\n  function normalizeChildren(nodes) {\n    const normalizedListItems = [];\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isListItemNode(node)) {\n        normalizedListItems.push(node);\n        const children = node.getChildren();\n        if (children.length > 1) {\n          children.forEach((child) => {\n            if ($isListNode(child)) {\n              normalizedListItems.push(wrapInListItem(child));\n            }\n          });\n        }\n      } else {\n        normalizedListItems.push(wrapInListItem(node));\n      }\n    }\n    return normalizedListItems;\n  }\n  function convertListNode(domNode) {\n    const nodeName = domNode.nodeName.toLowerCase();\n    let node = null;\n    if (nodeName === \"ol\") {\n      node = $createListNode(\"number\");\n    } else if (nodeName === \"ul\") {\n      if (utils.isHTMLElement(domNode) && domNode.getAttribute(\"__lexicallisttype\") === \"check\") {\n        node = $createListNode(\"check\");\n      } else {\n        node = $createListNode(\"bullet\");\n      }\n    }\n    return {\n      after: normalizeChildren,\n      node\n    };\n  }\n  const TAG_TO_LIST_TYPE = {\n    ol: \"number\",\n    ul: \"bullet\"\n  };\n  function $createListNode(listType, start = 1) {\n    return lexical.$applyNodeReplacement(new ListNode(listType, start));\n  }\n  function $isListNode(node) {\n    return node instanceof ListNode;\n  }\n  const INSERT_UNORDERED_LIST_COMMAND = lexical.createCommand(\"INSERT_UNORDERED_LIST_COMMAND\");\n  const INSERT_ORDERED_LIST_COMMAND = lexical.createCommand(\"INSERT_ORDERED_LIST_COMMAND\");\n  const INSERT_CHECK_LIST_COMMAND = lexical.createCommand(\"INSERT_CHECK_LIST_COMMAND\");\n  const REMOVE_LIST_COMMAND = lexical.createCommand(\"REMOVE_LIST_COMMAND\");\n  LexicalList_dev.$createListItemNode = $createListItemNode;\n  LexicalList_dev.$createListNode = $createListNode;\n  LexicalList_dev.$getListDepth = $getListDepth;\n  LexicalList_dev.$handleListInsertParagraph = $handleListInsertParagraph;\n  LexicalList_dev.$isListItemNode = $isListItemNode;\n  LexicalList_dev.$isListNode = $isListNode;\n  LexicalList_dev.INSERT_CHECK_LIST_COMMAND = INSERT_CHECK_LIST_COMMAND;\n  LexicalList_dev.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND;\n  LexicalList_dev.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND;\n  LexicalList_dev.ListItemNode = ListItemNode;\n  LexicalList_dev.ListNode = ListNode;\n  LexicalList_dev.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND;\n  LexicalList_dev.insertList = insertList;\n  LexicalList_dev.removeList = removeList;\n  return LexicalList_dev;\n}\nvar LexicalList_prod = {};\nvar hasRequiredLexicalList_prod;\nfunction requireLexicalList_prod() {\n  if (hasRequiredLexicalList_prod)\n    return LexicalList_prod;\n  hasRequiredLexicalList_prod = 1;\n  var h = require$$1, k = requireLexicalUtils();\n  function m(a) {\n    throw Error(`Minified Lexical error #${a}; visit https://lexical.dev/docs/error?code=${a} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);\n  }\n  function n(a) {\n    let b = 1;\n    for (a = a.getParent(); null != a; ) {\n      if (p(a)) {\n        a = a.getParent();\n        if (q(a)) {\n          b++;\n          a = a.getParent();\n          continue;\n        }\n        m(40);\n      }\n      break;\n    }\n    return b;\n  }\n  function r(a) {\n    a = a.getParent();\n    q(a) || m(40);\n    let b = a;\n    for (; null !== b; )\n      b = b.getParent(), q(b) && (a = b);\n    return a;\n  }\n  function t(a) {\n    let b = [];\n    a = a.getChildren().filter(p);\n    for (let c = 0; c < a.length; c++) {\n      let d = a[c], e = d.getFirstChild();\n      q(e) ? b = b.concat(t(e)) : b.push(d);\n    }\n    return b;\n  }\n  function u(a) {\n    return p(a) && q(a.getFirstChild());\n  }\n  function v(a) {\n    for (; null == a.getNextSibling() && null == a.getPreviousSibling(); ) {\n      let b = a.getParent();\n      if (null == b || !p(a) && !q(a))\n        break;\n      a = b;\n    }\n    a.remove();\n  }\n  function w(a) {\n    return y().append(a);\n  }\n  function z(a, b) {\n    return p(a) && (0 === b.length || 1 === b.length && a.is(b[0]) && 0 === a.getChildrenSize());\n  }\n  function B(a, b) {\n    a.splice(a.getChildrenSize(), 0, b);\n  }\n  function C(a, b) {\n    if (q(a))\n      return a;\n    let c = a.getPreviousSibling(), d = a.getNextSibling(), e = y();\n    e.setFormat(a.getFormatType());\n    e.setIndent(a.getIndent());\n    B(e, a.getChildren());\n    if (q(c) && b === c.getListType())\n      return c.append(e), a.remove(), q(d) && b === d.getListType() && (B(c, d.getChildren()), d.remove()), c;\n    if (q(d) && b === d.getListType())\n      return d.getFirstChildOrThrow().insertBefore(e), a.remove(), d;\n    b = D(b);\n    b.append(e);\n    a.replace(b);\n    E(b);\n    return b;\n  }\n  function E(a, b) {\n    a = b || a.getChildren();\n    if (void 0 !== a)\n      for (b = 0; b < a.length; b++) {\n        let f = a[b];\n        if (p(f)) {\n          let g = f.getValue();\n          var c = f, d = c.getParent(), e = 1;\n          null != d && (q(d) ? e = d.getStart() : m(44));\n          c = c.getPreviousSiblings();\n          for (d = 0; d < c.length; d++) {\n            let l = c[d];\n            p(l) && !q(l.getFirstChild()) && e++;\n          }\n          g !== e && f.setValue(e);\n        }\n      }\n  }\n  function F(a) {\n    if (!u(a)) {\n      var b = a.getParent(), c = b ? b.getParent() : void 0, d = c ? c.getParent() : void 0;\n      if (q(d) && p(c) && q(b)) {\n        var e = b ? b.getFirstChild() : void 0, f = b ? b.getLastChild() : void 0;\n        if (a.is(e))\n          c.insertBefore(a), b.isEmpty() && c.remove();\n        else if (a.is(f))\n          c.insertAfter(a), b.isEmpty() && c.remove();\n        else {\n          var g = b.getListType();\n          e = y();\n          let l = D(g);\n          e.append(l);\n          a.getPreviousSiblings().forEach((x) => l.append(x));\n          f = y();\n          g = D(g);\n          f.append(g);\n          B(g, a.getNextSiblings());\n          c.insertBefore(e);\n          c.insertAfter(f);\n          c.replace(a);\n        }\n        E(b);\n        E(d);\n      }\n    }\n  }\n  class G extends h.ElementNode {\n    static getType() {\n      return \"listitem\";\n    }\n    static clone(a) {\n      return new G(a.__value, a.__checked, a.__key);\n    }\n    constructor(a, b, c) {\n      super(c);\n      this.__value = void 0 === a ? 1 : a;\n      this.__checked = b;\n    }\n    createDOM(a) {\n      let b = document.createElement(\"li\"), c = this.getParent();\n      q(c) && (E(c), H(b, this, null, c));\n      b.value = this.__value;\n      I(b, a.theme, this);\n      return b;\n    }\n    updateDOM(a, b, c) {\n      let d = this.getParent();\n      q(d) && (E(d), H(b, this, a, d));\n      b.value = this.__value;\n      I(b, c.theme, this);\n      return false;\n    }\n    static importDOM() {\n      return { li: () => ({\n        conversion: J,\n        priority: 0\n      }) };\n    }\n    static importJSON(a) {\n      let b = new G(a.value, a.checked);\n      b.setFormat(a.format);\n      b.setIndent(a.indent);\n      b.setDirection(a.direction);\n      return b;\n    }\n    exportJSON() {\n      return { ...super.exportJSON(), checked: this.getChecked(), type: \"listitem\", value: this.getValue(), version: 1 };\n    }\n    append(...a) {\n      for (let b = 0; b < a.length; b++) {\n        let c = a[b];\n        if (h.$isElementNode(c) && this.canMergeWith(c)) {\n          let d = c.getChildren();\n          this.append(...d);\n          c.remove();\n        } else\n          super.append(c);\n      }\n      return this;\n    }\n    replace(a, b) {\n      if (p(a))\n        return super.replace(a);\n      let c = this.getParentOrThrow();\n      if (q(c)) {\n        var d = c.getChildrenKeys();\n        let f = d.length;\n        var e = d.indexOf(this.__key);\n        if (0 === e)\n          c.insertBefore(a);\n        else if (e === f - 1)\n          c.insertAfter(a);\n        else {\n          d = D(c.getListType());\n          let g = c.getChildren();\n          for (e += 1; e < f; e++)\n            d.append(g[e]);\n          c.insertAfter(a);\n          a.insertAfter(d);\n        }\n        b && this.getChildren().forEach((g) => {\n          a.append(g);\n        });\n        this.remove();\n        1 === f && c.remove();\n      }\n      return a;\n    }\n    insertAfter(a, b = true) {\n      var c = this.getParentOrThrow();\n      q(c) || m(39);\n      var d = this.getNextSiblings();\n      if (p(a))\n        return b = super.insertAfter(a, b), a = a.getParentOrThrow(), q(a) && E(a), b;\n      if (q(a) && a.getListType() === c.getListType()) {\n        c = a;\n        a = a.getChildren();\n        for (d = a.length - 1; 0 <= d; d--)\n          c = a[d], this.insertAfter(c, b);\n        return c;\n      }\n      c.insertAfter(a, b);\n      if (0 !== d.length) {\n        let e = D(c.getListType());\n        d.forEach((f) => e.append(f));\n        a.insertAfter(e, b);\n      }\n      return a;\n    }\n    remove(a) {\n      let b = this.getNextSibling();\n      super.remove(a);\n      null !== b && (a = b.getParent(), q(a) && E(a));\n    }\n    insertNewAfter(a, b = true) {\n      a = y(null == this.__checked ? void 0 : false);\n      this.insertAfter(a, b);\n      return a;\n    }\n    collapseAtStart(a) {\n      let b = h.$createParagraphNode();\n      this.getChildren().forEach((f) => b.append(f));\n      var c = this.getParentOrThrow(), d = c.getParentOrThrow();\n      let e = p(d);\n      1 === c.getChildrenSize() ? e ? (c.remove(), d.select()) : (c.insertBefore(b), c.remove(), c = a.anchor, a = a.focus, d = b.getKey(), \"element\" === c.type && c.getNode().is(this) && c.set(d, c.offset, \"element\"), \"element\" === a.type && a.getNode().is(this) && a.set(d, a.offset, \"element\")) : (c.insertBefore(b), this.remove());\n      return true;\n    }\n    getValue() {\n      return this.getLatest().__value;\n    }\n    setValue(a) {\n      this.getWritable().__value = a;\n    }\n    getChecked() {\n      return this.getLatest().__checked;\n    }\n    setChecked(a) {\n      this.getWritable().__checked = a;\n    }\n    toggleChecked() {\n      this.setChecked(!this.__checked);\n    }\n    getIndent() {\n      var a = this.getParent();\n      if (null === a)\n        return this.getLatest().__indent;\n      a = a.getParentOrThrow();\n      let b = 0;\n      for (; p(a); )\n        a = a.getParentOrThrow().getParentOrThrow(), b++;\n      return b;\n    }\n    setIndent(a) {\n      let b = this.getIndent();\n      for (; b !== a; )\n        if (b < a) {\n          a: {\n            var c = /* @__PURE__ */ new Set();\n            if (u(this) || c.has(this.getKey()))\n              break a;\n            let g = this.getParent();\n            var d = this.getNextSibling(), e = this.getPreviousSibling();\n            if (u(d) && u(e)) {\n              if (e = e.getFirstChild(), q(e)) {\n                e.append(this);\n                var f = d.getFirstChild();\n                q(f) && (f = f.getChildren(), B(e, f), d.remove(), c.add(d.getKey()));\n                E(e);\n              }\n            } else\n              u(d) ? (d = d.getFirstChild(), q(d) && (c = d.getFirstChild(), null !== c && c.insertBefore(this), E(d))) : u(e) ? (d = e.getFirstChild(), q(d) && (d.append(this), E(d))) : q(g) && (c = y(), f = D(g.getListType()), c.append(f), f.append(this), e ? e.insertAfter(c) : d ? d.insertBefore(c) : g.append(c));\n            q(g) && E(g);\n          }\n          b++;\n        } else\n          F(this), b--;\n      return this;\n    }\n    insertBefore(a) {\n      if (p(a)) {\n        let b = this.getParentOrThrow();\n        if (q(b)) {\n          let c = this.getNextSiblings();\n          E(b, c);\n        }\n      }\n      return super.insertBefore(a);\n    }\n    canInsertAfter(a) {\n      return p(a);\n    }\n    canReplaceWith(a) {\n      return p(a);\n    }\n    canMergeWith(a) {\n      return h.$isParagraphNode(a) || p(a);\n    }\n    extractWithChild(a, b) {\n      if (!h.$isRangeSelection(b))\n        return false;\n      a = b.anchor.getNode();\n      let c = b.focus.getNode();\n      return this.isParentOf(a) && this.isParentOf(c) && this.getTextContent().length === b.getTextContent().length;\n    }\n    isParentRequired() {\n      return true;\n    }\n    createParentElementNode() {\n      return D(\"bullet\");\n    }\n  }\n  function I(a, b, c) {\n    let d = [], e = [];\n    var f = (b = b.list) ? b.listitem : void 0;\n    if (b && b.nested)\n      var g = b.nested.listitem;\n    void 0 !== f && (f = f.split(\" \"), d.push(...f));\n    if (b) {\n      f = c.getParent();\n      f = q(f) && \"check\" === f.getListType();\n      let l = c.getChecked();\n      f && !l || e.push(b.listitemUnchecked);\n      f && l || e.push(b.listitemChecked);\n      f && d.push(l ? b.listitemChecked : b.listitemUnchecked);\n    }\n    void 0 !== g && (g = g.split(\" \"), c.getChildren().some((l) => q(l)) ? d.push(...g) : e.push(...g));\n    0 < e.length && k.removeClassNamesFromElement(a, ...e);\n    0 < d.length && k.addClassNamesToElement(\n      a,\n      ...d\n    );\n  }\n  function H(a, b, c, d) {\n    \"check\" === d.getListType() ? q(b.getFirstChild()) ? (a.removeAttribute(\"role\"), a.removeAttribute(\"tabIndex\"), a.removeAttribute(\"aria-checked\")) : (a.setAttribute(\"role\", \"checkbox\"), a.setAttribute(\"tabIndex\", \"-1\"), c && b.__checked === c.__checked || a.setAttribute(\"aria-checked\", b.getChecked() ? \"true\" : \"false\")) : null != b.getChecked() && b.setChecked(void 0);\n  }\n  function J(a) {\n    a = k.isHTMLElement(a) && \"true\" === a.getAttribute(\"aria-checked\");\n    return { node: y(a) };\n  }\n  function y(a) {\n    return h.$applyNodeReplacement(new G(void 0, a));\n  }\n  function p(a) {\n    return a instanceof G;\n  }\n  class K extends h.ElementNode {\n    static getType() {\n      return \"list\";\n    }\n    static clone(a) {\n      return new K(a.__listType || M[a.__tag], a.__start, a.__key);\n    }\n    constructor(a, b, c) {\n      super(c);\n      this.__listType = a = M[a] || a;\n      this.__tag = \"number\" === a ? \"ol\" : \"ul\";\n      this.__start = b;\n    }\n    getTag() {\n      return this.__tag;\n    }\n    getListType() {\n      return this.__listType;\n    }\n    getStart() {\n      return this.__start;\n    }\n    createDOM(a) {\n      let b = document.createElement(this.__tag);\n      1 !== this.__start && b.setAttribute(\"start\", String(this.__start));\n      b.__lexicalListType = this.__listType;\n      N(b, a.theme, this);\n      return b;\n    }\n    updateDOM(a, b, c) {\n      if (a.__tag !== this.__tag)\n        return true;\n      N(b, c.theme, this);\n      return false;\n    }\n    static importDOM() {\n      return { ol: () => ({ conversion: O, priority: 0 }), ul: () => ({ conversion: O, priority: 0 }) };\n    }\n    static importJSON(a) {\n      let b = D(a.listType, a.start);\n      b.setFormat(a.format);\n      b.setIndent(a.indent);\n      b.setDirection(a.direction);\n      return b;\n    }\n    exportDOM(a) {\n      ({ element: a } = super.exportDOM(a));\n      a && (1 !== this.__start && a.setAttribute(\"start\", String(this.__start)), \"check\" === this.__listType && a.setAttribute(\"__lexicalListType\", \"check\"));\n      return { element: a };\n    }\n    exportJSON() {\n      return {\n        ...super.exportJSON(),\n        listType: this.getListType(),\n        start: this.getStart(),\n        tag: this.getTag(),\n        type: \"list\",\n        version: 1\n      };\n    }\n    canBeEmpty() {\n      return false;\n    }\n    canIndent() {\n      return false;\n    }\n    append(...a) {\n      for (let c = 0; c < a.length; c++) {\n        var b = a[c];\n        if (p(b))\n          super.append(b);\n        else {\n          let d = y();\n          q(b) ? d.append(b) : h.$isElementNode(b) ? (b = h.$createTextNode(b.getTextContent()), d.append(b)) : d.append(b);\n          super.append(d);\n        }\n      }\n      return this;\n    }\n    extractWithChild(a) {\n      return p(a);\n    }\n  }\n  function N(a, b, c) {\n    let d = [], e = [];\n    var f = b.list;\n    if (void 0 !== f) {\n      let l = f[`${c.__tag}Depth`] || [];\n      b = n(c) - 1;\n      let x = b % l.length;\n      var g = l[x];\n      let L = f[c.__tag], A;\n      f = f.nested;\n      void 0 !== f && f.list && (A = f.list);\n      void 0 !== L && d.push(L);\n      if (void 0 !== g)\n        for (g = g.split(\" \"), d.push(...g), g = 0; g < l.length; g++)\n          g !== x && e.push(c.__tag + g);\n      void 0 !== A && (c = A.split(\" \"), 1 < b ? d.push(...c) : e.push(...c));\n    }\n    0 < e.length && k.removeClassNamesFromElement(a, ...e);\n    0 < d.length && k.addClassNamesToElement(a, ...d);\n  }\n  function P(a) {\n    let b = [];\n    for (let d = 0; d < a.length; d++) {\n      var c = a[d];\n      p(c) ? (b.push(c), c = c.getChildren(), 1 < c.length && c.forEach((e) => {\n        q(e) && b.push(w(e));\n      })) : b.push(w(c));\n    }\n    return b;\n  }\n  function O(a) {\n    let b = a.nodeName.toLowerCase(), c = null;\n    \"ol\" === b ? c = D(\"number\") : \"ul\" === b && (c = k.isHTMLElement(a) && \"check\" === a.getAttribute(\"__lexicallisttype\") ? D(\"check\") : D(\"bullet\"));\n    return { after: P, node: c };\n  }\n  let M = { ol: \"number\", ul: \"bullet\" };\n  function D(a, b = 1) {\n    return h.$applyNodeReplacement(new K(a, b));\n  }\n  function q(a) {\n    return a instanceof K;\n  }\n  let Q = h.createCommand(\"INSERT_UNORDERED_LIST_COMMAND\"), R = h.createCommand(\"INSERT_ORDERED_LIST_COMMAND\"), S = h.createCommand(\"INSERT_CHECK_LIST_COMMAND\"), T = h.createCommand(\"REMOVE_LIST_COMMAND\");\n  LexicalList_prod.$createListItemNode = y;\n  LexicalList_prod.$createListNode = D;\n  LexicalList_prod.$getListDepth = n;\n  LexicalList_prod.$handleListInsertParagraph = function() {\n    var a = h.$getSelection();\n    if (!h.$isRangeSelection(a) || !a.isCollapsed())\n      return false;\n    a = a.anchor.getNode();\n    if (!p(a) || \"\" !== a.getTextContent())\n      return false;\n    var b = r(a), c = a.getParent();\n    q(c) || m(40);\n    let d = c.getParent(), e;\n    if (h.$isRootOrShadowRoot(d))\n      e = h.$createParagraphNode(), b.insertAfter(e);\n    else if (p(d))\n      e = y(), d.insertAfter(e);\n    else\n      return false;\n    e.select();\n    b = a.getNextSiblings();\n    if (0 < b.length) {\n      let f = D(c.getListType());\n      h.$isParagraphNode(e) ? e.insertAfter(f) : (c = y(), c.append(f), e.insertAfter(c));\n      b.forEach((g) => {\n        g.remove();\n        f.append(g);\n      });\n    }\n    v(a);\n    return true;\n  };\n  LexicalList_prod.$isListItemNode = p;\n  LexicalList_prod.$isListNode = q;\n  LexicalList_prod.INSERT_CHECK_LIST_COMMAND = S;\n  LexicalList_prod.INSERT_ORDERED_LIST_COMMAND = R;\n  LexicalList_prod.INSERT_UNORDERED_LIST_COMMAND = Q;\n  LexicalList_prod.ListItemNode = G;\n  LexicalList_prod.ListNode = K;\n  LexicalList_prod.REMOVE_LIST_COMMAND = T;\n  LexicalList_prod.insertList = function(a, b) {\n    a.update(() => {\n      var c = h.$getSelection();\n      if (h.$isRangeSelection(c) || h.DEPRECATED_$isGridSelection(c)) {\n        var d = c.getNodes();\n        c = c.anchor.getNode();\n        var e = c.getParent();\n        if (z(c, d))\n          d = D(b), h.$isRootOrShadowRoot(e) ? (c.replace(d), e = y(), h.$isElementNode(c) && (e.setFormat(c.getFormatType()), e.setIndent(c.getIndent())), d.append(e)) : p(c) && (c = c.getParentOrThrow(), B(d, c.getChildren()), c.replace(d));\n        else\n          for (c = /* @__PURE__ */ new Set(), e = 0; e < d.length; e++) {\n            var f = d[e];\n            if (h.$isElementNode(f) && f.isEmpty() && !c.has(f.getKey()))\n              C(\n                f,\n                b\n              );\n            else if (h.$isLeafNode(f))\n              for (f = f.getParent(); null != f; ) {\n                let l = f.getKey();\n                if (q(f)) {\n                  if (!c.has(l)) {\n                    var g = D(b);\n                    B(g, f.getChildren());\n                    f.replace(g);\n                    E(g);\n                    c.add(l);\n                  }\n                  break;\n                } else {\n                  g = f.getParent();\n                  if (h.$isRootOrShadowRoot(g) && !c.has(l)) {\n                    c.add(l);\n                    C(f, b);\n                    break;\n                  }\n                  f = g;\n                }\n              }\n          }\n      }\n    });\n  };\n  LexicalList_prod.removeList = function(a) {\n    a.update(() => {\n      let b = h.$getSelection();\n      if (h.$isRangeSelection(b)) {\n        var c = /* @__PURE__ */ new Set(), d = b.getNodes(), e = b.anchor.getNode();\n        if (z(e, d))\n          c.add(r(e));\n        else\n          for (e = 0; e < d.length; e++) {\n            var f = d[e];\n            h.$isLeafNode(f) && (f = k.$getNearestNodeOfType(f, G), null != f && c.add(r(f)));\n          }\n        for (let g of c) {\n          c = g;\n          d = t(g);\n          for (let l of d)\n            d = h.$createParagraphNode(), B(d, l.getChildren()), c.insertAfter(d), c = d, l.__key === b.anchor.key && b.anchor.set(d.getKey(), 0, \"element\"), l.__key === b.focus.key && b.focus.set(d.getKey(), 0, \"element\"), l.remove();\n          g.remove();\n        }\n      }\n    });\n  };\n  return LexicalList_prod;\n}\nconst LexicalList = process.env.NODE_ENV === \"development\" ? requireLexicalList_dev() : requireLexicalList_prod();\nvar LexicalList_1 = LexicalList;\nvar LexicalMarkdown_dev = {};\nvar LexicalRichText_dev = {};\nvar LexicalClipboard_dev = {};\nvar LexicalHtml_dev = {};\nvar hasRequiredLexicalHtml_dev;\nfunction requireLexicalHtml_dev() {\n  if (hasRequiredLexicalHtml_dev)\n    return LexicalHtml_dev;\n  hasRequiredLexicalHtml_dev = 1;\n  var selection = requireLexicalSelection();\n  var lexical = require$$1;\n  function $generateNodesFromDOM(editor, dom) {\n    let lexicalNodes = [];\n    const elements = dom.body ? Array.from(dom.body.childNodes) : [];\n    const elementsLength = elements.length;\n    for (let i = 0; i < elementsLength; i++) {\n      const element = elements[i];\n      if (!IGNORE_TAGS.has(element.nodeName)) {\n        const lexicalNode = $createNodesFromDOM(element, editor);\n        if (lexicalNode !== null) {\n          lexicalNodes = lexicalNodes.concat(lexicalNode);\n        }\n      }\n    }\n    return lexicalNodes;\n  }\n  function $generateHtmlFromNodes(editor, selection2) {\n    if (typeof document === \"undefined\" || typeof window === \"undefined\") {\n      throw new Error(\"To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.\");\n    }\n    const container = document.createElement(\"div\");\n    const root = lexical.$getRoot();\n    const topLevelChildren = root.getChildren();\n    for (let i = 0; i < topLevelChildren.length; i++) {\n      const topLevelNode = topLevelChildren[i];\n      $appendNodesToHTML(editor, topLevelNode, container, selection2);\n    }\n    return container.innerHTML;\n  }\n  function $appendNodesToHTML(editor, currentNode, parentElement, selection$1 = null) {\n    let shouldInclude = selection$1 != null ? currentNode.isSelected() : true;\n    const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy(\"html\");\n    let target = currentNode;\n    if (selection$1 !== null) {\n      let clone = selection.$cloneWithProperties(currentNode);\n      clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n      target = clone;\n    }\n    const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n    const {\n      element,\n      after\n    } = target.exportDOM(editor);\n    if (!element) {\n      return false;\n    }\n    const fragment = new DocumentFragment();\n    for (let i = 0; i < children.length; i++) {\n      const childNode = children[i];\n      const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);\n      if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, \"html\")) {\n        shouldInclude = true;\n      }\n    }\n    if (shouldInclude && !shouldExclude) {\n      element.append(fragment);\n      parentElement.append(element);\n      if (after) {\n        const newElement = after.call(target, element);\n        if (newElement)\n          element.replaceWith(newElement);\n      }\n    } else {\n      parentElement.append(fragment);\n    }\n    return shouldInclude;\n  }\n  function getConversionFunction(domNode, editor) {\n    const {\n      nodeName\n    } = domNode;\n    const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n    let currentConversion = null;\n    if (cachedConversions !== void 0) {\n      for (const cachedConversion of cachedConversions) {\n        const domConversion = cachedConversion(domNode);\n        if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {\n          currentConversion = domConversion;\n        }\n      }\n    }\n    return currentConversion !== null ? currentConversion.conversion : null;\n  }\n  const IGNORE_TAGS = /* @__PURE__ */ new Set([\"STYLE\"]);\n  function $createNodesFromDOM(node, editor, forChildMap = /* @__PURE__ */ new Map(), parentLexicalNode, preformatted = false) {\n    let lexicalNodes = [];\n    if (IGNORE_TAGS.has(node.nodeName)) {\n      return lexicalNodes;\n    }\n    let currentLexicalNode = null;\n    const transformFunction = getConversionFunction(node, editor);\n    const transformOutput = transformFunction ? transformFunction(node, void 0, preformatted) : null;\n    let postTransform = null;\n    if (transformOutput !== null) {\n      postTransform = transformOutput.after;\n      currentLexicalNode = transformOutput.node;\n      if (currentLexicalNode !== null) {\n        for (const [, forChildFunction] of forChildMap) {\n          currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n          if (!currentLexicalNode) {\n            break;\n          }\n        }\n        if (currentLexicalNode) {\n          lexicalNodes.push(currentLexicalNode);\n        }\n      }\n      if (transformOutput.forChild != null) {\n        forChildMap.set(node.nodeName, transformOutput.forChild);\n      }\n    }\n    const children = node.childNodes;\n    let childLexicalNodes = [];\n    for (let i = 0; i < children.length; i++) {\n      childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode, preformatted || (transformOutput && transformOutput.preformatted) === true));\n    }\n    if (postTransform != null) {\n      childLexicalNodes = postTransform(childLexicalNodes);\n    }\n    if (currentLexicalNode == null) {\n      lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n    } else {\n      if (lexical.$isElementNode(currentLexicalNode)) {\n        currentLexicalNode.append(...childLexicalNodes);\n      }\n    }\n    return lexicalNodes;\n  }\n  LexicalHtml_dev.$generateHtmlFromNodes = $generateHtmlFromNodes;\n  LexicalHtml_dev.$generateNodesFromDOM = $generateNodesFromDOM;\n  return LexicalHtml_dev;\n}\nvar LexicalHtml_prod = {};\nvar hasRequiredLexicalHtml_prod;\nfunction requireLexicalHtml_prod() {\n  if (hasRequiredLexicalHtml_prod)\n    return LexicalHtml_prod;\n  hasRequiredLexicalHtml_prod = 1;\n  var n = requireLexicalSelection(), q = require$$1;\n  function r(c, d, h, b = null) {\n    let e = null != b ? d.isSelected() : true, l = q.$isElementNode(d) && d.excludeFromCopy(\"html\");\n    var a = d;\n    null !== b && (a = n.$cloneWithProperties(d), a = q.$isTextNode(a) && null != b ? n.$sliceSelectedTextNodeContent(b, a) : a);\n    let f = q.$isElementNode(a) ? a.getChildren() : [], { element: k, after: g } = a.exportDOM(c);\n    if (!k)\n      return false;\n    let m = new DocumentFragment();\n    for (let p = 0; p < f.length; p++) {\n      let t = f[p], w = r(c, t, m, b);\n      !e && q.$isElementNode(d) && w && d.extractWithChild(t, b, \"html\") && (e = true);\n    }\n    e && !l ? (k.append(m), h.append(k), g && (c = g.call(\n      a,\n      k\n    )) && k.replaceWith(c)) : h.append(m);\n    return e;\n  }\n  let u = /* @__PURE__ */ new Set([\"STYLE\"]);\n  function v(c, d, h = /* @__PURE__ */ new Map(), b, e = false) {\n    let l = [];\n    if (u.has(c.nodeName))\n      return l;\n    let a = null;\n    var { nodeName: f } = c, k = d._htmlConversions.get(f.toLowerCase());\n    f = null;\n    if (void 0 !== k)\n      for (g of k)\n        k = g(c), null !== k && (null === f || f.priority < k.priority) && (f = k);\n    var g = (g = null !== f ? f.conversion : null) ? g(c, void 0, e) : null;\n    f = null;\n    if (null !== g) {\n      f = g.after;\n      a = g.node;\n      if (null !== a) {\n        for (var [, m] of h)\n          if (a = m(a, b), !a)\n            break;\n        a && l.push(a);\n      }\n      null != g.forChild && h.set(c.nodeName, g.forChild);\n    }\n    c = c.childNodes;\n    b = [];\n    for (m = 0; m < c.length; m++)\n      b.push(...v(\n        c[m],\n        d,\n        new Map(h),\n        a,\n        e || true === (g && g.preformatted)\n      ));\n    null != f && (b = f(b));\n    null == a ? l = l.concat(b) : q.$isElementNode(a) && a.append(...b);\n    return l;\n  }\n  LexicalHtml_prod.$generateHtmlFromNodes = function(c, d) {\n    if (\"undefined\" === typeof document || \"undefined\" === typeof window)\n      throw Error(\"To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.\");\n    let h = document.createElement(\"div\"), b = q.$getRoot().getChildren();\n    for (let e = 0; e < b.length; e++)\n      r(c, b[e], h, d);\n    return h.innerHTML;\n  };\n  LexicalHtml_prod.$generateNodesFromDOM = function(c, d) {\n    let h = [];\n    d = d.body ? Array.from(d.body.childNodes) : [];\n    let b = d.length;\n    for (let l = 0; l < b; l++) {\n      var e = d[l];\n      u.has(e.nodeName) || (e = v(e, c), null !== e && (h = h.concat(e)));\n    }\n    return h;\n  };\n  return LexicalHtml_prod;\n}\nvar LexicalHtml_1;\nvar hasRequiredLexicalHtml;\nfunction requireLexicalHtml() {\n  if (hasRequiredLexicalHtml)\n    return LexicalHtml_1;\n  hasRequiredLexicalHtml = 1;\n  const LexicalHtml = process.env.NODE_ENV === \"development\" ? requireLexicalHtml_dev() : requireLexicalHtml_prod();\n  LexicalHtml_1 = LexicalHtml;\n  return LexicalHtml_1;\n}\nvar hasRequiredLexicalClipboard_dev;\nfunction requireLexicalClipboard_dev() {\n  if (hasRequiredLexicalClipboard_dev)\n    return LexicalClipboard_dev;\n  hasRequiredLexicalClipboard_dev = 1;\n  var html = requireLexicalHtml();\n  var selection = requireLexicalSelection();\n  var utils = requireLexicalUtils();\n  var lexical = require$$1;\n  function $getHtmlContent(editor) {\n    const selection2 = lexical.$getSelection();\n    if (selection2 == null) {\n      {\n        throw Error(`Expected valid LexicalSelection`);\n      }\n    }\n    if (lexical.$isRangeSelection(selection2) && selection2.isCollapsed() || selection2.getNodes().length === 0) {\n      return \"\";\n    }\n    return html.$generateHtmlFromNodes(editor, selection2);\n  }\n  function $getLexicalContent(editor) {\n    const selection2 = lexical.$getSelection();\n    if (selection2 == null) {\n      {\n        throw Error(`Expected valid LexicalSelection`);\n      }\n    }\n    if (lexical.$isRangeSelection(selection2) && selection2.isCollapsed() || selection2.getNodes().length === 0) {\n      return null;\n    }\n    return JSON.stringify($generateJSONFromSelectedNodes(editor, selection2));\n  }\n  function $insertDataTransferForPlainText(dataTransfer, selection2) {\n    const text = dataTransfer.getData(\"text/plain\");\n    if (text != null) {\n      selection2.insertRawText(text);\n    }\n  }\n  function $insertDataTransferForRichText(dataTransfer, selection2, editor) {\n    const lexicalString = dataTransfer.getData(\"application/x-lexical-editor\");\n    if (lexicalString) {\n      try {\n        const payload = JSON.parse(lexicalString);\n        if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n          const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n          return $insertGeneratedNodes(editor, nodes, selection2);\n        }\n      } catch {\n      }\n    }\n    const htmlString = dataTransfer.getData(\"text/html\");\n    if (htmlString) {\n      try {\n        const parser = new DOMParser();\n        const dom = parser.parseFromString(htmlString, \"text/html\");\n        const nodes = html.$generateNodesFromDOM(editor, dom);\n        return $insertGeneratedNodes(editor, nodes, selection2);\n      } catch {\n      }\n    }\n    const text = dataTransfer.getData(\"text/plain\");\n    if (text != null) {\n      if (lexical.$isRangeSelection(selection2)) {\n        const lines = text.split(/\\r?\\n/);\n        const linesLength = lines.length;\n        for (let i = 0; i < linesLength; i++) {\n          selection2.insertText(lines[i]);\n          if (i < linesLength - 1) {\n            selection2.insertParagraph();\n          }\n        }\n      } else {\n        selection2.insertRawText(text);\n      }\n    }\n  }\n  function $insertGeneratedNodes(editor, nodes, selection2) {\n    const isSelectionInsideOfGrid = lexical.DEPRECATED_$isGridSelection(selection2) || utils.$findMatchingParent(selection2.anchor.getNode(), (n) => lexical.DEPRECATED_$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection2.focus.getNode(), (n) => lexical.DEPRECATED_$isGridCellNode(n)) !== null;\n    if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.DEPRECATED_$isGridNode(nodes[0])) {\n      $mergeGridNodesStrategy(nodes, selection2, false, editor);\n      return;\n    }\n    $basicInsertStrategy(nodes, selection2);\n    return;\n  }\n  function $basicInsertStrategy(nodes, selection2) {\n    const topLevelBlocks = [];\n    let currentBlock = null;\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const isLineBreakNode = lexical.$isLineBreakNode(node);\n      if (isLineBreakNode || lexical.$isDecoratorNode(node) && node.isInline() || lexical.$isElementNode(node) && node.isInline() || lexical.$isTextNode(node) || node.isParentRequired()) {\n        if (currentBlock === null) {\n          currentBlock = node.createParentElementNode();\n          topLevelBlocks.push(currentBlock);\n          if (isLineBreakNode) {\n            continue;\n          }\n        }\n        if (currentBlock !== null) {\n          currentBlock.append(node);\n        }\n      } else {\n        topLevelBlocks.push(node);\n        currentBlock = null;\n      }\n    }\n    if (lexical.$isRangeSelection(selection2)) {\n      selection2.insertNodes(topLevelBlocks);\n    } else if (lexical.DEPRECATED_$isGridSelection(selection2)) {\n      const anchorCell = selection2.anchor.getNode();\n      if (!lexical.DEPRECATED_$isGridCellNode(anchorCell)) {\n        {\n          throw Error(`Expected Grid Cell in Grid Selection`);\n        }\n      }\n      anchorCell.append(...topLevelBlocks);\n    }\n  }\n  function $mergeGridNodesStrategy(nodes, selection2, isFromLexical, editor) {\n    if (nodes.length !== 1 || !lexical.DEPRECATED_$isGridNode(nodes[0])) {\n      {\n        throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);\n      }\n    }\n    const newGrid = nodes[0];\n    const newGridRows = newGrid.getChildren();\n    const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n    const newRowCount = newGrid.getChildrenSize();\n    const gridCellNode = utils.$findMatchingParent(selection2.anchor.getNode(), (n) => lexical.DEPRECATED_$isGridCellNode(n));\n    const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, (n) => lexical.DEPRECATED_$isGridRowNode(n));\n    const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, (n) => lexical.DEPRECATED_$isGridNode(n));\n    if (!lexical.DEPRECATED_$isGridCellNode(gridCellNode) || !lexical.DEPRECATED_$isGridRowNode(gridRowNode) || !lexical.DEPRECATED_$isGridNode(gridNode)) {\n      {\n        throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);\n      }\n    }\n    const startY = gridRowNode.getIndexWithinParent();\n    const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n    const startX = gridCellNode.getIndexWithinParent();\n    const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n    const fromX = Math.min(startX, stopX);\n    const fromY = Math.min(startY, stopY);\n    const toX = Math.max(startX, stopX);\n    const toY = Math.max(startY, stopY);\n    const gridRowNodes = gridNode.getChildren();\n    let newRowIdx = 0;\n    let newAnchorCellKey;\n    let newFocusCellKey;\n    for (let r = fromY; r <= toY; r++) {\n      const currentGridRowNode = gridRowNodes[r];\n      if (!lexical.DEPRECATED_$isGridRowNode(currentGridRowNode)) {\n        {\n          throw Error(`getNodes: expected to find GridRowNode`);\n        }\n      }\n      const newGridRowNode = newGridRows[newRowIdx];\n      if (!lexical.DEPRECATED_$isGridRowNode(newGridRowNode)) {\n        {\n          throw Error(`getNodes: expected to find GridRowNode`);\n        }\n      }\n      const gridCellNodes = currentGridRowNode.getChildren();\n      const newGridCellNodes = newGridRowNode.getChildren();\n      let newColumnIdx = 0;\n      for (let c = fromX; c <= toX; c++) {\n        const currentGridCellNode = gridCellNodes[c];\n        if (!lexical.DEPRECATED_$isGridCellNode(currentGridCellNode)) {\n          {\n            throw Error(`getNodes: expected to find GridCellNode`);\n          }\n        }\n        const newGridCellNode = newGridCellNodes[newColumnIdx];\n        if (!lexical.DEPRECATED_$isGridCellNode(newGridCellNode)) {\n          {\n            throw Error(`getNodes: expected to find GridCellNode`);\n          }\n        }\n        if (r === fromY && c === fromX) {\n          newAnchorCellKey = currentGridCellNode.getKey();\n        } else if (r === toY && c === toX) {\n          newFocusCellKey = currentGridCellNode.getKey();\n        }\n        const originalChildren = currentGridCellNode.getChildren();\n        newGridCellNode.getChildren().forEach((child) => {\n          if (lexical.$isTextNode(child)) {\n            const paragraphNode = lexical.$createParagraphNode();\n            paragraphNode.append(child);\n            currentGridCellNode.append(child);\n          } else {\n            currentGridCellNode.append(child);\n          }\n        });\n        originalChildren.forEach((n) => n.remove());\n        newColumnIdx++;\n      }\n      newRowIdx++;\n    }\n    if (newAnchorCellKey && newFocusCellKey) {\n      const newGridSelection = lexical.DEPRECATED_$createGridSelection();\n      newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);\n      lexical.$setSelection(newGridSelection);\n      editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, void 0);\n    }\n  }\n  function exportNodeToJSON(node) {\n    const serializedNode = node.exportJSON();\n    const nodeClass = node.constructor;\n    if (serializedNode.type !== nodeClass.getType()) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n      }\n    }\n    const serializedChildren = serializedNode.children;\n    if (lexical.$isElementNode(node)) {\n      if (!Array.isArray(serializedChildren)) {\n        {\n          throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n        }\n      }\n    }\n    return serializedNode;\n  }\n  function $appendNodesToJSON(editor, selection$1, currentNode, targetArray = []) {\n    let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;\n    const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy(\"html\");\n    let target = currentNode;\n    if (selection$1 !== null) {\n      let clone = selection.$cloneWithProperties(currentNode);\n      clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n      target = clone;\n    }\n    const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n    const serializedNode = exportNodeToJSON(target);\n    if (lexical.$isTextNode(target)) {\n      const text = target.__text;\n      if (text.length > 0) {\n        serializedNode.text = text;\n      } else {\n        shouldInclude = false;\n      }\n    }\n    for (let i = 0; i < children.length; i++) {\n      const childNode = children[i];\n      const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);\n      if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, \"clone\")) {\n        shouldInclude = true;\n      }\n    }\n    if (shouldInclude && !shouldExclude) {\n      targetArray.push(serializedNode);\n    } else if (Array.isArray(serializedNode.children)) {\n      for (let i = 0; i < serializedNode.children.length; i++) {\n        const serializedChildNode = serializedNode.children[i];\n        targetArray.push(serializedChildNode);\n      }\n    }\n    return shouldInclude;\n  }\n  function $generateJSONFromSelectedNodes(editor, selection2) {\n    const nodes = [];\n    const root = lexical.$getRoot();\n    const topLevelChildren = root.getChildren();\n    for (let i = 0; i < topLevelChildren.length; i++) {\n      const topLevelNode = topLevelChildren[i];\n      $appendNodesToJSON(editor, selection2, topLevelNode, nodes);\n    }\n    return {\n      namespace: editor._config.namespace,\n      nodes\n    };\n  }\n  function $generateNodesFromSerializedNodes(serializedNodes) {\n    const nodes = [];\n    for (let i = 0; i < serializedNodes.length; i++) {\n      const serializedNode = serializedNodes[i];\n      const node = lexical.$parseSerializedNode(serializedNode);\n      if (lexical.$isTextNode(node)) {\n        selection.$addNodeStyle(node);\n      }\n      nodes.push(node);\n    }\n    return nodes;\n  }\n  const EVENT_LATENCY = 50;\n  let clipboardEventTimeout = null;\n  async function copyToClipboard__EXPERIMENTAL(editor, event) {\n    if (clipboardEventTimeout !== null) {\n      return false;\n    }\n    if (event !== null) {\n      return new Promise((resolve, reject) => {\n        editor.update(() => {\n          resolve($copyToClipboardEvent(editor, event));\n        });\n      });\n    }\n    const rootElement = editor.getRootElement();\n    const domSelection = document.getSelection();\n    if (rootElement === null || domSelection === null) {\n      return false;\n    }\n    const element = document.createElement(\"span\");\n    element.style.cssText = \"position: fixed; top: -1000px;\";\n    element.append(document.createTextNode(\"#\"));\n    rootElement.append(element);\n    const range = new Range();\n    range.setStart(element, 0);\n    range.setEnd(element, 1);\n    domSelection.removeAllRanges();\n    domSelection.addRange(range);\n    return new Promise((resolve, reject) => {\n      const removeListener = editor.registerCommand(lexical.COPY_COMMAND, (secondEvent) => {\n        if (secondEvent instanceof ClipboardEvent) {\n          removeListener();\n          if (clipboardEventTimeout !== null) {\n            window.clearTimeout(clipboardEventTimeout);\n            clipboardEventTimeout = null;\n          }\n          resolve($copyToClipboardEvent(editor, secondEvent));\n        }\n        return true;\n      }, lexical.COMMAND_PRIORITY_CRITICAL);\n      clipboardEventTimeout = window.setTimeout(() => {\n        removeListener();\n        clipboardEventTimeout = null;\n        resolve(false);\n      }, EVENT_LATENCY);\n      document.execCommand(\"copy\");\n      element.remove();\n    });\n  }\n  function $copyToClipboardEvent(editor, event) {\n    const domSelection = window.getSelection();\n    if (!domSelection) {\n      return false;\n    }\n    const anchorDOM = domSelection.anchorNode;\n    const focusDOM = domSelection.focusNode;\n    if (anchorDOM !== null && focusDOM !== null && !lexical.isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return false;\n    }\n    event.preventDefault();\n    const clipboardData = event.clipboardData;\n    const selection2 = lexical.$getSelection();\n    if (clipboardData === null || selection2 === null) {\n      return false;\n    }\n    const htmlString = $getHtmlContent(editor);\n    const lexicalString = $getLexicalContent(editor);\n    let plainString = \"\";\n    if (selection2 !== null) {\n      plainString = selection2.getTextContent();\n    }\n    if (htmlString !== null) {\n      clipboardData.setData(\"text/html\", htmlString);\n    }\n    if (lexicalString !== null) {\n      clipboardData.setData(\"application/x-lexical-editor\", lexicalString);\n    }\n    clipboardData.setData(\"text/plain\", plainString);\n    return true;\n  }\n  LexicalClipboard_dev.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;\n  LexicalClipboard_dev.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;\n  LexicalClipboard_dev.$getHtmlContent = $getHtmlContent;\n  LexicalClipboard_dev.$getLexicalContent = $getLexicalContent;\n  LexicalClipboard_dev.$insertDataTransferForPlainText = $insertDataTransferForPlainText;\n  LexicalClipboard_dev.$insertDataTransferForRichText = $insertDataTransferForRichText;\n  LexicalClipboard_dev.$insertGeneratedNodes = $insertGeneratedNodes;\n  LexicalClipboard_dev.copyToClipboard__EXPERIMENTAL = copyToClipboard__EXPERIMENTAL;\n  return LexicalClipboard_dev;\n}\nvar LexicalClipboard_prod = {};\nvar hasRequiredLexicalClipboard_prod;\nfunction requireLexicalClipboard_prod() {\n  if (hasRequiredLexicalClipboard_prod)\n    return LexicalClipboard_prod;\n  hasRequiredLexicalClipboard_prod = 1;\n  var d = requireLexicalHtml(), n = requireLexicalSelection(), r = requireLexicalUtils(), t = require$$1;\n  function z(a) {\n    throw Error(`Minified Lexical error #${a}; visit https://lexical.dev/docs/error?code=${a} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);\n  }\n  function A(a) {\n    let b = t.$getSelection();\n    if (null == b)\n      throw Error(\"Expected valid LexicalSelection\");\n    return t.$isRangeSelection(b) && b.isCollapsed() || 0 === b.getNodes().length ? \"\" : d.$generateHtmlFromNodes(a, b);\n  }\n  function B(a) {\n    let b = t.$getSelection();\n    if (null == b)\n      throw Error(\"Expected valid LexicalSelection\");\n    return t.$isRangeSelection(b) && b.isCollapsed() || 0 === b.getNodes().length ? null : JSON.stringify(C(a, b));\n  }\n  function D(a, b, c) {\n    (t.DEPRECATED_$isGridSelection(c) || null !== r.$findMatchingParent(c.anchor.getNode(), (f) => t.DEPRECATED_$isGridCellNode(f)) && null !== r.$findMatchingParent(c.focus.getNode(), (f) => t.DEPRECATED_$isGridCellNode(f))) && 1 === b.length && t.DEPRECATED_$isGridNode(b[0]) ? E(b, c, false, a) : H(b, c);\n  }\n  function H(a, b) {\n    let c = [], f = null;\n    for (let e = 0; e < a.length; e++) {\n      let g = a[e], h = t.$isLineBreakNode(g);\n      if (h || t.$isDecoratorNode(g) && g.isInline() || t.$isElementNode(g) && g.isInline() || t.$isTextNode(g) || g.isParentRequired()) {\n        if (null === f && (f = g.createParentElementNode(), c.push(f), h))\n          continue;\n        null !== f && f.append(g);\n      } else\n        c.push(g), f = null;\n    }\n    t.$isRangeSelection(b) ? b.insertNodes(c) : t.DEPRECATED_$isGridSelection(b) && (a = b.anchor.getNode(), t.DEPRECATED_$isGridCellNode(a) || z(41), a.append(...c));\n  }\n  function E(a, b, c, f) {\n    1 === a.length && t.DEPRECATED_$isGridNode(a[0]) || z(42);\n    var e = a[0];\n    a = e.getChildren();\n    c = e.getFirstChildOrThrow().getChildrenSize();\n    var g = e.getChildrenSize(), h = r.$findMatchingParent(b.anchor.getNode(), (l) => t.DEPRECATED_$isGridCellNode(l));\n    b = (e = h && r.$findMatchingParent(h, (l) => t.DEPRECATED_$isGridRowNode(l))) && r.$findMatchingParent(e, (l) => t.DEPRECATED_$isGridNode(l));\n    t.DEPRECATED_$isGridCellNode(h) && t.DEPRECATED_$isGridRowNode(e) && t.DEPRECATED_$isGridNode(b) || z(43);\n    var k = e.getIndexWithinParent(), p = Math.min(b.getChildrenSize() - 1, k + g - 1);\n    g = h.getIndexWithinParent();\n    h = Math.min(e.getChildrenSize() - 1, g + c - 1);\n    c = Math.min(g, h);\n    e = Math.min(k, p);\n    g = Math.max(g, h);\n    k = Math.max(k, p);\n    p = b.getChildren();\n    h = 0;\n    let m, q;\n    for (let l = e; l <= k; l++) {\n      var x = p[l];\n      t.DEPRECATED_$isGridRowNode(x) || z(24);\n      var y = a[h];\n      t.DEPRECATED_$isGridRowNode(y) || z(24);\n      x = x.getChildren();\n      y = y.getChildren();\n      let F = 0;\n      for (let u = c; u <= g; u++) {\n        let v = x[u];\n        t.DEPRECATED_$isGridCellNode(v) || z(25);\n        let G = y[F];\n        t.DEPRECATED_$isGridCellNode(G) || z(25);\n        l === e && u === c ? m = v.getKey() : l === k && u === g && (q = v.getKey());\n        let M = v.getChildren();\n        G.getChildren().forEach((w) => {\n          t.$isTextNode(w) && t.$createParagraphNode().append(w);\n          v.append(w);\n        });\n        M.forEach((w) => w.remove());\n        F++;\n      }\n      h++;\n    }\n    m && q && (a = t.DEPRECATED_$createGridSelection(), a.set(b.getKey(), m, q), t.$setSelection(a), f.dispatchCommand(t.SELECTION_CHANGE_COMMAND, void 0));\n  }\n  function I(a, b, c, f = []) {\n    let e = null != b ? c.isSelected(b) : true, g = t.$isElementNode(c) && c.excludeFromCopy(\"html\");\n    var h = c;\n    if (null !== b) {\n      var k = n.$cloneWithProperties(c);\n      h = k = t.$isTextNode(k) && null != b ? n.$sliceSelectedTextNodeContent(b, k) : k;\n    }\n    let p = t.$isElementNode(h) ? h.getChildren() : [];\n    var m = h;\n    k = m.exportJSON();\n    k.type !== m.constructor.getType() && z(58);\n    var q = k.children;\n    t.$isElementNode(m) && (Array.isArray(q) || z(59));\n    t.$isTextNode(h) && (h = h.__text, 0 < h.length ? k.text = h : e = false);\n    for (h = 0; h < p.length; h++)\n      m = p[h], q = I(a, b, m, k.children), !e && t.$isElementNode(c) && q && c.extractWithChild(m, b, \"clone\") && (e = true);\n    if (e && !g)\n      f.push(k);\n    else if (Array.isArray(k.children))\n      for (a = 0; a < k.children.length; a++)\n        f.push(k.children[a]);\n    return e;\n  }\n  function C(a, b) {\n    let c = [], f = t.$getRoot().getChildren();\n    for (let e = 0; e < f.length; e++)\n      I(a, b, f[e], c);\n    return { namespace: a._config.namespace, nodes: c };\n  }\n  function J(a) {\n    let b = [];\n    for (let c = 0; c < a.length; c++) {\n      let f = t.$parseSerializedNode(a[c]);\n      t.$isTextNode(f) && n.$addNodeStyle(f);\n      b.push(f);\n    }\n    return b;\n  }\n  let K = null;\n  function L(a, b) {\n    var c = window.getSelection();\n    if (!c)\n      return false;\n    var f = c.anchorNode;\n    c = c.focusNode;\n    if (null !== f && null !== c && !t.isSelectionWithinEditor(a, f, c))\n      return false;\n    b.preventDefault();\n    b = b.clipboardData;\n    f = t.$getSelection();\n    if (null === b || null === f)\n      return false;\n    c = A(a);\n    a = B(a);\n    let e = \"\";\n    null !== f && (e = f.getTextContent());\n    null !== c && b.setData(\"text/html\", c);\n    null !== a && b.setData(\"application/x-lexical-editor\", a);\n    b.setData(\"text/plain\", e);\n    return true;\n  }\n  LexicalClipboard_prod.$generateJSONFromSelectedNodes = C;\n  LexicalClipboard_prod.$generateNodesFromSerializedNodes = J;\n  LexicalClipboard_prod.$getHtmlContent = A;\n  LexicalClipboard_prod.$getLexicalContent = B;\n  LexicalClipboard_prod.$insertDataTransferForPlainText = function(a, b) {\n    a = a.getData(\"text/plain\");\n    null != a && b.insertRawText(a);\n  };\n  LexicalClipboard_prod.$insertDataTransferForRichText = function(a, b, c) {\n    var f = a.getData(\"application/x-lexical-editor\");\n    if (f)\n      try {\n        let g = JSON.parse(f);\n        if (g.namespace === c._config.namespace && Array.isArray(g.nodes)) {\n          let h = J(g.nodes);\n          return D(c, h, b);\n        }\n      } catch {\n      }\n    if (f = a.getData(\"text/html\"))\n      try {\n        var e = new DOMParser().parseFromString(f, \"text/html\");\n        let g = d.$generateNodesFromDOM(c, e);\n        return D(c, g, b);\n      } catch {\n      }\n    a = a.getData(\"text/plain\");\n    if (null != a)\n      if (t.$isRangeSelection(b))\n        for (a = a.split(/\\r?\\n/), c = a.length, e = 0; e < c; e++)\n          b.insertText(a[e]), e < c - 1 && b.insertParagraph();\n      else\n        b.insertRawText(a);\n  };\n  LexicalClipboard_prod.$insertGeneratedNodes = D;\n  LexicalClipboard_prod.copyToClipboard__EXPERIMENTAL = async function(a, b) {\n    if (null !== K)\n      return false;\n    if (null !== b)\n      return new Promise((g) => {\n        a.update(() => {\n          g(L(a, b));\n        });\n      });\n    var c = a.getRootElement();\n    let f = document.getSelection();\n    if (null === c || null === f)\n      return false;\n    let e = document.createElement(\"span\");\n    e.style.cssText = \"position: fixed; top: -1000px;\";\n    e.append(document.createTextNode(\"#\"));\n    c.append(e);\n    c = new Range();\n    c.setStart(e, 0);\n    c.setEnd(e, 1);\n    f.removeAllRanges();\n    f.addRange(c);\n    return new Promise((g) => {\n      let h = a.registerCommand(\n        t.COPY_COMMAND,\n        (k) => {\n          k instanceof ClipboardEvent && (h(), null !== K && (window.clearTimeout(K), K = null), g(L(a, k)));\n          return true;\n        },\n        t.COMMAND_PRIORITY_CRITICAL\n      );\n      K = window.setTimeout(() => {\n        h();\n        K = null;\n        g(false);\n      }, 50);\n      document.execCommand(\"copy\");\n      e.remove();\n    });\n  };\n  return LexicalClipboard_prod;\n}\nvar LexicalClipboard_1;\nvar hasRequiredLexicalClipboard;\nfunction requireLexicalClipboard() {\n  if (hasRequiredLexicalClipboard)\n    return LexicalClipboard_1;\n  hasRequiredLexicalClipboard = 1;\n  const LexicalClipboard = process.env.NODE_ENV === \"development\" ? requireLexicalClipboard_dev() : requireLexicalClipboard_prod();\n  LexicalClipboard_1 = LexicalClipboard;\n  return LexicalClipboard_1;\n}\nvar hasRequiredLexicalRichText_dev;\nfunction requireLexicalRichText_dev() {\n  if (hasRequiredLexicalRichText_dev)\n    return LexicalRichText_dev;\n  hasRequiredLexicalRichText_dev = 1;\n  var clipboard = requireLexicalClipboard();\n  var selection = requireLexicalSelection();\n  var utils = requireLexicalUtils();\n  var lexical = require$$1;\n  function caretFromPoint(x, y) {\n    if (typeof document.caretRangeFromPoint !== \"undefined\") {\n      const range = document.caretRangeFromPoint(x, y);\n      if (range === null) {\n        return null;\n      }\n      return {\n        node: range.startContainer,\n        offset: range.startOffset\n      };\n    } else if (document.caretPositionFromPoint !== \"undefined\") {\n      const range = document.caretPositionFromPoint(x, y);\n      if (range === null) {\n        return null;\n      }\n      return {\n        node: range.offsetNode,\n        offset: range.offset\n      };\n    } else {\n      return null;\n    }\n  }\n  const CAN_USE_DOM = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\n  const documentMode = CAN_USE_DOM && \"documentMode\" in document ? document.documentMode : null;\n  const CAN_USE_BEFORE_INPUT = CAN_USE_DOM && \"InputEvent\" in window && !documentMode ? \"getTargetRanges\" in new window.InputEvent(\"input\") : false;\n  const IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\n  const IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n  const IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n  const IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n  const DRAG_DROP_PASTE = lexical.createCommand(\"DRAG_DROP_PASTE_FILE\");\n  class QuoteNode extends lexical.ElementNode {\n    static getType() {\n      return \"quote\";\n    }\n    static clone(node) {\n      return new QuoteNode(node.__key);\n    }\n    constructor(key) {\n      super(key);\n    }\n    // View\n    createDOM(config) {\n      const element = document.createElement(\"blockquote\");\n      utils.addClassNamesToElement(element, config.theme.quote);\n      return element;\n    }\n    updateDOM(prevNode, dom) {\n      return false;\n    }\n    static importDOM() {\n      return {\n        blockquote: (node) => ({\n          conversion: convertBlockquoteElement,\n          priority: 0\n        })\n      };\n    }\n    static importJSON(serializedNode) {\n      const node = $createQuoteNode();\n      node.setFormat(serializedNode.format);\n      node.setIndent(serializedNode.indent);\n      node.setDirection(serializedNode.direction);\n      return node;\n    }\n    exportJSON() {\n      return {\n        ...super.exportJSON(),\n        type: \"quote\"\n      };\n    }\n    // Mutation\n    insertNewAfter(_, restoreSelection) {\n      const newBlock = lexical.$createParagraphNode();\n      const direction = this.getDirection();\n      newBlock.setDirection(direction);\n      this.insertAfter(newBlock, restoreSelection);\n      return newBlock;\n    }\n    collapseAtStart() {\n      const paragraph = lexical.$createParagraphNode();\n      const children = this.getChildren();\n      children.forEach((child) => paragraph.append(child));\n      this.replace(paragraph);\n      return true;\n    }\n  }\n  function $createQuoteNode() {\n    return lexical.$applyNodeReplacement(new QuoteNode());\n  }\n  function $isQuoteNode(node) {\n    return node instanceof QuoteNode;\n  }\n  class HeadingNode extends lexical.ElementNode {\n    /** @internal */\n    static getType() {\n      return \"heading\";\n    }\n    static clone(node) {\n      return new HeadingNode(node.__tag, node.__key);\n    }\n    constructor(tag, key) {\n      super(key);\n      this.__tag = tag;\n    }\n    getTag() {\n      return this.__tag;\n    }\n    // View\n    createDOM(config) {\n      const tag = this.__tag;\n      const element = document.createElement(tag);\n      const theme = config.theme;\n      const classNames = theme.heading;\n      if (classNames !== void 0) {\n        const className = classNames[tag];\n        utils.addClassNamesToElement(element, className);\n      }\n      return element;\n    }\n    updateDOM(prevNode, dom) {\n      return false;\n    }\n    static importDOM() {\n      return {\n        h1: (node) => ({\n          conversion: convertHeadingElement,\n          priority: 0\n        }),\n        h2: (node) => ({\n          conversion: convertHeadingElement,\n          priority: 0\n        }),\n        h3: (node) => ({\n          conversion: convertHeadingElement,\n          priority: 0\n        }),\n        h4: (node) => ({\n          conversion: convertHeadingElement,\n          priority: 0\n        }),\n        h5: (node) => ({\n          conversion: convertHeadingElement,\n          priority: 0\n        }),\n        h6: (node) => ({\n          conversion: convertHeadingElement,\n          priority: 0\n        }),\n        p: (node) => {\n          const paragraph = node;\n          const firstChild = paragraph.firstChild;\n          if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n            return {\n              conversion: () => ({\n                node: null\n              }),\n              priority: 3\n            };\n          }\n          return null;\n        },\n        span: (node) => {\n          if (isGoogleDocsTitle(node)) {\n            return {\n              conversion: (domNode) => {\n                return {\n                  node: $createHeadingNode(\"h1\")\n                };\n              },\n              priority: 3\n            };\n          }\n          return null;\n        }\n      };\n    }\n    static importJSON(serializedNode) {\n      const node = $createHeadingNode(serializedNode.tag);\n      node.setFormat(serializedNode.format);\n      node.setIndent(serializedNode.indent);\n      node.setDirection(serializedNode.direction);\n      return node;\n    }\n    exportJSON() {\n      return {\n        ...super.exportJSON(),\n        tag: this.getTag(),\n        type: \"heading\",\n        version: 1\n      };\n    }\n    // Mutation\n    insertNewAfter(selection2, restoreSelection = true) {\n      const anchorOffet = selection2 ? selection2.anchor.offset : 0;\n      const newElement = anchorOffet > 0 && anchorOffet < this.getTextContentSize() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();\n      const direction = this.getDirection();\n      newElement.setDirection(direction);\n      this.insertAfter(newElement, restoreSelection);\n      return newElement;\n    }\n    collapseAtStart() {\n      const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();\n      const children = this.getChildren();\n      children.forEach((child) => newElement.append(child));\n      this.replace(newElement);\n      return true;\n    }\n    extractWithChild() {\n      return true;\n    }\n  }\n  function isGoogleDocsTitle(domNode) {\n    if (domNode.nodeName.toLowerCase() === \"span\") {\n      return domNode.style.fontSize === \"26pt\";\n    }\n    return false;\n  }\n  function convertHeadingElement(domNode) {\n    const nodeName = domNode.nodeName.toLowerCase();\n    let node = null;\n    if (nodeName === \"h1\" || nodeName === \"h2\" || nodeName === \"h3\" || nodeName === \"h4\" || nodeName === \"h5\" || nodeName === \"h6\") {\n      node = $createHeadingNode(nodeName);\n    }\n    return {\n      node\n    };\n  }\n  function convertBlockquoteElement() {\n    const node = $createQuoteNode();\n    return {\n      node\n    };\n  }\n  function $createHeadingNode(headingTag) {\n    return lexical.$applyNodeReplacement(new HeadingNode(headingTag));\n  }\n  function $isHeadingNode(node) {\n    return node instanceof HeadingNode;\n  }\n  function onPasteForRichText(event, editor) {\n    event.preventDefault();\n    editor.update(() => {\n      const selection2 = lexical.$getSelection();\n      const clipboardData = event instanceof InputEvent || event instanceof KeyboardEvent ? null : event.clipboardData;\n      if (clipboardData != null && (lexical.$isRangeSelection(selection2) || lexical.DEPRECATED_$isGridSelection(selection2))) {\n        clipboard.$insertDataTransferForRichText(clipboardData, selection2, editor);\n      }\n    }, {\n      tag: \"paste\"\n    });\n  }\n  async function onCutForRichText(event, editor) {\n    await clipboard.copyToClipboard__EXPERIMENTAL(editor, event instanceof ClipboardEvent ? event : null);\n    editor.update(() => {\n      const selection2 = lexical.$getSelection();\n      if (lexical.$isRangeSelection(selection2)) {\n        selection2.removeText();\n      } else if (lexical.$isNodeSelection(selection2)) {\n        selection2.getNodes().forEach((node) => node.remove());\n      }\n    });\n  }\n  function eventFiles(event) {\n    let dataTransfer = null;\n    if (event instanceof DragEvent) {\n      dataTransfer = event.dataTransfer;\n    } else if (event instanceof ClipboardEvent) {\n      dataTransfer = event.clipboardData;\n    }\n    if (dataTransfer === null) {\n      return [false, [], false];\n    }\n    const types = dataTransfer.types;\n    const hasFiles = types.includes(\"Files\");\n    const hasContent = types.includes(\"text/html\") || types.includes(\"text/plain\");\n    return [hasFiles, Array.from(dataTransfer.files), hasContent];\n  }\n  function handleIndentAndOutdent(insertTab, indentOrOutdent) {\n    const selection2 = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection2)) {\n      return;\n    }\n    const alreadyHandled = /* @__PURE__ */ new Set();\n    const nodes = selection2.getNodes();\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const key = node.getKey();\n      if (alreadyHandled.has(key)) {\n        continue;\n      }\n      const parentBlock = utils.$getNearestBlockElementAncestorOrThrow(node);\n      const parentKey = parentBlock.getKey();\n      if (parentBlock.canInsertTab()) {\n        insertTab(node);\n        alreadyHandled.add(key);\n      } else if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n        alreadyHandled.add(parentKey);\n        indentOrOutdent(parentBlock);\n      }\n    }\n  }\n  function $isTargetWithinDecorator(target) {\n    const node = lexical.$getNearestNodeFromDOMNode(target);\n    return lexical.$isDecoratorNode(node);\n  }\n  function $isSelectionAtEndOfRoot(selection2) {\n    const focus = selection2.focus;\n    return focus.key === \"root\" && focus.offset === lexical.$getRoot().getChildrenSize();\n  }\n  function registerRichText(editor) {\n    const removeListener = utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, (payload) => {\n      const selection2 = lexical.$getSelection();\n      if (lexical.$isNodeSelection(selection2)) {\n        selection2.clear();\n        return true;\n      }\n      return false;\n    }, 0), editor.registerCommand(lexical.DELETE_CHARACTER_COMMAND, (isBackward) => {\n      const selection2 = lexical.$getSelection();\n      if (!lexical.$isRangeSelection(selection2)) {\n        return false;\n      }\n      selection2.deleteCharacter(isBackward);\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_WORD_COMMAND, (isBackward) => {\n      const selection2 = lexical.$getSelection();\n      if (!lexical.$isRangeSelection(selection2)) {\n        return false;\n      }\n      selection2.deleteWord(isBackward);\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_LINE_COMMAND, (isBackward) => {\n      const selection2 = lexical.$getSelection();\n      if (!lexical.$isRangeSelection(selection2)) {\n        return false;\n      }\n      selection2.deleteLine(isBackward);\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, (eventOrText) => {\n      const selection2 = lexical.$getSelection();\n      if (typeof eventOrText === \"string\") {\n        if (lexical.$isRangeSelection(selection2)) {\n          selection2.insertText(eventOrText);\n        } else if (lexical.DEPRECATED_$isGridSelection(selection2))\n          ;\n      } else {\n        if (!lexical.$isRangeSelection(selection2) && !lexical.DEPRECATED_$isGridSelection(selection2)) {\n          return false;\n        }\n        const dataTransfer = eventOrText.dataTransfer;\n        if (dataTransfer != null) {\n          clipboard.$insertDataTransferForRichText(dataTransfer, selection2, editor);\n        } else if (lexical.$isRangeSelection(selection2)) {\n          const data = eventOrText.data;\n          if (data) {\n            selection2.insertText(data);\n          }\n          return true;\n        }\n      }\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REMOVE_TEXT_COMMAND, () => {\n      const selection2 = lexical.$getSelection();\n      if (!lexical.$isRangeSelection(selection2)) {\n        return false;\n      }\n      selection2.removeText();\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, (format) => {\n      const selection2 = lexical.$getSelection();\n      if (!lexical.$isRangeSelection(selection2)) {\n        return false;\n      }\n      selection2.formatText(format);\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_ELEMENT_COMMAND, (format) => {\n      const selection2 = lexical.$getSelection();\n      if (!lexical.$isRangeSelection(selection2) && !lexical.$isNodeSelection(selection2)) {\n        return false;\n      }\n      const nodes = selection2.getNodes();\n      for (const node of nodes) {\n        const element = utils.$getNearestBlockElementAncestorOrThrow(node);\n        element.setFormat(format);\n      }\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_LINE_BREAK_COMMAND, (selectStart) => {\n      const selection2 = lexical.$getSelection();\n      if (!lexical.$isRangeSelection(selection2)) {\n        return false;\n      }\n      selection2.insertLineBreak(selectStart);\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {\n      const selection2 = lexical.$getSelection();\n      if (!lexical.$isRangeSelection(selection2)) {\n        return false;\n      }\n      selection2.insertParagraph();\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, () => {\n      handleIndentAndOutdent(() => {\n        editor.dispatchCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, \"\t\");\n      }, (block) => {\n        const indent = block.getIndent();\n        if (indent !== 10) {\n          block.setIndent(indent + 1);\n        }\n      });\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, () => {\n      handleIndentAndOutdent((node) => {\n        if (lexical.$isTextNode(node)) {\n          const textContent = node.getTextContent();\n          const character = textContent[textContent.length - 1];\n          if (character === \"\t\") {\n            editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);\n          }\n        }\n      }, (block) => {\n        const indent = block.getIndent();\n        if (indent !== 0) {\n          block.setIndent(indent - 1);\n        }\n      });\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, (event) => {\n      const selection2 = lexical.$getSelection();\n      if (lexical.$isNodeSelection(selection2) && !$isTargetWithinDecorator(event.target)) {\n        const nodes = selection2.getNodes();\n        if (nodes.length > 0) {\n          nodes[0].selectPrevious();\n          return true;\n        }\n      } else if (lexical.$isRangeSelection(selection2)) {\n        const possibleNode = lexical.$getAdjacentNode(selection2.focus, true);\n        if (lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n          possibleNode.selectPrevious();\n          event.preventDefault();\n          return true;\n        } else if (lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\n          possibleNode.select();\n          event.preventDefault();\n          return true;\n        }\n      }\n      return false;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, (event) => {\n      const selection2 = lexical.$getSelection();\n      if (lexical.$isNodeSelection(selection2)) {\n        const nodes = selection2.getNodes();\n        if (nodes.length > 0) {\n          nodes[0].selectNext(0, 0);\n          return true;\n        }\n      } else if (lexical.$isRangeSelection(selection2)) {\n        if ($isSelectionAtEndOfRoot(selection2)) {\n          event.preventDefault();\n          return true;\n        }\n        const possibleNode = lexical.$getAdjacentNode(selection2.focus, false);\n        if (lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n          possibleNode.selectNext();\n          event.preventDefault();\n          return true;\n        }\n      }\n      return false;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, (event) => {\n      const selection$1 = lexical.$getSelection();\n      if (lexical.$isNodeSelection(selection$1)) {\n        const nodes = selection$1.getNodes();\n        if (nodes.length > 0) {\n          event.preventDefault();\n          nodes[0].selectPrevious();\n          return true;\n        }\n      }\n      if (!lexical.$isRangeSelection(selection$1)) {\n        return false;\n      }\n      if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, true)) {\n        const isHoldingShift = event.shiftKey;\n        event.preventDefault();\n        selection.$moveCharacter(selection$1, isHoldingShift, true);\n        return true;\n      }\n      return false;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, (event) => {\n      const selection$1 = lexical.$getSelection();\n      if (lexical.$isNodeSelection(selection$1) && !$isTargetWithinDecorator(event.target)) {\n        const nodes = selection$1.getNodes();\n        if (nodes.length > 0) {\n          event.preventDefault();\n          nodes[0].selectNext(0, 0);\n          return true;\n        }\n      }\n      if (!lexical.$isRangeSelection(selection$1)) {\n        return false;\n      }\n      const isHoldingShift = event.shiftKey;\n      if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, false)) {\n        event.preventDefault();\n        selection.$moveCharacter(selection$1, isHoldingShift, false);\n        return true;\n      }\n      return false;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, (event) => {\n      if ($isTargetWithinDecorator(event.target)) {\n        return false;\n      }\n      const selection2 = lexical.$getSelection();\n      if (!lexical.$isRangeSelection(selection2)) {\n        return false;\n      }\n      event.preventDefault();\n      const {\n        anchor\n      } = selection2;\n      const anchorNode = anchor.getNode();\n      if (selection2.isCollapsed() && anchor.offset === 0 && !lexical.$isRootNode(anchorNode)) {\n        const element = utils.$getNearestBlockElementAncestorOrThrow(anchorNode);\n        if (element.getIndent() > 0) {\n          return editor.dispatchCommand(lexical.OUTDENT_CONTENT_COMMAND, void 0);\n        }\n      }\n      return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_DELETE_COMMAND, (event) => {\n      if ($isTargetWithinDecorator(event.target)) {\n        return false;\n      }\n      const selection2 = lexical.$getSelection();\n      if (!lexical.$isRangeSelection(selection2)) {\n        return false;\n      }\n      event.preventDefault();\n      return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, false);\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ENTER_COMMAND, (event) => {\n      const selection2 = lexical.$getSelection();\n      if (!lexical.$isRangeSelection(selection2)) {\n        return false;\n      }\n      if (event !== null) {\n        if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n          return false;\n        }\n        event.preventDefault();\n        if (event.shiftKey) {\n          return editor.dispatchCommand(lexical.INSERT_LINE_BREAK_COMMAND, false);\n        }\n      }\n      return editor.dispatchCommand(lexical.INSERT_PARAGRAPH_COMMAND, void 0);\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, () => {\n      const selection2 = lexical.$getSelection();\n      if (!lexical.$isRangeSelection(selection2)) {\n        return false;\n      }\n      editor.blur();\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DROP_COMMAND, (event) => {\n      const [, files] = eventFiles(event);\n      if (files.length > 0) {\n        const x = event.clientX;\n        const y = event.clientY;\n        const eventRange = caretFromPoint(x, y);\n        if (eventRange !== null) {\n          const {\n            offset: domOffset,\n            node: domNode\n          } = eventRange;\n          const node = lexical.$getNearestNodeFromDOMNode(domNode);\n          if (node !== null) {\n            const selection3 = lexical.$createRangeSelection();\n            if (lexical.$isTextNode(node)) {\n              selection3.anchor.set(node.getKey(), domOffset, \"text\");\n              selection3.focus.set(node.getKey(), domOffset, \"text\");\n            } else {\n              const parentKey = node.getParentOrThrow().getKey();\n              const offset = node.getIndexWithinParent() + 1;\n              selection3.anchor.set(parentKey, offset, \"element\");\n              selection3.focus.set(parentKey, offset, \"element\");\n            }\n            const normalizedSelection = lexical.$normalizeSelection__EXPERIMENTAL(selection3);\n            lexical.$setSelection(normalizedSelection);\n          }\n          editor.dispatchCommand(DRAG_DROP_PASTE, files);\n        }\n        event.preventDefault();\n        return true;\n      }\n      const selection2 = lexical.$getSelection();\n      if (lexical.$isRangeSelection(selection2)) {\n        return true;\n      }\n      return false;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGSTART_COMMAND, (event) => {\n      const [isFileTransfer] = eventFiles(event);\n      const selection2 = lexical.$getSelection();\n      if (isFileTransfer && !lexical.$isRangeSelection(selection2)) {\n        return false;\n      }\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGOVER_COMMAND, (event) => {\n      const [isFileTransfer] = eventFiles(event);\n      const selection2 = lexical.$getSelection();\n      if (isFileTransfer && !lexical.$isRangeSelection(selection2)) {\n        return false;\n      }\n      const x = event.clientX;\n      const y = event.clientY;\n      const eventRange = caretFromPoint(x, y);\n      if (eventRange !== null) {\n        const node = lexical.$getNearestNodeFromDOMNode(eventRange.node);\n        if (lexical.$isDecoratorNode(node)) {\n          event.preventDefault();\n        }\n      }\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.COPY_COMMAND, (event) => {\n      clipboard.copyToClipboard__EXPERIMENTAL(editor, event instanceof ClipboardEvent ? event : null);\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CUT_COMMAND, (event) => {\n      onCutForRichText(event, editor);\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.PASTE_COMMAND, (event) => {\n      const [, files, hasTextContent] = eventFiles(event);\n      if (files.length > 0 && !hasTextContent) {\n        editor.dispatchCommand(DRAG_DROP_PASTE, files);\n        return true;\n      }\n      const selection2 = lexical.$getSelection();\n      if (lexical.$isRangeSelection(selection2) || lexical.DEPRECATED_$isGridSelection(selection2)) {\n        onPasteForRichText(event, editor);\n        return true;\n      }\n      return false;\n    }, lexical.COMMAND_PRIORITY_EDITOR));\n    return removeListener;\n  }\n  LexicalRichText_dev.$createHeadingNode = $createHeadingNode;\n  LexicalRichText_dev.$createQuoteNode = $createQuoteNode;\n  LexicalRichText_dev.$isHeadingNode = $isHeadingNode;\n  LexicalRichText_dev.$isQuoteNode = $isQuoteNode;\n  LexicalRichText_dev.DRAG_DROP_PASTE = DRAG_DROP_PASTE;\n  LexicalRichText_dev.HeadingNode = HeadingNode;\n  LexicalRichText_dev.QuoteNode = QuoteNode;\n  LexicalRichText_dev.eventFiles = eventFiles;\n  LexicalRichText_dev.registerRichText = registerRichText;\n  return LexicalRichText_dev;\n}\nvar LexicalRichText_prod = {};\nvar hasRequiredLexicalRichText_prod;\nfunction requireLexicalRichText_prod() {\n  if (hasRequiredLexicalRichText_prod)\n    return LexicalRichText_prod;\n  hasRequiredLexicalRichText_prod = 1;\n  var a = requireLexicalClipboard(), g = requireLexicalSelection(), k = requireLexicalUtils(), l = require$$1;\n  function m(c, b) {\n    return \"undefined\" !== typeof document.caretRangeFromPoint ? (c = document.caretRangeFromPoint(c, b), null === c ? null : { node: c.startContainer, offset: c.startOffset }) : \"undefined\" !== document.caretPositionFromPoint ? (c = document.caretPositionFromPoint(c, b), null === c ? null : { node: c.offsetNode, offset: c.offset }) : null;\n  }\n  let p = \"undefined\" !== typeof window && \"undefined\" !== typeof window.document && \"undefined\" !== typeof window.document.createElement, q = p && \"documentMode\" in document ? document.documentMode : null;\n  let r = p && \"InputEvent\" in window && !q ? \"getTargetRanges\" in new window.InputEvent(\"input\") : false, t = p && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent), u = p && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, w = p && /^(?=.*Chrome).*/i.test(navigator.userAgent), x = p && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !w, y = l.createCommand(\"DRAG_DROP_PASTE_FILE\");\n  class z extends l.ElementNode {\n    static getType() {\n      return \"quote\";\n    }\n    static clone(c) {\n      return new z(c.__key);\n    }\n    constructor(c) {\n      super(c);\n    }\n    createDOM(c) {\n      let b = document.createElement(\"blockquote\");\n      k.addClassNamesToElement(b, c.theme.quote);\n      return b;\n    }\n    updateDOM() {\n      return false;\n    }\n    static importDOM() {\n      return { blockquote: () => ({ conversion: A, priority: 0 }) };\n    }\n    static importJSON(c) {\n      let b = B();\n      b.setFormat(c.format);\n      b.setIndent(c.indent);\n      b.setDirection(c.direction);\n      return b;\n    }\n    exportJSON() {\n      return { ...super.exportJSON(), type: \"quote\" };\n    }\n    insertNewAfter(c, b) {\n      c = l.$createParagraphNode();\n      let d = this.getDirection();\n      c.setDirection(d);\n      this.insertAfter(c, b);\n      return c;\n    }\n    collapseAtStart() {\n      let c = l.$createParagraphNode();\n      this.getChildren().forEach((b) => c.append(b));\n      this.replace(c);\n      return true;\n    }\n  }\n  function B() {\n    return l.$applyNodeReplacement(new z());\n  }\n  class D extends l.ElementNode {\n    static getType() {\n      return \"heading\";\n    }\n    static clone(c) {\n      return new D(c.__tag, c.__key);\n    }\n    constructor(c, b) {\n      super(b);\n      this.__tag = c;\n    }\n    getTag() {\n      return this.__tag;\n    }\n    createDOM(c) {\n      let b = this.__tag, d = document.createElement(b);\n      c = c.theme.heading;\n      void 0 !== c && k.addClassNamesToElement(d, c[b]);\n      return d;\n    }\n    updateDOM() {\n      return false;\n    }\n    static importDOM() {\n      return { h1: () => ({ conversion: E, priority: 0 }), h2: () => ({ conversion: E, priority: 0 }), h3: () => ({ conversion: E, priority: 0 }), h4: () => ({ conversion: E, priority: 0 }), h5: () => ({\n        conversion: E,\n        priority: 0\n      }), h6: () => ({ conversion: E, priority: 0 }), p: (c) => {\n        c = c.firstChild;\n        return null !== c && F(c) ? { conversion: () => ({ node: null }), priority: 3 } : null;\n      }, span: (c) => F(c) ? { conversion: () => ({ node: G(\"h1\") }), priority: 3 } : null };\n    }\n    static importJSON(c) {\n      let b = G(c.tag);\n      b.setFormat(c.format);\n      b.setIndent(c.indent);\n      b.setDirection(c.direction);\n      return b;\n    }\n    exportJSON() {\n      return { ...super.exportJSON(), tag: this.getTag(), type: \"heading\", version: 1 };\n    }\n    insertNewAfter(c, b = true) {\n      c = c ? c.anchor.offset : 0;\n      c = 0 < c && c < this.getTextContentSize() ? G(this.getTag()) : l.$createParagraphNode();\n      let d = this.getDirection();\n      c.setDirection(d);\n      this.insertAfter(c, b);\n      return c;\n    }\n    collapseAtStart() {\n      let c = this.isEmpty() ? l.$createParagraphNode() : G(this.getTag());\n      this.getChildren().forEach((b) => c.append(b));\n      this.replace(c);\n      return true;\n    }\n    extractWithChild() {\n      return true;\n    }\n  }\n  function F(c) {\n    return \"span\" === c.nodeName.toLowerCase() ? \"26pt\" === c.style.fontSize : false;\n  }\n  function E(c) {\n    c = c.nodeName.toLowerCase();\n    let b = null;\n    if (\"h1\" === c || \"h2\" === c || \"h3\" === c || \"h4\" === c || \"h5\" === c || \"h6\" === c)\n      b = G(c);\n    return { node: b };\n  }\n  function A() {\n    return { node: B() };\n  }\n  function G(c) {\n    return l.$applyNodeReplacement(new D(c));\n  }\n  function H(c, b) {\n    c.preventDefault();\n    b.update(() => {\n      let d = l.$getSelection(), e = c instanceof InputEvent || c instanceof KeyboardEvent ? null : c.clipboardData;\n      null != e && (l.$isRangeSelection(d) || l.DEPRECATED_$isGridSelection(d)) && a.$insertDataTransferForRichText(e, d, b);\n    }, { tag: \"paste\" });\n  }\n  async function I(c, b) {\n    await a.copyToClipboard__EXPERIMENTAL(b, c instanceof ClipboardEvent ? c : null);\n    b.update(() => {\n      let d = l.$getSelection();\n      l.$isRangeSelection(d) ? d.removeText() : l.$isNodeSelection(d) && d.getNodes().forEach((e) => e.remove());\n    });\n  }\n  function J(c) {\n    let b = null;\n    c instanceof DragEvent ? b = c.dataTransfer : c instanceof ClipboardEvent && (b = c.clipboardData);\n    if (null === b)\n      return [false, [], false];\n    var d = b.types;\n    c = d.includes(\"Files\");\n    d = d.includes(\"text/html\") || d.includes(\"text/plain\");\n    return [c, Array.from(b.files), d];\n  }\n  function K(c, b) {\n    var d = l.$getSelection();\n    if (l.$isRangeSelection(d)) {\n      var e = /* @__PURE__ */ new Set();\n      d = d.getNodes();\n      for (let f = 0; f < d.length; f++) {\n        let n = d[f], v = n.getKey();\n        if (e.has(v))\n          continue;\n        let h = k.$getNearestBlockElementAncestorOrThrow(n), C = h.getKey();\n        h.canInsertTab() ? (c(n), e.add(v)) : h.canIndent() && !e.has(C) && (e.add(C), b(h));\n      }\n    }\n  }\n  function L(c) {\n    c = l.$getNearestNodeFromDOMNode(c);\n    return l.$isDecoratorNode(c);\n  }\n  LexicalRichText_prod.$createHeadingNode = G;\n  LexicalRichText_prod.$createQuoteNode = B;\n  LexicalRichText_prod.$isHeadingNode = function(c) {\n    return c instanceof D;\n  };\n  LexicalRichText_prod.$isQuoteNode = function(c) {\n    return c instanceof z;\n  };\n  LexicalRichText_prod.DRAG_DROP_PASTE = y;\n  LexicalRichText_prod.HeadingNode = D;\n  LexicalRichText_prod.QuoteNode = z;\n  LexicalRichText_prod.eventFiles = J;\n  LexicalRichText_prod.registerRichText = function(c) {\n    return k.mergeRegister(\n      c.registerCommand(l.CLICK_COMMAND, () => {\n        const b = l.$getSelection();\n        return l.$isNodeSelection(b) ? (b.clear(), true) : false;\n      }, 0),\n      c.registerCommand(l.DELETE_CHARACTER_COMMAND, (b) => {\n        const d = l.$getSelection();\n        if (!l.$isRangeSelection(d))\n          return false;\n        d.deleteCharacter(b);\n        return true;\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(l.DELETE_WORD_COMMAND, (b) => {\n        const d = l.$getSelection();\n        if (!l.$isRangeSelection(d))\n          return false;\n        d.deleteWord(b);\n        return true;\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(l.DELETE_LINE_COMMAND, (b) => {\n        const d = l.$getSelection();\n        if (!l.$isRangeSelection(d))\n          return false;\n        d.deleteLine(b);\n        return true;\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(l.CONTROLLED_TEXT_INSERTION_COMMAND, (b) => {\n        const d = l.$getSelection();\n        if (\"string\" === typeof b)\n          l.$isRangeSelection(d) ? d.insertText(b) : l.DEPRECATED_$isGridSelection(d);\n        else {\n          if (!l.$isRangeSelection(d) && !l.DEPRECATED_$isGridSelection(d))\n            return false;\n          const e = b.dataTransfer;\n          null != e ? a.$insertDataTransferForRichText(e, d, c) : l.$isRangeSelection(d) && (b = b.data) && d.insertText(b);\n        }\n        return true;\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(l.REMOVE_TEXT_COMMAND, () => {\n        const b = l.$getSelection();\n        if (!l.$isRangeSelection(b))\n          return false;\n        b.removeText();\n        return true;\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(l.FORMAT_TEXT_COMMAND, (b) => {\n        const d = l.$getSelection();\n        if (!l.$isRangeSelection(d))\n          return false;\n        d.formatText(b);\n        return true;\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(l.FORMAT_ELEMENT_COMMAND, (b) => {\n        var d = l.$getSelection();\n        if (!l.$isRangeSelection(d) && !l.$isNodeSelection(d))\n          return false;\n        d = d.getNodes();\n        for (const e of d)\n          k.$getNearestBlockElementAncestorOrThrow(e).setFormat(b);\n        return true;\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(l.INSERT_LINE_BREAK_COMMAND, (b) => {\n        const d = l.$getSelection();\n        if (!l.$isRangeSelection(d))\n          return false;\n        d.insertLineBreak(b);\n        return true;\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(l.INSERT_PARAGRAPH_COMMAND, () => {\n        const b = l.$getSelection();\n        if (!l.$isRangeSelection(b))\n          return false;\n        b.insertParagraph();\n        return true;\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(\n        l.INDENT_CONTENT_COMMAND,\n        () => {\n          K(() => {\n            c.dispatchCommand(l.CONTROLLED_TEXT_INSERTION_COMMAND, \"\t\");\n          }, (b) => {\n            const d = b.getIndent();\n            10 !== d && b.setIndent(d + 1);\n          });\n          return true;\n        },\n        l.COMMAND_PRIORITY_EDITOR\n      ),\n      c.registerCommand(l.OUTDENT_CONTENT_COMMAND, () => {\n        K((b) => {\n          l.$isTextNode(b) && (b = b.getTextContent(), \"\t\" === b[b.length - 1] && c.dispatchCommand(l.DELETE_CHARACTER_COMMAND, true));\n        }, (b) => {\n          const d = b.getIndent();\n          0 !== d && b.setIndent(d - 1);\n        });\n        return true;\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(l.KEY_ARROW_UP_COMMAND, (b) => {\n        var d = l.$getSelection();\n        if (l.$isNodeSelection(d) && !L(b.target)) {\n          if (b = d.getNodes(), 0 < b.length)\n            return b[0].selectPrevious(), true;\n        } else if (l.$isRangeSelection(d)) {\n          d = l.$getAdjacentNode(d.focus, true);\n          if (l.$isDecoratorNode(d) && !d.isIsolated() && !d.isInline())\n            return d.selectPrevious(), b.preventDefault(), true;\n          if (l.$isElementNode(d) && !d.isInline() && !d.canBeEmpty())\n            return d.select(), b.preventDefault(), true;\n        }\n        return false;\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(l.KEY_ARROW_DOWN_COMMAND, (b) => {\n        var d = l.$getSelection();\n        if (l.$isNodeSelection(d)) {\n          if (b = d.getNodes(), 0 < b.length)\n            return b[0].selectNext(\n              0,\n              0\n            ), true;\n        } else if (l.$isRangeSelection(d)) {\n          let e = d.focus;\n          if (\"root\" === e.key && e.offset === l.$getRoot().getChildrenSize())\n            return b.preventDefault(), true;\n          d = l.$getAdjacentNode(d.focus, false);\n          if (l.$isDecoratorNode(d) && !d.isIsolated() && !d.isInline())\n            return d.selectNext(), b.preventDefault(), true;\n        }\n        return false;\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(l.KEY_ARROW_LEFT_COMMAND, (b) => {\n        const d = l.$getSelection();\n        if (l.$isNodeSelection(d)) {\n          var e = d.getNodes();\n          if (0 < e.length)\n            return b.preventDefault(), e[0].selectPrevious(), true;\n        }\n        return l.$isRangeSelection(d) ? g.$shouldOverrideDefaultCharacterSelection(d, true) ? (e = b.shiftKey, b.preventDefault(), g.$moveCharacter(d, e, true), true) : false : false;\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(l.KEY_ARROW_RIGHT_COMMAND, (b) => {\n        const d = l.$getSelection();\n        if (l.$isNodeSelection(d) && !L(b.target)) {\n          var e = d.getNodes();\n          if (0 < e.length)\n            return b.preventDefault(), e[0].selectNext(0, 0), true;\n        }\n        if (!l.$isRangeSelection(d))\n          return false;\n        e = b.shiftKey;\n        return g.$shouldOverrideDefaultCharacterSelection(d, false) ? (b.preventDefault(), g.$moveCharacter(d, e, false), true) : false;\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(l.KEY_BACKSPACE_COMMAND, (b) => {\n        if (L(b.target))\n          return false;\n        const d = l.$getSelection();\n        if (!l.$isRangeSelection(d))\n          return false;\n        b.preventDefault();\n        ({ anchor: b } = d);\n        const e = b.getNode();\n        return d.isCollapsed() && 0 === b.offset && !l.$isRootNode(e) && 0 < k.$getNearestBlockElementAncestorOrThrow(e).getIndent() ? c.dispatchCommand(l.OUTDENT_CONTENT_COMMAND, void 0) : c.dispatchCommand(l.DELETE_CHARACTER_COMMAND, true);\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(l.KEY_DELETE_COMMAND, (b) => {\n        if (L(b.target))\n          return false;\n        const d = l.$getSelection();\n        if (!l.$isRangeSelection(d))\n          return false;\n        b.preventDefault();\n        return c.dispatchCommand(l.DELETE_CHARACTER_COMMAND, false);\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(l.KEY_ENTER_COMMAND, (b) => {\n        const d = l.$getSelection();\n        if (!l.$isRangeSelection(d))\n          return false;\n        if (null !== b) {\n          if ((u || t || x) && r)\n            return false;\n          b.preventDefault();\n          if (b.shiftKey)\n            return c.dispatchCommand(l.INSERT_LINE_BREAK_COMMAND, false);\n        }\n        return c.dispatchCommand(l.INSERT_PARAGRAPH_COMMAND, void 0);\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(\n        l.KEY_ESCAPE_COMMAND,\n        () => {\n          const b = l.$getSelection();\n          if (!l.$isRangeSelection(b))\n            return false;\n          c.blur();\n          return true;\n        },\n        l.COMMAND_PRIORITY_EDITOR\n      ),\n      c.registerCommand(l.DROP_COMMAND, (b) => {\n        const [, d] = J(b);\n        if (0 < d.length) {\n          var e = m(b.clientX, b.clientY);\n          if (null !== e) {\n            const { offset: n, node: v } = e;\n            var f = l.$getNearestNodeFromDOMNode(v);\n            if (null !== f) {\n              e = l.$createRangeSelection();\n              if (l.$isTextNode(f))\n                e.anchor.set(f.getKey(), n, \"text\"), e.focus.set(f.getKey(), n, \"text\");\n              else {\n                const h = f.getParentOrThrow().getKey();\n                f = f.getIndexWithinParent() + 1;\n                e.anchor.set(\n                  h,\n                  f,\n                  \"element\"\n                );\n                e.focus.set(h, f, \"element\");\n              }\n              e = l.$normalizeSelection__EXPERIMENTAL(e);\n              l.$setSelection(e);\n            }\n            c.dispatchCommand(y, d);\n          }\n          b.preventDefault();\n          return true;\n        }\n        b = l.$getSelection();\n        return l.$isRangeSelection(b) ? true : false;\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(l.DRAGSTART_COMMAND, (b) => {\n        [b] = J(b);\n        const d = l.$getSelection();\n        return b && !l.$isRangeSelection(d) ? false : true;\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(l.DRAGOVER_COMMAND, (b) => {\n        var [d] = J(b);\n        const e = l.$getSelection();\n        if (d && !l.$isRangeSelection(e))\n          return false;\n        d = m(b.clientX, b.clientY);\n        null !== d && (d = l.$getNearestNodeFromDOMNode(d.node), l.$isDecoratorNode(d) && b.preventDefault());\n        return true;\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(l.COPY_COMMAND, (b) => {\n        a.copyToClipboard__EXPERIMENTAL(c, b instanceof ClipboardEvent ? b : null);\n        return true;\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(l.CUT_COMMAND, (b) => {\n        I(b, c);\n        return true;\n      }, l.COMMAND_PRIORITY_EDITOR),\n      c.registerCommand(l.PASTE_COMMAND, (b) => {\n        const [, d, e] = J(b);\n        if (0 < d.length && !e)\n          return c.dispatchCommand(y, d), true;\n        const f = l.$getSelection();\n        return l.$isRangeSelection(f) || l.DEPRECATED_$isGridSelection(f) ? (H(b, c), true) : false;\n      }, l.COMMAND_PRIORITY_EDITOR)\n    );\n  };\n  return LexicalRichText_prod;\n}\nconst LexicalRichText = process.env.NODE_ENV === \"development\" ? requireLexicalRichText_dev() : requireLexicalRichText_prod();\nvar LexicalRichText_1 = LexicalRichText;\nvar hasRequiredLexicalMarkdown_dev;\nfunction requireLexicalMarkdown_dev() {\n  if (hasRequiredLexicalMarkdown_dev)\n    return LexicalMarkdown_dev;\n  hasRequiredLexicalMarkdown_dev = 1;\n  var lexical = require$$1;\n  var code = LexicalCode_1;\n  var list = LexicalList_1;\n  var richText = LexicalRichText_1;\n  var utils = requireLexicalUtils();\n  var link = LexicalLink_1;\n  function indexBy(list2, callback) {\n    const index = {};\n    for (const item of list2) {\n      const key = callback(item);\n      if (index[key]) {\n        index[key].push(item);\n      } else {\n        index[key] = [item];\n      }\n    }\n    return index;\n  }\n  function transformersByType(transformers) {\n    const byType = indexBy(transformers, (t) => t.type);\n    return {\n      element: byType.element || [],\n      textFormat: byType[\"text-format\"] || [],\n      textMatch: byType[\"text-match\"] || []\n    };\n  }\n  const PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\\s]/;\n  function createMarkdownExport(transformers) {\n    const byType = transformersByType(transformers);\n    const textFormatTransformers = byType.textFormat.filter((transformer) => transformer.format.length === 1);\n    return () => {\n      const output = [];\n      const children = lexical.$getRoot().getChildren();\n      for (const child of children) {\n        const result = exportTopLevelElements(child, byType.element, textFormatTransformers, byType.textMatch);\n        if (result != null) {\n          output.push(result);\n        }\n      }\n      return output.join(\"\\n\\n\");\n    };\n  }\n  function exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {\n    for (const transformer of elementTransformers) {\n      const result = transformer.export(node, (_node) => exportChildren(_node, textTransformersIndex, textMatchTransformers));\n      if (result != null) {\n        return result;\n      }\n    }\n    if (lexical.$isElementNode(node)) {\n      return exportChildren(node, textTransformersIndex, textMatchTransformers);\n    } else if (lexical.$isDecoratorNode(node)) {\n      return node.getTextContent();\n    } else {\n      return null;\n    }\n  }\n  function exportChildren(node, textTransformersIndex, textMatchTransformers) {\n    const output = [];\n    const children = node.getChildren();\n    mainLoop:\n      for (const child of children) {\n        for (const transformer of textMatchTransformers) {\n          const result = transformer.export(child, (parentNode) => exportChildren(parentNode, textTransformersIndex, textMatchTransformers), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex));\n          if (result != null) {\n            output.push(result);\n            continue mainLoop;\n          }\n        }\n        if (lexical.$isLineBreakNode(child)) {\n          output.push(\"\\n\");\n        } else if (lexical.$isTextNode(child)) {\n          output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex));\n        } else if (lexical.$isElementNode(child)) {\n          output.push(exportChildren(child, textTransformersIndex, textMatchTransformers));\n        } else if (lexical.$isDecoratorNode(child)) {\n          output.push(child.getTextContent());\n        }\n      }\n    return output.join(\"\");\n  }\n  function exportTextFormat(node, textContent, textTransformers) {\n    const frozenString = textContent.trim();\n    let output = frozenString;\n    const applied = /* @__PURE__ */ new Set();\n    for (const transformer of textTransformers) {\n      const format = transformer.format[0];\n      const tag = transformer.tag;\n      if (hasFormat(node, format) && !applied.has(format)) {\n        applied.add(format);\n        const previousNode = getTextSibling(node, true);\n        if (!hasFormat(previousNode, format)) {\n          output = tag + output;\n        }\n        const nextNode = getTextSibling(node, false);\n        if (!hasFormat(nextNode, format)) {\n          output += tag;\n        }\n      }\n    }\n    return textContent.replace(frozenString, output);\n  }\n  function getTextSibling(node, backward) {\n    let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n    if (!sibling) {\n      const parent = node.getParentOrThrow();\n      if (parent.isInline()) {\n        sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n      }\n    }\n    while (sibling) {\n      if (lexical.$isElementNode(sibling)) {\n        if (!sibling.isInline()) {\n          break;\n        }\n        const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();\n        if (lexical.$isTextNode(descendant)) {\n          return descendant;\n        } else {\n          sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();\n        }\n      }\n      if (lexical.$isTextNode(sibling)) {\n        return sibling;\n      }\n      if (!lexical.$isElementNode(sibling)) {\n        return null;\n      }\n    }\n    return null;\n  }\n  function hasFormat(node, format) {\n    return lexical.$isTextNode(node) && node.hasFormat(format);\n  }\n  const CAN_USE_DOM = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\n  const documentMode = CAN_USE_DOM && \"documentMode\" in document ? document.documentMode : null;\n  CAN_USE_DOM && \"InputEvent\" in window && !documentMode ? \"getTargetRanges\" in new window.InputEvent(\"input\") : false;\n  const IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\n  const IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n  const IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n  const IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n  const MARKDOWN_EMPTY_LINE_REG_EXP = /^\\s{0,3}$/;\n  const CODE_BLOCK_REG_EXP = /^```(\\w{1,10})?\\s?$/;\n  function createMarkdownImport(transformers) {\n    const byType = transformersByType(transformers);\n    const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);\n    return (markdownString) => {\n      const lines = markdownString.split(\"\\n\");\n      const linesLength = lines.length;\n      const root = lexical.$getRoot();\n      root.clear();\n      for (let i = 0; i < linesLength; i++) {\n        const lineText = lines[i];\n        const [codeBlockNode, shiftedIndex] = importCodeBlock(lines, i, root);\n        if (codeBlockNode != null) {\n          i = shiftedIndex;\n          continue;\n        }\n        importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch);\n      }\n      const children = root.getChildren();\n      for (const child of children) {\n        if (isEmptyParagraph(child)) {\n          child.remove();\n        }\n      }\n      root.selectEnd();\n    };\n  }\n  function isEmptyParagraph(node) {\n    if (!lexical.$isParagraphNode(node)) {\n      return false;\n    }\n    const firstChild = node.getFirstChild();\n    return firstChild == null || node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());\n  }\n  function importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers) {\n    const lineTextTrimmed = lineText.trim();\n    const textNode = lexical.$createTextNode(lineTextTrimmed);\n    const elementNode = lexical.$createParagraphNode();\n    elementNode.append(textNode);\n    rootNode.append(elementNode);\n    for (const {\n      regExp,\n      replace\n    } of elementTransformers) {\n      const match = lineText.match(regExp);\n      if (match) {\n        textNode.setTextContent(lineText.slice(match[0].length));\n        replace(elementNode, [textNode], match, true);\n        break;\n      }\n    }\n    importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers);\n    if (elementNode.isAttached() && lineTextTrimmed.length > 0) {\n      const previousNode = elementNode.getPreviousSibling();\n      if (lexical.$isParagraphNode(previousNode) || richText.$isQuoteNode(previousNode) || list.$isListNode(previousNode)) {\n        let targetNode = previousNode;\n        if (list.$isListNode(previousNode)) {\n          const lastDescendant = previousNode.getLastDescendant();\n          if (lastDescendant == null) {\n            targetNode = null;\n          } else {\n            targetNode = utils.$findMatchingParent(lastDescendant, list.$isListItemNode);\n          }\n        }\n        if (targetNode != null && targetNode.getTextContentSize() > 0) {\n          targetNode.splice(targetNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...elementNode.getChildren()]);\n          elementNode.remove();\n        }\n      }\n    }\n  }\n  function importCodeBlock(lines, startLineIndex, rootNode) {\n    const openMatch = lines[startLineIndex].match(CODE_BLOCK_REG_EXP);\n    if (openMatch) {\n      let endLineIndex = startLineIndex;\n      const linesLength = lines.length;\n      while (++endLineIndex < linesLength) {\n        const closeMatch = lines[endLineIndex].match(CODE_BLOCK_REG_EXP);\n        if (closeMatch) {\n          const codeBlockNode = code.$createCodeNode(openMatch[1]);\n          const textNode = lexical.$createTextNode(lines.slice(startLineIndex + 1, endLineIndex).join(\"\\n\"));\n          codeBlockNode.append(textNode);\n          rootNode.append(codeBlockNode);\n          return [codeBlockNode, endLineIndex];\n        }\n      }\n    }\n    return [null, startLineIndex];\n  }\n  function importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {\n    const textContent = textNode.getTextContent();\n    const match = findOutermostMatch(textContent, textFormatTransformersIndex);\n    if (!match) {\n      importTextMatchTransformers(textNode, textMatchTransformers);\n      return;\n    }\n    let currentNode, remainderNode, leadingNode;\n    if (match[0] === textContent) {\n      currentNode = textNode;\n    } else {\n      const startIndex = match.index || 0;\n      const endIndex = startIndex + match[0].length;\n      if (startIndex === 0) {\n        [currentNode, remainderNode] = textNode.splitText(endIndex);\n      } else {\n        [leadingNode, currentNode, remainderNode] = textNode.splitText(startIndex, endIndex);\n      }\n    }\n    currentNode.setTextContent(match[2]);\n    const transformer = textFormatTransformersIndex.transformersByTag[match[1]];\n    if (transformer) {\n      for (const format of transformer.format) {\n        if (!currentNode.hasFormat(format)) {\n          currentNode.toggleFormat(format);\n        }\n      }\n    }\n    if (!currentNode.hasFormat(\"code\")) {\n      importTextFormatTransformers(currentNode, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (leadingNode) {\n      importTextFormatTransformers(leadingNode, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (remainderNode) {\n      importTextFormatTransformers(remainderNode, textFormatTransformersIndex, textMatchTransformers);\n    }\n  }\n  function importTextMatchTransformers(textNode_, textMatchTransformers) {\n    let textNode = textNode_;\n    mainLoop:\n      while (textNode) {\n        for (const transformer of textMatchTransformers) {\n          const match = textNode.getTextContent().match(transformer.importRegExp);\n          if (!match) {\n            continue;\n          }\n          const startIndex = match.index || 0;\n          const endIndex = startIndex + match[0].length;\n          let replaceNode, leftTextNode, rightTextNode;\n          if (startIndex === 0) {\n            [replaceNode, textNode] = textNode.splitText(endIndex);\n          } else {\n            [leftTextNode, replaceNode, rightTextNode] = textNode.splitText(startIndex, endIndex);\n          }\n          if (leftTextNode) {\n            importTextMatchTransformers(leftTextNode, textMatchTransformers);\n          }\n          if (rightTextNode) {\n            textNode = rightTextNode;\n          }\n          transformer.replace(replaceNode, match);\n          continue mainLoop;\n        }\n        break;\n      }\n  }\n  function findOutermostMatch(textContent, textTransformersIndex) {\n    const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);\n    if (openTagsMatch == null) {\n      return null;\n    }\n    for (const match of openTagsMatch) {\n      const tag = match.replace(/^\\s/, \"\");\n      const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];\n      if (fullMatchRegExp == null) {\n        continue;\n      }\n      const fullMatch = textContent.match(fullMatchRegExp);\n      const transformer = textTransformersIndex.transformersByTag[tag];\n      if (fullMatch != null && transformer != null) {\n        if (transformer.intraword !== false) {\n          return fullMatch;\n        }\n        const {\n          index = 0\n        } = fullMatch;\n        const beforeChar = textContent[index - 1];\n        const afterChar = textContent[index + fullMatch[0].length];\n        if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {\n          return fullMatch;\n        }\n      }\n    }\n    return null;\n  }\n  function createTextFormatTransformersIndex(textTransformers) {\n    const transformersByTag = {};\n    const fullMatchRegExpByTag = {};\n    const openTagsRegExp = [];\n    const escapeRegExp = `(?<![\\\\\\\\])`;\n    for (const transformer of textTransformers) {\n      const {\n        tag\n      } = transformer;\n      transformersByTag[tag] = transformer;\n      const tagRegExp = tag.replace(/(\\*|\\^|\\+)/g, \"\\\\$1\");\n      openTagsRegExp.push(tagRegExp);\n      if (IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT) {\n        fullMatchRegExpByTag[tag] = new RegExp(`(${tagRegExp})(?![${tagRegExp}\\\\s])(.*?[^${tagRegExp}\\\\s])${tagRegExp}(?!${tagRegExp})`);\n      } else {\n        fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\\\\${tagRegExp}])(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^${tagRegExp}\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?![\\\\\\\\${tagRegExp}])`);\n      }\n    }\n    return {\n      // Reg exp to find open tag + content + close tag\n      fullMatchRegExpByTag,\n      // Reg exp to find opening tags\n      openTagsRegExp: new RegExp((IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? \"\" : `${escapeRegExp}`) + \"(\" + openTagsRegExp.join(\"|\") + \")\", \"g\"),\n      transformersByTag\n    };\n  }\n  function runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n    const grandParentNode = parentNode.getParent();\n    if (!lexical.$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n      return false;\n    }\n    const textContent = anchorNode.getTextContent();\n    if (textContent[anchorOffset - 1] !== \" \") {\n      return false;\n    }\n    for (const {\n      regExp,\n      replace\n    } of elementTransformers) {\n      const match = textContent.match(regExp);\n      if (match && match[0].length === anchorOffset) {\n        const nextSiblings = anchorNode.getNextSiblings();\n        const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n        leadingNode.remove();\n        const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n        replace(parentNode, siblings, match, false);\n        return true;\n      }\n    }\n    return false;\n  }\n  function runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {\n    let textContent = anchorNode.getTextContent();\n    const lastChar = textContent[anchorOffset - 1];\n    const transformers = transformersByTrigger[lastChar];\n    if (transformers == null) {\n      return false;\n    }\n    if (anchorOffset < textContent.length) {\n      textContent = textContent.slice(0, anchorOffset);\n    }\n    for (const transformer of transformers) {\n      const match = textContent.match(transformer.regExp);\n      if (match === null) {\n        continue;\n      }\n      const startIndex = match.index || 0;\n      const endIndex = startIndex + match[0].length;\n      let replaceNode;\n      if (startIndex === 0) {\n        [replaceNode] = anchorNode.splitText(endIndex);\n      } else {\n        [, replaceNode] = anchorNode.splitText(startIndex, endIndex);\n      }\n      replaceNode.selectNext(0, 0);\n      transformer.replace(replaceNode, match);\n      return true;\n    }\n    return false;\n  }\n  function runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {\n    const textContent = anchorNode.getTextContent();\n    const closeTagEndIndex = anchorOffset - 1;\n    const closeChar = textContent[closeTagEndIndex];\n    const matchers = textFormatTransformers[closeChar];\n    if (!matchers) {\n      return false;\n    }\n    for (const matcher of matchers) {\n      const {\n        tag\n      } = matcher;\n      const tagLength = tag.length;\n      const closeTagStartIndex = closeTagEndIndex - tagLength + 1;\n      if (tagLength > 1) {\n        if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {\n          continue;\n        }\n      }\n      if (textContent[closeTagStartIndex - 1] === \" \") {\n        continue;\n      }\n      const afterCloseTagChar = textContent[closeTagEndIndex + 1];\n      if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {\n        continue;\n      }\n      const closeNode = anchorNode;\n      let openNode = closeNode;\n      let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag);\n      let sibling = openNode;\n      while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {\n        if (lexical.$isLineBreakNode(sibling)) {\n          break;\n        }\n        if (lexical.$isTextNode(sibling)) {\n          const siblingTextContent = sibling.getTextContent();\n          openNode = sibling;\n          openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);\n        }\n      }\n      if (openTagStartIndex < 0) {\n        continue;\n      }\n      if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {\n        continue;\n      }\n      const prevOpenNodeText = openNode.getTextContent();\n      if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {\n        continue;\n      }\n      const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];\n      if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {\n        continue;\n      }\n      const prevCloseNodeText = closeNode.getTextContent();\n      const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);\n      closeNode.setTextContent(closeNodeText);\n      const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;\n      openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));\n      const selection = lexical.$getSelection();\n      const nextSelection = lexical.$createRangeSelection();\n      lexical.$setSelection(nextSelection);\n      const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;\n      nextSelection.anchor.set(openNode.__key, openTagStartIndex, \"text\");\n      nextSelection.focus.set(closeNode.__key, newOffset, \"text\");\n      for (const format of matcher.format) {\n        if (!nextSelection.hasFormat(format)) {\n          nextSelection.formatText(format);\n        }\n      }\n      nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type);\n      for (const format of matcher.format) {\n        if (nextSelection.hasFormat(format)) {\n          nextSelection.toggleFormat(format);\n        }\n      }\n      if (lexical.$isRangeSelection(selection)) {\n        nextSelection.format = selection.format;\n      }\n      return true;\n    }\n    return false;\n  }\n  function getOpenTagStartIndex(string, maxIndex, tag) {\n    const tagLength = tag.length;\n    for (let i = maxIndex; i >= tagLength; i--) {\n      const startIndex = i - tagLength;\n      if (isEqualSubString(string, startIndex, tag, 0, tagLength) && // Space after opening tag cancels transformation\n      string[startIndex + tagLength] !== \" \") {\n        return startIndex;\n      }\n    }\n    return -1;\n  }\n  function isEqualSubString(stringA, aStart, stringB, bStart, length) {\n    for (let i = 0; i < length; i++) {\n      if (stringA[aStart + i] !== stringB[bStart + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {\n    const byType = transformersByType(transformers);\n    const textFormatTransformersIndex = indexBy(byType.textFormat, ({\n      tag\n    }) => tag[tag.length - 1]);\n    const textMatchTransformersIndex = indexBy(byType.textMatch, ({\n      trigger\n    }) => trigger);\n    for (const transformer of transformers) {\n      const type = transformer.type;\n      if (type === \"element\" || type === \"text-match\") {\n        const dependencies = transformer.dependencies;\n        if (!editor.hasNodes(dependencies)) {\n          {\n            throw Error(`MarkdownShortcuts: missing dependency for transformer. Ensure node dependency is included in editor initial config.`);\n          }\n        }\n      }\n    }\n    const transform = (parentNode, anchorNode, anchorOffset) => {\n      if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {\n        return;\n      }\n      if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersIndex)) {\n        return;\n      }\n      runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersIndex);\n    };\n    return editor.registerUpdateListener(({\n      tags,\n      dirtyLeaves,\n      editorState,\n      prevEditorState\n    }) => {\n      if (tags.has(\"historic\")) {\n        return;\n      }\n      const selection = editorState.read(lexical.$getSelection);\n      const prevSelection = prevEditorState.read(lexical.$getSelection);\n      if (!lexical.$isRangeSelection(prevSelection) || !lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n        return;\n      }\n      const anchorKey = selection.anchor.key;\n      const anchorOffset = selection.anchor.offset;\n      const anchorNode = editorState._nodeMap.get(anchorKey);\n      if (!lexical.$isTextNode(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset !== prevSelection.anchor.offset + 1) {\n        return;\n      }\n      editor.update(() => {\n        if (anchorNode.hasFormat(\"code\")) {\n          return;\n        }\n        const parentNode = anchorNode.getParent();\n        if (parentNode === null || code.$isCodeNode(parentNode)) {\n          return;\n        }\n        transform(parentNode, anchorNode, selection.anchor.offset);\n      });\n    });\n  }\n  const createBlockNode = (createNode) => {\n    return (parentNode, children, match) => {\n      const node = createNode(match);\n      node.append(...children);\n      parentNode.replace(node);\n      node.select(0, 0);\n    };\n  };\n  const LIST_INDENT_SIZE = 4;\n  const listReplace = (listType) => {\n    return (parentNode, children, match) => {\n      const previousNode = parentNode.getPreviousSibling();\n      const listItem = list.$createListItemNode(listType === \"check\" ? match[3] === \"x\" : void 0);\n      if (list.$isListNode(previousNode) && previousNode.getListType() === listType) {\n        previousNode.append(listItem);\n        parentNode.remove();\n      } else {\n        const list$1 = list.$createListNode(listType, listType === \"number\" ? Number(match[2]) : void 0);\n        list$1.append(listItem);\n        parentNode.replace(list$1);\n      }\n      listItem.append(...children);\n      listItem.select(0, 0);\n      const indent = Math.floor(match[1].length / LIST_INDENT_SIZE);\n      if (indent) {\n        listItem.setIndent(indent);\n      }\n    };\n  };\n  const listExport = (listNode, exportChildren2, depth) => {\n    const output = [];\n    const children = listNode.getChildren();\n    let index = 0;\n    for (const listItemNode of children) {\n      if (list.$isListItemNode(listItemNode)) {\n        if (listItemNode.getChildrenSize() === 1) {\n          const firstChild = listItemNode.getFirstChild();\n          if (list.$isListNode(firstChild)) {\n            output.push(listExport(firstChild, exportChildren2, depth + 1));\n            continue;\n          }\n        }\n        const indent = \" \".repeat(depth * LIST_INDENT_SIZE);\n        const listType = listNode.getListType();\n        const prefix = listType === \"number\" ? `${listNode.getStart() + index}. ` : listType === \"check\" ? `- [${listItemNode.getChecked() ? \"x\" : \" \"}] ` : \"- \";\n        output.push(indent + prefix + exportChildren2(listItemNode));\n        index++;\n      }\n    }\n    return output.join(\"\\n\");\n  };\n  const HEADING = {\n    dependencies: [richText.HeadingNode],\n    export: (node, exportChildren2) => {\n      if (!richText.$isHeadingNode(node)) {\n        return null;\n      }\n      const level = Number(node.getTag().slice(1));\n      return \"#\".repeat(level) + \" \" + exportChildren2(node);\n    },\n    regExp: /^(#{1,6})\\s/,\n    replace: createBlockNode((match) => {\n      const tag = \"h\" + match[1].length;\n      return richText.$createHeadingNode(tag);\n    }),\n    type: \"element\"\n  };\n  const QUOTE = {\n    dependencies: [richText.QuoteNode],\n    export: (node, exportChildren2) => {\n      if (!richText.$isQuoteNode(node)) {\n        return null;\n      }\n      const lines = exportChildren2(node).split(\"\\n\");\n      const output = [];\n      for (const line of lines) {\n        output.push(\"> \" + line);\n      }\n      return output.join(\"\\n\");\n    },\n    regExp: /^>\\s/,\n    replace: (parentNode, children, _match, isImport) => {\n      if (isImport) {\n        const previousNode = parentNode.getPreviousSibling();\n        if (richText.$isQuoteNode(previousNode)) {\n          previousNode.splice(previousNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...children]);\n          previousNode.select(0, 0);\n          parentNode.remove();\n          return;\n        }\n      }\n      const node = richText.$createQuoteNode();\n      node.append(...children);\n      parentNode.replace(node);\n      node.select(0, 0);\n    },\n    type: \"element\"\n  };\n  const CODE = {\n    dependencies: [code.CodeNode],\n    export: (node) => {\n      if (!code.$isCodeNode(node)) {\n        return null;\n      }\n      const textContent = node.getTextContent();\n      return \"```\" + (node.getLanguage() || \"\") + (textContent ? \"\\n\" + textContent : \"\") + \"\\n```\";\n    },\n    regExp: /^```(\\w{1,10})?\\s/,\n    replace: createBlockNode((match) => {\n      return code.$createCodeNode(match ? match[1] : void 0);\n    }),\n    type: \"element\"\n  };\n  const UNORDERED_LIST = {\n    dependencies: [list.ListNode, list.ListItemNode],\n    export: (node, exportChildren2) => {\n      return list.$isListNode(node) ? listExport(node, exportChildren2, 0) : null;\n    },\n    regExp: /^(\\s*)[-*+]\\s/,\n    replace: listReplace(\"bullet\"),\n    type: \"element\"\n  };\n  const CHECK_LIST = {\n    dependencies: [list.ListNode, list.ListItemNode],\n    export: (node, exportChildren2) => {\n      return list.$isListNode(node) ? listExport(node, exportChildren2, 0) : null;\n    },\n    regExp: /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i,\n    replace: listReplace(\"check\"),\n    type: \"element\"\n  };\n  const ORDERED_LIST = {\n    dependencies: [list.ListNode, list.ListItemNode],\n    export: (node, exportChildren2) => {\n      return list.$isListNode(node) ? listExport(node, exportChildren2, 0) : null;\n    },\n    regExp: /^(\\s*)(\\d{1,})\\.\\s/,\n    replace: listReplace(\"number\"),\n    type: \"element\"\n  };\n  const INLINE_CODE = {\n    format: [\"code\"],\n    tag: \"`\",\n    type: \"text-format\"\n  };\n  const HIGHLIGHT = {\n    format: [\"highlight\"],\n    tag: \"==\",\n    type: \"text-format\"\n  };\n  const BOLD_ITALIC_STAR = {\n    format: [\"bold\", \"italic\"],\n    tag: \"***\",\n    type: \"text-format\"\n  };\n  const BOLD_ITALIC_UNDERSCORE = {\n    format: [\"bold\", \"italic\"],\n    intraword: false,\n    tag: \"___\",\n    type: \"text-format\"\n  };\n  const BOLD_STAR = {\n    format: [\"bold\"],\n    tag: \"**\",\n    type: \"text-format\"\n  };\n  const BOLD_UNDERSCORE = {\n    format: [\"bold\"],\n    intraword: false,\n    tag: \"__\",\n    type: \"text-format\"\n  };\n  const STRIKETHROUGH = {\n    format: [\"strikethrough\"],\n    tag: \"~~\",\n    type: \"text-format\"\n  };\n  const ITALIC_STAR = {\n    format: [\"italic\"],\n    tag: \"*\",\n    type: \"text-format\"\n  };\n  const ITALIC_UNDERSCORE = {\n    format: [\"italic\"],\n    intraword: false,\n    tag: \"_\",\n    type: \"text-format\"\n  };\n  const LINK = {\n    dependencies: [link.LinkNode],\n    export: (node, exportChildren2, exportFormat) => {\n      if (!link.$isLinkNode(node)) {\n        return null;\n      }\n      const linkContent = `[${node.getTextContent()}](${node.getURL()})`;\n      const firstChild = node.getFirstChild();\n      if (node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild)) {\n        return exportFormat(firstChild, linkContent);\n      } else {\n        return linkContent;\n      }\n    },\n    importRegExp: /(?:\\[([^[]+)\\])(?:\\(([^()]+)\\))/,\n    regExp: /(?:\\[([^[]+)\\])(?:\\(([^()]+)\\))$/,\n    replace: (textNode, match) => {\n      const [, linkText, linkUrl] = match;\n      const linkNode = link.$createLinkNode(linkUrl);\n      const linkTextNode = lexical.$createTextNode(linkText);\n      linkTextNode.setFormat(textNode.getFormat());\n      linkNode.append(linkTextNode);\n      textNode.replace(linkNode);\n    },\n    trigger: \")\",\n    type: \"text-match\"\n  };\n  const ELEMENT_TRANSFORMERS = [HEADING, QUOTE, CODE, UNORDERED_LIST, ORDERED_LIST];\n  const TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];\n  const TEXT_MATCH_TRANSFORMERS = [LINK];\n  const TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];\n  function $convertFromMarkdownString(markdown, transformers = TRANSFORMERS) {\n    const importMarkdown = createMarkdownImport(transformers);\n    return importMarkdown(markdown);\n  }\n  function $convertToMarkdownString(transformers = TRANSFORMERS) {\n    const exportMarkdown = createMarkdownExport(transformers);\n    return exportMarkdown();\n  }\n  LexicalMarkdown_dev.$convertFromMarkdownString = $convertFromMarkdownString;\n  LexicalMarkdown_dev.$convertToMarkdownString = $convertToMarkdownString;\n  LexicalMarkdown_dev.BOLD_ITALIC_STAR = BOLD_ITALIC_STAR;\n  LexicalMarkdown_dev.BOLD_ITALIC_UNDERSCORE = BOLD_ITALIC_UNDERSCORE;\n  LexicalMarkdown_dev.BOLD_STAR = BOLD_STAR;\n  LexicalMarkdown_dev.BOLD_UNDERSCORE = BOLD_UNDERSCORE;\n  LexicalMarkdown_dev.CHECK_LIST = CHECK_LIST;\n  LexicalMarkdown_dev.CODE = CODE;\n  LexicalMarkdown_dev.ELEMENT_TRANSFORMERS = ELEMENT_TRANSFORMERS;\n  LexicalMarkdown_dev.HEADING = HEADING;\n  LexicalMarkdown_dev.HIGHLIGHT = HIGHLIGHT;\n  LexicalMarkdown_dev.INLINE_CODE = INLINE_CODE;\n  LexicalMarkdown_dev.ITALIC_STAR = ITALIC_STAR;\n  LexicalMarkdown_dev.ITALIC_UNDERSCORE = ITALIC_UNDERSCORE;\n  LexicalMarkdown_dev.LINK = LINK;\n  LexicalMarkdown_dev.ORDERED_LIST = ORDERED_LIST;\n  LexicalMarkdown_dev.QUOTE = QUOTE;\n  LexicalMarkdown_dev.STRIKETHROUGH = STRIKETHROUGH;\n  LexicalMarkdown_dev.TEXT_FORMAT_TRANSFORMERS = TEXT_FORMAT_TRANSFORMERS;\n  LexicalMarkdown_dev.TEXT_MATCH_TRANSFORMERS = TEXT_MATCH_TRANSFORMERS;\n  LexicalMarkdown_dev.TRANSFORMERS = TRANSFORMERS;\n  LexicalMarkdown_dev.UNORDERED_LIST = UNORDERED_LIST;\n  LexicalMarkdown_dev.registerMarkdownShortcuts = registerMarkdownShortcuts;\n  return LexicalMarkdown_dev;\n}\nvar LexicalMarkdown_prod = {};\nvar hasRequiredLexicalMarkdown_prod;\nfunction requireLexicalMarkdown_prod() {\n  if (hasRequiredLexicalMarkdown_prod)\n    return LexicalMarkdown_prod;\n  hasRequiredLexicalMarkdown_prod = 1;\n  var h = require$$1, t = LexicalCode_1, A = LexicalList_1, B = LexicalRichText_1, aa = requireLexicalUtils(), G = LexicalLink_1;\n  function H(a, b) {\n    let c = {};\n    for (let d of a)\n      a = b(d), c[a] ? c[a].push(d) : c[a] = [d];\n    return c;\n  }\n  function I(a) {\n    a = H(a, (b) => b.type);\n    return { element: a.element || [], textFormat: a[\"text-format\"] || [], textMatch: a[\"text-match\"] || [] };\n  }\n  let J = /[!-/:-@[-`{-~\\s]/;\n  function ba(a) {\n    let b = I(a), c = b.textFormat.filter((d) => 1 === d.format.length);\n    return () => {\n      let d = [];\n      var e = h.$getRoot().getChildren();\n      for (let f of e)\n        e = ca(f, b.element, c, b.textMatch), null != e && d.push(e);\n      return d.join(\"\\n\\n\");\n    };\n  }\n  function ca(a, b, c, d) {\n    for (let e of b)\n      if (b = e.export(a, (f) => K(f, c, d)), null != b)\n        return b;\n    return h.$isElementNode(a) ? K(a, c, d) : h.$isDecoratorNode(a) ? a.getTextContent() : null;\n  }\n  function K(a, b, c) {\n    let d = [];\n    a = a.getChildren();\n    a:\n      for (let e of a) {\n        for (let f of c)\n          if (a = f.export(e, (l) => K(l, b, c), (l, k) => L(l, k, b)), null != a) {\n            d.push(a);\n            continue a;\n          }\n        h.$isLineBreakNode(e) ? d.push(\"\\n\") : h.$isTextNode(e) ? d.push(L(e, e.getTextContent(), b)) : h.$isElementNode(e) ? d.push(K(e, b, c)) : h.$isDecoratorNode(e) && d.push(e.getTextContent());\n      }\n    return d.join(\"\");\n  }\n  function L(a, b, c) {\n    let d = b.trim(), e = d, f = /* @__PURE__ */ new Set();\n    for (let k of c) {\n      c = k.format[0];\n      let p = k.tag;\n      if (M(a, c) && !f.has(c)) {\n        f.add(c);\n        var l = N(a, true);\n        M(l, c) || (e = p + e);\n        l = N(a, false);\n        M(l, c) || (e += p);\n      }\n    }\n    return b.replace(d, e);\n  }\n  function N(a, b) {\n    let c = b ? a.getPreviousSibling() : a.getNextSibling();\n    c || (a = a.getParentOrThrow(), a.isInline() && (c = b ? a.getPreviousSibling() : a.getNextSibling()));\n    for (; c; ) {\n      if (h.$isElementNode(c)) {\n        if (!c.isInline())\n          break;\n        a = b ? c.getLastDescendant() : c.getFirstDescendant();\n        if (h.$isTextNode(a))\n          return a;\n        c = b ? c.getPreviousSibling() : c.getNextSibling();\n      }\n      if (h.$isTextNode(c))\n        return c;\n      if (!h.$isElementNode(c))\n        break;\n    }\n    return null;\n  }\n  function M(a, b) {\n    return h.$isTextNode(a) && a.hasFormat(b);\n  }\n  let O = \"undefined\" !== typeof window && \"undefined\" !== typeof window.document && \"undefined\" !== typeof window.document.createElement, da = O && \"documentMode\" in document ? document.documentMode : null;\n  O && \"InputEvent\" in window && !da ? \"getTargetRanges\" in new window.InputEvent(\"input\") : false;\n  let P = O && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent), Q = O && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, ea = O && /^(?=.*Chrome).*/i.test(navigator.userAgent), R = O && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !ea, fa = /^\\s{0,3}$/, S = /^```(\\w{1,10})?\\s?$/;\n  function ha(a) {\n    let b = I(a), c = ia(b.textFormat);\n    return (d) => {\n      var e = d.split(\"\\n\"), f = e.length;\n      d = h.$getRoot();\n      d.clear();\n      for (let g = 0; g < f; g++) {\n        var l = e[g];\n        a: {\n          var k = e, p = g;\n          var r = d;\n          var y = k[p].match(S);\n          if (y) {\n            for (var q = p, m = k.length; ++q < m; )\n              if (k[q].match(S)) {\n                y = t.$createCodeNode(y[1]);\n                k = h.$createTextNode(k.slice(p + 1, q).join(\"\\n\"));\n                y.append(k);\n                r.append(y);\n                r = [y, q];\n                break a;\n              }\n          }\n          r = [null, p];\n        }\n        let [n, v] = r;\n        if (null != n)\n          g = v;\n        else {\n          r = l;\n          m = d;\n          var w = b.element;\n          q = c;\n          k = b.textMatch;\n          p = r.trim();\n          y = h.$createTextNode(p);\n          l = h.$createParagraphNode();\n          l.append(y);\n          m.append(l);\n          for (let { regExp: x, replace: u } of w)\n            if (m = r.match(x)) {\n              y.setTextContent(r.slice(m[0].length));\n              u(l, [y], m, true);\n              break;\n            }\n          T(y, q, k);\n          l.isAttached() && 0 < p.length && (r = l.getPreviousSibling(), h.$isParagraphNode(r) || B.$isQuoteNode(r) || A.$isListNode(r)) && (q = r, A.$isListNode(r) && (r = r.getLastDescendant(), q = null == r ? null : aa.$findMatchingParent(r, A.$isListItemNode)), null != q && 0 < q.getTextContentSize() && (q.splice(q.getChildrenSize(), 0, [h.$createLineBreakNode(), ...l.getChildren()]), l.remove()));\n        }\n      }\n      e = d.getChildren();\n      for (let g of e)\n        e = g, h.$isParagraphNode(e) ? (f = e.getFirstChild(), e = null == f || 1 === e.getChildrenSize() && h.$isTextNode(f) && fa.test(f.getTextContent())) : e = false, e && g.remove();\n      d.selectEnd();\n    };\n  }\n  function T(a, b, c) {\n    var d = a.getTextContent();\n    let e = ja(d, b);\n    if (e) {\n      var f, l;\n      if (e[0] === d)\n        var k = a;\n      else {\n        d = e.index || 0;\n        let p = d + e[0].length;\n        0 === d ? [k, f] = a.splitText(p) : [l, k, f] = a.splitText(d, p);\n      }\n      k.setTextContent(e[2]);\n      if (a = b.transformersByTag[e[1]])\n        for (let p of a.format)\n          k.hasFormat(p) || k.toggleFormat(p);\n      k.hasFormat(\"code\") || T(k, b, c);\n      l && T(l, b, c);\n      f && T(f, b, c);\n    } else\n      U(a, c);\n  }\n  function U(a, b) {\n    a:\n      for (; a; ) {\n        for (let c of b) {\n          let d = a.getTextContent().match(c.importRegExp);\n          if (!d)\n            continue;\n          let e = d.index || 0, f = e + d[0].length, l, k, p;\n          0 === e ? [l, a] = a.splitText(f) : [k, l, p] = a.splitText(e, f);\n          k && U(k, b);\n          p && (a = p);\n          c.replace(l, d);\n          continue a;\n        }\n        break;\n      }\n  }\n  function ja(a, b) {\n    var c = a.match(b.openTagsRegExp);\n    if (null == c)\n      return null;\n    for (let f of c) {\n      var d = f.replace(/^\\s/, \"\");\n      c = b.fullMatchRegExpByTag[d];\n      if (null != c && (c = a.match(c), d = b.transformersByTag[d], null != c && null != d)) {\n        if (false !== d.intraword)\n          return c;\n        var { index: e = 0 } = c;\n        d = a[e - 1];\n        e = a[e + c[0].length];\n        if (!(d && !J.test(d) || e && !J.test(e)))\n          return c;\n      }\n    }\n    return null;\n  }\n  function ia(a) {\n    let b = {}, c = {}, d = [];\n    for (let e of a) {\n      ({ tag: a } = e);\n      b[a] = e;\n      let f = a.replace(/(\\*|\\^|\\+)/g, \"\\\\$1\");\n      d.push(f);\n      c[a] = P || Q || R ? new RegExp(`(${f})(?![${f}\\\\s])(.*?[^${f}\\\\s])${f}(?!${f})`) : new RegExp(`(?<![\\\\\\\\${f}])(${f})((\\\\\\\\${f})?.*?[^${f}\\\\s](\\\\\\\\${f})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${f})(?![\\\\\\\\${f}])`);\n    }\n    return { fullMatchRegExpByTag: c, openTagsRegExp: new RegExp((P || Q || R ? \"\" : \"(?<![\\\\\\\\])\") + \"(\" + d.join(\"|\") + \")\", \"g\"), transformersByTag: b };\n  }\n  function V(a, b, c) {\n    let d = c.length;\n    for (; b >= d; b--) {\n      let e = b - d;\n      if (W(a, e, c, 0, d) && \" \" !== a[e + d])\n        return e;\n    }\n    return -1;\n  }\n  function W(a, b, c, d, e) {\n    for (let f = 0; f < e; f++)\n      if (a[b + f] !== c[d + f])\n        return false;\n    return true;\n  }\n  let ka = (a) => (b, c, d) => {\n    d = a(d);\n    d.append(...c);\n    b.replace(d);\n    d.select(0, 0);\n  }, X = (a) => (b, c, d) => {\n    var e = b.getPreviousSibling();\n    const f = A.$createListItemNode(\"check\" === a ? \"x\" === d[3] : void 0);\n    A.$isListNode(e) && e.getListType() === a ? (e.append(f), b.remove()) : (e = A.$createListNode(a, \"number\" === a ? Number(d[2]) : void 0), e.append(f), b.replace(e));\n    f.append(...c);\n    f.select(0, 0);\n    (b = Math.floor(d[1].length / 4)) && f.setIndent(b);\n  }, Y = (a, b, c) => {\n    const d = [];\n    var e = a.getChildren();\n    let f = 0;\n    for (const k of e)\n      if (A.$isListItemNode(k)) {\n        if (1 === k.getChildrenSize() && (e = k.getFirstChild(), A.$isListNode(e))) {\n          d.push(Y(e, b, c + 1));\n          continue;\n        }\n        e = \" \".repeat(4 * c);\n        var l = a.getListType();\n        l = \"number\" === l ? `${a.getStart() + f}. ` : \"check\" === l ? `- [${k.getChecked() ? \"x\" : \" \"}] ` : \"- \";\n        d.push(e + l + b(k));\n        f++;\n      }\n    return d.join(\"\\n\");\n  }, la = { dependencies: [B.HeadingNode], export: (a, b) => {\n    if (!B.$isHeadingNode(a))\n      return null;\n    const c = Number(a.getTag().slice(1));\n    return \"#\".repeat(c) + \" \" + b(a);\n  }, regExp: /^(#{1,6})\\s/, replace: ka((a) => B.$createHeadingNode(\"h\" + a[1].length)), type: \"element\" }, ma = {\n    dependencies: [B.QuoteNode],\n    export: (a, b) => {\n      if (!B.$isQuoteNode(a))\n        return null;\n      a = b(a).split(\"\\n\");\n      b = [];\n      for (const c of a)\n        b.push(\"> \" + c);\n      return b.join(\"\\n\");\n    },\n    regExp: /^>\\s/,\n    replace: (a, b, c, d) => {\n      if (d && (c = a.getPreviousSibling(), B.$isQuoteNode(c))) {\n        c.splice(c.getChildrenSize(), 0, [h.$createLineBreakNode(), ...b]);\n        c.select(0, 0);\n        a.remove();\n        return;\n      }\n      c = B.$createQuoteNode();\n      c.append(...b);\n      a.replace(c);\n      c.select(0, 0);\n    },\n    type: \"element\"\n  }, na = { dependencies: [t.CodeNode], export: (a) => {\n    if (!t.$isCodeNode(a))\n      return null;\n    const b = a.getTextContent();\n    return \"```\" + (a.getLanguage() || \"\") + (b ? \"\\n\" + b : \"\") + \"\\n```\";\n  }, regExp: /^```(\\w{1,10})?\\s/, replace: ka((a) => t.$createCodeNode(a ? a[1] : void 0)), type: \"element\" }, oa = { dependencies: [A.ListNode, A.ListItemNode], export: (a, b) => A.$isListNode(a) ? Y(a, b, 0) : null, regExp: /^(\\s*)[-*+]\\s/, replace: X(\"bullet\"), type: \"element\" }, pa = { dependencies: [A.ListNode, A.ListItemNode], export: (a, b) => A.$isListNode(a) ? Y(a, b, 0) : null, regExp: /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i, replace: X(\"check\"), type: \"element\" }, qa = { dependencies: [A.ListNode, A.ListItemNode], export: (a, b) => A.$isListNode(a) ? Y(a, b, 0) : null, regExp: /^(\\s*)(\\d{1,})\\.\\s/, replace: X(\"number\"), type: \"element\" }, ra = { format: [\"code\"], tag: \"`\", type: \"text-format\" }, sa = { format: [\"highlight\"], tag: \"==\", type: \"text-format\" }, ta = { format: [\"bold\", \"italic\"], tag: \"***\", type: \"text-format\" }, va = { format: [\"bold\", \"italic\"], intraword: false, tag: \"___\", type: \"text-format\" }, wa = { format: [\"bold\"], tag: \"**\", type: \"text-format\" }, xa = { format: [\"bold\"], intraword: false, tag: \"__\", type: \"text-format\" }, ya = { format: [\"strikethrough\"], tag: \"~~\", type: \"text-format\" }, za = { format: [\"italic\"], tag: \"*\", type: \"text-format\" }, Aa = { format: [\"italic\"], intraword: false, tag: \"_\", type: \"text-format\" }, Ba = { dependencies: [G.LinkNode], export: (a, b, c) => {\n    if (!G.$isLinkNode(a))\n      return null;\n    b = `[${a.getTextContent()}](${a.getURL()})`;\n    const d = a.getFirstChild();\n    return 1 === a.getChildrenSize() && h.$isTextNode(d) ? c(d, b) : b;\n  }, importRegExp: /(?:\\[([^[]+)\\])(?:\\(([^()]+)\\))/, regExp: /(?:\\[([^[]+)\\])(?:\\(([^()]+)\\))$/, replace: (a, b) => {\n    const [, c, d] = b;\n    b = G.$createLinkNode(d);\n    const e = h.$createTextNode(c);\n    e.setFormat(a.getFormat());\n    b.append(e);\n    a.replace(b);\n  }, trigger: \")\", type: \"text-match\" }, Ca = [la, ma, na, oa, qa], Da = [ra, ta, va, wa, xa, sa, za, Aa, ya], Ea = [Ba], Z = [...Ca, ...Da, ...Ea];\n  LexicalMarkdown_prod.$convertFromMarkdownString = function(a, b = Z) {\n    return ha(b)(a);\n  };\n  LexicalMarkdown_prod.$convertToMarkdownString = function(a = Z) {\n    return ba(a)();\n  };\n  LexicalMarkdown_prod.BOLD_ITALIC_STAR = ta;\n  LexicalMarkdown_prod.BOLD_ITALIC_UNDERSCORE = va;\n  LexicalMarkdown_prod.BOLD_STAR = wa;\n  LexicalMarkdown_prod.BOLD_UNDERSCORE = xa;\n  LexicalMarkdown_prod.CHECK_LIST = pa;\n  LexicalMarkdown_prod.CODE = na;\n  LexicalMarkdown_prod.ELEMENT_TRANSFORMERS = Ca;\n  LexicalMarkdown_prod.HEADING = la;\n  LexicalMarkdown_prod.HIGHLIGHT = sa;\n  LexicalMarkdown_prod.INLINE_CODE = ra;\n  LexicalMarkdown_prod.ITALIC_STAR = za;\n  LexicalMarkdown_prod.ITALIC_UNDERSCORE = Aa;\n  LexicalMarkdown_prod.LINK = Ba;\n  LexicalMarkdown_prod.ORDERED_LIST = qa;\n  LexicalMarkdown_prod.QUOTE = ma;\n  LexicalMarkdown_prod.STRIKETHROUGH = ya;\n  LexicalMarkdown_prod.TEXT_FORMAT_TRANSFORMERS = Da;\n  LexicalMarkdown_prod.TEXT_MATCH_TRANSFORMERS = Ea;\n  LexicalMarkdown_prod.TRANSFORMERS = Z;\n  LexicalMarkdown_prod.UNORDERED_LIST = oa;\n  LexicalMarkdown_prod.registerMarkdownShortcuts = function(a, b = Z) {\n    let c = I(b), d = H(c.textFormat, ({ tag: f }) => f[f.length - 1]), e = H(c.textMatch, ({ trigger: f }) => f);\n    for (let f of b)\n      if (b = f.type, (\"element\" === b || \"text-match\" === b) && !a.hasNodes(f.dependencies))\n        throw Error(\"Minified Lexical error #79; visit https://lexical.dev/docs/error?code=79 for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\");\n    return a.registerUpdateListener(({ tags: f, dirtyLeaves: l, editorState: k, prevEditorState: p }) => {\n      if (!f.has(\"historic\")) {\n        var r = k.read(h.$getSelection);\n        f = p.read(h.$getSelection);\n        if (h.$isRangeSelection(f) && h.$isRangeSelection(r) && r.isCollapsed()) {\n          p = r.anchor.key;\n          var y = r.anchor.offset, q = k._nodeMap.get(p);\n          h.$isTextNode(q) && l.has(p) && (1 === y || y === f.anchor.offset + 1) && a.update(() => {\n            if (!q.hasFormat(\"code\")) {\n              var m = q.getParent();\n              if (null !== m && !t.$isCodeNode(m)) {\n                var w = r.anchor.offset;\n                b: {\n                  var g = c.element, n = m.getParent();\n                  if (h.$isRootOrShadowRoot(n) && m.getFirstChild() === q && (n = q.getTextContent(), \" \" === n[w - 1])) {\n                    for (let {\n                      regExp: D,\n                      replace: E\n                    } of g)\n                      if ((g = n.match(D)) && g[0].length === w) {\n                        n = q.getNextSiblings();\n                        let [F, ua] = q.splitText(w);\n                        F.remove();\n                        n = ua ? [ua, ...n] : n;\n                        E(m, n, g, false);\n                        m = true;\n                        break b;\n                      }\n                  }\n                  m = false;\n                }\n                if (!m) {\n                  b: {\n                    g = q.getTextContent();\n                    m = e[g[w - 1]];\n                    if (null != m) {\n                      w < g.length && (g = g.slice(0, w));\n                      for (x of m)\n                        if (m = g.match(x.regExp), null !== m) {\n                          g = m.index || 0;\n                          n = g + m[0].length;\n                          var v = void 0;\n                          0 === g ? [v] = q.splitText(n) : [, v] = q.splitText(g, n);\n                          v.selectNext(0, 0);\n                          x.replace(v, m);\n                          var x = true;\n                          break b;\n                        }\n                    }\n                    x = false;\n                  }\n                  if (!x)\n                    b: {\n                      n = q.getTextContent();\n                      --w;\n                      var u = n[w];\n                      if (x = d[u])\n                        for (let D of x) {\n                          var { tag: C } = D;\n                          x = C.length;\n                          let E = w - x + 1;\n                          if (!(1 < x && !W(n, E, C, 0, x) || \" \" === n[E - 1]) && (v = n[w + 1], false !== D.intraword || !v || J.test(v))) {\n                            m = v = q;\n                            g = V(n, E, C);\n                            for (var z = m; 0 > g && (z = z.getPreviousSibling()) && !h.$isLineBreakNode(z); )\n                              h.$isTextNode(z) && (g = z.getTextContent(), m = z, g = V(g, g.length, C));\n                            if (!(0 > g || m === v && g + x === E || (C = m.getTextContent(), 0 < g && C[g - 1] === u || (z = C[g - 1], false === D.intraword && z && !J.test(z))))) {\n                              n = v.getTextContent();\n                              n = n.slice(0, E) + n.slice(w + 1);\n                              v.setTextContent(n);\n                              n = m === v ? n : C;\n                              m.setTextContent(n.slice(0, g) + n.slice(g + x));\n                              n = h.$getSelection();\n                              u = h.$createRangeSelection();\n                              h.$setSelection(u);\n                              w = w - x * (m === v ? 2 : 1) + 1;\n                              u.anchor.set(m.__key, g, \"text\");\n                              u.focus.set(v.__key, w, \"text\");\n                              for (let F of D.format)\n                                u.hasFormat(F) || u.formatText(F);\n                              u.anchor.set(u.focus.key, u.focus.offset, u.focus.type);\n                              for (let F of D.format)\n                                u.hasFormat(F) && u.toggleFormat(F);\n                              h.$isRangeSelection(n) && (u.format = n.format);\n                              break b;\n                            }\n                          }\n                        }\n                    }\n                }\n              }\n            }\n          });\n        }\n      }\n    });\n  };\n  return LexicalMarkdown_prod;\n}\nconst LexicalMarkdown = process.env.NODE_ENV === \"development\" ? requireLexicalMarkdown_dev() : requireLexicalMarkdown_prod();\nvar LexicalMarkdown_1 = LexicalMarkdown;\nvar LexicalUtilsExports = requireLexicalUtils();\nfunction ListPlugin() {\n  const [editor] = useLexicalComposerContext();\n  useEffect(() => {\n    return LexicalUtilsExports.mergeRegister(\n      editor.registerCommand(\n        LexicalList_1.INSERT_ORDERED_LIST_COMMAND,\n        () => {\n          LexicalList_1.insertList(editor, \"number\");\n          return true;\n        },\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand(\n        LexicalList_1.INSERT_UNORDERED_LIST_COMMAND,\n        () => {\n          LexicalList_1.insertList(editor, \"bullet\");\n          return true;\n        },\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand(\n        LexicalList_1.REMOVE_LIST_COMMAND,\n        () => {\n          LexicalList_1.removeList(editor);\n          return true;\n        },\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand(\n        INSERT_PARAGRAPH_COMMAND,\n        () => {\n          const hasHandledInsertParagraph = LexicalList_1.$handleListInsertParagraph();\n          return hasHandledInsertParagraph;\n        },\n        COMMAND_PRIORITY_LOW\n      )\n    );\n  }, [editor]);\n  return null;\n}\nvar LexicalSelectionExports = requireLexicalSelection();\nconst useToolbarStyles = makeStyles((theme) => ({\n  paper: {\n    display: \"flex\",\n    flexDirection: \"row\",\n    borderBottom: `1px solid ${theme.palette.divider}`,\n    flexWrap: \"wrap\"\n  },\n  divider: {\n    margin: theme.spacing(1, 0.5)\n  },\n  button: {\n    color: theme.palette.primary.light,\n    \"&.Mui-selected:not(:disabled)\": {\n      color: theme.palette.primary.main\n    }\n  }\n}));\nconst StyledToggleButtonGroup = withStyles((theme) => ({\n  grouped: {\n    margin: theme.spacing(0.5),\n    border: \"none\",\n    \"&:not(:first-child)\": {\n      borderRadius: theme.shape.borderRadius\n    },\n    \"&:first-child\": {\n      borderRadius: theme.shape.borderRadius\n    }\n  }\n}))(ToggleButtonGroup);\nconst ToolbarPlugin = ({ readOnly }) => {\n  const [editor] = useLexicalComposerContext();\n  const [isBold, setIsBold] = useState(false);\n  const [isItalic, setIsItalic] = useState(false);\n  const [isStrikeTrough, setIsStrikeTrough] = useState(false);\n  const [isCode, setIsCode] = useState(false);\n  const [blockType, setBlockType] = useState(\"paragraph\");\n  const updateButtons = (toggled2) => {\n    setIsBold(toggled2.includes(\"bold\"));\n    setIsItalic(toggled2.includes(\"italic\"));\n    setIsStrikeTrough(toggled2.includes(\"strikethrough\"));\n    setIsCode(toggled2.includes(\"code\"));\n    if (toggled2.includes(\"paragraph\")) {\n      setBlockType(\"paragraph\");\n    }\n    if (toggled2.includes(\"header1\")) {\n      setBlockType(\"header1\");\n    }\n    if (toggled2.includes(\"number-list\")) {\n      setBlockType(\"number-list\");\n    }\n    if (toggled2.includes(\"bullet-list\")) {\n      setBlockType(\"bullet-list\");\n    }\n  };\n  const updateToolbar = useCallback(() => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const anchorNode = selection.anchor.getNode();\n      const element = anchorNode.getKey() === \"root\" ? anchorNode : anchorNode.getTopLevelElementOrThrow();\n      const elementKey = element.getKey();\n      const elementDOM = editor.getElementByKey(elementKey);\n      if (elementDOM !== null) {\n        setIsBold(selection.hasFormat(\"bold\"));\n        setIsItalic(selection.hasFormat(\"italic\"));\n        setIsStrikeTrough(selection.hasFormat(\"strikethrough\"));\n        setIsCode(selection.hasFormat(\"code\"));\n        if (LexicalList_1.$isListNode(element)) {\n          const parentList = LexicalUtilsExports.$getNearestNodeOfType(anchorNode, LexicalList_1.ListNode);\n          const type = parentList ? parentList.getTag() : element.getTag();\n          if (type === \"ol\") {\n            setBlockType(\"number-list\");\n          } else if (type === \"ul\") {\n            setBlockType(\"bullet-list\");\n          } else {\n            setBlockType(type);\n          }\n        } else {\n          const type = LexicalRichText_1.$isHeadingNode(element) ? element.getTag() : element.getType();\n          if (type === \"h1\") {\n            setBlockType(\"header1\");\n          } else if (type === \"paragraph\") {\n            setBlockType(\"paragraph\");\n          } else {\n            setBlockType(type);\n          }\n        }\n      }\n    }\n  }, []);\n  useEffect(() => {\n    return LexicalUtilsExports.mergeRegister(\n      editor.registerUpdateListener(({ editorState }) => {\n        editorState.read(() => {\n          updateToolbar();\n        });\n      }),\n      editor.registerCommand(\n        SELECTION_CHANGE_COMMAND,\n        (_payload, _newEditor) => {\n          updateToolbar();\n          return false;\n        },\n        COMMAND_PRIORITY_LOW\n      )\n    );\n  }, [editor, updateToolbar]);\n  const toggled = [blockType];\n  if (isBold) {\n    toggled.push(\"bold\");\n  }\n  if (isItalic) {\n    toggled.push(\"italic\");\n  }\n  if (isStrikeTrough) {\n    toggled.push(\"strikethrough\");\n  }\n  if (isCode) {\n    toggled.push(\"code\");\n  }\n  const classes = useToolbarStyles({});\n  return /* @__PURE__ */ jsxs(Paper, { elevation: 0, className: classes.paper, children: [\n    /* @__PURE__ */ jsxs(StyledToggleButtonGroup, { size: \"small\", value: toggled, onChange: (_, newStyles) => updateButtons(newStyles), children: [\n      /* @__PURE__ */ jsx(\n        ToggleButton,\n        {\n          classes: { root: classes.button },\n          disabled: readOnly,\n          value: \"paragraph\",\n          onClick: () => {\n            editor.update(() => {\n              const selection = $getSelection();\n              if ($isRangeSelection(selection)) {\n                LexicalSelectionExports.$wrapNodes(selection, () => $createParagraphNode());\n              }\n            });\n          },\n          children: /* @__PURE__ */ jsx(SubjectIcon, { fontSize: \"small\" })\n        },\n        \"paragraph\"\n      ),\n      /* @__PURE__ */ jsx(\n        ToggleButton,\n        {\n          classes: { root: classes.button },\n          disabled: readOnly,\n          value: \"header1\",\n          onClick: () => {\n            editor.update(() => {\n              const selection = $getSelection();\n              if ($isRangeSelection(selection)) {\n                LexicalSelectionExports.$wrapNodes(selection, () => LexicalRichText_1.$createHeadingNode(\"h1\"));\n              }\n            });\n          },\n          children: /* @__PURE__ */ jsx(TitleIcon, { fontSize: \"small\" })\n        },\n        \"header1\"\n      ),\n      /* @__PURE__ */ jsx(\n        ToggleButton,\n        {\n          classes: { root: classes.button },\n          disabled: readOnly,\n          value: \"bullet-list\",\n          onClick: () => {\n            if (blockType !== \"bullet-list\") {\n              editor.dispatchCommand(LexicalList_1.INSERT_UNORDERED_LIST_COMMAND, void 0);\n            } else {\n              editor.dispatchCommand(LexicalList_1.REMOVE_LIST_COMMAND, void 0);\n            }\n          },\n          children: /* @__PURE__ */ jsx(FormatListBulletedIcon, { fontSize: \"small\" })\n        },\n        \"bullet-list\"\n      ),\n      /* @__PURE__ */ jsx(\n        ToggleButton,\n        {\n          classes: { root: classes.button },\n          disabled: readOnly,\n          value: \"number-list\",\n          onClick: () => {\n            if (blockType !== \"number-list\") {\n              editor.dispatchCommand(LexicalList_1.INSERT_ORDERED_LIST_COMMAND, void 0);\n            } else {\n              editor.dispatchCommand(LexicalList_1.REMOVE_LIST_COMMAND, void 0);\n            }\n          },\n          children: /* @__PURE__ */ jsx(FormatListNumberedIcon, { fontSize: \"small\" })\n        },\n        \"number-list\"\n      )\n    ] }),\n    /* @__PURE__ */ jsx(Divider, { flexItem: true, orientation: \"vertical\", className: classes.divider }),\n    /* @__PURE__ */ jsxs(StyledToggleButtonGroup, { size: \"small\", value: toggled, onChange: (_, newStyles) => updateButtons(newStyles), children: [\n      /* @__PURE__ */ jsx(\n        ToggleButton,\n        {\n          classes: { root: classes.button },\n          disabled: readOnly,\n          value: \"bold\",\n          onClick: () => {\n            editor.dispatchCommand(FORMAT_TEXT_COMMAND, \"bold\");\n          },\n          children: /* @__PURE__ */ jsx(FormatBoldIcon, { fontSize: \"small\" })\n        },\n        \"bold\"\n      ),\n      /* @__PURE__ */ jsx(\n        ToggleButton,\n        {\n          classes: { root: classes.button },\n          disabled: readOnly,\n          value: \"italic\",\n          onClick: () => {\n            editor.dispatchCommand(FORMAT_TEXT_COMMAND, \"italic\");\n          },\n          children: /* @__PURE__ */ jsx(FormatItalicIcon, { fontSize: \"small\" })\n        },\n        \"italic\"\n      ),\n      /* @__PURE__ */ jsx(\n        ToggleButton,\n        {\n          classes: { root: classes.button },\n          disabled: readOnly,\n          value: \"code\",\n          onClick: () => {\n            editor.dispatchCommand(FORMAT_TEXT_COMMAND, \"code\");\n          },\n          children: /* @__PURE__ */ jsx(CodeIcon, { fontSize: \"small\" })\n        },\n        \"code\"\n      ),\n      /* @__PURE__ */ jsx(\n        ToggleButton,\n        {\n          classes: { root: classes.button },\n          disabled: readOnly,\n          value: \"strikethrough\",\n          onClick: () => {\n            editor.dispatchCommand(FORMAT_TEXT_COMMAND, \"strikethrough\");\n          },\n          children: /* @__PURE__ */ jsx(StrikethroughSIcon, { fontSize: \"small\" })\n        },\n        \"strikethrough\"\n      )\n    ] })\n  ] });\n};\nconst ContentEditable = ({ onFocus, readOnly }) => {\n  const [editor] = useLexicalComposerContext();\n  const ref = useCallback(\n    (rootElement) => {\n      editor.setRootElement(rootElement);\n    },\n    [editor]\n  );\n  return /* @__PURE__ */ jsx(\"div\", { ref, contentEditable: !readOnly, spellCheck: false, onFocus });\n};\nconst UpdateValuePlugin = ({ markdownText }) => {\n  const [editor] = useLexicalComposerContext();\n  useEffect(() => {\n    editor.update(() => {\n      LexicalMarkdown_1.$convertFromMarkdownString(markdownText, LexicalMarkdown_1.TRANSFORMERS);\n      $setSelection(null);\n    });\n  }, [editor, markdownText]);\n  return null;\n};\nconst OnBlurPlugin = ({ onBlur, children }) => {\n  const [editor] = useLexicalComposerContext();\n  return /* @__PURE__ */ jsx(\n    \"div\",\n    {\n      onBlur: (event) => {\n        if (!event.currentTarget.contains(event.relatedTarget)) {\n          editor.getEditorState().read(() => {\n            const markdown = LexicalMarkdown_1.$convertToMarkdownString(LexicalMarkdown_1.TRANSFORMERS);\n            onBlur(markdown);\n          });\n        }\n      },\n      children\n    }\n  );\n};\nconst useRichTextEditorStyles = makeStyles((theme) => ({\n  editorContainer: {\n    marginTop: theme.spacing(2),\n    color: theme.palette.text.primary,\n    position: \"relative\",\n    fontWeight: Number(theme.typography.fontWeightRegular),\n    textAlign: \"left\",\n    borderBottom: `1px solid ${theme.palette.divider}`,\n    \"&:hover\": {\n      borderBottom: `2px solid ${theme.palette.divider}`\n    },\n    \"&:focus-within\": {\n      transition: \"transform 200ms cubic-bezier(0.0, 0, 0.2, 1) 0ms\",\n      borderBottom: `2px solid ${theme.palette.primary.main}`\n    }\n  },\n  editorPlaceholder: {\n    color: theme.palette.text.secondary,\n    top: 0,\n    overflow: \"hidden\",\n    position: \"absolute\",\n    textOverflow: \"ellipsis\",\n    fontSize: theme.typography.fontSize,\n    userSelect: \"none\",\n    display: \"inline-block\",\n    pointerEvents: \"none\"\n  },\n  editorParagraph: {\n    margin: 0,\n    marginBottom: theme.spacing(2),\n    position: \"relative\"\n  },\n  editorTextBold: {\n    fontWeight: \"bold\"\n  },\n  editorTextItalic: {\n    fontStyle: \"italic\"\n  },\n  editorTextUnderline: {\n    textDecoration: \"underline\"\n  },\n  editorTextStrikethrough: {\n    textDecoration: \"line-through\"\n  },\n  editorTextUnderlineStrikethrough: {\n    textDecoration: \"underline line-through\"\n  },\n  editorTextCode: {\n    backgroundColor: theme.palette.background.default,\n    padding: \"1px 0.25rem\",\n    fontFamily: \"Menlo, Consolas, Monaco, monospace\",\n    fontSize: \"94%\"\n  },\n  editorHeading1: {\n    fontFamily: theme.typography.h4.fontFamily,\n    fontSize: theme.typography.h4.fontSize,\n    fontWeight: theme.typography.h4.fontWeight,\n    lineHeight: theme.typography.h4.lineHeight,\n    letterSpacing: theme.typography.h4.letterSpacing,\n    color: theme.palette.text.primary,\n    margin: 0,\n    marginBottom: theme.spacing(3),\n    padding: 0\n  },\n  editorHeading2: {\n    fontFamily: theme.typography.h5.fontFamily,\n    fontSize: theme.typography.h5.fontSize,\n    fontWeight: theme.typography.h5.fontWeight,\n    lineHeight: theme.typography.h5.lineHeight,\n    letterSpacing: theme.typography.h5.letterSpacing,\n    color: theme.palette.text.secondary,\n    margin: 0,\n    marginTop: theme.spacing(2),\n    padding: 0\n  },\n  editorListOl: {\n    padding: 0,\n    margin: 0,\n    marginLeft: theme.spacing(2),\n    listStyle: \"decimal\"\n  },\n  editorListUl: {\n    padding: 0,\n    margin: 0,\n    marginLeft: theme.spacing(2),\n    listStyle: \"circle\"\n  },\n  editorListitem: {\n    margin: `${theme.spacing(2)} ${theme.spacing(8)} ${theme.spacing(2)} ${theme.spacing(8)}`\n  },\n  editorNestedListitem: {\n    listStyleType: \"none\"\n  }\n}));\nconst RichTextEditor = ({ value: value2, placeholder, readOnly, onFocus, onBlur }) => {\n  const classes = useRichTextEditorStyles();\n  const theme = {\n    placeholder: classes.editorPlaceholder,\n    paragraph: classes.editorParagraph,\n    heading: {\n      h1: classes.editorHeading1,\n      h2: classes.editorHeading2\n    },\n    list: {\n      nested: {\n        listitem: classes.editorNestedListitem\n      },\n      ol: classes.editorListOl,\n      ul: classes.editorListUl,\n      listitem: classes.editorListitem\n    },\n    text: {\n      bold: classes.editorTextBold,\n      italic: classes.editorTextItalic,\n      underline: classes.editorTextUnderline,\n      strikethrough: classes.editorTextStrikethrough,\n      underlineStrikethrough: classes.editorTextUnderlineStrikethrough,\n      code: classes.editorTextCode\n    }\n  };\n  const initialConfig = {\n    namespace: \"RichTextEditor\",\n    onError: console.error,\n    theme,\n    nodes: [LexicalRichText_1.HeadingNode, LexicalList_1.ListNode, LexicalList_1.ListItemNode, LexicalRichText_1.QuoteNode, HorizontalRuleNode, TextNode, LexicalCode_1.CodeNode, LexicalLink_1.LinkNode]\n  };\n  return /* @__PURE__ */ jsx(LexicalComposer, { initialConfig, children: /* @__PURE__ */ jsxs(OnBlurPlugin, { onBlur, children: [\n    /* @__PURE__ */ jsx(UpdateValuePlugin, { markdownText: value2 }),\n    /* @__PURE__ */ jsx(ToolbarPlugin, { readOnly }),\n    /* @__PURE__ */ jsxs(\"div\", { className: classes.editorContainer, children: [\n      /* @__PURE__ */ jsx(MarkdownShortcutPlugin, { transformers: LexicalMarkdown_1.TRANSFORMERS }),\n      /* @__PURE__ */ jsx(ListPlugin, {}),\n      /* @__PURE__ */ jsx(\n        RichTextPlugin,\n        {\n          contentEditable: /* @__PURE__ */ jsx(ContentEditable, { onFocus, readOnly }),\n          placeholder: /* @__PURE__ */ jsx(\"div\", { className: classes.editorPlaceholder, children: placeholder }),\n          ErrorBoundary: LexicalErrorBoundary\n        }\n      ),\n      /* @__PURE__ */ jsx(TabIndentationPlugin, {})\n    ] })\n  ] }) });\n};\nconst editRichTextMutation = gql$2`\n  mutation editRichText($input: EditRichTextInput!) {\n    editRichText(input: $input) {\n      __typename\n      ... on ErrorPayload {\n        messages {\n          body\n          level\n        }\n      }\n      ... on SuccessPayload {\n        messages {\n          body\n          level\n        }\n      }\n    }\n  }\n`;\nconst updateWidgetFocusMutation$3 = gql$2`\n  mutation updateWidgetFocus($input: UpdateWidgetFocusInput!) {\n    updateWidgetFocus(input: $input) {\n      __typename\n      ... on ErrorPayload {\n        messages {\n          body\n          level\n        }\n      }\n    }\n  }\n`;\nconst isErrorPayload$3 = (payload) => payload.__typename === \"ErrorPayload\";\nconst isSuccessPayload$3 = (payload) => payload.__typename === \"SuccessPayload\";\nconst RichTextPropertySection = ({\n  editingContextId,\n  formId,\n  widget,\n  subscribers,\n  readOnly\n}) => {\n  const [editRichText, { loading: updateRichTextLoading, data: updateRichTextData, error: updateRichTextError }] = useMutation(editRichTextMutation);\n  const sendEditedValue = (newValue) => {\n    const input = {\n      id: crypto.randomUUID(),\n      editingContextId,\n      representationId: formId,\n      richTextId: widget.id,\n      newValue\n    };\n    const variables = { input };\n    editRichText({ variables });\n  };\n  const { addErrorMessage, addMessages } = useMultiToast();\n  useEffect(() => {\n    if (!updateRichTextLoading) {\n      if (updateRichTextError) {\n        addErrorMessage(\"An unexpected error has occurred, please refresh the page\");\n      }\n      if (updateRichTextData) {\n        const { editRichText: editRichText2 } = updateRichTextData;\n        if (isErrorPayload$3(editRichText2) || isSuccessPayload$3(editRichText2)) {\n          addMessages(editRichText2.messages);\n        }\n      }\n    }\n  }, [updateRichTextLoading, updateRichTextData, updateRichTextError]);\n  const [\n    updateWidgetFocus,\n    { loading: updateWidgetFocusLoading, data: updateWidgetFocusData, error: updateWidgetFocusError }\n  ] = useMutation(updateWidgetFocusMutation$3);\n  const sendUpdateWidgetFocus = (selected) => {\n    const input = {\n      id: crypto.randomUUID(),\n      editingContextId,\n      representationId: formId,\n      widgetId: widget.id,\n      selected\n    };\n    const variables = {\n      input\n    };\n    updateWidgetFocus({ variables });\n  };\n  useEffect(() => {\n    if (!updateWidgetFocusLoading) {\n      if (updateWidgetFocusError) {\n        addErrorMessage(\"An unexpected error has occurred, please refresh the page\");\n      }\n      if (updateWidgetFocusData) {\n        const { updateWidgetFocus: updateWidgetFocus2 } = updateWidgetFocusData;\n        if (isErrorPayload$3(updateWidgetFocus2)) {\n          addMessages(updateWidgetFocus2.messages);\n        }\n      }\n    }\n  }, [updateWidgetFocusLoading, updateWidgetFocusData, updateWidgetFocusError]);\n  const onFocus = () => sendUpdateWidgetFocus(true);\n  const onBlur = (currentText) => {\n    sendUpdateWidgetFocus(false);\n    if (currentText !== widget.stringValue) {\n      sendEditedValue(currentText);\n    }\n  };\n  return /* @__PURE__ */ jsxs(\"div\", { children: [\n    /* @__PURE__ */ jsx(\n      PropertySectionLabel,\n      {\n        editingContextId,\n        formId,\n        widget,\n        subscribers\n      }\n    ),\n    /* @__PURE__ */ jsx(\"div\", { \"data-testid\": widget.label, children: /* @__PURE__ */ jsx(\n      RichTextEditor,\n      {\n        value: widget.stringValue,\n        placeholder: widget.label,\n        onFocus,\n        onBlur,\n        readOnly: readOnly || widget.readOnly\n      }\n    ) })\n  ] });\n};\nconst useStyle$2 = makeStyles((theme) => ({\n  style: {\n    backgroundColor: ({ backgroundColor }) => backgroundColor ? getCSSColor(backgroundColor, theme) : null,\n    color: ({ foregroundColor }) => foregroundColor ? getCSSColor(foregroundColor, theme) : null,\n    fontSize: ({ fontSize }) => fontSize ? fontSize : null,\n    fontStyle: ({ italic }) => italic ? \"italic\" : null,\n    fontWeight: ({ bold }) => bold ? \"bold\" : null,\n    textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough)\n  },\n  iconRoot: {\n    minWidth: theme.spacing(3)\n  }\n}));\nconst editSelectMutation = gql$2`\n  mutation editSelect($input: EditSelectInput!) {\n    editSelect(input: $input) {\n      __typename\n      ... on ErrorPayload {\n        messages {\n          body\n          level\n        }\n      }\n      ... on SuccessPayload {\n        messages {\n          body\n          level\n        }\n      }\n    }\n  }\n`;\nconst updateWidgetFocusMutation$2 = gql$2`\n  mutation updateWidgetFocus($input: UpdateWidgetFocusInput!) {\n    updateWidgetFocus(input: $input) {\n      __typename\n      ... on ErrorPayload {\n        messages {\n          body\n          level\n        }\n      }\n    }\n  }\n`;\nconst isErrorPayload$2 = (payload) => payload.__typename === \"ErrorPayload\";\nconst isSuccessPayload$2 = (payload) => payload.__typename === \"SuccessPayload\";\nconst SelectPropertySection = ({\n  editingContextId,\n  formId,\n  widget,\n  subscribers,\n  readOnly\n}) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n  const props = {\n    backgroundColor: ((_a = widget.style) == null ? void 0 : _a.backgroundColor) ?? null,\n    foregroundColor: ((_b = widget.style) == null ? void 0 : _b.foregroundColor) ?? null,\n    fontSize: ((_c = widget.style) == null ? void 0 : _c.fontSize) ?? null,\n    italic: ((_d = widget.style) == null ? void 0 : _d.italic) ?? null,\n    bold: ((_e = widget.style) == null ? void 0 : _e.bold) ?? null,\n    underline: ((_f = widget.style) == null ? void 0 : _f.underline) ?? null,\n    strikeThrough: ((_g = widget.style) == null ? void 0 : _g.strikeThrough) ?? null\n  };\n  const classes = useStyle$2(props);\n  const [isFocused, setFocus] = useState(false);\n  const [editSelect, { loading, error, data }] = useMutation(editSelectMutation);\n  const onChange = (event) => {\n    const newValue = event.target.value;\n    const variables = {\n      input: {\n        id: crypto.randomUUID(),\n        editingContextId,\n        representationId: formId,\n        selectId: widget.id,\n        newValue\n      }\n    };\n    editSelect({ variables });\n  };\n  const { addErrorMessage, addMessages } = useMultiToast();\n  useEffect(() => {\n    if (!loading) {\n      if (error) {\n        addErrorMessage(\"An unexpected error has occurred, please refresh the page\");\n      }\n      if (data) {\n        const { editSelect: editSelect2 } = data;\n        if (isErrorPayload$2(editSelect2) || isSuccessPayload$2(editSelect2)) {\n          addMessages(editSelect2.messages);\n        }\n      }\n    }\n  }, [loading, error, data]);\n  const [\n    updateWidgetFocus,\n    { loading: updateWidgetFocusLoading, data: updateWidgetFocusData, error: updateWidgetFocusError }\n  ] = useMutation(updateWidgetFocusMutation$2);\n  const sendUpdateWidgetFocus = (selected) => {\n    const variables = {\n      input: {\n        id: crypto.randomUUID(),\n        editingContextId,\n        representationId: formId,\n        widgetId: widget.id,\n        selected\n      }\n    };\n    updateWidgetFocus({ variables });\n  };\n  useEffect(() => {\n    if (!updateWidgetFocusLoading) {\n      if (updateWidgetFocusError) {\n        addErrorMessage(\"An unexpected error has occurred, please refresh the page\");\n      }\n      if (updateWidgetFocusData) {\n        const { updateWidgetFocus: updateWidgetFocus2 } = updateWidgetFocusData;\n        if (isErrorPayload$2(updateWidgetFocus2)) {\n          addMessages(updateWidgetFocus2.messages);\n        }\n      }\n    }\n  }, [updateWidgetFocusLoading, updateWidgetFocusData, updateWidgetFocusError]);\n  const onFocus = () => {\n    if (!isFocused) {\n      setFocus(true);\n      sendUpdateWidgetFocus(true);\n    }\n  };\n  const onBlur = () => {\n    setFocus(false);\n    sendUpdateWidgetFocus(false);\n  };\n  return /* @__PURE__ */ jsxs(FormControl, { error: widget.diagnostics.length > 0, children: [\n    /* @__PURE__ */ jsx(\n      PropertySectionLabel,\n      {\n        editingContextId,\n        formId,\n        widget,\n        subscribers\n      }\n    ),\n    /* @__PURE__ */ jsxs(\n      Select,\n      {\n        value: widget.value || \"\",\n        onChange,\n        displayEmpty: true,\n        onFocus,\n        onBlur,\n        fullWidth: true,\n        \"data-testid\": widget.label,\n        disabled: readOnly || widget.readOnly,\n        inputProps: widget.style ? {\n          className: classes.style\n        } : {},\n        children: [\n          /* @__PURE__ */ jsx(\n            MenuItem,\n            {\n              value: \"\",\n              classes: widget.style ? {\n                root: classes.style\n              } : {},\n              children: /* @__PURE__ */ jsx(\"em\", { children: \"None\" })\n            }\n          ),\n          widget.options.map((option) => /* @__PURE__ */ jsxs(\n            MenuItem,\n            {\n              value: option.id,\n              classes: widget.style ? {\n                root: classes.style\n              } : {},\n              children: [\n                option.iconURL.length > 0 && /* @__PURE__ */ jsx(ListItemIcon, { className: classes.iconRoot, children: /* @__PURE__ */ jsx(IconOverlay, { iconURL: option.iconURL, alt: option.label }) }),\n                option.label\n              ]\n            },\n            option.id\n          ))\n        ]\n      }\n    ),\n    /* @__PURE__ */ jsx(FormHelperText, { children: (_h = widget.diagnostics[0]) == null ? void 0 : _h.message })\n  ] });\n};\nconst ProposalsList = ({ anchorEl, proposals, onProposalSelected, onClose }) => {\n  return /* @__PURE__ */ jsx(\n    Popover,\n    {\n      open: true,\n      onClose,\n      anchorEl,\n      anchorOrigin: {\n        vertical: \"bottom\",\n        horizontal: \"left\"\n      },\n      transformOrigin: {\n        vertical: \"top\",\n        horizontal: \"left\"\n      },\n      children: /* @__PURE__ */ jsx(MenuList, { id: \"completion-proposals\", \"data-testid\": \"completion-proposals\", children: proposals.map((proposal, index) => /* @__PURE__ */ jsx(\n        Tooltip,\n        {\n          \"data-testid\": `proposal-${proposal.textToInsert}-${proposal.charsToReplace}`,\n          title: proposal.description,\n          placement: \"right\",\n          children: /* @__PURE__ */ jsx(MenuItem, { button: true, onClick: () => onProposalSelected(proposal), children: /* @__PURE__ */ jsx(ListItemText, { primary: proposal.textToInsert }) })\n        },\n        index\n      )) })\n    }\n  );\n};\nconst textfieldPropertySectionMachine = Machine(\n  {\n    type: \"parallel\",\n    context: {\n      value: \"\",\n      completionRequest: null,\n      proposals: null\n    },\n    states: {\n      textfieldPropertySection: {\n        initial: \"pristine\",\n        states: {\n          pristine: {\n            on: {\n              INITIALIZE: {\n                target: \"pristine\",\n                actions: \"updateValue\"\n              },\n              CHANGE_VALUE: {\n                target: \"edited\",\n                actions: \"updateValue\"\n              }\n            }\n          },\n          edited: {\n            on: {\n              INITIALIZE: {\n                target: \"pristine\",\n                actions: \"initializeValue\"\n              },\n              CHANGE_VALUE: {\n                target: \"edited\",\n                actions: \"updateValue\"\n              }\n            }\n          }\n        }\n      },\n      completion: {\n        initial: \"idle\",\n        states: {\n          idle: {\n            on: {\n              COMPLETION_REQUESTED: {\n                target: \"requested\",\n                actions: \"setCompletionRequest\"\n              }\n            }\n          },\n          requested: {\n            on: {\n              COMPLETION_RECEIVED: [\n                {\n                  cond: \"noProposals\",\n                  target: \"idle\"\n                },\n                {\n                  target: \"received\",\n                  actions: \"setReceivedProposals\"\n                }\n              ]\n            }\n          },\n          received: {\n            on: {\n              COMPLETION_DISMISSED: {\n                target: \"idle\",\n                actions: \"resetCompletion\"\n              },\n              COMPLETION_REQUESTED: {\n                target: \"requested\",\n                actions: [\"resetCompletion\", \"setCompletionRequest\"]\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  {\n    guards: {\n      noProposals: (_, event) => {\n        const { proposals } = event;\n        return proposals.length === 0;\n      }\n    },\n    actions: {\n      initializeValue: assign((context, event) => {\n        const { value: value2 } = event;\n        const { value: previousValue } = context;\n        if (value2 !== previousValue) {\n          console.trace(`The following content \"${previousValue}\" has been overwritten by \"${value2}\"`);\n        }\n        return { value: value2 };\n      }),\n      updateValue: assign((_, event) => {\n        const { value: value2 } = event;\n        return { value: value2 };\n      }),\n      setCompletionRequest: assign((_, event) => {\n        const { currentText, cursorPosition } = event;\n        return { completionRequest: { currentText, cursorPosition } };\n      }),\n      setReceivedProposals: assign((_, event) => {\n        const { proposals } = event;\n        return { proposals };\n      }),\n      resetCompletion: assign((_) => {\n        return { completionRequest: null, proposals: null };\n      })\n    }\n  }\n);\nconst useStyle$1 = makeStyles((theme) => ({\n  style: {\n    backgroundColor: ({ backgroundColor }) => backgroundColor ? getCSSColor(backgroundColor, theme) : null,\n    color: ({ foregroundColor }) => foregroundColor ? getCSSColor(foregroundColor, theme) : null,\n    fontSize: ({ fontSize }) => fontSize ? fontSize : null,\n    fontStyle: ({ italic }) => italic ? \"italic\" : null,\n    fontWeight: ({ bold }) => bold ? \"bold\" : null,\n    textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough)\n  }\n}));\nconst getCompletionProposalsQuery = gql$2`\n  query completionProposals(\n    $editingContextId: ID!\n    $formId: ID!\n    $widgetId: ID!\n    $currentText: String!\n    $cursorPosition: Int!\n  ) {\n    viewer {\n      editingContext(editingContextId: $editingContextId) {\n        representation(representationId: $formId) {\n          description {\n            ... on FormDescription {\n              completionProposals(widgetId: $widgetId, currentText: $currentText, cursorPosition: $cursorPosition) {\n                description\n                textToInsert\n                charsToReplace\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n`;\nconst editTextfieldMutation = gql$2`\n  mutation editTextfield($input: EditTextfieldInput!) {\n    editTextfield(input: $input) {\n      __typename\n      ... on ErrorPayload {\n        messages {\n          body\n          level\n        }\n      }\n      ... on SuccessPayload {\n        messages {\n          body\n          level\n        }\n      }\n    }\n  }\n`;\nconst updateWidgetFocusMutation$1 = gql$2`\n  mutation updateWidgetFocus($input: UpdateWidgetFocusInput!) {\n    updateWidgetFocus(input: $input) {\n      __typename\n      ... on ErrorPayload {\n        messages {\n          body\n          level\n        }\n      }\n    }\n  }\n`;\nconst isTextarea$1 = (widget) => widget.__typename === \"Textarea\";\nconst isErrorPayload$1 = (payload) => payload.__typename === \"ErrorPayload\";\nconst isSuccessPayload$1 = (payload) => payload.__typename === \"SuccessPayload\";\nconst TextfieldPropertySection = ({\n  editingContextId,\n  formId,\n  widget,\n  subscribers,\n  readOnly\n}) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n  const inputElt = useRef();\n  const props = {\n    backgroundColor: ((_a = widget.style) == null ? void 0 : _a.backgroundColor) ?? null,\n    foregroundColor: ((_b = widget.style) == null ? void 0 : _b.foregroundColor) ?? null,\n    fontSize: ((_c = widget.style) == null ? void 0 : _c.fontSize) ?? null,\n    italic: ((_d = widget.style) == null ? void 0 : _d.italic) ?? null,\n    bold: ((_e = widget.style) == null ? void 0 : _e.bold) ?? null,\n    underline: ((_f = widget.style) == null ? void 0 : _f.underline) ?? null,\n    strikeThrough: ((_g = widget.style) == null ? void 0 : _g.strikeThrough) ?? null\n  };\n  const classes = useStyle$1(props);\n  const [{ value: schemaValue, context }, dispatch] = useMachine(textfieldPropertySectionMachine);\n  const { textfieldPropertySection } = schemaValue;\n  const { value: value2, completionRequest, proposals } = context;\n  useEffect(() => {\n    const initializeEvent = { type: \"INITIALIZE\", value: widget.stringValue };\n    dispatch(initializeEvent);\n  }, [dispatch, widget.stringValue]);\n  const onChange = (event) => {\n    const { value: value22 } = event.target;\n    const changeValueEvent = { type: \"CHANGE_VALUE\", value: value22 };\n    dispatch(changeValueEvent);\n  };\n  const [editTextfield, { loading: updateTextfieldLoading, data: updateTextfieldData, error: updateTextfieldError }] = useMutation(editTextfieldMutation);\n  const sendEditedValue = () => {\n    if (textfieldPropertySection === \"edited\") {\n      const input = {\n        id: crypto.randomUUID(),\n        editingContextId,\n        representationId: formId,\n        textfieldId: widget.id,\n        newValue: value2\n      };\n      const variables = { input };\n      editTextfield({ variables });\n    }\n  };\n  const { addErrorMessage, addMessages } = useMultiToast();\n  useEffect(() => {\n    if (!updateTextfieldLoading) {\n      let hasError = false;\n      if (updateTextfieldError) {\n        addErrorMessage(\"An unexpected error has occurred, please refresh the page\");\n        hasError = true;\n      }\n      if (updateTextfieldData) {\n        const { editTextfield: editTextfield2 } = updateTextfieldData;\n        if (isErrorPayload$1(editTextfield2)) {\n          addMessages(editTextfield2.messages);\n          hasError = true;\n        }\n        if (isSuccessPayload$1(editTextfield2)) {\n          addMessages(editTextfield2.messages);\n        }\n      }\n      if (hasError) {\n        const initializeEvent = { type: \"INITIALIZE\", value: widget.stringValue };\n        dispatch(initializeEvent);\n      }\n    }\n  }, [updateTextfieldLoading, updateTextfieldData, updateTextfieldError, dispatch]);\n  const [\n    updateWidgetFocus,\n    { loading: updateWidgetFocusLoading, data: updateWidgetFocusData, error: updateWidgetFocusError }\n  ] = useMutation(updateWidgetFocusMutation$1);\n  const sendUpdateWidgetFocus = (selected) => {\n    const input = {\n      id: crypto.randomUUID(),\n      editingContextId,\n      representationId: formId,\n      widgetId: widget.id,\n      selected\n    };\n    const variables = {\n      input\n    };\n    updateWidgetFocus({ variables });\n  };\n  useEffect(() => {\n    if (!updateWidgetFocusLoading) {\n      if (updateWidgetFocusError) {\n        addErrorMessage(\"An unexpected error has occurred, please refresh the page\");\n      }\n      if (updateWidgetFocusData) {\n        const { updateWidgetFocus: updateWidgetFocus2 } = updateWidgetFocusData;\n        if (isErrorPayload$1(updateWidgetFocus2)) {\n          addMessages(updateWidgetFocus2.messages);\n        }\n      }\n    }\n  }, [updateWidgetFocusLoading, updateWidgetFocusData, updateWidgetFocusError, dispatch]);\n  const onFocus = () => sendUpdateWidgetFocus(true);\n  const onBlur = () => {\n    sendUpdateWidgetFocus(false);\n    sendEditedValue();\n  };\n  const [getCompletionProposals, { loading: proposalsLoading, data: proposalsData, error: proposalsError }] = useLazyQuery(getCompletionProposalsQuery);\n  useEffect(() => {\n    if (!proposalsLoading) {\n      if (proposalsError) {\n        addErrorMessage(proposalsError.message);\n      }\n      if (proposalsData) {\n        const proposalsReceivedEvent = {\n          type: \"COMPLETION_RECEIVED\",\n          proposals: proposalsData.viewer.editingContext.representation.description.completionProposals\n        };\n        dispatch(proposalsReceivedEvent);\n      }\n    }\n  }, [proposalsLoading, proposalsData, proposalsError, dispatch]);\n  const onKeyPress = (event) => {\n    if (\"Enter\" === event.key && !event.shiftKey) {\n      event.preventDefault();\n      sendEditedValue();\n    }\n    const dismissCompletionEvent = { type: \"COMPLETION_DISMISSED\" };\n    dispatch(dismissCompletionEvent);\n  };\n  const [controlDown, setControlDown] = useState(false);\n  const onKeyDown = (event) => {\n    if (event.key === \"ArrowLeft\" || event.key === \"ArrowRight\") {\n      const proposalsMenu = document.getElementById(\"completion-proposals\");\n      if (proposalsMenu && proposalsMenu.firstChild) {\n        proposalsMenu.firstChild.focus();\n      }\n    } else if (\"Control\" === event.key) {\n      setControlDown(true);\n    } else if (\"Escape\" === event.key) {\n      const dismissCompletionEvent = { type: \"COMPLETION_DISMISSED\" };\n      dispatch(dismissCompletionEvent);\n    }\n    if (widget.supportsCompletion && controlDown && event.key === \" \") {\n      const cursorPosition = event.target.selectionStart;\n      const variables = {\n        editingContextId,\n        formId,\n        widgetId: widget.id,\n        currentText: value2,\n        cursorPosition\n      };\n      getCompletionProposals({ variables });\n      const requestCompletionEvent = {\n        type: \"COMPLETION_REQUESTED\",\n        currentText: value2,\n        cursorPosition\n      };\n      dispatch(requestCompletionEvent);\n    }\n  };\n  const onKeyUp = (event) => {\n    if (\"Control\" === event.key) {\n      setControlDown(false);\n    }\n  };\n  const [caretPos, setCaretPos] = useState(null);\n  useEffect(() => {\n    if (caretPos && inputElt.current) {\n      inputElt.current.setSelectionRange(caretPos, caretPos);\n      inputElt.current.focus();\n      setCaretPos(null);\n    }\n  }, [caretPos, inputElt.current]);\n  let proposalsList = null;\n  if (proposals) {\n    const dismissProposals = () => {\n      const dismissCompletionEvent = { type: \"COMPLETION_DISMISSED\" };\n      dispatch(dismissCompletionEvent);\n    };\n    const applyProposal = (proposal) => {\n      const result = applyCompletionProposal(\n        { textValue: value2, cursorPosition: completionRequest.cursorPosition },\n        proposal\n      );\n      const changeValueEvent = { type: \"CHANGE_VALUE\", value: result.textValue };\n      dispatch(changeValueEvent);\n      setCaretPos(result.cursorPosition);\n      dismissProposals();\n    };\n    proposalsList = /* @__PURE__ */ jsx(\n      ProposalsList,\n      {\n        anchorEl: inputElt.current,\n        proposals,\n        onProposalSelected: applyProposal,\n        onClose: dismissProposals\n      }\n    );\n  }\n  return /* @__PURE__ */ jsxs(\n    \"div\",\n    {\n      onBlur: (event) => {\n        if (!event.currentTarget.contains(event.relatedTarget)) {\n          onBlur();\n        }\n      },\n      children: [\n        /* @__PURE__ */ jsx(\n          PropertySectionLabel,\n          {\n            editingContextId,\n            formId,\n            widget,\n            subscribers\n          }\n        ),\n        /* @__PURE__ */ jsx(\n          TextField,\n          {\n            name: widget.label,\n            placeholder: widget.label,\n            value: value2,\n            spellCheck: false,\n            margin: \"dense\",\n            multiline: isTextarea$1(widget),\n            maxRows: isTextarea$1(widget) ? 4 : 1,\n            fullWidth: true,\n            onKeyDown,\n            onKeyUp,\n            onChange,\n            onFocus,\n            onKeyPress,\n            \"data-testid\": widget.label,\n            disabled: readOnly || widget.readOnly,\n            error: widget.diagnostics.length > 0,\n            helperText: (_h = widget.diagnostics[0]) == null ? void 0 : _h.message,\n            inputRef: inputElt,\n            InputProps: widget.style ? {\n              className: classes.style\n            } : {},\n            inputProps: {\n              \"data-testid\": `input-${widget.label}`\n            }\n          }\n        ),\n        proposalsList\n      ]\n    }\n  );\n};\nconst applyCompletionProposal = (initialState, proposal) => {\n  const prefix = initialState.textValue.substring(0, initialState.cursorPosition);\n  const inserted = proposal.textToInsert.substring(proposal.charsToReplace);\n  const suffix = initialState.textValue.substring(initialState.cursorPosition);\n  const newValue = prefix + inserted + suffix;\n  return { textValue: newValue, cursorPosition: (prefix + inserted).length };\n};\nconst useTreeItemWidgetStyles = makeStyles((theme) => ({\n  label: {\n    display: \"flex\",\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    columnGap: theme.spacing(1)\n  }\n}));\nconst TreeItem = ({ node, nodes }) => {\n  const styles = useTreeItemWidgetStyles();\n  const { setSelection } = useSelection();\n  const handleClick = () => {\n    if (node.selectable) {\n      const newSelection = {\n        id: node.id,\n        label: node.label,\n        kind: node.kind\n      };\n      setSelection({ entries: [newSelection] });\n    }\n  };\n  const label = /* @__PURE__ */ jsxs(\"div\", { className: styles.label, onClick: handleClick, children: [\n    /* @__PURE__ */ jsx(IconOverlay, { iconURL: node.iconURL, alt: node.label }),\n    /* @__PURE__ */ jsx(Typography, { children: node.label })\n  ] });\n  const childNodes = nodes.filter((childNode) => childNode.parentId === node.id);\n  return /* @__PURE__ */ jsx(TreeItem$1, { nodeId: node.id, label, children: childNodes.map((childNode) => /* @__PURE__ */ jsx(TreeItem, { node: childNode, nodes }, childNode.id)) });\n};\nconst TreePropertySection = ({ editingContextId, formId, widget, subscribers }) => {\n  let { nodes, expandedNodesIds } = widget;\n  if (widget.nodes.length === 0) {\n    expandedNodesIds = [];\n    nodes = [\n      {\n        id: \"none\",\n        parentId: null,\n        label: \"None\",\n        kind: \"siriusComponents://unknown\",\n        iconURL: [],\n        selectable: false\n      }\n    ];\n  }\n  const rootNodes = nodes.filter((node) => node.parentId === null);\n  return /* @__PURE__ */ jsxs(\"div\", { children: [\n    /* @__PURE__ */ jsx(\n      PropertySectionLabel,\n      {\n        editingContextId,\n        formId,\n        widget,\n        subscribers\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      TreeView,\n      {\n        defaultCollapseIcon: /* @__PURE__ */ jsx(ExpandMoreIcon, {}),\n        defaultExpanded: expandedNodesIds,\n        defaultExpandIcon: /* @__PURE__ */ jsx(ChevronRightIcon, {}),\n        children: rootNodes.map((rootNode) => /* @__PURE__ */ jsx(TreeItem, { node: rootNode, nodes }, rootNode.id))\n      }\n    )\n  ] });\n};\nconst isTextfield = (widget) => widget.__typename === \"Textfield\";\nconst isTextarea = (widget) => widget.__typename === \"Textarea\";\nconst isCheckbox = (widget) => widget.__typename === \"Checkbox\";\nconst isSelect = (widget) => widget.__typename === \"Select\";\nconst isMultiSelect = (widget) => widget.__typename === \"MultiSelect\";\nconst isRadio = (widget) => widget.__typename === \"Radio\";\nconst isList$1 = (widget) => widget.__typename === \"List\";\nconst isLink = (widget) => widget.__typename === \"Link\";\nconst isButton = (widget) => widget.__typename === \"Button\";\nconst isLabelWidget = (widget) => widget.__typename === \"LabelWidget\";\nconst isChartWidget = (widget) => widget.__typename === \"ChartWidget\";\nconst isFlexboxContainer = (widget) => widget.__typename === \"FlexboxContainer\";\nconst isTree = (widget) => widget.__typename === \"TreeWidget\";\nconst isImage = (widget) => widget.__typename === \"Image\";\nconst isRichText = (widget) => widget.__typename === \"RichText\";\nconst PropertySection = ({\n  editingContextId,\n  formId,\n  widget,\n  widgetSubscriptions,\n  readOnly\n}) => {\n  let subscribers = [];\n  const { propertySectionsRegistry: propertySectionsRegistry2 } = useContext(PropertySectionContext);\n  widgetSubscriptions.filter((subscription) => subscription.widgetId === widget.id).forEach((subscription) => subscribers.push(...subscription.subscribers));\n  let propertySection = null;\n  if (isTextfield(widget) || isTextarea(widget)) {\n    propertySection = /* @__PURE__ */ jsx(\n      TextfieldPropertySection,\n      {\n        editingContextId,\n        formId,\n        widget,\n        subscribers,\n        readOnly\n      },\n      widget.id\n    );\n  } else if (isCheckbox(widget)) {\n    propertySection = /* @__PURE__ */ jsx(\n      CheckboxPropertySection,\n      {\n        editingContextId,\n        formId,\n        widget,\n        subscribers,\n        readOnly\n      },\n      widget.id\n    );\n  } else if (isSelect(widget)) {\n    propertySection = /* @__PURE__ */ jsx(\n      SelectPropertySection,\n      {\n        editingContextId,\n        formId,\n        widget,\n        subscribers,\n        readOnly\n      },\n      widget.id\n    );\n  } else if (isMultiSelect(widget)) {\n    propertySection = /* @__PURE__ */ jsx(\n      MultiSelectPropertySection,\n      {\n        editingContextId,\n        formId,\n        widget,\n        subscribers,\n        readOnly\n      },\n      widget.id\n    );\n  } else if (isRadio(widget)) {\n    propertySection = /* @__PURE__ */ jsx(\n      RadioPropertySection,\n      {\n        editingContextId,\n        formId,\n        widget,\n        subscribers,\n        readOnly\n      },\n      widget.id\n    );\n  } else if (isList$1(widget)) {\n    propertySection = /* @__PURE__ */ jsx(\n      ListPropertySection,\n      {\n        editingContextId,\n        formId,\n        widget,\n        subscribers,\n        readOnly\n      },\n      widget.id\n    );\n  } else if (isLink(widget)) {\n    propertySection = /* @__PURE__ */ jsx(LinkPropertySection, { editingContextId, formId, widget }, widget.id);\n  } else if (isButton(widget)) {\n    propertySection = /* @__PURE__ */ jsx(\n      ButtonPropertySection,\n      {\n        editingContextId,\n        formId,\n        widget,\n        subscribers,\n        readOnly\n      },\n      widget.id\n    );\n  } else if (isLabelWidget(widget)) {\n    propertySection = /* @__PURE__ */ jsx(\n      LabelWidgetPropertySection,\n      {\n        editingContextId,\n        formId,\n        widget,\n        subscribers\n      },\n      widget.id\n    );\n  } else if (isChartWidget(widget)) {\n    propertySection = /* @__PURE__ */ jsx(\n      ChartWidgetPropertySection,\n      {\n        editingContextId,\n        formId,\n        widget,\n        subscribers\n      },\n      widget.id\n    );\n  } else if (isFlexboxContainer(widget)) {\n    propertySection = /* @__PURE__ */ jsx(\n      FlexboxContainerPropertySection,\n      {\n        editingContextId,\n        formId,\n        widget,\n        widgetSubscriptions,\n        readOnly\n      },\n      widget.id\n    );\n  } else if (isTree(widget)) {\n    propertySection = /* @__PURE__ */ jsx(\n      TreePropertySection,\n      {\n        editingContextId,\n        formId,\n        widget,\n        subscribers\n      },\n      widget.id\n    );\n  } else if (isImage(widget)) {\n    propertySection = /* @__PURE__ */ jsx(ImagePropertySection, { editingContextId, formId, widget }, widget.id);\n  } else if (isRichText(widget)) {\n    propertySection = /* @__PURE__ */ jsx(\n      RichTextPropertySection,\n      {\n        editingContextId,\n        formId,\n        widget,\n        subscribers,\n        readOnly\n      },\n      widget.id\n    );\n  } else {\n    const CustomWidgetComponent = propertySectionsRegistry2.getComponent(widget);\n    if (CustomWidgetComponent) {\n      propertySection = /* @__PURE__ */ jsx(\n        CustomWidgetComponent,\n        {\n          editingContextId,\n          formId,\n          widget,\n          subscribers,\n          readOnly\n        },\n        widget.id\n      );\n    } else {\n      console.error(`Unsupported widget type ${widget.__typename}`);\n    }\n  }\n  return propertySection;\n};\nconst useStyle = makeStyles((theme) => ({\n  style: {\n    minWidth: \"32px\",\n    lineHeight: 1.25,\n    backgroundColor: ({ backgroundColor }) => backgroundColor ? getCSSColor(backgroundColor, theme) : theme.palette.primary.light,\n    color: ({ foregroundColor }) => foregroundColor ? getCSSColor(foregroundColor, theme) : \"white\",\n    fontSize: ({ fontSize }) => fontSize ? fontSize : null,\n    fontStyle: ({ italic }) => italic ? \"italic\" : null,\n    fontWeight: ({ bold }) => bold ? \"bold\" : null,\n    textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough),\n    \"&:hover\": {\n      backgroundColor: ({ backgroundColor }) => backgroundColor ? getCSSColor(backgroundColor, theme) : theme.palette.primary.main,\n      color: ({ foregroundColor }) => foregroundColor ? getCSSColor(foregroundColor, theme) : \"white\",\n      fontSize: ({ fontSize }) => fontSize ? fontSize : null,\n      fontStyle: ({ italic }) => italic ? \"italic\" : null,\n      fontWeight: ({ bold }) => bold ? \"bold\" : null,\n      textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough)\n    }\n  },\n  icon: {\n    marginRight: ({ iconOnly }) => iconOnly ? theme.spacing(0) : theme.spacing(2)\n  }\n}));\nconst pushButtonMutation = gql$1`\n  mutation pushButton($input: PushButtonInput!) {\n    pushButton(input: $input) {\n      __typename\n      ... on ErrorPayload {\n        messages {\n          body\n          level\n        }\n      }\n      ... on SuccessPayload {\n        messages {\n          body\n          level\n        }\n      }\n    }\n  }\n`;\nconst updateWidgetFocusMutation = gql$1`\n  mutation updateWidgetFocus($input: UpdateWidgetFocusInput!) {\n    updateWidgetFocus(input: $input) {\n      __typename\n      ... on ErrorPayload {\n        messages {\n          body\n          level\n        }\n      }\n    }\n  }\n`;\nconst isErrorPayload = (payload) => payload.__typename === \"ErrorPayload\";\nconst isSuccessPayload = (payload) => payload.__typename === \"SuccessPayload\";\nconst ToolbarAction = ({ editingContextId, formId, widget, readOnly }) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n  const props = {\n    backgroundColor: ((_a = widget.style) == null ? void 0 : _a.backgroundColor) ?? null,\n    foregroundColor: ((_b = widget.style) == null ? void 0 : _b.foregroundColor) ?? null,\n    fontSize: ((_c = widget.style) == null ? void 0 : _c.fontSize) ?? null,\n    italic: ((_d = widget.style) == null ? void 0 : _d.italic) ?? null,\n    bold: ((_e = widget.style) == null ? void 0 : _e.bold) ?? null,\n    underline: ((_f = widget.style) == null ? void 0 : _f.underline) ?? null,\n    strikeThrough: ((_g = widget.style) == null ? void 0 : _g.strikeThrough) ?? null,\n    iconOnly: widget.buttonLabel ? false : true\n  };\n  const classes = useStyle(props);\n  const { httpOrigin } = useContext(ServerContext);\n  const [pushButton, { loading, data, error }] = useMutation(\n    pushButtonMutation\n  );\n  const { addErrorMessage, addMessages } = useMultiToast();\n  useEffect(() => {\n    if (!loading) {\n      if (error) {\n        addErrorMessage(\"An unexpected error has occurred, please refresh the page\");\n      }\n      if (data) {\n        const { pushButton: pushButton2 } = data;\n        if (isErrorPayload(pushButton2) || isSuccessPayload(pushButton2)) {\n          addMessages(pushButton2.messages);\n        }\n      }\n    }\n  }, [loading, error, data]);\n  const [\n    updateWidgetFocus,\n    { loading: updateWidgetFocusLoading, data: updateWidgetFocusData, error: updateWidgetFocusError }\n  ] = useMutation(updateWidgetFocusMutation);\n  const sendUpdateWidgetFocus = (selected) => {\n    const input = {\n      id: crypto.randomUUID(),\n      editingContextId,\n      representationId: formId,\n      widgetId: widget.id,\n      selected\n    };\n    const variables = {\n      input\n    };\n    updateWidgetFocus({ variables });\n  };\n  useEffect(() => {\n    if (!updateWidgetFocusLoading) {\n      if (updateWidgetFocusError) {\n        addErrorMessage(\"An unexpected error has occurred, please refresh the page\");\n      }\n      if (updateWidgetFocusData) {\n        const { updateWidgetFocus: updateWidgetFocus2 } = updateWidgetFocusData;\n        if (isErrorPayload(updateWidgetFocus2)) {\n          addMessages(updateWidgetFocus2.messages);\n        }\n      }\n    }\n  }, [updateWidgetFocusLoading, updateWidgetFocusData, updateWidgetFocusError]);\n  const onFocus = () => sendUpdateWidgetFocus(true);\n  const onBlur = () => {\n    sendUpdateWidgetFocus(false);\n  };\n  const onClick = () => {\n    const input = {\n      id: crypto.randomUUID(),\n      editingContextId,\n      representationId: formId,\n      buttonId: widget.id\n    };\n    const variables = { input };\n    pushButton({ variables });\n  };\n  const getImageURL = (widget2) => {\n    if (widget2.imageURL.startsWith(\"http://\") || widget2.imageURL.startsWith(\"https://\")) {\n      return widget2.imageURL;\n    }\n    return httpOrigin + widget2.imageURL;\n  };\n  return /* @__PURE__ */ jsx(\"div\", { children: /* @__PURE__ */ jsx(HelpTooltip, { editingContextId, formId, widgetId: widget.id, children: /* @__PURE__ */ jsxs(\n    Button,\n    {\n      \"data-testid\": widget.buttonLabel,\n      size: \"small\",\n      variant: \"contained\",\n      color: \"primary\",\n      onClick,\n      onBlur,\n      onFocus,\n      disabled: readOnly || widget.readOnly,\n      classes: { root: classes.style },\n      children: [\n        ((_h = widget.imageURL) == null ? void 0 : _h.length) > 0 ? /* @__PURE__ */ jsx(\"img\", { className: classes.icon, width: \"16\", height: \"16\", alt: widget.label, src: getImageURL(widget) }) : null,\n        widget.buttonLabel\n      ]\n    }\n  ) }) });\n};\nconst useGroupStyles = makeStyles((theme) => ({\n  group: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    margin: ({ borderStyle }) => borderStyle ? theme.spacing(0.5) : 0,\n    padding: ({ borderStyle }) => borderStyle ? theme.spacing(0.5) : 0,\n    borderWidth: ({ borderStyle }) => (borderStyle == null ? void 0 : borderStyle.size) || 0,\n    borderColor: ({ borderStyle }) => getCSSColor(borderStyle == null ? void 0 : borderStyle.color, theme) || \"transparent\",\n    borderStyle: ({ borderStyle }) => (borderStyle == null ? void 0 : borderStyle.lineStyle) || \"solid\",\n    borderRadius: ({ borderStyle }) => (borderStyle == null ? void 0 : borderStyle.radius) || 0\n  },\n  groupLabelAndToolbar: {\n    display: \"flex\",\n    flexDirection: \"row\",\n    justifyContent: \"space-between\"\n  },\n  toolbar: {\n    display: \"flex\",\n    flexDirection: \"row\",\n    justifyContent: \"flex-end\"\n  },\n  toolbarAction: {\n    paddingRight: theme.spacing(1),\n    whiteSpace: \"nowrap\"\n  },\n  title: {\n    whiteSpace: \"nowrap\",\n    overflow: \"hidden\",\n    textOverflow: \"ellipsis\"\n  },\n  verticalSections: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    \"& > *\": {\n      marginBottom: theme.spacing(2)\n    }\n  },\n  adaptableSections: {\n    display: \"grid\",\n    gridTemplateColumns: \"repeat(auto-fit, minmax(250px, 1fr))\",\n    gap: theme.spacing(2),\n    \"& > *\": {\n      marginBottom: theme.spacing(2)\n    }\n  },\n  button: {\n    paddingTop: \"1px\",\n    paddingBottom: \"0px\"\n  }\n}));\nconst Group = ({ editingContextId, formId, group, widgetSubscriptions, readOnly }) => {\n  var _a;\n  const props = {\n    borderStyle: group.borderStyle\n  };\n  const classes = useGroupStyles(props);\n  const theme = useTheme();\n  const [visibleWidgetIds, setVisibleWidgetIds] = useState([]);\n  useEffect(() => {\n    setVisibleWidgetIds(group.widgets.map((widget) => widget.id));\n  }, [group]);\n  let widgetSelector = void 0;\n  if (group.displayMode === \"TOGGLEABLE_AREAS\") {\n    widgetSelector = /* @__PURE__ */ jsx(ToggleButtonGroup, { value: visibleWidgetIds, onChange: (_, newVisibleIds) => setVisibleWidgetIds(newVisibleIds), children: group.widgets.map((widget) => {\n      return /* @__PURE__ */ jsxs(ToggleButton, { className: classes.button, value: widget.id, children: [\n        /* @__PURE__ */ jsx(\n          IconOverlay,\n          {\n            iconURL: widget.iconURL,\n            alt: widget.label,\n            customIconStyle: { marginRight: theme.spacing(1) }\n          }\n        ),\n        widget.label\n      ] }, widget.id);\n    }) });\n  }\n  let toolbar = null;\n  if (((_a = group.toolbarActions) == null ? void 0 : _a.length) > 0) {\n    toolbar = /* @__PURE__ */ jsx(\"div\", { className: classes.toolbar, children: group.toolbarActions.map((toolbarAction) => /* @__PURE__ */ jsx(\"div\", { className: classes.toolbarAction, children: /* @__PURE__ */ jsx(\n      ToolbarAction,\n      {\n        editingContextId,\n        formId,\n        readOnly,\n        widget: toolbarAction\n      }\n    ) }, toolbarAction.id)) });\n  }\n  return /* @__PURE__ */ jsxs(\"div\", { className: classes.group, \"data-testid\": `group-${group.label}`, children: [\n    /* @__PURE__ */ jsxs(\"div\", { className: classes.groupLabelAndToolbar, children: [\n      group.displayMode === \"TOGGLEABLE_AREAS\" ? widgetSelector : /* @__PURE__ */ jsx(Typography, { variant: \"subtitle1\", className: classes.title, gutterBottom: true, children: group.label }),\n      toolbar\n    ] }),\n    /* @__PURE__ */ jsx(\"div\", { className: group.displayMode === \"LIST\" ? classes.verticalSections : classes.adaptableSections, children: group.widgets.filter((widget) => visibleWidgetIds.includes(widget.id)).map((widget) => /* @__PURE__ */ jsx(\n      PropertySection,\n      {\n        editingContextId,\n        formId,\n        widget,\n        widgetSubscriptions,\n        readOnly\n      },\n      widget.id\n    )) })\n  ] });\n};\nconst usePageStyles = makeStyles((theme) => ({\n  page: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    \"& > *\": {\n      marginBottom: theme.spacing(2)\n    },\n    overflowY: \"auto\"\n  }\n}));\nconst Page = ({ editingContextId, formId, page, widgetSubscriptions, readOnly }) => {\n  const classes = usePageStyles();\n  return /* @__PURE__ */ jsx(\"div\", { className: classes.page, children: page.groups.map((group) => {\n    return /* @__PURE__ */ jsx(\n      Group,\n      {\n        editingContextId,\n        formId,\n        group,\n        widgetSubscriptions,\n        readOnly\n      },\n      group.id\n    );\n  }) });\n};\nconst useFormStyles = makeStyles((theme) => ({\n  form: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    paddingLeft: theme.spacing(1),\n    paddingRight: theme.spacing(1),\n    gap: theme.spacing(1)\n  },\n  tabsRoot: {\n    minHeight: theme.spacing(4),\n    borderBottomColor: theme.palette.divider,\n    borderBottomWidth: \"1px\",\n    borderBottomStyle: \"solid\"\n  },\n  tabRoot: {\n    minHeight: theme.spacing(4),\n    textTransform: \"none\"\n  },\n  tabLabel: {\n    display: \"flex\",\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    width: \"inherit\"\n  },\n  tabLabelText: {\n    textOverflow: \"ellipsis\",\n    whiteSpace: \"nowrap\",\n    overflow: \"hidden\"\n  },\n  toolbar: {\n    display: \"flex\",\n    flexDirection: \"row\",\n    justifyContent: \"flex-end\",\n    alignItems: \"center\"\n  },\n  toolbarAction: {\n    paddingRight: theme.spacing(1),\n    whiteSpace: \"nowrap\"\n  },\n  pagesListAndToolbar: {\n    display: \"flex\",\n    justifyContent: \"space-between\",\n    paddingLeft: theme.spacing(1)\n  }\n}));\nconst a11yProps = (id) => {\n  return {\n    id: `simple-tab-${id}`,\n    \"aria-controls\": `simple-tabpanel-${id}`\n  };\n};\nconst Form = ({ editingContextId, form, widgetSubscriptions, readOnly }) => {\n  var _a, _b;\n  const classes = useFormStyles();\n  const { id, pages } = form;\n  const [state, setState] = useState({ selectedPage: pages[0], pages });\n  useEffect(() => {\n    setState(() => {\n      const selectedPage = pages.find((page2) => {\n        var _a2;\n        return page2.id === ((_a2 = state.selectedPage) == null ? void 0 : _a2.id);\n      });\n      if (selectedPage) {\n        return { selectedPage, pages };\n      }\n      return { selectedPage: pages[0], pages };\n    });\n  }, [pages, state.selectedPage.id]);\n  const onChangeTab = (_, value2) => {\n    const selectedPage = pages.find((page2) => page2.id === value2);\n    setState((prevState) => {\n      return { ...prevState, selectedPage };\n    });\n  };\n  let selectedPageToolbar = null;\n  if (((_b = (_a = state.selectedPage) == null ? void 0 : _a.toolbarActions) == null ? void 0 : _b.length) > 0) {\n    selectedPageToolbar = /* @__PURE__ */ jsx(\"div\", { className: classes.toolbar, children: state.selectedPage.toolbarActions.map((toolbarAction) => /* @__PURE__ */ jsx(\"div\", { className: classes.toolbarAction, children: /* @__PURE__ */ jsx(ToolbarAction, { editingContextId, formId: id, readOnly, widget: toolbarAction }) }, toolbarAction.id)) });\n  }\n  let page = null;\n  if (state.selectedPage) {\n    page = /* @__PURE__ */ jsx(\n      Page,\n      {\n        editingContextId,\n        formId: id,\n        page: state.selectedPage,\n        widgetSubscriptions,\n        readOnly\n      }\n    );\n  }\n  const maxWidth = state.pages.length > 1 ? 100 : 390;\n  const variant = state.pages.length > 1 ? \"scrollable\" : \"standard\";\n  return /* @__PURE__ */ jsxs(\"div\", { \"data-testid\": \"form\", className: classes.form, children: [\n    /* @__PURE__ */ jsxs(\"div\", { className: classes.pagesListAndToolbar, children: [\n      /* @__PURE__ */ jsx(\n        Tabs,\n        {\n          classes: { root: classes.tabsRoot },\n          value: state.selectedPage.id,\n          onChange: onChangeTab,\n          variant,\n          scrollButtons: \"on\",\n          textColor: \"primary\",\n          indicatorColor: \"primary\",\n          children: state.pages.map((page2) => {\n            return /* @__PURE__ */ createElement(\n              Tab,\n              {\n                ...a11yProps(page2.id),\n                classes: { root: classes.tabRoot },\n                style: { minWidth: 1, maxWidth },\n                value: page2.id,\n                title: page2.label,\n                label: /* @__PURE__ */ jsx(\"div\", { className: classes.tabLabel, children: /* @__PURE__ */ jsx(\"div\", { className: classes.tabLabelText, children: page2.label }) }),\n                key: page2.id,\n                \"data-testid\": `page-tab-${page2.label}`\n              }\n            );\n          })\n        }\n      ),\n      selectedPageToolbar\n    ] }),\n    page\n  ] });\n};\nconst isFormRefreshedEventPayload$1 = (payload) => payload.__typename === \"FormRefreshedEventPayload\";\nconst isSubscribersUpdatedEventPayload$1 = (payload) => payload.__typename === \"SubscribersUpdatedEventPayload\";\nconst isWidgetSubscriptionsUpdatedEventPayload$1 = (payload) => payload.__typename == \"WidgetSubscriptionsUpdatedEventPayload\";\nconst formRepresentationMachine = Machine(\n  {\n    type: \"parallel\",\n    context: {\n      id: crypto.randomUUID(),\n      formId: null,\n      form: null,\n      subscribers: [],\n      widgetSubscriptions: [],\n      message: null\n    },\n    states: {\n      toast: {\n        initial: \"hidden\",\n        states: {\n          hidden: {\n            on: {\n              SHOW_TOAST: {\n                target: \"visible\",\n                actions: \"setMessage\"\n              }\n            }\n          },\n          visible: {\n            on: {\n              HIDE_TOAST: {\n                target: \"hidden\",\n                actions: \"clearMessage\"\n              }\n            }\n          }\n        }\n      },\n      formRepresentation: {\n        initial: \"idle\",\n        states: {\n          idle: {\n            on: {\n              SWITCH_FORM: {\n                target: \"idle\",\n                actions: \"switchForm\"\n              },\n              HANDLE_SUBSCRIPTION_RESULT: [\n                {\n                  cond: \"isFormRefreshedEventPayload\",\n                  target: \"ready\",\n                  actions: \"handleSubscriptionResult\"\n                },\n                {\n                  target: \"idle\",\n                  actions: \"handleSubscriptionResult\"\n                }\n              ]\n            }\n          },\n          ready: {\n            on: {\n              SWITCH_FORM: {\n                target: \"idle\",\n                actions: \"switchForm\"\n              },\n              HANDLE_SUBSCRIPTION_RESULT: {\n                target: \"ready\",\n                actions: \"handleSubscriptionResult\"\n              },\n              HANDLE_COMPLETE: {\n                target: \"complete\"\n              }\n            }\n          },\n          complete: {\n            on: {\n              SWITCH_FORM: {\n                target: \"idle\",\n                actions: \"switchForm\"\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  {\n    guards: {\n      isFormRefreshedEventPayload: (_, event) => {\n        const { result } = event;\n        const { data } = result;\n        return isFormRefreshedEventPayload$1(data.formEvent);\n      }\n    },\n    actions: {\n      switchForm: assign((_, event) => {\n        const { formId } = event;\n        return {\n          id: crypto.randomUUID(),\n          formId\n        };\n      }),\n      handleSubscriptionResult: assign((_, event) => {\n        const { result } = event;\n        const { data } = result;\n        if (isFormRefreshedEventPayload$1(data.formEvent)) {\n          const { form } = data.formEvent;\n          return { form };\n        } else if (isSubscribersUpdatedEventPayload$1(data.formEvent)) {\n          const { subscribers } = data.formEvent;\n          return { subscribers };\n        } else if (isWidgetSubscriptionsUpdatedEventPayload$1(data.formEvent)) {\n          const { widgetSubscriptions } = data.formEvent;\n          return { widgetSubscriptions };\n        }\n        return {};\n      }),\n      setMessage: assign((_, event) => {\n        const { message } = event;\n        return { message };\n      }),\n      clearMessage: assign((_) => {\n        return { message: null };\n      })\n    }\n  }\n);\nconst formEventSubscription = (contributions) => gql$2(`\n  subscription formEvent($input: FormEventInput!) {\n    formEvent(input: $input) {\n      __typename\n      ... on SubscribersUpdatedEventPayload {\n        ...subscribersUpdatedEventPayloadFragment\n      }\n      ... on WidgetSubscriptionsUpdatedEventPayload {\n        ...widgetSubscriptionsUpdatedEventPayloadFragment\n      }\n      ... on FormRefreshedEventPayload {\n        ...formRefreshedEventPayloadFragment\n      }\n    }\n  }\n  ${subscribersUpdatedEventPayloadFragment}\n  ${widgetSubscriptionsUpdatedEventPayloadFragment}\n  ${formRefreshedEventPayloadFragment(contributions)}\n`);\nconst useFormRepresentationStyles = makeStyles((theme) => ({\n  page: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    gap: theme.spacing(1),\n    paddingTop: theme.spacing(1),\n    paddingLeft: theme.spacing(1),\n    paddingRight: theme.spacing(1),\n    overflowY: \"scroll\"\n  },\n  complete: {\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\"\n  },\n  toolbar: {\n    display: \"flex\",\n    flexDirection: \"row\",\n    justifyContent: \"flex-end\",\n    alignItems: \"center\",\n    maxHeight: theme.spacing(4),\n    textTransform: \"none\"\n  },\n  toolbarAction: {\n    paddingRight: theme.spacing(1),\n    whiteSpace: \"nowrap\"\n  }\n}));\nconst FormRepresentation = ({ editingContextId, representationId, readOnly }) => {\n  var _a;\n  const classes = useFormRepresentationStyles();\n  const [{ value: value2, context }, dispatch] = useMachine(\n    formRepresentationMachine,\n    {\n      context: {\n        formId: representationId\n      }\n    }\n  );\n  const { toast, formRepresentation } = value2;\n  const { id, formId, form, widgetSubscriptions, message } = context;\n  useEffect(() => {\n    if (formId !== representationId) {\n      const switchFormEvent = { type: \"SWITCH_FORM\", formId: representationId };\n      dispatch(switchFormEvent);\n    }\n  }, [representationId, formId, dispatch]);\n  const { propertySectionsRegistry: propertySectionsRegistry2 } = useContext(PropertySectionContext);\n  const { error } = useSubscription(\n    formEventSubscription(propertySectionsRegistry2.getWidgetContributions()),\n    {\n      variables: {\n        input: {\n          id,\n          editingContextId,\n          formId: representationId\n        }\n      },\n      fetchPolicy: \"no-cache\",\n      onData: ({ data }) => {\n        const handleDataEvent = {\n          type: \"HANDLE_SUBSCRIPTION_RESULT\",\n          result: data\n        };\n        dispatch(handleDataEvent);\n      },\n      onComplete: () => {\n        const completeEvent = { type: \"HANDLE_COMPLETE\" };\n        dispatch(completeEvent);\n      }\n    }\n  );\n  useEffect(() => {\n    if (error) {\n      const { message: message2 } = error;\n      const showToastEvent = { type: \"SHOW_TOAST\", message: message2 };\n      dispatch(showToastEvent);\n    }\n  }, [error, dispatch]);\n  let content = null;\n  if (formRepresentation === \"ready\") {\n    if (form.pages.length > 1) {\n      content = /* @__PURE__ */ jsx(\n        Form,\n        {\n          editingContextId,\n          form,\n          widgetSubscriptions,\n          readOnly\n        }\n      );\n    } else if (form.pages.length === 1) {\n      let selectedPageToolbar = null;\n      if (((_a = form.pages[0].toolbarActions) == null ? void 0 : _a.length) > 0) {\n        selectedPageToolbar = /* @__PURE__ */ jsx(\"div\", { className: classes.toolbar, children: form.pages[0].toolbarActions.map((toolbarAction) => /* @__PURE__ */ jsx(\"div\", { className: classes.toolbarAction, children: /* @__PURE__ */ jsx(\n          ToolbarAction,\n          {\n            editingContextId,\n            formId: form.id,\n            readOnly,\n            widget: toolbarAction\n          }\n        ) }, toolbarAction.id)) });\n      }\n      content = /* @__PURE__ */ jsxs(\"div\", { \"data-testid\": \"page\", className: classes.page, children: [\n        selectedPageToolbar,\n        /* @__PURE__ */ jsx(\n          Page,\n          {\n            editingContextId,\n            formId: form.id,\n            page: form.pages[0],\n            widgetSubscriptions,\n            readOnly\n          }\n        )\n      ] });\n    }\n  } else if (formRepresentation === \"complete\") {\n    content = /* @__PURE__ */ jsx(\"div\", { className: classes.complete, children: /* @__PURE__ */ jsx(Typography, { variant: \"h5\", align: \"center\", children: \"The form does not exist anymore\" }) });\n  }\n  return /* @__PURE__ */ jsxs(\"div\", { \"data-representation-kind\": \"form\", children: [\n    content,\n    /* @__PURE__ */ jsx(\n      Toast,\n      {\n        message,\n        open: toast === \"visible\",\n        onClose: () => dispatch({ type: \"HIDE_TOAST\" })\n      }\n    )\n  ] });\n};\nconst converter = {\n  convert: (form) => form\n};\nconst defaultContext = {\n  converter\n};\nconst DetailsViewContext = React.createContext(defaultContext);\nconst DetailsViewConfiguration = ({ children, converter: converter2 }) => {\n  return /* @__PURE__ */ jsx(DetailsViewContext.Provider, { value: { converter: converter2 }, children });\n};\nconst useDetailsViewConfiguration = () => {\n  const { converter: converter2 } = React.useContext(DetailsViewContext);\n  return {\n    converter: converter2\n  };\n};\nconst isFormRefreshedEventPayload = (payload) => payload.__typename === \"FormRefreshedEventPayload\";\nconst isSubscribersUpdatedEventPayload = (payload) => payload.__typename === \"SubscribersUpdatedEventPayload\";\nconst isWidgetSubscriptionsUpdatedEventPayload = (payload) => payload.__typename == \"WidgetSubscriptionsUpdatedEventPayload\";\nconst formBasedViewMachine = Machine(\n  {\n    type: \"parallel\",\n    context: {\n      id: crypto.randomUUID(),\n      currentSelection: null,\n      form: null,\n      subscribers: [],\n      widgetSubscriptions: [],\n      message: null\n    },\n    states: {\n      toast: {\n        initial: \"hidden\",\n        states: {\n          hidden: {\n            on: {\n              SHOW_TOAST: {\n                target: \"visible\",\n                actions: \"setMessage\"\n              }\n            }\n          },\n          visible: {\n            on: {\n              HIDE_TOAST: {\n                target: \"hidden\",\n                actions: \"clearMessage\"\n              }\n            }\n          }\n        }\n      },\n      formBasedView: {\n        initial: \"empty\",\n        states: {\n          empty: {\n            on: {\n              SWITCH_SELECTION: [\n                {\n                  cond: \"isSelectionUnsupported\",\n                  target: \"unsupportedSelection\",\n                  actions: [\"switchSelection\", \"clearForm\"]\n                },\n                {\n                  target: \"idle\",\n                  actions: \"switchSelection\"\n                }\n              ]\n            }\n          },\n          unsupportedSelection: {\n            on: {\n              SWITCH_SELECTION: [\n                {\n                  cond: \"isSelectionUnsupported\",\n                  target: \"unsupportedSelection\",\n                  actions: [\"switchSelection\", \"clearForm\"]\n                },\n                {\n                  target: \"idle\",\n                  actions: \"switchSelection\"\n                }\n              ]\n            }\n          },\n          idle: {\n            on: {\n              SWITCH_SELECTION: [\n                {\n                  cond: \"isSelectionUnsupported\",\n                  target: \"unsupportedSelection\",\n                  actions: [\"switchSelection\", \"clearForm\"]\n                },\n                {\n                  target: \"idle\",\n                  actions: \"switchSelection\"\n                }\n              ],\n              HANDLE_SUBSCRIPTION_RESULT: [\n                {\n                  cond: \"isFormRefreshedEventPayload\",\n                  target: \"ready\",\n                  actions: \"handleSubscriptionResult\"\n                },\n                {\n                  target: \"idle\",\n                  actions: \"handleSubscriptionResult\"\n                }\n              ],\n              HANDLE_COMPLETE: {\n                target: \"complete\"\n              }\n            }\n          },\n          ready: {\n            on: {\n              SWITCH_SELECTION: [\n                {\n                  cond: \"isSelectionUnsupported\",\n                  target: \"unsupportedSelection\",\n                  actions: [\"switchSelection\", \"clearForm\"]\n                },\n                {\n                  target: \"idle\",\n                  actions: \"switchSelection\"\n                }\n              ],\n              HANDLE_SUBSCRIPTION_RESULT: {\n                target: \"ready\",\n                actions: \"handleSubscriptionResult\"\n              },\n              HANDLE_COMPLETE: {\n                target: \"complete\"\n              }\n            }\n          },\n          complete: {\n            on: {\n              SWITCH_SELECTION: [\n                {\n                  cond: \"isSelectionUnsupported\",\n                  target: \"unsupportedSelection\",\n                  actions: [\"switchSelection\", \"clearForm\"]\n                },\n                {\n                  target: \"idle\",\n                  actions: \"switchSelection\"\n                }\n              ]\n            }\n          }\n        }\n      }\n    }\n  },\n  {\n    guards: {\n      isFormRefreshedEventPayload: (_, event) => {\n        const { result } = event;\n        return isFormRefreshedEventPayload(result);\n      },\n      isSelectionUnsupported: (_, event) => {\n        const { selection } = event;\n        return !selection;\n      }\n    },\n    actions: {\n      switchSelection: assign((_, event) => {\n        const { selection } = event;\n        return {\n          id: crypto.randomUUID(),\n          currentSelection: selection\n        };\n      }),\n      clearForm: assign((_, _event) => {\n        return { form: null };\n      }),\n      handleSubscriptionResult: assign((_, event) => {\n        const { result } = event;\n        if (isFormRefreshedEventPayload(result)) {\n          const { form } = result;\n          return { form };\n        } else if (isSubscribersUpdatedEventPayload(result)) {\n          const { subscribers } = result;\n          return { subscribers };\n        } else if (isWidgetSubscriptionsUpdatedEventPayload(result)) {\n          const { widgetSubscriptions } = result;\n          return { widgetSubscriptions };\n        }\n        return {};\n      }),\n      setMessage: assign((_, event) => {\n        const { message } = event;\n        return { message };\n      }),\n      clearMessage: assign((_) => {\n        return { message: null };\n      })\n    }\n  }\n);\nconst getFormEventSubscription = (subscriptionName, contributions) => {\n  return `\n  subscription ${subscriptionName}($input: PropertiesEventInput!) {\n    ${subscriptionName}(input: $input) {\n      __typename\n      ... on SubscribersUpdatedEventPayload {\n        ...subscribersUpdatedEventPayloadFragment\n      }\n      ... on WidgetSubscriptionsUpdatedEventPayload {\n        ...widgetSubscriptionsUpdatedEventPayloadFragment\n      }\n      ... on FormRefreshedEventPayload {\n        ...formRefreshedEventPayloadFragment\n      }\n    }\n  }\n  ${subscribersUpdatedEventPayloadFragment}\n  ${widgetSubscriptionsUpdatedEventPayloadFragment}\n  ${formRefreshedEventPayloadFragment(contributions)}\n`;\n};\nconst useFormBasedViewStyles = makeStyles((theme) => ({\n  idle: {\n    padding: theme.spacing(1)\n  }\n}));\nconst FormBasedView = ({\n  editingContextId,\n  readOnly,\n  subscriptionName,\n  converter: converter2,\n  postProcessor\n}) => {\n  const classes = useFormBasedViewStyles();\n  const [{ value: value2, context }, dispatch] = useMachine(formBasedViewMachine);\n  const { toast, formBasedView } = value2;\n  const { id, currentSelection, form, widgetSubscriptions, message } = context;\n  const { selection } = useSelection();\n  const currentSelectionKey = currentSelection == null ? void 0 : currentSelection.entries.map((entry) => entry.id).sort().join(\":\");\n  const newSelectionKey = selection == null ? void 0 : selection.entries.map((entry) => entry.id).sort().join(\":\");\n  useEffect(() => {\n    if (selection.entries.length > 0 && currentSelectionKey !== newSelectionKey) {\n      const switchSelectionEvent = {\n        type: \"SWITCH_SELECTION\",\n        selection\n      };\n      dispatch(switchSelectionEvent);\n    } else if (selection.entries.length === 0) {\n      const switchSelectionEvent = {\n        type: \"SWITCH_SELECTION\",\n        selection: null\n      };\n      dispatch(switchSelectionEvent);\n    }\n  }, [currentSelectionKey, newSelectionKey, dispatch]);\n  const input = {\n    id,\n    editingContextId,\n    objectIds: currentSelection == null ? void 0 : currentSelection.entries.map((entry) => entry.id)\n  };\n  const variables = { input };\n  const { propertySectionsRegistry: propertySectionsRegistry2 } = useContext(PropertySectionContext);\n  const formSubscription = getFormEventSubscription(\n    subscriptionName,\n    propertySectionsRegistry2.getWidgetContributions()\n  );\n  const { error } = useSubscription(\n    gql$2(formSubscription),\n    {\n      variables,\n      fetchPolicy: \"no-cache\",\n      skip: formBasedView === \"empty\" || formBasedView === \"unsupportedSelection\",\n      onData: ({ data }) => {\n        const handleDataEvent = {\n          type: \"HANDLE_SUBSCRIPTION_RESULT\",\n          result: data.data[subscriptionName]\n        };\n        dispatch(handleDataEvent);\n      },\n      onComplete: () => {\n        const completeEvent = { type: \"HANDLE_COMPLETE\" };\n        dispatch(completeEvent);\n      }\n    }\n  );\n  useEffect(() => {\n    if (error) {\n      const { message: message2 } = error;\n      const showToastEvent = { type: \"SHOW_TOAST\", message: message2 };\n      dispatch(showToastEvent);\n    }\n  }, [error, dispatch]);\n  const formConverter = converter2 ? converter2 : { convert: (gqlForm) => gqlForm };\n  let content = null;\n  if (formBasedView === \"empty\" || formBasedView === \"unsupportedSelection\" || formBasedView === \"complete\") {\n    content = /* @__PURE__ */ jsx(\"div\", { className: classes.idle, children: /* @__PURE__ */ jsx(Typography, { variant: \"subtitle2\", children: \"No object selected\" }) });\n  }\n  if (formBasedView === \"idle\" && form || formBasedView === \"ready\") {\n    if (postProcessor) {\n      content = postProcessor({ editingContextId, readOnly }, formConverter.convert(form), widgetSubscriptions);\n    } else {\n      content = /* @__PURE__ */ jsx(\n        Form,\n        {\n          editingContextId,\n          form: formConverter.convert(form),\n          widgetSubscriptions,\n          readOnly\n        }\n      );\n    }\n  }\n  return /* @__PURE__ */ jsxs(Fragment$1, { children: [\n    content,\n    /* @__PURE__ */ jsx(\n      Toast,\n      {\n        message,\n        open: toast === \"visible\",\n        onClose: () => dispatch({ type: \"HIDE_TOAST\" })\n      }\n    )\n  ] });\n};\nconst DetailsView = (props) => {\n  const { converter: converter2 } = useDetailsViewConfiguration();\n  return /* @__PURE__ */ jsx(FormBasedView, { ...props, subscriptionName: \"propertiesEvent\", converter: converter2 });\n};\nconst useRelatedElementsViewStyles = makeStyles((theme) => ({\n  content: {\n    padding: theme.spacing(1)\n  }\n}));\nconst RelatedElementsView = (props) => {\n  const classes = useRelatedElementsViewStyles();\n  const extractFirstGroup = (props2, form, widgetSubscriptions) => {\n    var _a;\n    const group = (_a = form.pages[0]) == null ? void 0 : _a.groups[0];\n    if (group) {\n      return /* @__PURE__ */ jsx(\"div\", { className: classes.content, children: /* @__PURE__ */ jsx(\n        Group,\n        {\n          editingContextId: props2.editingContextId,\n          formId: form.id,\n          readOnly: props2.readOnly,\n          group,\n          widgetSubscriptions\n        }\n      ) });\n    } else {\n      return /* @__PURE__ */ jsx(\"div\", { className: classes.content });\n    }\n  };\n  return /* @__PURE__ */ jsx(FormBasedView, { ...props, subscriptionName: \"relatedElementsEvent\", postProcessor: extractFirstGroup });\n};\nconst useRepresentationsViewStyles = makeStyles((theme) => ({\n  content: {\n    padding: theme.spacing(1)\n  }\n}));\nconst isList = (widget) => widget.__typename === \"List\";\nconst RepresentationsView = (props) => {\n  const classes = useRepresentationsViewStyles();\n  const extractPlainList = (props2, form, widgetSubscriptions) => {\n    var _a, _b;\n    const widget = (_b = (_a = form.pages[0]) == null ? void 0 : _a.groups[0]) == null ? void 0 : _b.widgets[0];\n    if (isList(widget)) {\n      const uniqueSubscribers = /* @__PURE__ */ new Set();\n      widgetSubscriptions.forEach(\n        (subscription) => subscription.subscribers.forEach((subscriber) => uniqueSubscribers.add(subscriber))\n      );\n      return /* @__PURE__ */ jsx(\"div\", { className: classes.content, children: /* @__PURE__ */ jsx(\n        ListPropertySection,\n        {\n          editingContextId: props2.editingContextId,\n          formId: form.id,\n          readOnly: props2.readOnly,\n          widget,\n          subscribers: [...uniqueSubscribers.values()]\n        }\n      ) });\n    } else {\n      return /* @__PURE__ */ jsx(\"div\", { className: classes.content });\n    }\n  };\n  return /* @__PURE__ */ jsx(FormBasedView, { ...props, subscriptionName: \"representationsEvent\", postProcessor: extractPlainList });\n};\nexport {\n  DetailsView,\n  DetailsViewConfiguration,\n  FormRepresentation,\n  PropertySectionContext,\n  PropertySectionLabel,\n  RelatedElementsView,\n  RepresentationsView,\n  commonFields,\n  flexboxContainerFields,\n  formRefreshedEventPayloadFragment,\n  getTextDecorationLineValue,\n  subscribersUpdatedEventPayloadFragment,\n  useClickHandler,\n  useDetailsViewConfiguration,\n  widgetFields,\n  widgetSubscriptionsUpdatedEventPayloadFragment\n};\n", "import { jsx } from \"react/jsx-runtime\";\nimport * as d3 from \"d3\";\nimport { useRef, useEffect } from \"react\";\nconst getFontWeight = (style) => {\n  if (style == null ? void 0 : style.bold) {\n    return \"bold\";\n  }\n  return \"normal\";\n};\nconst getFontSize = (style) => {\n  return (style == null ? void 0 : style.fontSize) ?? 14;\n};\nconst getFontStyle = (style) => {\n  if (style == null ? void 0 : style.italic) {\n    return \"italic\";\n  }\n  return \"normal\";\n};\nconst getTextDecoration = (style) => {\n  let decoration = \"\";\n  if (style == null ? void 0 : style.strikeThrough) {\n    decoration = decoration + \"line-through\";\n  }\n  if (style == null ? void 0 : style.underline) {\n    let separator = decoration.length > 0 ? \" \" : \"\";\n    decoration = decoration + separator + \"underline\";\n  }\n  return decoration.length > 0 ? decoration : \"none\";\n};\nconst marginTop = 30;\nconst marginBottom = 30;\nconst marginRight = 0;\nconst marginLeft = 50;\nconst xPadding = 0.1;\nconst yType = d3.scaleLinear;\nconst yFormat = \"f\";\nconst x = (d) => d.key;\nconst y = (d) => d.value;\nconst BarChart = ({ chart }) => {\n  const d3Container = useRef(null);\n  useEffect(() => {\n    const width = chart.width;\n    const height = chart.height;\n    const xRange = [marginLeft, width - marginRight];\n    const yRange = [height - marginBottom, marginTop];\n    if (d3Container.current && chart) {\n      const { entries: data, label: yLabel, style } = chart;\n      const fontSize = getFontSize(style);\n      const fontStyle = getFontStyle(style);\n      const fontWeight = getFontWeight(style);\n      const textDecoration = getTextDecoration(style);\n      let color;\n      if ((style == null ? void 0 : style.barsColor) != null && (style == null ? void 0 : style.barsColor.length) > 0) {\n        color = style == null ? void 0 : style.barsColor;\n      } else {\n        color = \"steelblue\";\n      }\n      const X = d3.map(data, x);\n      const Y = d3.map(data, y);\n      const xDomain = new d3.InternSet(X);\n      const yDomain = [0, d3.max(Y)];\n      const I = d3.range(X.length).filter((i) => xDomain.has(X[i]));\n      const xScale = d3.scaleBand(xDomain, xRange).padding(xPadding);\n      const yScale = yType(yDomain, yRange);\n      const xAxis = d3.axisBottom(xScale).tickSizeOuter(0);\n      const yAxis = d3.axisLeft(yScale).ticks(height / 40, yFormat);\n      const formatValue = yScale.tickFormat(100, yFormat);\n      const title = (i) => `${X[i]}\n${formatValue(Y[i])}`;\n      const selection = d3.select(d3Container.current);\n      selection.selectAll(\"*\").remove();\n      const svg = selection.attr(\"viewBox\", [0, 0, width, height]).attr(\"text-decoration\", textDecoration).attr(\"pointer-events\", \"none\");\n      svg.append(\"g\").attr(\"transform\", `translate(${marginLeft},0)`).attr(\"style\", `font-size:${fontSize}; font-style: ${fontStyle}; font-weight: ${fontWeight}`).call(yAxis).call((g) => g.select(\".domain\").remove()).call(\n        (g) => g.selectAll(\".tick line\").clone().attr(\"x2\", width - marginLeft - marginRight).attr(\"stroke-opacity\", 0.1)\n      ).call(\n        (g) => g.append(\"text\").attr(\"x\", -marginLeft).attr(\"y\", 10).attr(\"fill\", \"currentColor\").attr(\"text-anchor\", \"start\").text(yLabel)\n      );\n      const bar = svg.append(\"g\").attr(\"fill\", color).selectAll(\"rect\").data(I).join(\"rect\").attr(\"x\", (i) => xScale(X[i])).attr(\"y\", (i) => yScale(Y[i])).attr(\"height\", (i) => yScale(0) - yScale(Y[i])).attr(\"width\", xScale.bandwidth());\n      if (title) {\n        bar.append(\"title\").text(title);\n      }\n      svg.append(\"g\").attr(\"transform\", `translate(0,${height - marginBottom})`).attr(\"style\", `font-size:${fontSize}; font-style: ${fontStyle}; font-weight: ${fontWeight}`).call(xAxis);\n    }\n  }, [chart, d3Container]);\n  return /* @__PURE__ */ jsx(\"svg\", { ref: d3Container, width: chart.width, height: chart.height });\n};\nconst name = (d) => d.key;\nconst value = (d) => d.value;\nconst innerRadius = 0;\nconst format = \",\";\nconst strokeLinejoin = \"round\";\nconst PieChart = ({ width, height, chart }) => {\n  const d3Container = useRef(null);\n  useEffect(() => {\n    const { entries: data, style } = chart;\n    const outerRadius = Math.min(width, height) / 2;\n    const labelRadius = innerRadius * 0.2 + outerRadius * 0.8;\n    const stroke = getStrokeColorValue(style);\n    const padAngle = stroke === \"none\" ? 1 / outerRadius : 0;\n    const strokeWidth = getStrokeWidth(style);\n    const fontWeight = getFontWeight(style);\n    const fontStyle = getFontStyle(style);\n    const textDecoration = getTextDecoration(style);\n    const fontSize = getFontSize(style);\n    const N = d3.map(data, name);\n    const V = d3.map(data, value);\n    const I = d3.range(N.length).filter((i) => !isNaN(V[i]));\n    const names = new d3.InternSet(N);\n    let colors = style == null ? void 0 : style.colors;\n    if (colors === void 0 || colors.length === 0) {\n      colors = d3.quantize((t) => d3.interpolateSpectral(t * 0.8 + 0.1), names.size);\n    }\n    const color = d3.scaleOrdinal(names, colors);\n    const formatValue = d3.format(format);\n    const title = (i) => `${N[i]}\n${formatValue(V[i])}`;\n    const label = (d) => {\n      const lines = `${title(d.data)}`.split(/\\n/);\n      let value2 = d.endAngle - d.startAngle > 0.25 ? lines : lines.slice(0, 1);\n      return value2.map((v) => {\n        if (v.length > 13) {\n          return v.substring(0, 10).concat(\"...\");\n        }\n        return v;\n      });\n    };\n    const arcs = d3.pie().padAngle(padAngle).sort(null).value((i) => V[i])(I);\n    const arc = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);\n    const arcLabel = d3.arc().innerRadius(labelRadius).outerRadius(labelRadius);\n    const selection = d3.select(d3Container.current);\n    selection.selectAll(\"*\").remove();\n    const svg = selection.attr(\"width\", width).attr(\"height\", height).attr(\"viewBox\", [-width / 2, -height / 2, width, height]).attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\").attr(\"pointer-events\", \"none\");\n    svg.append(\"g\").attr(\"stroke\", stroke).attr(\"stroke-width\", strokeWidth).attr(\"stroke-linejoin\", strokeLinejoin).selectAll(\"path\").data(arcs).join(\"path\").attr(\"fill\", (d) => color(N[d.data])).attr(\"d\", arc).append(\"title\").text((d) => title(d.data));\n    svg.append(\"g\").attr(\"font-family\", \"sans-serif\").attr(\"font-size\", fontSize).attr(\"font-style\", fontStyle).attr(\"text-decoration\", textDecoration).attr(\"font-weight\", fontWeight).attr(\"text-anchor\", \"middle\").selectAll(\"text\").data(arcs).join(\"text\").attr(\"transform\", (d) => `translate(${arcLabel.centroid(d)})`).selectAll(\"tspan\").data(label).join(\"tspan\").attr(\"x\", 0).attr(\"y\", (_, i) => `${i * 1.1}em`).attr(\"font-weight\", (_, i) => i ? null : \"bold\").text((d) => d);\n    Object.assign(svg.node(), { scales: { color } });\n  }, [width, height, chart, d3Container]);\n  const getStrokeColorValue = (style) => {\n    return (style == null ? void 0 : style.strokeColor) ?? \"white\";\n  };\n  const getStrokeWidth = (style) => {\n    return (style == null ? void 0 : style.strokeWidth) ?? 1;\n  };\n  return /* @__PURE__ */ jsx(\"svg\", { ref: d3Container });\n};\nexport {\n  BarChart,\n  PieChart\n};\n", "export default function ascending(a, b) {\n  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n", "export default function descending(a, b) {\n  return a == null || b == null ? NaN\n    : b < a ? -1\n    : b > a ? 1\n    : b >= a ? 0\n    : NaN;\n}\n", "import ascending from \"./ascending.js\";\nimport descending from \"./descending.js\";\n\nexport default function bisector(f) {\n  let compare1, compare2, delta;\n\n  // If an accessor is specified, promote it to a comparator. In this case we\n  // can test whether the search value is (self-) comparable. We cant do this\n  // for a comparator (except for specific, known comparators) because we cant\n  // tell if the comparator is symmetric, and an asymmetric comparator cant be\n  // used to test whether a single value is comparable.\n  if (f.length !== 2) {\n    compare1 = ascending;\n    compare2 = (d, x) => ascending(f(d), x);\n    delta = (d, x) => f(d) - x;\n  } else {\n    compare1 = f === ascending || f === descending ? f : zero;\n    compare2 = f;\n    delta = f;\n  }\n\n  function left(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function right(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) <= 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function center(a, x, lo = 0, hi = a.length) {\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n\nfunction zero() {\n  return 0;\n}\n", "export default function number(x) {\n  return x === null ? NaN : +x;\n}\n\nexport function* numbers(values, valueof) {\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  }\n}\n", "import ascending from \"./ascending.js\";\nimport bisector from \"./bisector.js\";\nimport number from \"./number.js\";\n\nconst ascendingBisect = bisector(ascending);\nexport const bisectRight = ascendingBisect.right;\nexport const bisectLeft = ascendingBisect.left;\nexport const bisectCenter = bisector(number).center;\nexport default bisectRight;\n", "export function blur(values, r) {\n  if (!((r = +r) >= 0)) throw new RangeError(\"invalid r\");\n  let length = values.length;\n  if (!((length = Math.floor(length)) >= 0)) throw new RangeError(\"invalid length\");\n  if (!length || !r) return values;\n  const blur = blurf(r);\n  const temp = values.slice();\n  blur(values, temp, 0, length, 1);\n  blur(temp, values, 0, length, 1);\n  blur(values, temp, 0, length, 1);\n  return values;\n}\n\nexport const blur2 = Blur2(blurf);\n\nexport const blurImage = Blur2(blurfImage);\n\nfunction Blur2(blur) {\n  return function(data, rx, ry = rx) {\n    if (!((rx = +rx) >= 0)) throw new RangeError(\"invalid rx\");\n    if (!((ry = +ry) >= 0)) throw new RangeError(\"invalid ry\");\n    let {data: values, width, height} = data;\n    if (!((width = Math.floor(width)) >= 0)) throw new RangeError(\"invalid width\");\n    if (!((height = Math.floor(height !== undefined ? height : values.length / width)) >= 0)) throw new RangeError(\"invalid height\");\n    if (!width || !height || (!rx && !ry)) return data;\n    const blurx = rx && blur(rx);\n    const blury = ry && blur(ry);\n    const temp = values.slice();\n    if (blurx && blury) {\n      blurh(blurx, temp, values, width, height);\n      blurh(blurx, values, temp, width, height);\n      blurh(blurx, temp, values, width, height);\n      blurv(blury, values, temp, width, height);\n      blurv(blury, temp, values, width, height);\n      blurv(blury, values, temp, width, height);\n    } else if (blurx) {\n      blurh(blurx, values, temp, width, height);\n      blurh(blurx, temp, values, width, height);\n      blurh(blurx, values, temp, width, height);\n    } else if (blury) {\n      blurv(blury, values, temp, width, height);\n      blurv(blury, temp, values, width, height);\n      blurv(blury, values, temp, width, height);\n    }\n    return data;\n  };\n}\n\nfunction blurh(blur, T, S, w, h) {\n  for (let y = 0, n = w * h; y < n;) {\n    blur(T, S, y, y += w, 1);\n  }\n}\n\nfunction blurv(blur, T, S, w, h) {\n  for (let x = 0, n = w * h; x < w; ++x) {\n    blur(T, S, x, x + n, w);\n  }\n}\n\nfunction blurfImage(radius) {\n  const blur = blurf(radius);\n  return (T, S, start, stop, step) => {\n    start <<= 2, stop <<= 2, step <<= 2;\n    blur(T, S, start + 0, stop + 0, step);\n    blur(T, S, start + 1, stop + 1, step);\n    blur(T, S, start + 2, stop + 2, step);\n    blur(T, S, start + 3, stop + 3, step);\n  };\n}\n\n// Given a target array T, a source array S, sets each value T[i] to the average\n// of {S[i - r], , S[i], , S[i + r]}, where r = radius, start <= i < stop,\n// for each i, i + step, i + 2 * step, etc., and where S[j] is clamped between\n// S[start] (inclusive) and S[stop] (exclusive). If the given radius is not an\n// integer, S[i - r - 1] and S[i + r + 1] are added to the sum, each weighted\n// according to r - radius.\nfunction blurf(radius) {\n  const radius0 = Math.floor(radius);\n  if (radius0 === radius) return bluri(radius);\n  const t = radius - radius0;\n  const w = 2 * radius + 1;\n  return (T, S, start, stop, step) => { // stop must be aligned!\n    if (!((stop -= step) >= start)) return; // inclusive stop\n    let sum = radius0 * S[start];\n    const s0 = step * radius0;\n    const s1 = s0 + step;\n    for (let i = start, j = start + s0; i < j; i += step) {\n      sum += S[Math.min(stop, i)];\n    }\n    for (let i = start, j = stop; i <= j; i += step) {\n      sum += S[Math.min(stop, i + s0)];\n      T[i] = (sum + t * (S[Math.max(start, i - s1)] + S[Math.min(stop, i + s1)])) / w;\n      sum -= S[Math.max(start, i - s0)];\n    }\n  };\n}\n\n// Like blurf, but optimized for integer radius.\nfunction bluri(radius) {\n  const w = 2 * radius + 1;\n  return (T, S, start, stop, step) => { // stop must be aligned!\n    if (!((stop -= step) >= start)) return; // inclusive stop\n    let sum = radius * S[start];\n    const s = step * radius;\n    for (let i = start, j = start + s; i < j; i += step) {\n      sum += S[Math.min(stop, i)];\n    }\n    for (let i = start, j = stop; i <= j; i += step) {\n      sum += S[Math.min(stop, i + s)];\n      T[i] = sum / w;\n      sum -= S[Math.max(start, i - s)];\n    }\n  };\n}\n", "// https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423\nexport class Adder {\n  constructor() {\n    this._partials = new Float64Array(32);\n    this._n = 0;\n  }\n  add(x) {\n    const p = this._partials;\n    let i = 0;\n    for (let j = 0; j < this._n && j < 32; j++) {\n      const y = p[j],\n        hi = x + y,\n        lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);\n      if (lo) p[i++] = lo;\n      x = hi;\n    }\n    p[i] = x;\n    this._n = i + 1;\n    return this;\n  }\n  valueOf() {\n    const p = this._partials;\n    let n = this._n, x, y, lo, hi = 0;\n    if (n > 0) {\n      hi = p[--n];\n      while (n > 0) {\n        x = hi;\n        y = p[--n];\n        hi = x + y;\n        lo = y - (hi - x);\n        if (lo) break;\n      }\n      if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {\n        y = lo * 2;\n        x = hi + y;\n        if (y == x - hi) hi = x;\n      }\n    }\n    return hi;\n  }\n}\n\nexport function fsum(values, valueof) {\n  const adder = new Adder();\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value = +value) {\n        adder.add(value);\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if (value = +valueof(value, ++index, values)) {\n        adder.add(value);\n      }\n    }\n  }\n  return +adder;\n}\n\nexport function fcumsum(values, valueof) {\n  const adder = new Adder();\n  let index = -1;\n  return Float64Array.from(values, valueof === undefined\n      ? v => adder.add(+v || 0)\n      : v => adder.add(+valueof(v, ++index, values) || 0)\n  );\n}\n", "export class InternMap extends Map {\n  constructor(entries, key = keyof) {\n    super();\n    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});\n    if (entries != null) for (const [key, value] of entries) this.set(key, value);\n  }\n  get(key) {\n    return super.get(intern_get(this, key));\n  }\n  has(key) {\n    return super.has(intern_get(this, key));\n  }\n  set(key, value) {\n    return super.set(intern_set(this, key), value);\n  }\n  delete(key) {\n    return super.delete(intern_delete(this, key));\n  }\n}\n\nexport class InternSet extends Set {\n  constructor(values, key = keyof) {\n    super();\n    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});\n    if (values != null) for (const value of values) this.add(value);\n  }\n  has(value) {\n    return super.has(intern_get(this, value));\n  }\n  add(value) {\n    return super.add(intern_set(this, value));\n  }\n  delete(value) {\n    return super.delete(intern_delete(this, value));\n  }\n}\n\nfunction intern_get({_intern, _key}, value) {\n  const key = _key(value);\n  return _intern.has(key) ? _intern.get(key) : value;\n}\n\nfunction intern_set({_intern, _key}, value) {\n  const key = _key(value);\n  if (_intern.has(key)) return _intern.get(key);\n  _intern.set(key, value);\n  return value;\n}\n\nfunction intern_delete({_intern, _key}, value) {\n  const key = _key(value);\n  if (_intern.has(key)) {\n    value = _intern.get(key);\n    _intern.delete(key);\n  }\n  return value;\n}\n\nfunction keyof(value) {\n  return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n}\n", "var array = Array.prototype;\n\nexport var slice = array.slice;\nexport var map = array.map;\n", "const e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\nfunction tickSpec(start, stop, count) {\n  const step = (stop - start) / Math.max(0, count),\n      power = Math.floor(Math.log10(step)),\n      error = step / Math.pow(10, power),\n      factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;\n  let i1, i2, inc;\n  if (power < 0) {\n    inc = Math.pow(10, -power) / factor;\n    i1 = Math.round(start * inc);\n    i2 = Math.round(stop * inc);\n    if (i1 / inc < start) ++i1;\n    if (i2 / inc > stop) --i2;\n    inc = -inc;\n  } else {\n    inc = Math.pow(10, power) * factor;\n    i1 = Math.round(start / inc);\n    i2 = Math.round(stop / inc);\n    if (i1 * inc < start) ++i1;\n    if (i2 * inc > stop) --i2;\n  }\n  if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start, stop, count * 2);\n  return [i1, i2, inc];\n}\n\nexport default function ticks(start, stop, count) {\n  stop = +stop, start = +start, count = +count;\n  if (!(count > 0)) return [];\n  if (start === stop) return [start];\n  const reverse = stop < start, [i1, i2, inc] = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count);\n  if (!(i2 >= i1)) return [];\n  const n = i2 - i1 + 1, ticks = new Array(n);\n  if (reverse) {\n    if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) / -inc;\n    else for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) * inc;\n  } else {\n    if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) / -inc;\n    else for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) * inc;\n  }\n  return ticks;\n}\n\nexport function tickIncrement(start, stop, count) {\n  stop = +stop, start = +start, count = +count;\n  return tickSpec(start, stop, count)[2];\n}\n\nexport function tickStep(start, stop, count) {\n  stop = +stop, start = +start, count = +count;\n  const reverse = stop < start, inc = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);\n  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);\n}\n", "export default function max(values, valueof) {\n  let max;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null\n          && (max < value || (max === undefined && value >= value))) {\n        max = value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null\n          && (max < value || (max === undefined && value >= value))) {\n        max = value;\n      }\n    }\n  }\n  return max;\n}\n", "function* flatten(arrays) {\n  for (const array of arrays) {\n    yield* array;\n  }\n}\n\nexport default function merge(arrays) {\n  return Array.from(flatten(arrays));\n}\n", "export default function range(start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n}\n", "export default shuffler(Math.random);\n\nexport function shuffler(random) {\n  return function shuffle(array, i0 = 0, i1 = array.length) {\n    let m = i1 - (i0 = +i0);\n    while (m) {\n      const i = random() * m-- | 0, t = array[m + i0];\n      array[m + i0] = array[i + i0];\n      array[i + i0] = t;\n    }\n    return array;\n  };\n}\n", "export default function map(values, mapper) {\n  if (typeof values[Symbol.iterator] !== \"function\") throw new TypeError(\"values is not iterable\");\n  if (typeof mapper !== \"function\") throw new TypeError(\"mapper is not a function\");\n  return Array.from(values, (value, index) => mapper(value, index, values));\n}\n", "export default function(x) {\n  return x;\n}\n", "import identity from \"./identity.js\";\n\nvar top = 1,\n    right = 2,\n    bottom = 3,\n    left = 4,\n    epsilon = 1e-6;\n\nfunction translateX(x) {\n  return \"translate(\" + x + \",0)\";\n}\n\nfunction translateY(y) {\n  return \"translate(0,\" + y + \")\";\n}\n\nfunction number(scale) {\n  return d => +scale(d);\n}\n\nfunction center(scale, offset) {\n  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;\n  if (scale.round()) offset = Math.round(offset);\n  return d => +scale(d) + offset;\n}\n\nfunction entering() {\n  return !this.__axis;\n}\n\nfunction axis(orient, scale) {\n  var tickArguments = [],\n      tickValues = null,\n      tickFormat = null,\n      tickSizeInner = 6,\n      tickSizeOuter = 6,\n      tickPadding = 3,\n      offset = typeof window !== \"undefined\" && window.devicePixelRatio > 1 ? 0 : 0.5,\n      k = orient === top || orient === left ? -1 : 1,\n      x = orient === left || orient === right ? \"x\" : \"y\",\n      transform = orient === top || orient === bottom ? translateX : translateY;\n\n  function axis(context) {\n    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,\n        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity) : tickFormat,\n        spacing = Math.max(tickSizeInner, 0) + tickPadding,\n        range = scale.range(),\n        range0 = +range[0] + offset,\n        range1 = +range[range.length - 1] + offset,\n        position = (scale.bandwidth ? center : number)(scale.copy(), offset),\n        selection = context.selection ? context.selection() : context,\n        path = selection.selectAll(\".domain\").data([null]),\n        tick = selection.selectAll(\".tick\").data(values, scale).order(),\n        tickExit = tick.exit(),\n        tickEnter = tick.enter().append(\"g\").attr(\"class\", \"tick\"),\n        line = tick.select(\"line\"),\n        text = tick.select(\"text\");\n\n    path = path.merge(path.enter().insert(\"path\", \".tick\")\n        .attr(\"class\", \"domain\")\n        .attr(\"stroke\", \"currentColor\"));\n\n    tick = tick.merge(tickEnter);\n\n    line = line.merge(tickEnter.append(\"line\")\n        .attr(\"stroke\", \"currentColor\")\n        .attr(x + \"2\", k * tickSizeInner));\n\n    text = text.merge(tickEnter.append(\"text\")\n        .attr(\"fill\", \"currentColor\")\n        .attr(x, k * spacing)\n        .attr(\"dy\", orient === top ? \"0em\" : orient === bottom ? \"0.71em\" : \"0.32em\"));\n\n    if (context !== selection) {\n      path = path.transition(context);\n      tick = tick.transition(context);\n      line = line.transition(context);\n      text = text.transition(context);\n\n      tickExit = tickExit.transition(context)\n          .attr(\"opacity\", epsilon)\n          .attr(\"transform\", function(d) { return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute(\"transform\"); });\n\n      tickEnter\n          .attr(\"opacity\", epsilon)\n          .attr(\"transform\", function(d) { var p = this.parentNode.__axis; return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset); });\n    }\n\n    tickExit.remove();\n\n    path\n        .attr(\"d\", orient === left || orient === right\n            ? (tickSizeOuter ? \"M\" + k * tickSizeOuter + \",\" + range0 + \"H\" + offset + \"V\" + range1 + \"H\" + k * tickSizeOuter : \"M\" + offset + \",\" + range0 + \"V\" + range1)\n            : (tickSizeOuter ? \"M\" + range0 + \",\" + k * tickSizeOuter + \"V\" + offset + \"H\" + range1 + \"V\" + k * tickSizeOuter : \"M\" + range0 + \",\" + offset + \"H\" + range1));\n\n    tick\n        .attr(\"opacity\", 1)\n        .attr(\"transform\", function(d) { return transform(position(d) + offset); });\n\n    line\n        .attr(x + \"2\", k * tickSizeInner);\n\n    text\n        .attr(x, k * spacing)\n        .text(format);\n\n    selection.filter(entering)\n        .attr(\"fill\", \"none\")\n        .attr(\"font-size\", 10)\n        .attr(\"font-family\", \"sans-serif\")\n        .attr(\"text-anchor\", orient === right ? \"start\" : orient === left ? \"end\" : \"middle\");\n\n    selection\n        .each(function() { this.__axis = position; });\n  }\n\n  axis.scale = function(_) {\n    return arguments.length ? (scale = _, axis) : scale;\n  };\n\n  axis.ticks = function() {\n    return tickArguments = Array.from(arguments), axis;\n  };\n\n  axis.tickArguments = function(_) {\n    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis) : tickArguments.slice();\n  };\n\n  axis.tickValues = function(_) {\n    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis) : tickValues && tickValues.slice();\n  };\n\n  axis.tickFormat = function(_) {\n    return arguments.length ? (tickFormat = _, axis) : tickFormat;\n  };\n\n  axis.tickSize = function(_) {\n    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;\n  };\n\n  axis.tickSizeInner = function(_) {\n    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;\n  };\n\n  axis.tickSizeOuter = function(_) {\n    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;\n  };\n\n  axis.tickPadding = function(_) {\n    return arguments.length ? (tickPadding = +_, axis) : tickPadding;\n  };\n\n  axis.offset = function(_) {\n    return arguments.length ? (offset = +_, axis) : offset;\n  };\n\n  return axis;\n}\n\nexport function axisTop(scale) {\n  return axis(top, scale);\n}\n\nexport function axisRight(scale) {\n  return axis(right, scale);\n}\n\nexport function axisBottom(scale) {\n  return axis(bottom, scale);\n}\n\nexport function axisLeft(scale) {\n  return axis(left, scale);\n}\n", "import {dispatch} from \"d3-dispatch\";\nimport {dragDisable, dragEnable} from \"d3-drag\";\nimport {interpolate} from \"d3-interpolate\";\nimport {pointer, select} from \"d3-selection\";\nimport {interrupt} from \"d3-transition\";\nimport constant from \"./constant.js\";\nimport BrushEvent from \"./event.js\";\nimport noevent, {nopropagation} from \"./noevent.js\";\n\nvar MODE_DRAG = {name: \"drag\"},\n    MODE_SPACE = {name: \"space\"},\n    MODE_HANDLE = {name: \"handle\"},\n    MODE_CENTER = {name: \"center\"};\n\nconst {abs, max, min} = Math;\n\nfunction number1(e) {\n  return [+e[0], +e[1]];\n}\n\nfunction number2(e) {\n  return [number1(e[0]), number1(e[1])];\n}\n\nvar X = {\n  name: \"x\",\n  handles: [\"w\", \"e\"].map(type),\n  input: function(x, e) { return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]]; },\n  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }\n};\n\nvar Y = {\n  name: \"y\",\n  handles: [\"n\", \"s\"].map(type),\n  input: function(y, e) { return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]]; },\n  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }\n};\n\nvar XY = {\n  name: \"xy\",\n  handles: [\"n\", \"w\", \"e\", \"s\", \"nw\", \"ne\", \"sw\", \"se\"].map(type),\n  input: function(xy) { return xy == null ? null : number2(xy); },\n  output: function(xy) { return xy; }\n};\n\nvar cursors = {\n  overlay: \"crosshair\",\n  selection: \"move\",\n  n: \"ns-resize\",\n  e: \"ew-resize\",\n  s: \"ns-resize\",\n  w: \"ew-resize\",\n  nw: \"nwse-resize\",\n  ne: \"nesw-resize\",\n  se: \"nwse-resize\",\n  sw: \"nesw-resize\"\n};\n\nvar flipX = {\n  e: \"w\",\n  w: \"e\",\n  nw: \"ne\",\n  ne: \"nw\",\n  se: \"sw\",\n  sw: \"se\"\n};\n\nvar flipY = {\n  n: \"s\",\n  s: \"n\",\n  nw: \"sw\",\n  ne: \"se\",\n  se: \"ne\",\n  sw: \"nw\"\n};\n\nvar signsX = {\n  overlay: +1,\n  selection: +1,\n  n: null,\n  e: +1,\n  s: null,\n  w: -1,\n  nw: -1,\n  ne: +1,\n  se: +1,\n  sw: -1\n};\n\nvar signsY = {\n  overlay: +1,\n  selection: +1,\n  n: -1,\n  e: null,\n  s: +1,\n  w: null,\n  nw: -1,\n  ne: -1,\n  se: +1,\n  sw: +1\n};\n\nfunction type(t) {\n  return {type: t};\n}\n\n// Ignore right-click, since that should open the context menu.\nfunction defaultFilter(event) {\n  return !event.ctrlKey && !event.button;\n}\n\nfunction defaultExtent() {\n  var svg = this.ownerSVGElement || this;\n  if (svg.hasAttribute(\"viewBox\")) {\n    svg = svg.viewBox.baseVal;\n    return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];\n  }\n  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];\n}\n\nfunction defaultTouchable() {\n  return navigator.maxTouchPoints || (\"ontouchstart\" in this);\n}\n\n// Like d3.local, but with the name __brush rather than auto-generated.\nfunction local(node) {\n  while (!node.__brush) if (!(node = node.parentNode)) return;\n  return node.__brush;\n}\n\nfunction empty(extent) {\n  return extent[0][0] === extent[1][0]\n      || extent[0][1] === extent[1][1];\n}\n\nexport function brushSelection(node) {\n  var state = node.__brush;\n  return state ? state.dim.output(state.selection) : null;\n}\n\nexport function brushX() {\n  return brush(X);\n}\n\nexport function brushY() {\n  return brush(Y);\n}\n\nexport default function() {\n  return brush(XY);\n}\n\nfunction brush(dim) {\n  var extent = defaultExtent,\n      filter = defaultFilter,\n      touchable = defaultTouchable,\n      keys = true,\n      listeners = dispatch(\"start\", \"brush\", \"end\"),\n      handleSize = 6,\n      touchending;\n\n  function brush(group) {\n    var overlay = group\n        .property(\"__brush\", initialize)\n      .selectAll(\".overlay\")\n      .data([type(\"overlay\")]);\n\n    overlay.enter().append(\"rect\")\n        .attr(\"class\", \"overlay\")\n        .attr(\"pointer-events\", \"all\")\n        .attr(\"cursor\", cursors.overlay)\n      .merge(overlay)\n        .each(function() {\n          var extent = local(this).extent;\n          select(this)\n              .attr(\"x\", extent[0][0])\n              .attr(\"y\", extent[0][1])\n              .attr(\"width\", extent[1][0] - extent[0][0])\n              .attr(\"height\", extent[1][1] - extent[0][1]);\n        });\n\n    group.selectAll(\".selection\")\n      .data([type(\"selection\")])\n      .enter().append(\"rect\")\n        .attr(\"class\", \"selection\")\n        .attr(\"cursor\", cursors.selection)\n        .attr(\"fill\", \"#777\")\n        .attr(\"fill-opacity\", 0.3)\n        .attr(\"stroke\", \"#fff\")\n        .attr(\"shape-rendering\", \"crispEdges\");\n\n    var handle = group.selectAll(\".handle\")\n      .data(dim.handles, function(d) { return d.type; });\n\n    handle.exit().remove();\n\n    handle.enter().append(\"rect\")\n        .attr(\"class\", function(d) { return \"handle handle--\" + d.type; })\n        .attr(\"cursor\", function(d) { return cursors[d.type]; });\n\n    group\n        .each(redraw)\n        .attr(\"fill\", \"none\")\n        .attr(\"pointer-events\", \"all\")\n        .on(\"mousedown.brush\", started)\n      .filter(touchable)\n        .on(\"touchstart.brush\", started)\n        .on(\"touchmove.brush\", touchmoved)\n        .on(\"touchend.brush touchcancel.brush\", touchended)\n        .style(\"touch-action\", \"none\")\n        .style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n  }\n\n  brush.move = function(group, selection, event) {\n    if (group.tween) {\n      group\n          .on(\"start.brush\", function(event) { emitter(this, arguments).beforestart().start(event); })\n          .on(\"interrupt.brush end.brush\", function(event) { emitter(this, arguments).end(event); })\n          .tween(\"brush\", function() {\n            var that = this,\n                state = that.__brush,\n                emit = emitter(that, arguments),\n                selection0 = state.selection,\n                selection1 = dim.input(typeof selection === \"function\" ? selection.apply(this, arguments) : selection, state.extent),\n                i = interpolate(selection0, selection1);\n\n            function tween(t) {\n              state.selection = t === 1 && selection1 === null ? null : i(t);\n              redraw.call(that);\n              emit.brush();\n            }\n\n            return selection0 !== null && selection1 !== null ? tween : tween(1);\n          });\n    } else {\n      group\n          .each(function() {\n            var that = this,\n                args = arguments,\n                state = that.__brush,\n                selection1 = dim.input(typeof selection === \"function\" ? selection.apply(that, args) : selection, state.extent),\n                emit = emitter(that, args).beforestart();\n\n            interrupt(that);\n            state.selection = selection1 === null ? null : selection1;\n            redraw.call(that);\n            emit.start(event).brush(event).end(event);\n          });\n    }\n  };\n\n  brush.clear = function(group, event) {\n    brush.move(group, null, event);\n  };\n\n  function redraw() {\n    var group = select(this),\n        selection = local(this).selection;\n\n    if (selection) {\n      group.selectAll(\".selection\")\n          .style(\"display\", null)\n          .attr(\"x\", selection[0][0])\n          .attr(\"y\", selection[0][1])\n          .attr(\"width\", selection[1][0] - selection[0][0])\n          .attr(\"height\", selection[1][1] - selection[0][1]);\n\n      group.selectAll(\".handle\")\n          .style(\"display\", null)\n          .attr(\"x\", function(d) { return d.type[d.type.length - 1] === \"e\" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })\n          .attr(\"y\", function(d) { return d.type[0] === \"s\" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })\n          .attr(\"width\", function(d) { return d.type === \"n\" || d.type === \"s\" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })\n          .attr(\"height\", function(d) { return d.type === \"e\" || d.type === \"w\" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });\n    }\n\n    else {\n      group.selectAll(\".selection,.handle\")\n          .style(\"display\", \"none\")\n          .attr(\"x\", null)\n          .attr(\"y\", null)\n          .attr(\"width\", null)\n          .attr(\"height\", null);\n    }\n  }\n\n  function emitter(that, args, clean) {\n    var emit = that.__brush.emitter;\n    return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);\n  }\n\n  function Emitter(that, args, clean) {\n    this.that = that;\n    this.args = args;\n    this.state = that.__brush;\n    this.active = 0;\n    this.clean = clean;\n  }\n\n  Emitter.prototype = {\n    beforestart: function() {\n      if (++this.active === 1) this.state.emitter = this, this.starting = true;\n      return this;\n    },\n    start: function(event, mode) {\n      if (this.starting) this.starting = false, this.emit(\"start\", event, mode);\n      else this.emit(\"brush\", event);\n      return this;\n    },\n    brush: function(event, mode) {\n      this.emit(\"brush\", event, mode);\n      return this;\n    },\n    end: function(event, mode) {\n      if (--this.active === 0) delete this.state.emitter, this.emit(\"end\", event, mode);\n      return this;\n    },\n    emit: function(type, event, mode) {\n      var d = select(this.that).datum();\n      listeners.call(\n        type,\n        this.that,\n        new BrushEvent(type, {\n          sourceEvent: event,\n          target: brush,\n          selection: dim.output(this.state.selection),\n          mode,\n          dispatch: listeners\n        }),\n        d\n      );\n    }\n  };\n\n  function started(event) {\n    if (touchending && !event.touches) return;\n    if (!filter.apply(this, arguments)) return;\n\n    var that = this,\n        type = event.target.__data__.type,\n        mode = (keys && event.metaKey ? type = \"overlay\" : type) === \"selection\" ? MODE_DRAG : (keys && event.altKey ? MODE_CENTER : MODE_HANDLE),\n        signX = dim === Y ? null : signsX[type],\n        signY = dim === X ? null : signsY[type],\n        state = local(that),\n        extent = state.extent,\n        selection = state.selection,\n        W = extent[0][0], w0, w1,\n        N = extent[0][1], n0, n1,\n        E = extent[1][0], e0, e1,\n        S = extent[1][1], s0, s1,\n        dx = 0,\n        dy = 0,\n        moving,\n        shifting = signX && signY && keys && event.shiftKey,\n        lockX,\n        lockY,\n        points = Array.from(event.touches || [event], t => {\n          const i = t.identifier;\n          t = pointer(t, that);\n          t.point0 = t.slice();\n          t.identifier = i;\n          return t;\n        });\n\n    interrupt(that);\n    var emit = emitter(that, arguments, true).beforestart();\n\n    if (type === \"overlay\") {\n      if (selection) moving = true;\n      const pts = [points[0], points[1] || points[0]];\n      state.selection = selection = [[\n          w0 = dim === Y ? W : min(pts[0][0], pts[1][0]),\n          n0 = dim === X ? N : min(pts[0][1], pts[1][1])\n        ], [\n          e0 = dim === Y ? E : max(pts[0][0], pts[1][0]),\n          s0 = dim === X ? S : max(pts[0][1], pts[1][1])\n        ]];\n      if (points.length > 1) move(event);\n    } else {\n      w0 = selection[0][0];\n      n0 = selection[0][1];\n      e0 = selection[1][0];\n      s0 = selection[1][1];\n    }\n\n    w1 = w0;\n    n1 = n0;\n    e1 = e0;\n    s1 = s0;\n\n    var group = select(that)\n        .attr(\"pointer-events\", \"none\");\n\n    var overlay = group.selectAll(\".overlay\")\n        .attr(\"cursor\", cursors[type]);\n\n    if (event.touches) {\n      emit.moved = moved;\n      emit.ended = ended;\n    } else {\n      var view = select(event.view)\n          .on(\"mousemove.brush\", moved, true)\n          .on(\"mouseup.brush\", ended, true);\n      if (keys) view\n          .on(\"keydown.brush\", keydowned, true)\n          .on(\"keyup.brush\", keyupped, true)\n\n      dragDisable(event.view);\n    }\n\n    redraw.call(that);\n    emit.start(event, mode.name);\n\n    function moved(event) {\n      for (const p of event.changedTouches || [event]) {\n        for (const d of points)\n          if (d.identifier === p.identifier) d.cur = pointer(p, that);\n      }\n      if (shifting && !lockX && !lockY && points.length === 1) {\n        const point = points[0];\n        if (abs(point.cur[0] - point[0]) > abs(point.cur[1] - point[1]))\n          lockY = true;\n        else\n          lockX = true;\n      }\n      for (const point of points)\n        if (point.cur) point[0] = point.cur[0], point[1] = point.cur[1];\n      moving = true;\n      noevent(event);\n      move(event);\n    }\n\n    function move(event) {\n      const point = points[0], point0 = point.point0;\n      var t;\n\n      dx = point[0] - point0[0];\n      dy = point[1] - point0[1];\n\n      switch (mode) {\n        case MODE_SPACE:\n        case MODE_DRAG: {\n          if (signX) dx = max(W - w0, min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;\n          if (signY) dy = max(N - n0, min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;\n          break;\n        }\n        case MODE_HANDLE: {\n          if (points[1]) {\n            if (signX) w1 = max(W, min(E, points[0][0])), e1 = max(W, min(E, points[1][0])), signX = 1;\n            if (signY) n1 = max(N, min(S, points[0][1])), s1 = max(N, min(S, points[1][1])), signY = 1;\n          } else {\n            if (signX < 0) dx = max(W - w0, min(E - w0, dx)), w1 = w0 + dx, e1 = e0;\n            else if (signX > 0) dx = max(W - e0, min(E - e0, dx)), w1 = w0, e1 = e0 + dx;\n            if (signY < 0) dy = max(N - n0, min(S - n0, dy)), n1 = n0 + dy, s1 = s0;\n            else if (signY > 0) dy = max(N - s0, min(S - s0, dy)), n1 = n0, s1 = s0 + dy;\n          }\n          break;\n        }\n        case MODE_CENTER: {\n          if (signX) w1 = max(W, min(E, w0 - dx * signX)), e1 = max(W, min(E, e0 + dx * signX));\n          if (signY) n1 = max(N, min(S, n0 - dy * signY)), s1 = max(N, min(S, s0 + dy * signY));\n          break;\n        }\n      }\n\n      if (e1 < w1) {\n        signX *= -1;\n        t = w0, w0 = e0, e0 = t;\n        t = w1, w1 = e1, e1 = t;\n        if (type in flipX) overlay.attr(\"cursor\", cursors[type = flipX[type]]);\n      }\n\n      if (s1 < n1) {\n        signY *= -1;\n        t = n0, n0 = s0, s0 = t;\n        t = n1, n1 = s1, s1 = t;\n        if (type in flipY) overlay.attr(\"cursor\", cursors[type = flipY[type]]);\n      }\n\n      if (state.selection) selection = state.selection; // May be set by brush.move!\n      if (lockX) w1 = selection[0][0], e1 = selection[1][0];\n      if (lockY) n1 = selection[0][1], s1 = selection[1][1];\n\n      if (selection[0][0] !== w1\n          || selection[0][1] !== n1\n          || selection[1][0] !== e1\n          || selection[1][1] !== s1) {\n        state.selection = [[w1, n1], [e1, s1]];\n        redraw.call(that);\n        emit.brush(event, mode.name);\n      }\n    }\n\n    function ended(event) {\n      nopropagation(event);\n      if (event.touches) {\n        if (event.touches.length) return;\n        if (touchending) clearTimeout(touchending);\n        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!\n      } else {\n        dragEnable(event.view, moving);\n        view.on(\"keydown.brush keyup.brush mousemove.brush mouseup.brush\", null);\n      }\n      group.attr(\"pointer-events\", \"all\");\n      overlay.attr(\"cursor\", cursors.overlay);\n      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!\n      if (empty(selection)) state.selection = null, redraw.call(that);\n      emit.end(event, mode.name);\n    }\n\n    function keydowned(event) {\n      switch (event.keyCode) {\n        case 16: { // SHIFT\n          shifting = signX && signY;\n          break;\n        }\n        case 18: { // ALT\n          if (mode === MODE_HANDLE) {\n            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;\n            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;\n            mode = MODE_CENTER;\n            move(event);\n          }\n          break;\n        }\n        case 32: { // SPACE; takes priority over ALT\n          if (mode === MODE_HANDLE || mode === MODE_CENTER) {\n            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;\n            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;\n            mode = MODE_SPACE;\n            overlay.attr(\"cursor\", cursors.selection);\n            move(event);\n          }\n          break;\n        }\n        default: return;\n      }\n      noevent(event);\n    }\n\n    function keyupped(event) {\n      switch (event.keyCode) {\n        case 16: { // SHIFT\n          if (shifting) {\n            lockX = lockY = shifting = false;\n            move(event);\n          }\n          break;\n        }\n        case 18: { // ALT\n          if (mode === MODE_CENTER) {\n            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;\n            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;\n            mode = MODE_HANDLE;\n            move(event);\n          }\n          break;\n        }\n        case 32: { // SPACE\n          if (mode === MODE_SPACE) {\n            if (event.altKey) {\n              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;\n              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;\n              mode = MODE_CENTER;\n            } else {\n              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;\n              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;\n              mode = MODE_HANDLE;\n            }\n            overlay.attr(\"cursor\", cursors[type]);\n            move(event);\n          }\n          break;\n        }\n        default: return;\n      }\n      noevent(event);\n    }\n  }\n\n  function touchmoved(event) {\n    emitter(this, arguments).moved(event);\n  }\n\n  function touchended(event) {\n    emitter(this, arguments).ended(event);\n  }\n\n  function initialize() {\n    var state = this.__brush || {selection: null};\n    state.extent = number2(extent.apply(this, arguments));\n    state.dim = dim;\n    return state;\n  }\n\n  brush.extent = function(_) {\n    return arguments.length ? (extent = typeof _ === \"function\" ? _ : constant(number2(_)), brush) : extent;\n  };\n\n  brush.filter = function(_) {\n    return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant(!!_), brush) : filter;\n  };\n\n  brush.touchable = function(_) {\n    return arguments.length ? (touchable = typeof _ === \"function\" ? _ : constant(!!_), brush) : touchable;\n  };\n\n  brush.handleSize = function(_) {\n    return arguments.length ? (handleSize = +_, brush) : handleSize;\n  };\n\n  brush.keyModifiers = function(_) {\n    return arguments.length ? (keys = !!_, brush) : keys;\n  };\n\n  brush.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? brush : value;\n  };\n\n  return brush;\n}\n", "export var abs = Math.abs;\nexport var cos = Math.cos;\nexport var sin = Math.sin;\nexport var pi = Math.PI;\nexport var halfPi = pi / 2;\nexport var tau = pi * 2;\nexport var max = Math.max;\nexport var epsilon = 1e-12;\n", "const pi = Math.PI,\n    tau = 2 * pi,\n    epsilon = 1e-6,\n    tauEpsilon = tau - epsilon;\n\nfunction append(strings) {\n  this._ += strings[0];\n  for (let i = 1, n = strings.length; i < n; ++i) {\n    this._ += arguments[i] + strings[i];\n  }\n}\n\nfunction appendRound(digits) {\n  let d = Math.floor(digits);\n  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);\n  if (d > 15) return append;\n  const k = 10 ** d;\n  return function(strings) {\n    this._ += strings[0];\n    for (let i = 1, n = strings.length; i < n; ++i) {\n      this._ += Math.round(arguments[i] * k) / k + strings[i];\n    }\n  };\n}\n\nexport class Path {\n  constructor(digits) {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null; // end of current subpath\n    this._ = \"\";\n    this._append = digits == null ? append : appendRound(digits);\n  }\n  moveTo(x, y) {\n    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._append`Z`;\n    }\n  }\n  lineTo(x, y) {\n    this._append`L${this._x1 = +x},${this._y1 = +y}`;\n  }\n  quadraticCurveTo(x1, y1, x, y) {\n    this._append`Q${+x1},${+y1},${this._x1 = +x},${this._y1 = +y}`;\n  }\n  bezierCurveTo(x1, y1, x2, y2, x, y) {\n    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x},${this._y1 = +y}`;\n  }\n  arcTo(x1, y1, x2, y2, r) {\n    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(`negative radius: ${r}`);\n\n    let x0 = this._x1,\n        y0 = this._y1,\n        x21 = x2 - x1,\n        y21 = y2 - y1,\n        x01 = x0 - x1,\n        y01 = y0 - y1,\n        l01_2 = x01 * x01 + y01 * y01;\n\n    // Is this path empty? Move to (x1,y1).\n    if (this._x1 === null) {\n      this._append`M${this._x1 = x1},${this._y1 = y1}`;\n    }\n\n    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.\n    else if (!(l01_2 > epsilon));\n\n    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?\n    // Equivalently, is (x1,y1) coincident with (x2,y2)?\n    // Or, is the radius zero? Line to (x1,y1).\n    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {\n      this._append`L${this._x1 = x1},${this._y1 = y1}`;\n    }\n\n    // Otherwise, draw an arc!\n    else {\n      let x20 = x2 - x0,\n          y20 = y2 - y0,\n          l21_2 = x21 * x21 + y21 * y21,\n          l20_2 = x20 * x20 + y20 * y20,\n          l21 = Math.sqrt(l21_2),\n          l01 = Math.sqrt(l01_2),\n          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),\n          t01 = l / l01,\n          t21 = l / l21;\n\n      // If the start tangent is not coincident with (x0,y0), line to.\n      if (Math.abs(t01 - 1) > epsilon) {\n        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;\n      }\n\n      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;\n    }\n  }\n  arc(x, y, r, a0, a1, ccw) {\n    x = +x, y = +y, r = +r, ccw = !!ccw;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(`negative radius: ${r}`);\n\n    let dx = r * Math.cos(a0),\n        dy = r * Math.sin(a0),\n        x0 = x + dx,\n        y0 = y + dy,\n        cw = 1 ^ ccw,\n        da = ccw ? a0 - a1 : a1 - a0;\n\n    // Is this path empty? Move to (x0,y0).\n    if (this._x1 === null) {\n      this._append`M${x0},${y0}`;\n    }\n\n    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).\n    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {\n      this._append`L${x0},${y0}`;\n    }\n\n    // Is this arc empty? Were done.\n    if (!r) return;\n\n    // Does the angle go the wrong way? Flip the direction.\n    if (da < 0) da = da % tau + tau;\n\n    // Is this a complete circle? Draw two arcs to complete the circle.\n    if (da > tauEpsilon) {\n      this._append`A${r},${r},0,1,${cw},${x - dx},${y - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;\n    }\n\n    // Is this arc non-empty? Draw an arc!\n    else if (da > epsilon) {\n      this._append`A${r},${r},0,${+(da >= pi)},${cw},${this._x1 = x + r * Math.cos(a1)},${this._y1 = y + r * Math.sin(a1)}`;\n    }\n  }\n  rect(x, y, w, h) {\n    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${w = +w}v${+h}h${-w}Z`;\n  }\n  toString() {\n    return this._;\n  }\n}\n\nexport function path() {\n  return new Path;\n}\n\n// Allow instanceof d3.path\npath.prototype = Path.prototype;\n\nexport function pathRound(digits = 3) {\n  return new Path(+digits);\n}\n", "export var slice = Array.prototype.slice;\n", "var array = Array.prototype;\n\nexport var slice = array.slice;\n", "export const epsilon = 1.1102230246251565e-16;\nexport const splitter = 134217729;\nexport const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n// fast_expansion_sum_zeroelim routine from oritinal code\nexport function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if ((fnow > enow) === (fnow > -enow)) {\n        Q = enow;\n        enow = e[++eindex];\n    } else {\n        Q = fnow;\n        fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n        if ((fnow > enow) === (fnow > -enow)) {\n            Qnew = enow + Q;\n            hh = Q - (Qnew - enow);\n            enow = e[++eindex];\n        } else {\n            Qnew = fnow + Q;\n            hh = Q - (Qnew - fnow);\n            fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = Q + enow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                enow = e[++eindex];\n            } else {\n                Qnew = Q + fnow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n    }\n    while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function sum_three(alen, a, blen, b, clen, c, tmp, out) {\n    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);\n}\n\n// scale_expansion_zeroelim routine from oritinal code\nexport function scale(elen, e, b, h) {\n    let Q, sum, hh, product1, product0;\n    let bvirt, c, ahi, alo, bhi, blo;\n\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    let enow = e[0];\n    Q = enow * b;\n    c = splitter * enow;\n    ahi = c - (c - enow);\n    alo = enow - ahi;\n    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);\n    let hindex = 0;\n    if (hh !== 0) {\n        h[hindex++] = hh;\n    }\n    for (let i = 1; i < elen; i++) {\n        enow = e[i];\n        product1 = enow * b;\n        c = splitter * enow;\n        ahi = c - (c - enow);\n        alo = enow - ahi;\n        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);\n        sum = Q + product0;\n        bvirt = sum - Q;\n        hh = Q - (sum - bvirt) + (product0 - bvirt);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        Q = product1 + sum;\n        hh = sum - (Q - product1);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function negate(elen, e) {\n    for (let i = 0; i < elen; i++) e[i] = -e[i];\n    return elen;\n}\n\nexport function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n}\n\nexport function vec(n) {\n    return new Float64Array(n);\n}\n", "import {epsilon, splitter, resulterrbound, estimate, vec, sum} from './util.js';\n\nconst ccwerrboundA = (3 + 16 * epsilon) * epsilon;\nconst ccwerrboundB = (2 + 12 * epsilon) * epsilon;\nconst ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\nconst B = vec(4);\nconst C1 = vec(8);\nconst C2 = vec(12);\nconst D = vec(16);\nconst u = vec(4);\n\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n    }\n\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n\n    return D[Dlen - 1];\n}\n\nexport function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\nexport function orient2dfast(ax, ay, bx, by, cx, cy) {\n    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);\n}\n", "import {epsilon, splitter, resulterrbound, estimate, vec, sum, scale} from './util.js';\n\nconst o3derrboundA = (7 + 56 * epsilon) * epsilon;\nconst o3derrboundB = (3 + 28 * epsilon) * epsilon;\nconst o3derrboundC = (26 + 288 * epsilon) * epsilon * epsilon;\n\nconst bc = vec(4);\nconst ca = vec(4);\nconst ab = vec(4);\nconst at_b = vec(4);\nconst at_c = vec(4);\nconst bt_c = vec(4);\nconst bt_a = vec(4);\nconst ct_a = vec(4);\nconst ct_b = vec(4);\nconst bct = vec(8);\nconst cat = vec(8);\nconst abt = vec(8);\nconst u = vec(4);\n\nconst _8 = vec(8);\nconst _8b = vec(8);\nconst _16 = vec(8);\nconst _12 = vec(12);\n\nlet fin = vec(192);\nlet fin2 = vec(192);\n\nfunction finadd(finlen, alen, a) {\n    finlen = sum(finlen, fin, alen, a, fin2);\n    const tmp = fin; fin = fin2; fin2 = tmp;\n    return finlen;\n}\n\nfunction tailinit(xtail, ytail, ax, ay, bx, by, a, b) {\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _k, _0, s1, s0, t1, t0, u3, negate;\n    if (xtail === 0) {\n        if (ytail === 0) {\n            a[0] = 0;\n            b[0] = 0;\n            return 1;\n        } else {\n            negate = -ytail;\n            s1 = negate * ax;\n            c = splitter * negate;\n            ahi = c - (c - negate);\n            alo = negate - ahi;\n            c = splitter * ax;\n            bhi = c - (c - ax);\n            blo = ax - bhi;\n            a[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            a[1] = s1;\n            s1 = ytail * bx;\n            c = splitter * ytail;\n            ahi = c - (c - ytail);\n            alo = ytail - ahi;\n            c = splitter * bx;\n            bhi = c - (c - bx);\n            blo = bx - bhi;\n            b[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            b[1] = s1;\n            return 2;\n        }\n    } else {\n        if (ytail === 0) {\n            s1 = xtail * ay;\n            c = splitter * xtail;\n            ahi = c - (c - xtail);\n            alo = xtail - ahi;\n            c = splitter * ay;\n            bhi = c - (c - ay);\n            blo = ay - bhi;\n            a[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            a[1] = s1;\n            negate = -xtail;\n            s1 = negate * by;\n            c = splitter * negate;\n            ahi = c - (c - negate);\n            alo = negate - ahi;\n            c = splitter * by;\n            bhi = c - (c - by);\n            blo = by - bhi;\n            b[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            b[1] = s1;\n            return 2;\n        } else {\n            s1 = xtail * ay;\n            c = splitter * xtail;\n            ahi = c - (c - xtail);\n            alo = xtail - ahi;\n            c = splitter * ay;\n            bhi = c - (c - ay);\n            blo = ay - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = ytail * ax;\n            c = splitter * ytail;\n            ahi = c - (c - ytail);\n            alo = ytail - ahi;\n            c = splitter * ax;\n            bhi = c - (c - ax);\n            blo = ax - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 - t0;\n            bvirt = s0 - _i;\n            a[0] = s0 - (_i + bvirt) + (bvirt - t0);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 - t1;\n            bvirt = _0 - _i;\n            a[1] = _0 - (_i + bvirt) + (bvirt - t1);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            a[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            a[3] = u3;\n            s1 = ytail * bx;\n            c = splitter * ytail;\n            ahi = c - (c - ytail);\n            alo = ytail - ahi;\n            c = splitter * bx;\n            bhi = c - (c - bx);\n            blo = bx - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = xtail * by;\n            c = splitter * xtail;\n            ahi = c - (c - xtail);\n            alo = xtail - ahi;\n            c = splitter * by;\n            bhi = c - (c - by);\n            blo = by - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 - t0;\n            bvirt = s0 - _i;\n            b[0] = s0 - (_i + bvirt) + (bvirt - t0);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 - t1;\n            bvirt = _0 - _i;\n            b[1] = _0 - (_i + bvirt) + (bvirt - t1);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            b[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            b[3] = u3;\n            return 4;\n        }\n    }\n}\n\nfunction tailadd(finlen, a, b, k, z) {\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _k, _0, s1, s0, u3;\n    s1 = a * b;\n    c = splitter * a;\n    ahi = c - (c - a);\n    alo = a - ahi;\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    c = splitter * k;\n    bhi = c - (c - k);\n    blo = k - bhi;\n    _i = s0 * k;\n    c = splitter * s0;\n    ahi = c - (c - s0);\n    alo = s0 - ahi;\n    u[0] = alo * blo - (_i - ahi * bhi - alo * bhi - ahi * blo);\n    _j = s1 * k;\n    c = splitter * s1;\n    ahi = c - (c - s1);\n    alo = s1 - ahi;\n    _0 = alo * blo - (_j - ahi * bhi - alo * bhi - ahi * blo);\n    _k = _i + _0;\n    bvirt = _k - _i;\n    u[1] = _i - (_k - bvirt) + (_0 - bvirt);\n    u3 = _j + _k;\n    u[2] = _k - (u3 - _j);\n    u[3] = u3;\n    finlen = finadd(finlen, 4, u);\n    if (z !== 0) {\n        c = splitter * z;\n        bhi = c - (c - z);\n        blo = z - bhi;\n        _i = s0 * z;\n        c = splitter * s0;\n        ahi = c - (c - s0);\n        alo = s0 - ahi;\n        u[0] = alo * blo - (_i - ahi * bhi - alo * bhi - ahi * blo);\n        _j = s1 * z;\n        c = splitter * s1;\n        ahi = c - (c - s1);\n        alo = s1 - ahi;\n        _0 = alo * blo - (_j - ahi * bhi - alo * bhi - ahi * blo);\n        _k = _i + _0;\n        bvirt = _k - _i;\n        u[1] = _i - (_k - bvirt) + (_0 - bvirt);\n        u3 = _j + _k;\n        u[2] = _k - (u3 - _j);\n        u[3] = u3;\n        finlen = finadd(finlen, 4, u);\n    }\n    return finlen;\n}\n\nfunction orient3dadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, permanent) {\n    let finlen;\n    let adxtail, bdxtail, cdxtail;\n    let adytail, bdytail, cdytail;\n    let adztail, bdztail, cdztail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _k, _0, s1, s0, t1, t0, u3;\n\n    const adx = ax - dx;\n    const bdx = bx - dx;\n    const cdx = cx - dx;\n    const ady = ay - dy;\n    const bdy = by - dy;\n    const cdy = cy - dy;\n    const adz = az - dz;\n    const bdz = bz - dz;\n    const cdz = cz - dz;\n\n    s1 = bdx * cdy;\n    c = splitter * bdx;\n    ahi = c - (c - bdx);\n    alo = bdx - ahi;\n    c = splitter * cdy;\n    bhi = c - (c - cdy);\n    blo = cdy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = cdx * bdy;\n    c = splitter * cdx;\n    ahi = c - (c - cdx);\n    alo = cdx - ahi;\n    c = splitter * bdy;\n    bhi = c - (c - bdy);\n    blo = bdy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    bc[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    bc[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    bc[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    bc[3] = u3;\n    s1 = cdx * ady;\n    c = splitter * cdx;\n    ahi = c - (c - cdx);\n    alo = cdx - ahi;\n    c = splitter * ady;\n    bhi = c - (c - ady);\n    blo = ady - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = adx * cdy;\n    c = splitter * adx;\n    ahi = c - (c - adx);\n    alo = adx - ahi;\n    c = splitter * cdy;\n    bhi = c - (c - cdy);\n    blo = cdy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ca[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ca[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ca[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ca[3] = u3;\n    s1 = adx * bdy;\n    c = splitter * adx;\n    ahi = c - (c - adx);\n    alo = adx - ahi;\n    c = splitter * bdy;\n    bhi = c - (c - bdy);\n    blo = bdy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = bdx * ady;\n    c = splitter * bdx;\n    ahi = c - (c - bdx);\n    alo = bdx - ahi;\n    c = splitter * ady;\n    bhi = c - (c - ady);\n    blo = ady - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ab[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ab[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ab[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ab[3] = u3;\n\n    finlen = sum(\n        sum(\n            scale(4, bc, adz, _8), _8,\n            scale(4, ca, bdz, _8b), _8b, _16), _16,\n        scale(4, ab, cdz, _8), _8, fin);\n\n    let det = estimate(finlen, fin);\n    let errbound = o3derrboundB * permanent;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - adx;\n    adxtail = ax - (adx + bvirt) + (bvirt - dx);\n    bvirt = bx - bdx;\n    bdxtail = bx - (bdx + bvirt) + (bvirt - dx);\n    bvirt = cx - cdx;\n    cdxtail = cx - (cdx + bvirt) + (bvirt - dx);\n    bvirt = ay - ady;\n    adytail = ay - (ady + bvirt) + (bvirt - dy);\n    bvirt = by - bdy;\n    bdytail = by - (bdy + bvirt) + (bvirt - dy);\n    bvirt = cy - cdy;\n    cdytail = cy - (cdy + bvirt) + (bvirt - dy);\n    bvirt = az - adz;\n    adztail = az - (adz + bvirt) + (bvirt - dz);\n    bvirt = bz - bdz;\n    bdztail = bz - (bdz + bvirt) + (bvirt - dz);\n    bvirt = cz - cdz;\n    cdztail = cz - (cdz + bvirt) + (bvirt - dz);\n\n    if (adxtail === 0 && bdxtail === 0 && cdxtail === 0 &&\n        adytail === 0 && bdytail === 0 && cdytail === 0 &&\n        adztail === 0 && bdztail === 0 && cdztail === 0) {\n        return det;\n    }\n\n    errbound = o3derrboundC * permanent + resulterrbound * Math.abs(det);\n    det +=\n        adz * (bdx * cdytail + cdy * bdxtail - (bdy * cdxtail + cdx * bdytail)) + adztail * (bdx * cdy - bdy * cdx) +\n        bdz * (cdx * adytail + ady * cdxtail - (cdy * adxtail + adx * cdytail)) + bdztail * (cdx * ady - cdy * adx) +\n        cdz * (adx * bdytail + bdy * adxtail - (ady * bdxtail + bdx * adytail)) + cdztail * (adx * bdy - ady * bdx);\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    const at_len = tailinit(adxtail, adytail, bdx, bdy, cdx, cdy, at_b, at_c);\n    const bt_len = tailinit(bdxtail, bdytail, cdx, cdy, adx, ady, bt_c, bt_a);\n    const ct_len = tailinit(cdxtail, cdytail, adx, ady, bdx, bdy, ct_a, ct_b);\n\n    const bctlen = sum(bt_len, bt_c, ct_len, ct_b, bct);\n    finlen = finadd(finlen, scale(bctlen, bct, adz, _16), _16);\n\n    const catlen = sum(ct_len, ct_a, at_len, at_c, cat);\n    finlen = finadd(finlen, scale(catlen, cat, bdz, _16), _16);\n\n    const abtlen = sum(at_len, at_b, bt_len, bt_a, abt);\n    finlen = finadd(finlen, scale(abtlen, abt, cdz, _16), _16);\n\n    if (adztail !== 0) {\n        finlen = finadd(finlen, scale(4, bc, adztail, _12), _12);\n        finlen = finadd(finlen, scale(bctlen, bct, adztail, _16), _16);\n    }\n    if (bdztail !== 0) {\n        finlen = finadd(finlen, scale(4, ca, bdztail, _12), _12);\n        finlen = finadd(finlen, scale(catlen, cat, bdztail, _16), _16);\n    }\n    if (cdztail !== 0) {\n        finlen = finadd(finlen, scale(4, ab, cdztail, _12), _12);\n        finlen = finadd(finlen, scale(abtlen, abt, cdztail, _16), _16);\n    }\n\n    if (adxtail !== 0) {\n        if (bdytail !== 0) {\n            finlen = tailadd(finlen, adxtail, bdytail, cdz, cdztail);\n        }\n        if (cdytail !== 0) {\n            finlen = tailadd(finlen, -adxtail, cdytail, bdz, bdztail);\n        }\n    }\n    if (bdxtail !== 0) {\n        if (cdytail !== 0) {\n            finlen = tailadd(finlen, bdxtail, cdytail, adz, adztail);\n        }\n        if (adytail !== 0) {\n            finlen = tailadd(finlen, -bdxtail, adytail, cdz, cdztail);\n        }\n    }\n    if (cdxtail !== 0) {\n        if (adytail !== 0) {\n            finlen = tailadd(finlen, cdxtail, adytail, bdz, bdztail);\n        }\n        if (bdytail !== 0) {\n            finlen = tailadd(finlen, -cdxtail, bdytail, adz, adztail);\n        }\n    }\n\n    return fin[finlen - 1];\n}\n\nexport function orient3d(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz) {\n    const adx = ax - dx;\n    const bdx = bx - dx;\n    const cdx = cx - dx;\n    const ady = ay - dy;\n    const bdy = by - dy;\n    const cdy = cy - dy;\n    const adz = az - dz;\n    const bdz = bz - dz;\n    const cdz = cz - dz;\n\n    const bdxcdy = bdx * cdy;\n    const cdxbdy = cdx * bdy;\n\n    const cdxady = cdx * ady;\n    const adxcdy = adx * cdy;\n\n    const adxbdy = adx * bdy;\n    const bdxady = bdx * ady;\n\n    const det =\n        adz * (bdxcdy - cdxbdy) +\n        bdz * (cdxady - adxcdy) +\n        cdz * (adxbdy - bdxady);\n\n    const permanent =\n        (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz) +\n        (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz) +\n        (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz);\n\n    const errbound = o3derrboundA * permanent;\n    if (det > errbound || -det > errbound) {\n        return det;\n    }\n\n    return orient3dadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, permanent);\n}\n\nexport function orient3dfast(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz) {\n    const adx = ax - dx;\n    const bdx = bx - dx;\n    const cdx = cx - dx;\n    const ady = ay - dy;\n    const bdy = by - dy;\n    const cdy = cy - dy;\n    const adz = az - dz;\n    const bdz = bz - dz;\n    const cdz = cz - dz;\n\n    return adx * (bdy * cdz - bdz * cdy) +\n        bdx * (cdy * adz - cdz * ady) +\n        cdx * (ady * bdz - adz * bdy);\n}\n", "import {epsilon, splitter, resulterrbound, estimate, vec, sum, sum_three, scale} from './util.js';\n\nconst iccerrboundA = (10 + 96 * epsilon) * epsilon;\nconst iccerrboundB = (4 + 48 * epsilon) * epsilon;\nconst iccerrboundC = (44 + 576 * epsilon) * epsilon * epsilon;\n\nconst bc = vec(4);\nconst ca = vec(4);\nconst ab = vec(4);\nconst aa = vec(4);\nconst bb = vec(4);\nconst cc = vec(4);\nconst u = vec(4);\nconst v = vec(4);\nconst axtbc = vec(8);\nconst aytbc = vec(8);\nconst bxtca = vec(8);\nconst bytca = vec(8);\nconst cxtab = vec(8);\nconst cytab = vec(8);\nconst abt = vec(8);\nconst bct = vec(8);\nconst cat = vec(8);\nconst abtt = vec(4);\nconst bctt = vec(4);\nconst catt = vec(4);\n\nconst _8 = vec(8);\nconst _16 = vec(16);\nconst _16b = vec(16);\nconst _16c = vec(16);\nconst _32 = vec(32);\nconst _32b = vec(32);\nconst _48 = vec(48);\nconst _64 = vec(64);\n\nlet fin = vec(1152);\nlet fin2 = vec(1152);\n\nfunction finadd(finlen, a, alen) {\n    finlen = sum(finlen, fin, a, alen, fin2);\n    const tmp = fin; fin = fin2; fin2 = tmp;\n    return finlen;\n}\n\nfunction incircleadapt(ax, ay, bx, by, cx, cy, dx, dy, permanent) {\n    let finlen;\n    let adxtail, bdxtail, cdxtail, adytail, bdytail, cdytail;\n    let axtbclen, aytbclen, bxtcalen, bytcalen, cxtablen, cytablen;\n    let abtlen, bctlen, catlen;\n    let abttlen, bcttlen, cattlen;\n    let n1, n0;\n\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const adx = ax - dx;\n    const bdx = bx - dx;\n    const cdx = cx - dx;\n    const ady = ay - dy;\n    const bdy = by - dy;\n    const cdy = cy - dy;\n\n    s1 = bdx * cdy;\n    c = splitter * bdx;\n    ahi = c - (c - bdx);\n    alo = bdx - ahi;\n    c = splitter * cdy;\n    bhi = c - (c - cdy);\n    blo = cdy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = cdx * bdy;\n    c = splitter * cdx;\n    ahi = c - (c - cdx);\n    alo = cdx - ahi;\n    c = splitter * bdy;\n    bhi = c - (c - bdy);\n    blo = bdy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    bc[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    bc[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    bc[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    bc[3] = u3;\n    s1 = cdx * ady;\n    c = splitter * cdx;\n    ahi = c - (c - cdx);\n    alo = cdx - ahi;\n    c = splitter * ady;\n    bhi = c - (c - ady);\n    blo = ady - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = adx * cdy;\n    c = splitter * adx;\n    ahi = c - (c - adx);\n    alo = adx - ahi;\n    c = splitter * cdy;\n    bhi = c - (c - cdy);\n    blo = cdy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ca[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ca[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ca[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ca[3] = u3;\n    s1 = adx * bdy;\n    c = splitter * adx;\n    ahi = c - (c - adx);\n    alo = adx - ahi;\n    c = splitter * bdy;\n    bhi = c - (c - bdy);\n    blo = bdy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = bdx * ady;\n    c = splitter * bdx;\n    ahi = c - (c - bdx);\n    alo = bdx - ahi;\n    c = splitter * ady;\n    bhi = c - (c - ady);\n    blo = ady - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ab[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ab[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ab[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ab[3] = u3;\n\n    finlen = sum(\n        sum(\n            sum(\n                scale(scale(4, bc, adx, _8), _8, adx, _16), _16,\n                scale(scale(4, bc, ady, _8), _8, ady, _16b), _16b, _32), _32,\n            sum(\n                scale(scale(4, ca, bdx, _8), _8, bdx, _16), _16,\n                scale(scale(4, ca, bdy, _8), _8, bdy, _16b), _16b, _32b), _32b, _64), _64,\n        sum(\n            scale(scale(4, ab, cdx, _8), _8, cdx, _16), _16,\n            scale(scale(4, ab, cdy, _8), _8, cdy, _16b), _16b, _32), _32, fin);\n\n    let det = estimate(finlen, fin);\n    let errbound = iccerrboundB * permanent;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - adx;\n    adxtail = ax - (adx + bvirt) + (bvirt - dx);\n    bvirt = ay - ady;\n    adytail = ay - (ady + bvirt) + (bvirt - dy);\n    bvirt = bx - bdx;\n    bdxtail = bx - (bdx + bvirt) + (bvirt - dx);\n    bvirt = by - bdy;\n    bdytail = by - (bdy + bvirt) + (bvirt - dy);\n    bvirt = cx - cdx;\n    cdxtail = cx - (cdx + bvirt) + (bvirt - dx);\n    bvirt = cy - cdy;\n    cdytail = cy - (cdy + bvirt) + (bvirt - dy);\n    if (adxtail === 0 && bdxtail === 0 && cdxtail === 0 && adytail === 0 && bdytail === 0 && cdytail === 0) {\n        return det;\n    }\n\n    errbound = iccerrboundC * permanent + resulterrbound * Math.abs(det);\n    det += ((adx * adx + ady * ady) * ((bdx * cdytail + cdy * bdxtail) - (bdy * cdxtail + cdx * bdytail)) +\n        2 * (adx * adxtail + ady * adytail) * (bdx * cdy - bdy * cdx)) +\n        ((bdx * bdx + bdy * bdy) * ((cdx * adytail + ady * cdxtail) - (cdy * adxtail + adx * cdytail)) +\n        2 * (bdx * bdxtail + bdy * bdytail) * (cdx * ady - cdy * adx)) +\n        ((cdx * cdx + cdy * cdy) * ((adx * bdytail + bdy * adxtail) - (ady * bdxtail + bdx * adytail)) +\n        2 * (cdx * cdxtail + cdy * cdytail) * (adx * bdy - ady * bdx));\n\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    if (bdxtail !== 0 || bdytail !== 0 || cdxtail !== 0 || cdytail !== 0) {\n        s1 = adx * adx;\n        c = splitter * adx;\n        ahi = c - (c - adx);\n        alo = adx - ahi;\n        s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);\n        t1 = ady * ady;\n        c = splitter * ady;\n        ahi = c - (c - ady);\n        alo = ady - ahi;\n        t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);\n        _i = s0 + t0;\n        bvirt = _i - s0;\n        aa[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n        _j = s1 + _i;\n        bvirt = _j - s1;\n        _0 = s1 - (_j - bvirt) + (_i - bvirt);\n        _i = _0 + t1;\n        bvirt = _i - _0;\n        aa[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n        u3 = _j + _i;\n        bvirt = u3 - _j;\n        aa[2] = _j - (u3 - bvirt) + (_i - bvirt);\n        aa[3] = u3;\n    }\n    if (cdxtail !== 0 || cdytail !== 0 || adxtail !== 0 || adytail !== 0) {\n        s1 = bdx * bdx;\n        c = splitter * bdx;\n        ahi = c - (c - bdx);\n        alo = bdx - ahi;\n        s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);\n        t1 = bdy * bdy;\n        c = splitter * bdy;\n        ahi = c - (c - bdy);\n        alo = bdy - ahi;\n        t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);\n        _i = s0 + t0;\n        bvirt = _i - s0;\n        bb[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n        _j = s1 + _i;\n        bvirt = _j - s1;\n        _0 = s1 - (_j - bvirt) + (_i - bvirt);\n        _i = _0 + t1;\n        bvirt = _i - _0;\n        bb[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n        u3 = _j + _i;\n        bvirt = u3 - _j;\n        bb[2] = _j - (u3 - bvirt) + (_i - bvirt);\n        bb[3] = u3;\n    }\n    if (adxtail !== 0 || adytail !== 0 || bdxtail !== 0 || bdytail !== 0) {\n        s1 = cdx * cdx;\n        c = splitter * cdx;\n        ahi = c - (c - cdx);\n        alo = cdx - ahi;\n        s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);\n        t1 = cdy * cdy;\n        c = splitter * cdy;\n        ahi = c - (c - cdy);\n        alo = cdy - ahi;\n        t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);\n        _i = s0 + t0;\n        bvirt = _i - s0;\n        cc[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n        _j = s1 + _i;\n        bvirt = _j - s1;\n        _0 = s1 - (_j - bvirt) + (_i - bvirt);\n        _i = _0 + t1;\n        bvirt = _i - _0;\n        cc[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n        u3 = _j + _i;\n        bvirt = u3 - _j;\n        cc[2] = _j - (u3 - bvirt) + (_i - bvirt);\n        cc[3] = u3;\n    }\n\n    if (adxtail !== 0) {\n        axtbclen = scale(4, bc, adxtail, axtbc);\n        finlen = finadd(finlen, sum_three(\n            scale(axtbclen, axtbc, 2 * adx, _16), _16,\n            scale(scale(4, cc, adxtail, _8), _8, bdy, _16b), _16b,\n            scale(scale(4, bb, adxtail, _8), _8, -cdy, _16c), _16c, _32, _48), _48);\n    }\n    if (adytail !== 0) {\n        aytbclen = scale(4, bc, adytail, aytbc);\n        finlen = finadd(finlen, sum_three(\n            scale(aytbclen, aytbc, 2 * ady, _16), _16,\n            scale(scale(4, bb, adytail, _8), _8, cdx, _16b), _16b,\n            scale(scale(4, cc, adytail, _8), _8, -bdx, _16c), _16c, _32, _48), _48);\n    }\n    if (bdxtail !== 0) {\n        bxtcalen = scale(4, ca, bdxtail, bxtca);\n        finlen = finadd(finlen, sum_three(\n            scale(bxtcalen, bxtca, 2 * bdx, _16), _16,\n            scale(scale(4, aa, bdxtail, _8), _8, cdy, _16b), _16b,\n            scale(scale(4, cc, bdxtail, _8), _8, -ady, _16c), _16c, _32, _48), _48);\n    }\n    if (bdytail !== 0) {\n        bytcalen = scale(4, ca, bdytail, bytca);\n        finlen = finadd(finlen, sum_three(\n            scale(bytcalen, bytca, 2 * bdy, _16), _16,\n            scale(scale(4, cc, bdytail, _8), _8, adx, _16b), _16b,\n            scale(scale(4, aa, bdytail, _8), _8, -cdx, _16c), _16c, _32, _48), _48);\n    }\n    if (cdxtail !== 0) {\n        cxtablen = scale(4, ab, cdxtail, cxtab);\n        finlen = finadd(finlen, sum_three(\n            scale(cxtablen, cxtab, 2 * cdx, _16), _16,\n            scale(scale(4, bb, cdxtail, _8), _8, ady, _16b), _16b,\n            scale(scale(4, aa, cdxtail, _8), _8, -bdy, _16c), _16c, _32, _48), _48);\n    }\n    if (cdytail !== 0) {\n        cytablen = scale(4, ab, cdytail, cytab);\n        finlen = finadd(finlen, sum_three(\n            scale(cytablen, cytab, 2 * cdy, _16), _16,\n            scale(scale(4, aa, cdytail, _8), _8, bdx, _16b), _16b,\n            scale(scale(4, bb, cdytail, _8), _8, -adx, _16c), _16c, _32, _48), _48);\n    }\n\n    if (adxtail !== 0 || adytail !== 0) {\n        if (bdxtail !== 0 || bdytail !== 0 || cdxtail !== 0 || cdytail !== 0) {\n            s1 = bdxtail * cdy;\n            c = splitter * bdxtail;\n            ahi = c - (c - bdxtail);\n            alo = bdxtail - ahi;\n            c = splitter * cdy;\n            bhi = c - (c - cdy);\n            blo = cdy - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = bdx * cdytail;\n            c = splitter * bdx;\n            ahi = c - (c - bdx);\n            alo = bdx - ahi;\n            c = splitter * cdytail;\n            bhi = c - (c - cdytail);\n            blo = cdytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 + t0;\n            bvirt = _i - s0;\n            u[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 + t1;\n            bvirt = _i - _0;\n            u[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            u[3] = u3;\n            s1 = cdxtail * -bdy;\n            c = splitter * cdxtail;\n            ahi = c - (c - cdxtail);\n            alo = cdxtail - ahi;\n            c = splitter * -bdy;\n            bhi = c - (c - -bdy);\n            blo = -bdy - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = cdx * -bdytail;\n            c = splitter * cdx;\n            ahi = c - (c - cdx);\n            alo = cdx - ahi;\n            c = splitter * -bdytail;\n            bhi = c - (c - -bdytail);\n            blo = -bdytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 + t0;\n            bvirt = _i - s0;\n            v[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 + t1;\n            bvirt = _i - _0;\n            v[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            v[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            v[3] = u3;\n            bctlen = sum(4, u, 4, v, bct);\n            s1 = bdxtail * cdytail;\n            c = splitter * bdxtail;\n            ahi = c - (c - bdxtail);\n            alo = bdxtail - ahi;\n            c = splitter * cdytail;\n            bhi = c - (c - cdytail);\n            blo = cdytail - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = cdxtail * bdytail;\n            c = splitter * cdxtail;\n            ahi = c - (c - cdxtail);\n            alo = cdxtail - ahi;\n            c = splitter * bdytail;\n            bhi = c - (c - bdytail);\n            blo = bdytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 - t0;\n            bvirt = s0 - _i;\n            bctt[0] = s0 - (_i + bvirt) + (bvirt - t0);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 - t1;\n            bvirt = _0 - _i;\n            bctt[1] = _0 - (_i + bvirt) + (bvirt - t1);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            bctt[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            bctt[3] = u3;\n            bcttlen = 4;\n        } else {\n            bct[0] = 0;\n            bctlen = 1;\n            bctt[0] = 0;\n            bcttlen = 1;\n        }\n        if (adxtail !== 0) {\n            const len = scale(bctlen, bct, adxtail, _16c);\n            finlen = finadd(finlen, sum(\n                scale(axtbclen, axtbc, adxtail, _16), _16,\n                scale(len, _16c, 2 * adx, _32), _32, _48), _48);\n\n            const len2 = scale(bcttlen, bctt, adxtail, _8);\n            finlen = finadd(finlen, sum_three(\n                scale(len2, _8, 2 * adx, _16), _16,\n                scale(len2, _8, adxtail, _16b), _16b,\n                scale(len, _16c, adxtail, _32), _32, _32b, _64), _64);\n\n            if (bdytail !== 0) {\n                finlen = finadd(finlen, scale(scale(4, cc, adxtail, _8), _8, bdytail, _16), _16);\n            }\n            if (cdytail !== 0) {\n                finlen = finadd(finlen, scale(scale(4, bb, -adxtail, _8), _8, cdytail, _16), _16);\n            }\n        }\n        if (adytail !== 0) {\n            const len = scale(bctlen, bct, adytail, _16c);\n            finlen = finadd(finlen, sum(\n                scale(aytbclen, aytbc, adytail, _16), _16,\n                scale(len, _16c, 2 * ady, _32), _32, _48), _48);\n\n            const len2 = scale(bcttlen, bctt, adytail, _8);\n            finlen = finadd(finlen, sum_three(\n                scale(len2, _8, 2 * ady, _16), _16,\n                scale(len2, _8, adytail, _16b), _16b,\n                scale(len, _16c, adytail, _32), _32, _32b, _64), _64);\n        }\n    }\n    if (bdxtail !== 0 || bdytail !== 0) {\n        if (cdxtail !== 0 || cdytail !== 0 || adxtail !== 0 || adytail !== 0) {\n            s1 = cdxtail * ady;\n            c = splitter * cdxtail;\n            ahi = c - (c - cdxtail);\n            alo = cdxtail - ahi;\n            c = splitter * ady;\n            bhi = c - (c - ady);\n            blo = ady - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = cdx * adytail;\n            c = splitter * cdx;\n            ahi = c - (c - cdx);\n            alo = cdx - ahi;\n            c = splitter * adytail;\n            bhi = c - (c - adytail);\n            blo = adytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 + t0;\n            bvirt = _i - s0;\n            u[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 + t1;\n            bvirt = _i - _0;\n            u[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            u[3] = u3;\n            n1 = -cdy;\n            n0 = -cdytail;\n            s1 = adxtail * n1;\n            c = splitter * adxtail;\n            ahi = c - (c - adxtail);\n            alo = adxtail - ahi;\n            c = splitter * n1;\n            bhi = c - (c - n1);\n            blo = n1 - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = adx * n0;\n            c = splitter * adx;\n            ahi = c - (c - adx);\n            alo = adx - ahi;\n            c = splitter * n0;\n            bhi = c - (c - n0);\n            blo = n0 - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 + t0;\n            bvirt = _i - s0;\n            v[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 + t1;\n            bvirt = _i - _0;\n            v[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            v[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            v[3] = u3;\n            catlen = sum(4, u, 4, v, cat);\n            s1 = cdxtail * adytail;\n            c = splitter * cdxtail;\n            ahi = c - (c - cdxtail);\n            alo = cdxtail - ahi;\n            c = splitter * adytail;\n            bhi = c - (c - adytail);\n            blo = adytail - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = adxtail * cdytail;\n            c = splitter * adxtail;\n            ahi = c - (c - adxtail);\n            alo = adxtail - ahi;\n            c = splitter * cdytail;\n            bhi = c - (c - cdytail);\n            blo = cdytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 - t0;\n            bvirt = s0 - _i;\n            catt[0] = s0 - (_i + bvirt) + (bvirt - t0);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 - t1;\n            bvirt = _0 - _i;\n            catt[1] = _0 - (_i + bvirt) + (bvirt - t1);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            catt[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            catt[3] = u3;\n            cattlen = 4;\n        } else {\n            cat[0] = 0;\n            catlen = 1;\n            catt[0] = 0;\n            cattlen = 1;\n        }\n        if (bdxtail !== 0) {\n            const len = scale(catlen, cat, bdxtail, _16c);\n            finlen = finadd(finlen, sum(\n                scale(bxtcalen, bxtca, bdxtail, _16), _16,\n                scale(len, _16c, 2 * bdx, _32), _32, _48), _48);\n\n            const len2 = scale(cattlen, catt, bdxtail, _8);\n            finlen = finadd(finlen, sum_three(\n                scale(len2, _8, 2 * bdx, _16), _16,\n                scale(len2, _8, bdxtail, _16b), _16b,\n                scale(len, _16c, bdxtail, _32), _32, _32b, _64), _64);\n\n            if (cdytail !== 0) {\n                finlen = finadd(finlen, scale(scale(4, aa, bdxtail, _8), _8, cdytail, _16), _16);\n            }\n            if (adytail !== 0) {\n                finlen = finadd(finlen, scale(scale(4, cc, -bdxtail, _8), _8, adytail, _16), _16);\n            }\n        }\n        if (bdytail !== 0) {\n            const len = scale(catlen, cat, bdytail, _16c);\n            finlen = finadd(finlen, sum(\n                scale(bytcalen, bytca, bdytail, _16), _16,\n                scale(len, _16c, 2 * bdy, _32), _32, _48), _48);\n\n            const len2 = scale(cattlen, catt, bdytail, _8);\n            finlen = finadd(finlen, sum_three(\n                scale(len2, _8, 2 * bdy, _16), _16,\n                scale(len2, _8, bdytail, _16b), _16b,\n                scale(len, _16c, bdytail, _32), _32,  _32b, _64), _64);\n        }\n    }\n    if (cdxtail !== 0 || cdytail !== 0) {\n        if (adxtail !== 0 || adytail !== 0 || bdxtail !== 0 || bdytail !== 0) {\n            s1 = adxtail * bdy;\n            c = splitter * adxtail;\n            ahi = c - (c - adxtail);\n            alo = adxtail - ahi;\n            c = splitter * bdy;\n            bhi = c - (c - bdy);\n            blo = bdy - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = adx * bdytail;\n            c = splitter * adx;\n            ahi = c - (c - adx);\n            alo = adx - ahi;\n            c = splitter * bdytail;\n            bhi = c - (c - bdytail);\n            blo = bdytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 + t0;\n            bvirt = _i - s0;\n            u[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 + t1;\n            bvirt = _i - _0;\n            u[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            u[3] = u3;\n            n1 = -ady;\n            n0 = -adytail;\n            s1 = bdxtail * n1;\n            c = splitter * bdxtail;\n            ahi = c - (c - bdxtail);\n            alo = bdxtail - ahi;\n            c = splitter * n1;\n            bhi = c - (c - n1);\n            blo = n1 - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = bdx * n0;\n            c = splitter * bdx;\n            ahi = c - (c - bdx);\n            alo = bdx - ahi;\n            c = splitter * n0;\n            bhi = c - (c - n0);\n            blo = n0 - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 + t0;\n            bvirt = _i - s0;\n            v[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 + t1;\n            bvirt = _i - _0;\n            v[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            v[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            v[3] = u3;\n            abtlen = sum(4, u, 4, v, abt);\n            s1 = adxtail * bdytail;\n            c = splitter * adxtail;\n            ahi = c - (c - adxtail);\n            alo = adxtail - ahi;\n            c = splitter * bdytail;\n            bhi = c - (c - bdytail);\n            blo = bdytail - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = bdxtail * adytail;\n            c = splitter * bdxtail;\n            ahi = c - (c - bdxtail);\n            alo = bdxtail - ahi;\n            c = splitter * adytail;\n            bhi = c - (c - adytail);\n            blo = adytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 - t0;\n            bvirt = s0 - _i;\n            abtt[0] = s0 - (_i + bvirt) + (bvirt - t0);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 - t1;\n            bvirt = _0 - _i;\n            abtt[1] = _0 - (_i + bvirt) + (bvirt - t1);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            abtt[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            abtt[3] = u3;\n            abttlen = 4;\n        } else {\n            abt[0] = 0;\n            abtlen = 1;\n            abtt[0] = 0;\n            abttlen = 1;\n        }\n        if (cdxtail !== 0) {\n            const len = scale(abtlen, abt, cdxtail, _16c);\n            finlen = finadd(finlen, sum(\n                scale(cxtablen, cxtab, cdxtail, _16), _16,\n                scale(len, _16c, 2 * cdx, _32), _32, _48), _48);\n\n            const len2 = scale(abttlen, abtt, cdxtail, _8);\n            finlen = finadd(finlen, sum_three(\n                scale(len2, _8, 2 * cdx, _16), _16,\n                scale(len2, _8, cdxtail, _16b), _16b,\n                scale(len, _16c, cdxtail, _32), _32, _32b, _64), _64);\n\n            if (adytail !== 0) {\n                finlen = finadd(finlen, scale(scale(4, bb, cdxtail, _8), _8, adytail, _16), _16);\n            }\n            if (bdytail !== 0) {\n                finlen = finadd(finlen, scale(scale(4, aa, -cdxtail, _8), _8, bdytail, _16), _16);\n            }\n        }\n        if (cdytail !== 0) {\n            const len = scale(abtlen, abt, cdytail, _16c);\n            finlen = finadd(finlen, sum(\n                scale(cytablen, cytab, cdytail, _16), _16,\n                scale(len, _16c, 2 * cdy, _32), _32, _48), _48);\n\n            const len2 = scale(abttlen, abtt, cdytail, _8);\n            finlen = finadd(finlen, sum_three(\n                scale(len2, _8, 2 * cdy, _16), _16,\n                scale(len2, _8, cdytail, _16b), _16b,\n                scale(len, _16c, cdytail, _32), _32, _32b, _64), _64);\n        }\n    }\n\n    return fin[finlen - 1];\n}\n\nexport function incircle(ax, ay, bx, by, cx, cy, dx, dy) {\n    const adx = ax - dx;\n    const bdx = bx - dx;\n    const cdx = cx - dx;\n    const ady = ay - dy;\n    const bdy = by - dy;\n    const cdy = cy - dy;\n\n    const bdxcdy = bdx * cdy;\n    const cdxbdy = cdx * bdy;\n    const alift = adx * adx + ady * ady;\n\n    const cdxady = cdx * ady;\n    const adxcdy = adx * cdy;\n    const blift = bdx * bdx + bdy * bdy;\n\n    const adxbdy = adx * bdy;\n    const bdxady = bdx * ady;\n    const clift = cdx * cdx + cdy * cdy;\n\n    const det =\n        alift * (bdxcdy - cdxbdy) +\n        blift * (cdxady - adxcdy) +\n        clift * (adxbdy - bdxady);\n\n    const permanent =\n        (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * alift +\n        (Math.abs(cdxady) + Math.abs(adxcdy)) * blift +\n        (Math.abs(adxbdy) + Math.abs(bdxady)) * clift;\n\n    const errbound = iccerrboundA * permanent;\n\n    if (det > errbound || -det > errbound) {\n        return det;\n    }\n    return incircleadapt(ax, ay, bx, by, cx, cy, dx, dy, permanent);\n}\n\nexport function incirclefast(ax, ay, bx, by, cx, cy, dx, dy) {\n    const adx = ax - dx;\n    const ady = ay - dy;\n    const bdx = bx - dx;\n    const bdy = by - dy;\n    const cdx = cx - dx;\n    const cdy = cy - dy;\n\n    const abdet = adx * bdy - bdx * ady;\n    const bcdet = bdx * cdy - cdx * bdy;\n    const cadet = cdx * ady - adx * cdy;\n    const alift = adx * adx + ady * ady;\n    const blift = bdx * bdx + bdy * bdy;\n    const clift = cdx * cdx + cdy * cdy;\n\n    return alift * bcdet + blift * cadet + clift * abdet;\n}\n", "import {epsilon, splitter, resulterrbound, estimate, vec, sum, sum_three, scale, negate} from './util.js';\n\nconst isperrboundA = (16 + 224 * epsilon) * epsilon;\nconst isperrboundB = (5 + 72 * epsilon) * epsilon;\nconst isperrboundC = (71 + 1408 * epsilon) * epsilon * epsilon;\n\nconst ab = vec(4);\nconst bc = vec(4);\nconst cd = vec(4);\nconst de = vec(4);\nconst ea = vec(4);\nconst ac = vec(4);\nconst bd = vec(4);\nconst ce = vec(4);\nconst da = vec(4);\nconst eb = vec(4);\n\nconst abc = vec(24);\nconst bcd = vec(24);\nconst cde = vec(24);\nconst dea = vec(24);\nconst eab = vec(24);\nconst abd = vec(24);\nconst bce = vec(24);\nconst cda = vec(24);\nconst deb = vec(24);\nconst eac = vec(24);\n\nconst adet = vec(1152);\nconst bdet = vec(1152);\nconst cdet = vec(1152);\nconst ddet = vec(1152);\nconst edet = vec(1152);\nconst abdet = vec(2304);\nconst cddet = vec(2304);\nconst cdedet = vec(3456);\nconst deter = vec(5760);\n\nconst _8 = vec(8);\nconst _8b = vec(8);\nconst _8c = vec(8);\nconst _16 = vec(16);\nconst _24 = vec(24);\nconst _48 = vec(48);\nconst _48b = vec(48);\nconst _96 = vec(96);\nconst _192 = vec(192);\nconst _384x = vec(384);\nconst _384y = vec(384);\nconst _384z = vec(384);\nconst _768 = vec(768);\n\nfunction sum_three_scale(a, b, c, az, bz, cz, out) {\n    return sum_three(\n        scale(4, a, az, _8), _8,\n        scale(4, b, bz, _8b), _8b,\n        scale(4, c, cz, _8c), _8c, _16, out);\n}\n\nfunction liftexact(alen, a, blen, b, clen, c, dlen, d, x, y, z, out) {\n    const len = sum(\n        sum(alen, a, blen, b, _48), _48,\n        negate(sum(clen, c, dlen, d, _48b), _48b), _48b, _96);\n\n    return sum_three(\n        scale(scale(len, _96, x, _192), _192, x, _384x), _384x,\n        scale(scale(len, _96, y, _192), _192, y, _384y), _384y,\n        scale(scale(len, _96, z, _192), _192, z, _384z), _384z, _768, out);\n}\n\nfunction insphereexact(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez) {\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    s1 = ax * by;\n    c = splitter * ax;\n    ahi = c - (c - ax);\n    alo = ax - ahi;\n    c = splitter * by;\n    bhi = c - (c - by);\n    blo = by - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = bx * ay;\n    c = splitter * bx;\n    ahi = c - (c - bx);\n    alo = bx - ahi;\n    c = splitter * ay;\n    bhi = c - (c - ay);\n    blo = ay - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ab[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ab[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ab[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ab[3] = u3;\n    s1 = bx * cy;\n    c = splitter * bx;\n    ahi = c - (c - bx);\n    alo = bx - ahi;\n    c = splitter * cy;\n    bhi = c - (c - cy);\n    blo = cy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = cx * by;\n    c = splitter * cx;\n    ahi = c - (c - cx);\n    alo = cx - ahi;\n    c = splitter * by;\n    bhi = c - (c - by);\n    blo = by - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    bc[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    bc[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    bc[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    bc[3] = u3;\n    s1 = cx * dy;\n    c = splitter * cx;\n    ahi = c - (c - cx);\n    alo = cx - ahi;\n    c = splitter * dy;\n    bhi = c - (c - dy);\n    blo = dy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = dx * cy;\n    c = splitter * dx;\n    ahi = c - (c - dx);\n    alo = dx - ahi;\n    c = splitter * cy;\n    bhi = c - (c - cy);\n    blo = cy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    cd[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    cd[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    cd[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    cd[3] = u3;\n    s1 = dx * ey;\n    c = splitter * dx;\n    ahi = c - (c - dx);\n    alo = dx - ahi;\n    c = splitter * ey;\n    bhi = c - (c - ey);\n    blo = ey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = ex * dy;\n    c = splitter * ex;\n    ahi = c - (c - ex);\n    alo = ex - ahi;\n    c = splitter * dy;\n    bhi = c - (c - dy);\n    blo = dy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    de[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    de[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    de[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    de[3] = u3;\n    s1 = ex * ay;\n    c = splitter * ex;\n    ahi = c - (c - ex);\n    alo = ex - ahi;\n    c = splitter * ay;\n    bhi = c - (c - ay);\n    blo = ay - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = ax * ey;\n    c = splitter * ax;\n    ahi = c - (c - ax);\n    alo = ax - ahi;\n    c = splitter * ey;\n    bhi = c - (c - ey);\n    blo = ey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ea[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ea[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ea[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ea[3] = u3;\n    s1 = ax * cy;\n    c = splitter * ax;\n    ahi = c - (c - ax);\n    alo = ax - ahi;\n    c = splitter * cy;\n    bhi = c - (c - cy);\n    blo = cy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = cx * ay;\n    c = splitter * cx;\n    ahi = c - (c - cx);\n    alo = cx - ahi;\n    c = splitter * ay;\n    bhi = c - (c - ay);\n    blo = ay - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ac[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ac[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ac[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ac[3] = u3;\n    s1 = bx * dy;\n    c = splitter * bx;\n    ahi = c - (c - bx);\n    alo = bx - ahi;\n    c = splitter * dy;\n    bhi = c - (c - dy);\n    blo = dy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = dx * by;\n    c = splitter * dx;\n    ahi = c - (c - dx);\n    alo = dx - ahi;\n    c = splitter * by;\n    bhi = c - (c - by);\n    blo = by - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    bd[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    bd[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    bd[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    bd[3] = u3;\n    s1 = cx * ey;\n    c = splitter * cx;\n    ahi = c - (c - cx);\n    alo = cx - ahi;\n    c = splitter * ey;\n    bhi = c - (c - ey);\n    blo = ey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = ex * cy;\n    c = splitter * ex;\n    ahi = c - (c - ex);\n    alo = ex - ahi;\n    c = splitter * cy;\n    bhi = c - (c - cy);\n    blo = cy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ce[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ce[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ce[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ce[3] = u3;\n    s1 = dx * ay;\n    c = splitter * dx;\n    ahi = c - (c - dx);\n    alo = dx - ahi;\n    c = splitter * ay;\n    bhi = c - (c - ay);\n    blo = ay - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = ax * dy;\n    c = splitter * ax;\n    ahi = c - (c - ax);\n    alo = ax - ahi;\n    c = splitter * dy;\n    bhi = c - (c - dy);\n    blo = dy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    da[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    da[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    da[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    da[3] = u3;\n    s1 = ex * by;\n    c = splitter * ex;\n    ahi = c - (c - ex);\n    alo = ex - ahi;\n    c = splitter * by;\n    bhi = c - (c - by);\n    blo = by - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = bx * ey;\n    c = splitter * bx;\n    ahi = c - (c - bx);\n    alo = bx - ahi;\n    c = splitter * ey;\n    bhi = c - (c - ey);\n    blo = ey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    eb[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    eb[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    eb[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    eb[3] = u3;\n\n    const abclen = sum_three_scale(ab, bc, ac, cz, az, -bz, abc);\n    const bcdlen = sum_three_scale(bc, cd, bd, dz, bz, -cz, bcd);\n    const cdelen = sum_three_scale(cd, de, ce, ez, cz, -dz, cde);\n    const dealen = sum_three_scale(de, ea, da, az, dz, -ez, dea);\n    const eablen = sum_three_scale(ea, ab, eb, bz, ez, -az, eab);\n    const abdlen = sum_three_scale(ab, bd, da, dz, az, bz, abd);\n    const bcelen = sum_three_scale(bc, ce, eb, ez, bz, cz, bce);\n    const cdalen = sum_three_scale(cd, da, ac, az, cz, dz, cda);\n    const deblen = sum_three_scale(de, eb, bd, bz, dz, ez, deb);\n    const eaclen = sum_three_scale(ea, ac, ce, cz, ez, az, eac);\n\n    const deterlen = sum_three(\n        liftexact(cdelen, cde, bcelen, bce, deblen, deb, bcdlen, bcd, ax, ay, az, adet), adet,\n        liftexact(dealen, dea, cdalen, cda, eaclen, eac, cdelen, cde, bx, by, bz, bdet), bdet,\n        sum_three(\n            liftexact(eablen, eab, deblen, deb, abdlen, abd, dealen, dea, cx, cy, cz, cdet), cdet,\n            liftexact(abclen, abc, eaclen, eac, bcelen, bce, eablen, eab, dx, dy, dz, ddet), ddet,\n            liftexact(bcdlen, bcd, abdlen, abd, cdalen, cda, abclen, abc, ex, ey, ez, edet), edet, cddet, cdedet), cdedet, abdet, deter);\n\n    return deter[deterlen - 1];\n}\n\nconst xdet = vec(96);\nconst ydet = vec(96);\nconst zdet = vec(96);\nconst fin = vec(1152);\n\nfunction liftadapt(a, b, c, az, bz, cz, x, y, z, out) {\n    const len = sum_three_scale(a, b, c, az, bz, cz, _24);\n    return sum_three(\n        scale(scale(len, _24, x, _48), _48, x, xdet), xdet,\n        scale(scale(len, _24, y, _48), _48, y, ydet), ydet,\n        scale(scale(len, _24, z, _48), _48, z, zdet), zdet, _192, out);\n}\n\nfunction insphereadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez, permanent) {\n    let ab3, bc3, cd3, da3, ac3, bd3;\n\n    let aextail, bextail, cextail, dextail;\n    let aeytail, beytail, ceytail, deytail;\n    let aeztail, beztail, ceztail, deztail;\n\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0;\n\n    const aex = ax - ex;\n    const bex = bx - ex;\n    const cex = cx - ex;\n    const dex = dx - ex;\n    const aey = ay - ey;\n    const bey = by - ey;\n    const cey = cy - ey;\n    const dey = dy - ey;\n    const aez = az - ez;\n    const bez = bz - ez;\n    const cez = cz - ez;\n    const dez = dz - ez;\n\n    s1 = aex * bey;\n    c = splitter * aex;\n    ahi = c - (c - aex);\n    alo = aex - ahi;\n    c = splitter * bey;\n    bhi = c - (c - bey);\n    blo = bey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = bex * aey;\n    c = splitter * bex;\n    ahi = c - (c - bex);\n    alo = bex - ahi;\n    c = splitter * aey;\n    bhi = c - (c - aey);\n    blo = aey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ab[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ab[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    ab3 = _j + _i;\n    bvirt = ab3 - _j;\n    ab[2] = _j - (ab3 - bvirt) + (_i - bvirt);\n    ab[3] = ab3;\n    s1 = bex * cey;\n    c = splitter * bex;\n    ahi = c - (c - bex);\n    alo = bex - ahi;\n    c = splitter * cey;\n    bhi = c - (c - cey);\n    blo = cey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = cex * bey;\n    c = splitter * cex;\n    ahi = c - (c - cex);\n    alo = cex - ahi;\n    c = splitter * bey;\n    bhi = c - (c - bey);\n    blo = bey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    bc[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    bc[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    bc3 = _j + _i;\n    bvirt = bc3 - _j;\n    bc[2] = _j - (bc3 - bvirt) + (_i - bvirt);\n    bc[3] = bc3;\n    s1 = cex * dey;\n    c = splitter * cex;\n    ahi = c - (c - cex);\n    alo = cex - ahi;\n    c = splitter * dey;\n    bhi = c - (c - dey);\n    blo = dey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = dex * cey;\n    c = splitter * dex;\n    ahi = c - (c - dex);\n    alo = dex - ahi;\n    c = splitter * cey;\n    bhi = c - (c - cey);\n    blo = cey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    cd[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    cd[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    cd3 = _j + _i;\n    bvirt = cd3 - _j;\n    cd[2] = _j - (cd3 - bvirt) + (_i - bvirt);\n    cd[3] = cd3;\n    s1 = dex * aey;\n    c = splitter * dex;\n    ahi = c - (c - dex);\n    alo = dex - ahi;\n    c = splitter * aey;\n    bhi = c - (c - aey);\n    blo = aey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = aex * dey;\n    c = splitter * aex;\n    ahi = c - (c - aex);\n    alo = aex - ahi;\n    c = splitter * dey;\n    bhi = c - (c - dey);\n    blo = dey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    da[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    da[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    da3 = _j + _i;\n    bvirt = da3 - _j;\n    da[2] = _j - (da3 - bvirt) + (_i - bvirt);\n    da[3] = da3;\n    s1 = aex * cey;\n    c = splitter * aex;\n    ahi = c - (c - aex);\n    alo = aex - ahi;\n    c = splitter * cey;\n    bhi = c - (c - cey);\n    blo = cey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = cex * aey;\n    c = splitter * cex;\n    ahi = c - (c - cex);\n    alo = cex - ahi;\n    c = splitter * aey;\n    bhi = c - (c - aey);\n    blo = aey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ac[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ac[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    ac3 = _j + _i;\n    bvirt = ac3 - _j;\n    ac[2] = _j - (ac3 - bvirt) + (_i - bvirt);\n    ac[3] = ac3;\n    s1 = bex * dey;\n    c = splitter * bex;\n    ahi = c - (c - bex);\n    alo = bex - ahi;\n    c = splitter * dey;\n    bhi = c - (c - dey);\n    blo = dey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = dex * bey;\n    c = splitter * dex;\n    ahi = c - (c - dex);\n    alo = dex - ahi;\n    c = splitter * bey;\n    bhi = c - (c - bey);\n    blo = bey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    bd[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    bd[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    bd3 = _j + _i;\n    bvirt = bd3 - _j;\n    bd[2] = _j - (bd3 - bvirt) + (_i - bvirt);\n    bd[3] = bd3;\n\n    const finlen = sum(\n        sum(\n            negate(liftadapt(bc, cd, bd, dez, bez, -cez, aex, aey, aez, adet), adet), adet,\n            liftadapt(cd, da, ac, aez, cez, dez, bex, bey, bez, bdet), bdet, abdet), abdet,\n        sum(\n            negate(liftadapt(da, ab, bd, bez, dez, aez, cex, cey, cez, cdet), cdet), cdet,\n            liftadapt(ab, bc, ac, cez, aez, -bez, dex, dey, dez, ddet), ddet, cddet), cddet, fin);\n\n    let det = estimate(finlen, fin);\n    let errbound = isperrboundB * permanent;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - aex;\n    aextail = ax - (aex + bvirt) + (bvirt - ex);\n    bvirt = ay - aey;\n    aeytail = ay - (aey + bvirt) + (bvirt - ey);\n    bvirt = az - aez;\n    aeztail = az - (aez + bvirt) + (bvirt - ez);\n    bvirt = bx - bex;\n    bextail = bx - (bex + bvirt) + (bvirt - ex);\n    bvirt = by - bey;\n    beytail = by - (bey + bvirt) + (bvirt - ey);\n    bvirt = bz - bez;\n    beztail = bz - (bez + bvirt) + (bvirt - ez);\n    bvirt = cx - cex;\n    cextail = cx - (cex + bvirt) + (bvirt - ex);\n    bvirt = cy - cey;\n    ceytail = cy - (cey + bvirt) + (bvirt - ey);\n    bvirt = cz - cez;\n    ceztail = cz - (cez + bvirt) + (bvirt - ez);\n    bvirt = dx - dex;\n    dextail = dx - (dex + bvirt) + (bvirt - ex);\n    bvirt = dy - dey;\n    deytail = dy - (dey + bvirt) + (bvirt - ey);\n    bvirt = dz - dez;\n    deztail = dz - (dez + bvirt) + (bvirt - ez);\n    if (aextail === 0 && aeytail === 0 && aeztail === 0 &&\n        bextail === 0 && beytail === 0 && beztail === 0 &&\n        cextail === 0 && ceytail === 0 && ceztail === 0 &&\n        dextail === 0 && deytail === 0 && deztail === 0) {\n        return det;\n    }\n\n    errbound = isperrboundC * permanent + resulterrbound * Math.abs(det);\n\n    const abeps = (aex * beytail + bey * aextail) - (aey * bextail + bex * aeytail);\n    const bceps = (bex * ceytail + cey * bextail) - (bey * cextail + cex * beytail);\n    const cdeps = (cex * deytail + dey * cextail) - (cey * dextail + dex * ceytail);\n    const daeps = (dex * aeytail + aey * dextail) - (dey * aextail + aex * deytail);\n    const aceps = (aex * ceytail + cey * aextail) - (aey * cextail + cex * aeytail);\n    const bdeps = (bex * deytail + dey * bextail) - (bey * dextail + dex * beytail);\n    det +=\n        (((bex * bex + bey * bey + bez * bez) * ((cez * daeps + dez * aceps + aez * cdeps) +\n        (ceztail * da3 + deztail * ac3 + aeztail * cd3)) + (dex * dex + dey * dey + dez * dez) *\n        ((aez * bceps - bez * aceps + cez * abeps) + (aeztail * bc3 - beztail * ac3 + ceztail * ab3))) -\n        ((aex * aex + aey * aey + aez * aez) * ((bez * cdeps - cez * bdeps + dez * bceps) +\n        (beztail * cd3 - ceztail * bd3 + deztail * bc3)) + (cex * cex + cey * cey + cez * cez) *\n        ((dez * abeps + aez * bdeps + bez * daeps) + (deztail * ab3 + aeztail * bd3 + beztail * da3)))) +\n        2 * (((bex * bextail + bey * beytail + bez * beztail) * (cez * da3 + dez * ac3 + aez * cd3) +\n        (dex * dextail + dey * deytail + dez * deztail) * (aez * bc3 - bez * ac3 + cez * ab3)) -\n        ((aex * aextail + aey * aeytail + aez * aeztail) * (bez * cd3 - cez * bd3 + dez * bc3) +\n        (cex * cextail + cey * ceytail + cez * ceztail) * (dez * ab3 + aez * bd3 + bez * da3)));\n\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    return insphereexact(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez);\n}\n\nexport function insphere(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez) {\n    const aex = ax - ex;\n    const bex = bx - ex;\n    const cex = cx - ex;\n    const dex = dx - ex;\n    const aey = ay - ey;\n    const bey = by - ey;\n    const cey = cy - ey;\n    const dey = dy - ey;\n    const aez = az - ez;\n    const bez = bz - ez;\n    const cez = cz - ez;\n    const dez = dz - ez;\n\n    const aexbey = aex * bey;\n    const bexaey = bex * aey;\n    const ab = aexbey - bexaey;\n    const bexcey = bex * cey;\n    const cexbey = cex * bey;\n    const bc = bexcey - cexbey;\n    const cexdey = cex * dey;\n    const dexcey = dex * cey;\n    const cd = cexdey - dexcey;\n    const dexaey = dex * aey;\n    const aexdey = aex * dey;\n    const da = dexaey - aexdey;\n    const aexcey = aex * cey;\n    const cexaey = cex * aey;\n    const ac = aexcey - cexaey;\n    const bexdey = bex * dey;\n    const dexbey = dex * bey;\n    const bd = bexdey - dexbey;\n\n    const alift = aex * aex + aey * aey + aez * aez;\n    const blift = bex * bex + bey * bey + bez * bez;\n    const clift = cex * cex + cey * cey + cez * cez;\n    const dlift = dex * dex + dey * dey + dez * dez;\n\n    const det =\n        (clift * (dez * ab + aez * bd + bez * da) - dlift * (aez * bc - bez * ac + cez * ab)) +\n        (alift * (bez * cd - cez * bd + dez * bc) - blift * (cez * da + dez * ac + aez * cd));\n\n    const aezplus = Math.abs(aez);\n    const bezplus = Math.abs(bez);\n    const cezplus = Math.abs(cez);\n    const dezplus = Math.abs(dez);\n    const aexbeyplus = Math.abs(aexbey) + Math.abs(bexaey);\n    const bexceyplus = Math.abs(bexcey) + Math.abs(cexbey);\n    const cexdeyplus = Math.abs(cexdey) + Math.abs(dexcey);\n    const dexaeyplus = Math.abs(dexaey) + Math.abs(aexdey);\n    const aexceyplus = Math.abs(aexcey) + Math.abs(cexaey);\n    const bexdeyplus = Math.abs(bexdey) + Math.abs(dexbey);\n    const permanent =\n        (cexdeyplus * bezplus + bexdeyplus * cezplus + bexceyplus * dezplus) * alift +\n        (dexaeyplus * cezplus + aexceyplus * dezplus + cexdeyplus * aezplus) * blift +\n        (aexbeyplus * dezplus + bexdeyplus * aezplus + dexaeyplus * bezplus) * clift +\n        (bexceyplus * aezplus + aexceyplus * bezplus + aexbeyplus * cezplus) * dlift;\n\n    const errbound = isperrboundA * permanent;\n    if (det > errbound || -det > errbound) {\n        return det;\n    }\n    return -insphereadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez, permanent);\n}\n\nexport function inspherefast(pax, pay, paz, pbx, pby, pbz, pcx, pcy, pcz, pdx, pdy, pdz, pex, pey, pez) {\n    const aex = pax - pex;\n    const bex = pbx - pex;\n    const cex = pcx - pex;\n    const dex = pdx - pex;\n    const aey = pay - pey;\n    const bey = pby - pey;\n    const cey = pcy - pey;\n    const dey = pdy - pey;\n    const aez = paz - pez;\n    const bez = pbz - pez;\n    const cez = pcz - pez;\n    const dez = pdz - pez;\n\n    const ab = aex * bey - bex * aey;\n    const bc = bex * cey - cex * bey;\n    const cd = cex * dey - dex * cey;\n    const da = dex * aey - aex * dey;\n    const ac = aex * cey - cex * aey;\n    const bd = bex * dey - dex * bey;\n\n    const abc = aez * bc - bez * ac + cez * ab;\n    const bcd = bez * cd - cez * bd + dez * bc;\n    const cda = cez * da + dez * ac + aez * cd;\n    const dab = dez * ab + aez * bd + bez * da;\n\n    const alift = aex * aex + aey * aey + aez * aez;\n    const blift = bex * bex + bey * bey + bez * bez;\n    const clift = cex * cex + cey * cey + cez * cez;\n    const dlift = dex * dex + dey * dey + dez * dez;\n\n    return (clift * dab - dlift * abc) + (alift * bcd - blift * cda);\n}\n", "\nconst EPSILON = Math.pow(2, -52);\nconst EDGE_STACK = new Uint32Array(512);\n\nimport {orient2d} from 'robust-predicates';\n\nexport default class Delaunator {\n\n    static from(points, getX = defaultGetX, getY = defaultGetY) {\n        const n = points.length;\n        const coords = new Float64Array(n * 2);\n\n        for (let i = 0; i < n; i++) {\n            const p = points[i];\n            coords[2 * i] = getX(p);\n            coords[2 * i + 1] = getY(p);\n        }\n\n        return new Delaunator(coords);\n    }\n\n    constructor(coords) {\n        const n = coords.length >> 1;\n        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');\n\n        this.coords = coords;\n\n        // arrays that will store the triangulation graph\n        const maxTriangles = Math.max(2 * n - 5, 0);\n        this._triangles = new Uint32Array(maxTriangles * 3);\n        this._halfedges = new Int32Array(maxTriangles * 3);\n\n        // temporary arrays for tracking the edges of the advancing convex hull\n        this._hashSize = Math.ceil(Math.sqrt(n));\n        this._hullPrev = new Uint32Array(n); // edge to prev edge\n        this._hullNext = new Uint32Array(n); // edge to next edge\n        this._hullTri = new Uint32Array(n); // edge to adjacent triangle\n        this._hullHash = new Int32Array(this._hashSize); // angular edge hash\n\n        // temporary arrays for sorting points\n        this._ids = new Uint32Array(n);\n        this._dists = new Float64Array(n);\n\n        this.update();\n    }\n\n    update() {\n        const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;\n        const n = coords.length >> 1;\n\n        // populate an array of point indices; calculate input data bbox\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0; i < n; i++) {\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n            this._ids[i] = i;\n        }\n        const cx = (minX + maxX) / 2;\n        const cy = (minY + maxY) / 2;\n\n        let i0, i1, i2;\n\n        // pick a seed point close to the center\n        for (let i = 0, minDist = Infinity; i < n; i++) {\n            const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist) {\n                i0 = i;\n                minDist = d;\n            }\n        }\n        const i0x = coords[2 * i0];\n        const i0y = coords[2 * i0 + 1];\n\n        // find the point closest to the seed\n        for (let i = 0, minDist = Infinity; i < n; i++) {\n            if (i === i0) continue;\n            const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist && d > 0) {\n                i1 = i;\n                minDist = d;\n            }\n        }\n        let i1x = coords[2 * i1];\n        let i1y = coords[2 * i1 + 1];\n\n        let minRadius = Infinity;\n\n        // find the third point which forms the smallest circumcircle with the first two\n        for (let i = 0; i < n; i++) {\n            if (i === i0 || i === i1) continue;\n            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);\n            if (r < minRadius) {\n                i2 = i;\n                minRadius = r;\n            }\n        }\n        let i2x = coords[2 * i2];\n        let i2y = coords[2 * i2 + 1];\n\n        if (minRadius === Infinity) {\n            // order collinear points by dx (or dy if all x are identical)\n            // and return the list as a hull\n            for (let i = 0; i < n; i++) {\n                this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);\n            }\n            quicksort(this._ids, this._dists, 0, n - 1);\n            const hull = new Uint32Array(n);\n            let j = 0;\n            for (let i = 0, d0 = -Infinity; i < n; i++) {\n                const id = this._ids[i];\n                const d = this._dists[id];\n                if (d > d0) {\n                    hull[j++] = id;\n                    d0 = d;\n                }\n            }\n            this.hull = hull.subarray(0, j);\n            this.triangles = new Uint32Array(0);\n            this.halfedges = new Uint32Array(0);\n            return;\n        }\n\n        // swap the order of the seed points for counter-clockwise orientation\n        if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {\n            const i = i1;\n            const x = i1x;\n            const y = i1y;\n            i1 = i2;\n            i1x = i2x;\n            i1y = i2y;\n            i2 = i;\n            i2x = x;\n            i2y = y;\n        }\n\n        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);\n        this._cx = center.x;\n        this._cy = center.y;\n\n        for (let i = 0; i < n; i++) {\n            this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);\n        }\n\n        // sort the points by distance from the seed triangle circumcenter\n        quicksort(this._ids, this._dists, 0, n - 1);\n\n        // set up the seed triangle as the starting hull\n        this._hullStart = i0;\n        let hullSize = 3;\n\n        hullNext[i0] = hullPrev[i2] = i1;\n        hullNext[i1] = hullPrev[i0] = i2;\n        hullNext[i2] = hullPrev[i1] = i0;\n\n        hullTri[i0] = 0;\n        hullTri[i1] = 1;\n        hullTri[i2] = 2;\n\n        hullHash.fill(-1);\n        hullHash[this._hashKey(i0x, i0y)] = i0;\n        hullHash[this._hashKey(i1x, i1y)] = i1;\n        hullHash[this._hashKey(i2x, i2y)] = i2;\n\n        this.trianglesLen = 0;\n        this._addTriangle(i0, i1, i2, -1, -1, -1);\n\n        for (let k = 0, xp, yp; k < this._ids.length; k++) {\n            const i = this._ids[k];\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n\n            // skip near-duplicate points\n            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;\n            xp = x;\n            yp = y;\n\n            // skip seed triangle points\n            if (i === i0 || i === i1 || i === i2) continue;\n\n            // find a visible edge on the convex hull using edge hash\n            let start = 0;\n            for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {\n                start = hullHash[(key + j) % this._hashSize];\n                if (start !== -1 && start !== hullNext[start]) break;\n            }\n\n            start = hullPrev[start];\n            let e = start, q;\n            while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {\n                e = q;\n                if (e === start) {\n                    e = -1;\n                    break;\n                }\n            }\n            if (e === -1) continue; // likely a near-duplicate point; skip it\n\n            // add the first triangle from the point\n            let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);\n\n            // recursively flip triangles from the point until they satisfy the Delaunay condition\n            hullTri[i] = this._legalize(t + 2);\n            hullTri[e] = t; // keep track of boundary triangles on the hull\n            hullSize++;\n\n            // walk forward through the hull, adding more triangles and flipping recursively\n            let n = hullNext[e];\n            while (q = hullNext[n], orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {\n                t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);\n                hullTri[i] = this._legalize(t + 2);\n                hullNext[n] = n; // mark as removed\n                hullSize--;\n                n = q;\n            }\n\n            // walk backward from the other side, adding more triangles and flipping\n            if (e === start) {\n                while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {\n                    t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);\n                    this._legalize(t + 2);\n                    hullTri[q] = t;\n                    hullNext[e] = e; // mark as removed\n                    hullSize--;\n                    e = q;\n                }\n            }\n\n            // update the hull indices\n            this._hullStart = hullPrev[i] = e;\n            hullNext[e] = hullPrev[n] = i;\n            hullNext[i] = n;\n\n            // save the two new edges in the hash table\n            hullHash[this._hashKey(x, y)] = i;\n            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;\n        }\n\n        this.hull = new Uint32Array(hullSize);\n        for (let i = 0, e = this._hullStart; i < hullSize; i++) {\n            this.hull[i] = e;\n            e = hullNext[e];\n        }\n\n        // trim typed triangle mesh arrays\n        this.triangles = this._triangles.subarray(0, this.trianglesLen);\n        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);\n    }\n\n    _hashKey(x, y) {\n        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;\n    }\n\n    _legalize(a) {\n        const {_triangles: triangles, _halfedges: halfedges, coords} = this;\n\n        let i = 0;\n        let ar = 0;\n\n        // recursion eliminated with a fixed-size stack\n        while (true) {\n            const b = halfedges[a];\n\n            /* if the pair of triangles doesn't satisfy the Delaunay condition\n             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,\n             * then do the same check/flip recursively for the new pair of triangles\n             *\n             *           pl                    pl\n             *          /||\\                  /  \\\n             *       al/ || \\bl            al/    \\a\n             *        /  ||  \\              /      \\\n             *       /  a||b  \\    flip    /___ar___\\\n             *     p0\\   ||   /p1   =>   p0\\---bl---/p1\n             *        \\  ||  /              \\      /\n             *       ar\\ || /br             b\\    /br\n             *          \\||/                  \\  /\n             *           pr                    pr\n             */\n            const a0 = a - a % 3;\n            ar = a0 + (a + 2) % 3;\n\n            if (b === -1) { // convex hull edge\n                if (i === 0) break;\n                a = EDGE_STACK[--i];\n                continue;\n            }\n\n            const b0 = b - b % 3;\n            const al = a0 + (a + 1) % 3;\n            const bl = b0 + (b + 2) % 3;\n\n            const p0 = triangles[ar];\n            const pr = triangles[a];\n            const pl = triangles[al];\n            const p1 = triangles[bl];\n\n            const illegal = inCircle(\n                coords[2 * p0], coords[2 * p0 + 1],\n                coords[2 * pr], coords[2 * pr + 1],\n                coords[2 * pl], coords[2 * pl + 1],\n                coords[2 * p1], coords[2 * p1 + 1]);\n\n            if (illegal) {\n                triangles[a] = p1;\n                triangles[b] = p0;\n\n                const hbl = halfedges[bl];\n\n                // edge swapped on the other side of the hull (rare); fix the halfedge reference\n                if (hbl === -1) {\n                    let e = this._hullStart;\n                    do {\n                        if (this._hullTri[e] === bl) {\n                            this._hullTri[e] = a;\n                            break;\n                        }\n                        e = this._hullPrev[e];\n                    } while (e !== this._hullStart);\n                }\n                this._link(a, hbl);\n                this._link(b, halfedges[ar]);\n                this._link(ar, bl);\n\n                const br = b0 + (b + 1) % 3;\n\n                // don't worry about hitting the cap: it can only happen on extremely degenerate input\n                if (i < EDGE_STACK.length) {\n                    EDGE_STACK[i++] = br;\n                }\n            } else {\n                if (i === 0) break;\n                a = EDGE_STACK[--i];\n            }\n        }\n\n        return ar;\n    }\n\n    _link(a, b) {\n        this._halfedges[a] = b;\n        if (b !== -1) this._halfedges[b] = a;\n    }\n\n    // add a new triangle given vertex indices and adjacent half-edge ids\n    _addTriangle(i0, i1, i2, a, b, c) {\n        const t = this.trianglesLen;\n\n        this._triangles[t] = i0;\n        this._triangles[t + 1] = i1;\n        this._triangles[t + 2] = i2;\n\n        this._link(t, a);\n        this._link(t + 1, b);\n        this._link(t + 2, c);\n\n        this.trianglesLen += 3;\n\n        return t;\n    }\n}\n\n// monotonically increases with real angle, but doesn't need expensive trigonometry\nfunction pseudoAngle(dx, dy) {\n    const p = dx / (Math.abs(dx) + Math.abs(dy));\n    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]\n}\n\nfunction dist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n\nfunction inCircle(ax, ay, bx, by, cx, cy, px, py) {\n    const dx = ax - px;\n    const dy = ay - py;\n    const ex = bx - px;\n    const ey = by - py;\n    const fx = cx - px;\n    const fy = cy - py;\n\n    const ap = dx * dx + dy * dy;\n    const bp = ex * ex + ey * ey;\n    const cp = fx * fx + fy * fy;\n\n    return dx * (ey * cp - bp * fy) -\n           dy * (ex * cp - bp * fx) +\n           ap * (ex * fy - ey * fx) < 0;\n}\n\nfunction circumradius(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = 0.5 / (dx * ey - dy * ex);\n\n    const x = (ey * bl - dy * cl) * d;\n    const y = (dx * cl - ex * bl) * d;\n\n    return x * x + y * y;\n}\n\nfunction circumcenter(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = 0.5 / (dx * ey - dy * ex);\n\n    const x = ax + (ey * bl - dy * cl) * d;\n    const y = ay + (dx * cl - ex * bl) * d;\n\n    return {x, y};\n}\n\nfunction quicksort(ids, dists, left, right) {\n    if (right - left <= 20) {\n        for (let i = left + 1; i <= right; i++) {\n            const temp = ids[i];\n            const tempDist = dists[temp];\n            let j = i - 1;\n            while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];\n            ids[j + 1] = temp;\n        }\n    } else {\n        const median = (left + right) >> 1;\n        let i = left + 1;\n        let j = right;\n        swap(ids, median, i);\n        if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);\n        if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);\n        if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);\n\n        const temp = ids[i];\n        const tempDist = dists[temp];\n        while (true) {\n            do i++; while (dists[ids[i]] < tempDist);\n            do j--; while (dists[ids[j]] > tempDist);\n            if (j < i) break;\n            swap(ids, i, j);\n        }\n        ids[left + 1] = ids[j];\n        ids[j] = temp;\n\n        if (right - i + 1 >= j - left) {\n            quicksort(ids, dists, i, right);\n            quicksort(ids, dists, left, j - 1);\n        } else {\n            quicksort(ids, dists, left, j - 1);\n            quicksort(ids, dists, i, right);\n        }\n    }\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultGetX(p) {\n    return p[0];\n}\nfunction defaultGetY(p) {\n    return p[1];\n}\n", "import Delaunator from \"delaunator\";\nimport Path from \"./path.js\";\nimport Polygon from \"./polygon.js\";\nimport Voronoi from \"./voronoi.js\";\n\nconst tau = 2 * Math.PI, pow = Math.pow;\n\nfunction pointX(p) {\n  return p[0];\n}\n\nfunction pointY(p) {\n  return p[1];\n}\n\n// A triangulation is collinear if all its triangles have a non-null area\nfunction collinear(d) {\n  const {triangles, coords} = d;\n  for (let i = 0; i < triangles.length; i += 3) {\n    const a = 2 * triangles[i],\n          b = 2 * triangles[i + 1],\n          c = 2 * triangles[i + 2],\n          cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])\n                - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);\n    if (cross > 1e-10) return false;\n  }\n  return true;\n}\n\nfunction jitter(x, y, r) {\n  return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];\n}\n\nexport default class Delaunay {\n  static from(points, fx = pointX, fy = pointY, that) {\n    return new Delaunay(\"length\" in points\n        ? flatArray(points, fx, fy, that)\n        : Float64Array.from(flatIterable(points, fx, fy, that)));\n  }\n  constructor(points) {\n    this._delaunator = new Delaunator(points);\n    this.inedges = new Int32Array(points.length / 2);\n    this._hullIndex = new Int32Array(points.length / 2);\n    this.points = this._delaunator.coords;\n    this._init();\n  }\n  update() {\n    this._delaunator.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const d = this._delaunator, points = this.points;\n\n    // check for collinear\n    if (d.hull && d.hull.length > 2 && collinear(d)) {\n      this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)\n        .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors\n      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],\n        bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],\n        r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);\n      for (let i = 0, n = points.length / 2; i < n; ++i) {\n        const p = jitter(points[2 * i], points[2 * i + 1], r);\n        points[2 * i] = p[0];\n        points[2 * i + 1] = p[1];\n      }\n      this._delaunator = new Delaunator(points);\n    } else {\n      delete this.collinear;\n    }\n\n    const halfedges = this.halfedges = this._delaunator.halfedges;\n    const hull = this.hull = this._delaunator.hull;\n    const triangles = this.triangles = this._delaunator.triangles;\n    const inedges = this.inedges.fill(-1);\n    const hullIndex = this._hullIndex.fill(-1);\n\n    // Compute an index from each point to an (arbitrary) incoming halfedge\n    // Used to give the first neighbor of each point; for this reason,\n    // on the hull we give priority to exterior halfedges\n    for (let e = 0, n = halfedges.length; e < n; ++e) {\n      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];\n      if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;\n    }\n    for (let i = 0, n = hull.length; i < n; ++i) {\n      hullIndex[hull[i]] = i;\n    }\n\n    // degenerate case: 1 or 2 (distinct) points\n    if (hull.length <= 2 && hull.length > 0) {\n      this.triangles = new Int32Array(3).fill(-1);\n      this.halfedges = new Int32Array(3).fill(-1);\n      this.triangles[0] = hull[0];\n      inedges[hull[0]] = 1;\n      if (hull.length === 2) {\n        inedges[hull[1]] = 0;\n        this.triangles[1] = hull[1];\n        this.triangles[2] = hull[1];\n      }\n    }\n  }\n  voronoi(bounds) {\n    return new Voronoi(this, bounds);\n  }\n  *neighbors(i) {\n    const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;\n\n    // degenerate case with several collinear points\n    if (collinear) {\n      const l = collinear.indexOf(i);\n      if (l > 0) yield collinear[l - 1];\n      if (l < collinear.length - 1) yield collinear[l + 1];\n      return;\n    }\n\n    const e0 = inedges[i];\n    if (e0 === -1) return; // coincident point\n    let e = e0, p0 = -1;\n    do {\n      yield p0 = triangles[e];\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) return; // bad triangulation\n      e = halfedges[e];\n      if (e === -1) {\n        const p = hull[(_hullIndex[i] + 1) % hull.length];\n        if (p !== p0) yield p;\n        return;\n      }\n    } while (e !== e0);\n  }\n  find(x, y, i = 0) {\n    if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;\n    const i0 = i;\n    let c;\n    while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;\n    return c;\n  }\n  _step(i, x, y) {\n    const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;\n    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);\n    let c = i;\n    let dc = pow(x - points[i * 2], 2) + pow(y - points[i * 2 + 1], 2);\n    const e0 = inedges[i];\n    let e = e0;\n    do {\n      let t = triangles[e];\n      const dt = pow(x - points[t * 2], 2) + pow(y - points[t * 2 + 1], 2);\n      if (dt < dc) dc = dt, c = t;\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) break; // bad triangulation\n      e = halfedges[e];\n      if (e === -1) {\n        e = hull[(_hullIndex[i] + 1) % hull.length];\n        if (e !== t) {\n          if (pow(x - points[e * 2], 2) + pow(y - points[e * 2 + 1], 2) < dc) return e;\n        }\n        break;\n      }\n    } while (e !== e0);\n    return c;\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points, halfedges, triangles} = this;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i) continue;\n      const ti = triangles[i] * 2;\n      const tj = triangles[j] * 2;\n      context.moveTo(points[ti], points[ti + 1]);\n      context.lineTo(points[tj], points[tj + 1]);\n    }\n    this.renderHull(context);\n    return buffer && buffer.value();\n  }\n  renderPoints(context, r) {\n    if (r === undefined && (!context || typeof context.moveTo !== \"function\")) r = context, context = null;\n    r = r == undefined ? 2 : +r;\n    const buffer = context == null ? context = new Path : undefined;\n    const {points} = this;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i], y = points[i + 1];\n      context.moveTo(x + r, y);\n      context.arc(x, y, r, 0, tau);\n    }\n    return buffer && buffer.value();\n  }\n  renderHull(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {hull, points} = this;\n    const h = hull[0] * 2, n = hull.length;\n    context.moveTo(points[h], points[h + 1]);\n    for (let i = 1; i < n; ++i) {\n      const h = 2 * hull[i];\n      context.lineTo(points[h], points[h + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  hullPolygon() {\n    const polygon = new Polygon;\n    this.renderHull(polygon);\n    return polygon.value();\n  }\n  renderTriangle(i, context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points, triangles} = this;\n    const t0 = triangles[i *= 3] * 2;\n    const t1 = triangles[i + 1] * 2;\n    const t2 = triangles[i + 2] * 2;\n    context.moveTo(points[t0], points[t0 + 1]);\n    context.lineTo(points[t1], points[t1 + 1]);\n    context.lineTo(points[t2], points[t2 + 1]);\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *trianglePolygons() {\n    const {triangles} = this;\n    for (let i = 0, n = triangles.length / 3; i < n; ++i) {\n      yield this.trianglePolygon(i);\n    }\n  }\n  trianglePolygon(i) {\n    const polygon = new Polygon;\n    this.renderTriangle(i, polygon);\n    return polygon.value();\n  }\n}\n\nfunction flatArray(points, fx, fy, that) {\n  const n = points.length;\n  const array = new Float64Array(n * 2);\n  for (let i = 0; i < n; ++i) {\n    const p = points[i];\n    array[i * 2] = fx.call(that, p, i, points);\n    array[i * 2 + 1] = fy.call(that, p, i, points);\n  }\n  return array;\n}\n\nfunction* flatIterable(points, fx, fy, that) {\n  let i = 0;\n  for (const p of points) {\n    yield fx.call(that, p, i, points);\n    yield fy.call(that, p, i, points);\n    ++i;\n  }\n}\n", "var EOL = {},\n    EOF = {},\n    QUOTE = 34,\n    NEWLINE = 10,\n    RETURN = 13;\n\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"] || \\\"\\\"\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function(row, i) {\n    return f(object(row), i, columns);\n  };\n}\n\n// Compute unique columns in order of discovery.\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n\n  rows.forEach(function(row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n\n  return columns;\n}\n\nfunction pad(value, width) {\n  var s = value + \"\", length = s.length;\n  return length < width ? new Array(width - length + 1).join(0) + s : s;\n}\n\nfunction formatYear(year) {\n  return year < 0 ? \"-\" + pad(-year, 6)\n    : year > 9999 ? \"+\" + pad(year, 6)\n    : pad(year, 4);\n}\n\nfunction formatDate(date) {\n  var hours = date.getUTCHours(),\n      minutes = date.getUTCMinutes(),\n      seconds = date.getUTCSeconds(),\n      milliseconds = date.getUTCMilliseconds();\n  return isNaN(date) ? \"Invalid Date\"\n      : formatYear(date.getUTCFullYear(), 4) + \"-\" + pad(date.getUTCMonth() + 1, 2) + \"-\" + pad(date.getUTCDate(), 2)\n      + (milliseconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \".\" + pad(milliseconds, 3) + \"Z\"\n      : seconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \"Z\"\n      : minutes || hours ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \"Z\"\n      : \"\");\n}\n\nexport default function(delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"),\n      DELIMITER = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert, columns, rows = parseRows(text, function(row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns || [];\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var rows = [], // output rows\n        N = text.length,\n        I = 0, // current character index\n        n = 0, // current line number\n        t, // current token\n        eof = N <= 0, // current token followed by EOF?\n        eol = false; // current token followed by EOL?\n\n    // Strip the trailing newline.\n    if (text.charCodeAt(N - 1) === NEWLINE) --N;\n    if (text.charCodeAt(N - 1) === RETURN) --N;\n\n    function token() {\n      if (eof) return EOF;\n      if (eol) return eol = false, EOL;\n\n      // Unescape quotes.\n      var i, j = I, c;\n      if (text.charCodeAt(j) === QUOTE) {\n        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);\n        if ((i = I) >= N) eof = true;\n        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        return text.slice(j + 1, i - 1).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // Find next delimiter or newline.\n      while (I < N) {\n        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        else if (c !== DELIMITER) continue;\n        return text.slice(j, i);\n      }\n\n      // Return last token before EOF.\n      return eof = true, text.slice(j, N);\n    }\n\n    while ((t = token()) !== EOF) {\n      var row = [];\n      while (t !== EOL && t !== EOF) row.push(t), t = token();\n      if (f && (row = f(row, n++)) == null) continue;\n      rows.push(row);\n    }\n\n    return rows;\n  }\n\n  function preformatBody(rows, columns) {\n    return rows.map(function(row) {\n      return columns.map(function(column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    });\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join(\"\\n\");\n  }\n\n  function formatBody(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return preformatBody(rows, columns).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(value) {\n    return value == null ? \"\"\n        : value instanceof Date ? formatDate(value)\n        : reFormat.test(value += \"\") ? \"\\\"\" + value.replace(/\"/g, \"\\\"\\\"\") + \"\\\"\"\n        : value;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatBody: formatBody,\n    formatRows: formatRows,\n    formatRow: formatRow,\n    formatValue: formatValue\n  };\n}\n", "import dsv from \"./dsv.js\";\n\nvar csv = dsv(\",\");\n\nexport var csvParse = csv.parse;\nexport var csvParseRows = csv.parseRows;\nexport var csvFormat = csv.format;\nexport var csvFormatBody = csv.formatBody;\nexport var csvFormatRows = csv.formatRows;\nexport var csvFormatRow = csv.formatRow;\nexport var csvFormatValue = csv.formatValue;\n", "import dsv from \"./dsv.js\";\n\nvar tsv = dsv(\"\\t\");\n\nexport var tsvParse = tsv.parse;\nexport var tsvParseRows = tsv.parseRows;\nexport var tsvFormat = tsv.format;\nexport var tsvFormatBody = tsv.formatBody;\nexport var tsvFormatRows = tsv.formatRows;\nexport var tsvFormatRow = tsv.formatRow;\nexport var tsvFormatValue = tsv.formatValue;\n", "export default function autoType(object) {\n  for (var key in object) {\n    var value = object[key].trim(), number, m;\n    if (!value) value = null;\n    else if (value === \"true\") value = true;\n    else if (value === \"false\") value = false;\n    else if (value === \"NaN\") value = NaN;\n    else if (!isNaN(number = +value)) value = number;\n    else if (m = value.match(/^([-+]\\d{2})?\\d{4}(-\\d{2}(-\\d{2})?)?(T\\d{2}:\\d{2}(:\\d{2}(\\.\\d{3})?)?(Z|[-+]\\d{2}:\\d{2})?)?$/)) {\n      if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, \"/\").replace(/T/, \" \");\n      value = new Date(value);\n    }\n    else continue;\n    object[key] = value;\n  }\n  return object;\n}\n\n// https://github.com/d3/d3-dsv/issues/45\nconst fixtz = new Date(\"2019-01-01T00:00\").getHours() || new Date(\"2019-07-01T00:00\").getHours();", "function responseText(response) {\n  if (!response.ok) throw new Error(response.status + \" \" + response.statusText);\n  return response.text();\n}\n\nexport default function(input, init) {\n  return fetch(input, init).then(responseText);\n}\n", "import {csvParse, dsvFormat, tsvParse} from \"d3-dsv\";\nimport text from \"./text.js\";\n\nfunction dsvParse(parse) {\n  return function(input, init, row) {\n    if (arguments.length === 2 && typeof init === \"function\") row = init, init = undefined;\n    return text(input, init).then(function(response) {\n      return parse(response, row);\n    });\n  };\n}\n\nexport default function dsv(delimiter, input, init, row) {\n  if (arguments.length === 3 && typeof init === \"function\") row = init, init = undefined;\n  var format = dsvFormat(delimiter);\n  return text(input, init).then(function(response) {\n    return format.parse(response, row);\n  });\n}\n\nexport var csv = dsvParse(csvParse);\nexport var tsv = dsvParse(tsvParse);\n", "import text from \"./text.js\";\n\nfunction parser(type) {\n  return (input, init) => text(input, init)\n    .then(text => (new DOMParser).parseFromString(text, type));\n}\n\nexport default parser(\"application/xml\");\n\nexport var html = parser(\"text/html\");\n\nexport var svg = parser(\"image/svg+xml\");\n", "export default function(d) {\n  const x = +this._x.call(null, d),\n      y = +this._y.call(null, d);\n  return add(this.cover(x, y), x, y, d);\n}\n\nfunction add(tree, x, y, d) {\n  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points\n\n  var parent,\n      node = tree._root,\n      leaf = {data: d},\n      x0 = tree._x0,\n      y0 = tree._y0,\n      x1 = tree._x1,\n      y1 = tree._y1,\n      xm,\n      ym,\n      xp,\n      yp,\n      right,\n      bottom,\n      i,\n      j;\n\n  // If the tree is empty, initialize the root as a leaf.\n  if (!node) return tree._root = leaf, tree;\n\n  // Find the existing leaf for the new point, or add it.\n  while (node.length) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;\n  }\n\n  // Is the new point is exactly coincident with the existing point?\n  xp = +tree._x.call(null, node.data);\n  yp = +tree._y.call(null, node.data);\n  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;\n\n  // Otherwise, split the leaf node until the old and new point are separated.\n  do {\n    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));\n  return parent[j] = node, parent[i] = leaf, tree;\n}\n\nexport function addAll(data) {\n  var d, i, n = data.length,\n      x,\n      y,\n      xz = new Array(n),\n      yz = new Array(n),\n      x0 = Infinity,\n      y0 = Infinity,\n      x1 = -Infinity,\n      y1 = -Infinity;\n\n  // Compute the points and their extent.\n  for (i = 0; i < n; ++i) {\n    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;\n    xz[i] = x;\n    yz[i] = y;\n    if (x < x0) x0 = x;\n    if (x > x1) x1 = x;\n    if (y < y0) y0 = y;\n    if (y > y1) y1 = y;\n  }\n\n  // If there were no (valid) points, abort.\n  if (x0 > x1 || y0 > y1) return this;\n\n  // Expand the tree to cover the new points.\n  this.cover(x0, y0).cover(x1, y1);\n\n  // Add the new points.\n  for (i = 0; i < n; ++i) {\n    add(this, xz[i], yz[i], data[i]);\n  }\n\n  return this;\n}\n", "export default function(x, y) {\n  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points\n\n  var x0 = this._x0,\n      y0 = this._y0,\n      x1 = this._x1,\n      y1 = this._y1;\n\n  // If the quadtree has no extent, initialize them.\n  // Integer extent are necessary so that if we later double the extent,\n  // the existing quadrant boundaries dont change due to floating point error!\n  if (isNaN(x0)) {\n    x1 = (x0 = Math.floor(x)) + 1;\n    y1 = (y0 = Math.floor(y)) + 1;\n  }\n\n  // Otherwise, double repeatedly to cover.\n  else {\n    var z = x1 - x0 || 1,\n        node = this._root,\n        parent,\n        i;\n\n    while (x0 > x || x >= x1 || y0 > y || y >= y1) {\n      i = (y < y0) << 1 | (x < x0);\n      parent = new Array(4), parent[i] = node, node = parent, z *= 2;\n      switch (i) {\n        case 0: x1 = x0 + z, y1 = y0 + z; break;\n        case 1: x0 = x1 - z, y1 = y0 + z; break;\n        case 2: x1 = x0 + z, y0 = y1 - z; break;\n        case 3: x0 = x1 - z, y0 = y1 - z; break;\n      }\n    }\n\n    if (this._root && this._root.length) this._root = node;\n  }\n\n  this._x0 = x0;\n  this._y0 = y0;\n  this._x1 = x1;\n  this._y1 = y1;\n  return this;\n}\n", "export default function() {\n  var data = [];\n  this.visit(function(node) {\n    if (!node.length) do data.push(node.data); while (node = node.next)\n  });\n  return data;\n}\n", "export default function(_) {\n  return arguments.length\n      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])\n      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];\n}\n", "export default function(node, x0, y0, x1, y1) {\n  this.node = node;\n  this.x0 = x0;\n  this.y0 = y0;\n  this.x1 = x1;\n  this.y1 = y1;\n}\n", "import Quad from \"./quad.js\";\n\nexport default function(x, y, radius) {\n  var data,\n      x0 = this._x0,\n      y0 = this._y0,\n      x1,\n      y1,\n      x2,\n      y2,\n      x3 = this._x1,\n      y3 = this._y1,\n      quads = [],\n      node = this._root,\n      q,\n      i;\n\n  if (node) quads.push(new Quad(node, x0, y0, x3, y3));\n  if (radius == null) radius = Infinity;\n  else {\n    x0 = x - radius, y0 = y - radius;\n    x3 = x + radius, y3 = y + radius;\n    radius *= radius;\n  }\n\n  while (q = quads.pop()) {\n\n    // Stop searching if this quadrant cant contain a closer node.\n    if (!(node = q.node)\n        || (x1 = q.x0) > x3\n        || (y1 = q.y0) > y3\n        || (x2 = q.x1) < x0\n        || (y2 = q.y1) < y0) continue;\n\n    // Bisect the current quadrant.\n    if (node.length) {\n      var xm = (x1 + x2) / 2,\n          ym = (y1 + y2) / 2;\n\n      quads.push(\n        new Quad(node[3], xm, ym, x2, y2),\n        new Quad(node[2], x1, ym, xm, y2),\n        new Quad(node[1], xm, y1, x2, ym),\n        new Quad(node[0], x1, y1, xm, ym)\n      );\n\n      // Visit the closest quadrant first.\n      if (i = (y >= ym) << 1 | (x >= xm)) {\n        q = quads[quads.length - 1];\n        quads[quads.length - 1] = quads[quads.length - 1 - i];\n        quads[quads.length - 1 - i] = q;\n      }\n    }\n\n    // Visit this point. (Visiting coincident points isnt necessary!)\n    else {\n      var dx = x - +this._x.call(null, node.data),\n          dy = y - +this._y.call(null, node.data),\n          d2 = dx * dx + dy * dy;\n      if (d2 < radius) {\n        var d = Math.sqrt(radius = d2);\n        x0 = x - d, y0 = y - d;\n        x3 = x + d, y3 = y + d;\n        data = node.data;\n      }\n    }\n  }\n\n  return data;\n}\n", "export default function(d) {\n  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points\n\n  var parent,\n      node = this._root,\n      retainer,\n      previous,\n      next,\n      x0 = this._x0,\n      y0 = this._y0,\n      x1 = this._x1,\n      y1 = this._y1,\n      x,\n      y,\n      xm,\n      ym,\n      right,\n      bottom,\n      i,\n      j;\n\n  // If the tree is empty, initialize the root as a leaf.\n  if (!node) return this;\n\n  // Find the leaf node for the point.\n  // While descending, also retain the deepest parent with a non-removed sibling.\n  if (node.length) while (true) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;\n    if (!node.length) break;\n    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;\n  }\n\n  // Find the point to remove.\n  while (node.data !== d) if (!(previous = node, node = node.next)) return this;\n  if (next = node.next) delete node.next;\n\n  // If there are multiple coincident points, remove just the point.\n  if (previous) return (next ? previous.next = next : delete previous.next), this;\n\n  // If this is the root point, remove it.\n  if (!parent) return this._root = next, this;\n\n  // Remove this leaf.\n  next ? parent[i] = next : delete parent[i];\n\n  // If the parent now contains exactly one leaf, collapse superfluous parents.\n  if ((node = parent[0] || parent[1] || parent[2] || parent[3])\n      && node === (parent[3] || parent[2] || parent[1] || parent[0])\n      && !node.length) {\n    if (retainer) retainer[j] = node;\n    else this._root = node;\n  }\n\n  return this;\n}\n\nexport function removeAll(data) {\n  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);\n  return this;\n}\n", "export default function() {\n  return this._root;\n}\n", "export default function() {\n  var size = 0;\n  this.visit(function(node) {\n    if (!node.length) do ++size; while (node = node.next)\n  });\n  return size;\n}\n", "import Quad from \"./quad.js\";\n\nexport default function(callback) {\n  var quads = [], q, node = this._root, child, x0, y0, x1, y1;\n  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));\n  while (q = quads.pop()) {\n    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {\n      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n    }\n  }\n  return this;\n}\n", "import Quad from \"./quad.js\";\n\nexport default function(callback) {\n  var quads = [], next = [], q;\n  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));\n  while (q = quads.pop()) {\n    var node = q.node;\n    if (node.length) {\n      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n    }\n    next.push(q);\n  }\n  while (q = next.pop()) {\n    callback(q.node, q.x0, q.y0, q.x1, q.y1);\n  }\n  return this;\n}\n", "export function defaultX(d) {\n  return d[0];\n}\n\nexport default function(_) {\n  return arguments.length ? (this._x = _, this) : this._x;\n}\n", "export function defaultY(d) {\n  return d[1];\n}\n\nexport default function(_) {\n  return arguments.length ? (this._y = _, this) : this._y;\n}\n", "import tree_add, {addAll as tree_addAll} from \"./add.js\";\nimport tree_cover from \"./cover.js\";\nimport tree_data from \"./data.js\";\nimport tree_extent from \"./extent.js\";\nimport tree_find from \"./find.js\";\nimport tree_remove, {removeAll as tree_removeAll} from \"./remove.js\";\nimport tree_root from \"./root.js\";\nimport tree_size from \"./size.js\";\nimport tree_visit from \"./visit.js\";\nimport tree_visitAfter from \"./visitAfter.js\";\nimport tree_x, {defaultX} from \"./x.js\";\nimport tree_y, {defaultY} from \"./y.js\";\n\nexport default function quadtree(nodes, x, y) {\n  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);\n  return nodes == null ? tree : tree.addAll(nodes);\n}\n\nfunction Quadtree(x, y, x0, y0, x1, y1) {\n  this._x = x;\n  this._y = y;\n  this._x0 = x0;\n  this._y0 = y0;\n  this._x1 = x1;\n  this._y1 = y1;\n  this._root = undefined;\n}\n\nfunction leaf_copy(leaf) {\n  var copy = {data: leaf.data}, next = copy;\n  while (leaf = leaf.next) next = next.next = {data: leaf.data};\n  return copy;\n}\n\nvar treeProto = quadtree.prototype = Quadtree.prototype;\n\ntreeProto.copy = function() {\n  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),\n      node = this._root,\n      nodes,\n      child;\n\n  if (!node) return copy;\n\n  if (!node.length) return copy._root = leaf_copy(node), copy;\n\n  nodes = [{source: node, target: copy._root = new Array(4)}];\n  while (node = nodes.pop()) {\n    for (var i = 0; i < 4; ++i) {\n      if (child = node.source[i]) {\n        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});\n        else node.target[i] = leaf_copy(child);\n      }\n    }\n  }\n\n  return copy;\n};\n\ntreeProto.add = tree_add;\ntreeProto.addAll = tree_addAll;\ntreeProto.cover = tree_cover;\ntreeProto.data = tree_data;\ntreeProto.extent = tree_extent;\ntreeProto.find = tree_find;\ntreeProto.remove = tree_remove;\ntreeProto.removeAll = tree_removeAll;\ntreeProto.root = tree_root;\ntreeProto.size = tree_size;\ntreeProto.visit = tree_visit;\ntreeProto.visitAfter = tree_visitAfter;\ntreeProto.x = tree_x;\ntreeProto.y = tree_y;\n", "import {dispatch} from \"d3-dispatch\";\nimport {timer} from \"d3-timer\";\nimport lcg from \"./lcg.js\";\n\nexport function x(d) {\n  return d.x;\n}\n\nexport function y(d) {\n  return d.y;\n}\n\nvar initialRadius = 10,\n    initialAngle = Math.PI * (3 - Math.sqrt(5));\n\nexport default function(nodes) {\n  var simulation,\n      alpha = 1,\n      alphaMin = 0.001,\n      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),\n      alphaTarget = 0,\n      velocityDecay = 0.6,\n      forces = new Map(),\n      stepper = timer(step),\n      event = dispatch(\"tick\", \"end\"),\n      random = lcg();\n\n  if (nodes == null) nodes = [];\n\n  function step() {\n    tick();\n    event.call(\"tick\", simulation);\n    if (alpha < alphaMin) {\n      stepper.stop();\n      event.call(\"end\", simulation);\n    }\n  }\n\n  function tick(iterations) {\n    var i, n = nodes.length, node;\n\n    if (iterations === undefined) iterations = 1;\n\n    for (var k = 0; k < iterations; ++k) {\n      alpha += (alphaTarget - alpha) * alphaDecay;\n\n      forces.forEach(function(force) {\n        force(alpha);\n      });\n\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        if (node.fx == null) node.x += node.vx *= velocityDecay;\n        else node.x = node.fx, node.vx = 0;\n        if (node.fy == null) node.y += node.vy *= velocityDecay;\n        else node.y = node.fy, node.vy = 0;\n      }\n    }\n\n    return simulation;\n  }\n\n  function initializeNodes() {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.index = i;\n      if (node.fx != null) node.x = node.fx;\n      if (node.fy != null) node.y = node.fy;\n      if (isNaN(node.x) || isNaN(node.y)) {\n        var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;\n        node.x = radius * Math.cos(angle);\n        node.y = radius * Math.sin(angle);\n      }\n      if (isNaN(node.vx) || isNaN(node.vy)) {\n        node.vx = node.vy = 0;\n      }\n    }\n  }\n\n  function initializeForce(force) {\n    if (force.initialize) force.initialize(nodes, random);\n    return force;\n  }\n\n  initializeNodes();\n\n  return simulation = {\n    tick: tick,\n\n    restart: function() {\n      return stepper.restart(step), simulation;\n    },\n\n    stop: function() {\n      return stepper.stop(), simulation;\n    },\n\n    nodes: function(_) {\n      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;\n    },\n\n    alpha: function(_) {\n      return arguments.length ? (alpha = +_, simulation) : alpha;\n    },\n\n    alphaMin: function(_) {\n      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;\n    },\n\n    alphaDecay: function(_) {\n      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;\n    },\n\n    alphaTarget: function(_) {\n      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;\n    },\n\n    velocityDecay: function(_) {\n      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;\n    },\n\n    randomSource: function(_) {\n      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;\n    },\n\n    force: function(name, _) {\n      return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);\n    },\n\n    find: function(x, y, radius) {\n      var i = 0,\n          n = nodes.length,\n          dx,\n          dy,\n          d2,\n          node,\n          closest;\n\n      if (radius == null) radius = Infinity;\n      else radius *= radius;\n\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        dx = x - node.x;\n        dy = y - node.y;\n        d2 = dx * dx + dy * dy;\n        if (d2 < radius) closest = node, radius = d2;\n      }\n\n      return closest;\n    },\n\n    on: function(name, _) {\n      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);\n    }\n  };\n}\n", "export default function(x) {\n  return Math.abs(x = Math.round(x)) >= 1e21\n      ? x.toLocaleString(\"en\").replace(/,/g, \"\")\n      : x.toString(10);\n}\n\n// Computes the decimal coefficient and exponent of the specified number x with\n// significant digits p, where x is positive and p is in [1, 21] or undefined.\n// For example, formatDecimalParts(1.23) returns [\"123\", 0].\nexport function formatDecimalParts(x, p) {\n  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, Infinity\n  var i, coefficient = x.slice(0, i);\n\n  // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n  // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n  return [\n    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n    +x.slice(i + 1)\n  ];\n}\n", "import {formatDecimalParts} from \"./formatDecimal.js\";\n\nexport default function(x) {\n  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;\n}\n", "export default function(grouping, thousands) {\n  return function(value, width) {\n    var i = value.length,\n        t = [],\n        j = 0,\n        g = grouping[0],\n        length = 0;\n\n    while (i > 0 && g > 0) {\n      if (length + g + 1 > width) g = Math.max(1, width - length);\n      t.push(value.substring(i -= g, i + g));\n      if ((length += g + 1) > width) break;\n      g = grouping[j = (j + 1) % grouping.length];\n    }\n\n    return t.reverse().join(thousands);\n  };\n}\n", "export default function(numerals) {\n  return function(value) {\n    return value.replace(/[0-9]/g, function(i) {\n      return numerals[+i];\n    });\n  };\n}\n", "// [[fill]align][sign][symbol][0][width][,][.precision][~][type]\nvar re = /^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;\n\nexport default function formatSpecifier(specifier) {\n  if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n  var match;\n  return new FormatSpecifier({\n    fill: match[1],\n    align: match[2],\n    sign: match[3],\n    symbol: match[4],\n    zero: match[5],\n    width: match[6],\n    comma: match[7],\n    precision: match[8] && match[8].slice(1),\n    trim: match[9],\n    type: match[10]\n  });\n}\n\nformatSpecifier.prototype = FormatSpecifier.prototype; // instanceof\n\nexport function FormatSpecifier(specifier) {\n  this.fill = specifier.fill === undefined ? \" \" : specifier.fill + \"\";\n  this.align = specifier.align === undefined ? \">\" : specifier.align + \"\";\n  this.sign = specifier.sign === undefined ? \"-\" : specifier.sign + \"\";\n  this.symbol = specifier.symbol === undefined ? \"\" : specifier.symbol + \"\";\n  this.zero = !!specifier.zero;\n  this.width = specifier.width === undefined ? undefined : +specifier.width;\n  this.comma = !!specifier.comma;\n  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;\n  this.trim = !!specifier.trim;\n  this.type = specifier.type === undefined ? \"\" : specifier.type + \"\";\n}\n\nFormatSpecifier.prototype.toString = function() {\n  return this.fill\n      + this.align\n      + this.sign\n      + this.symbol\n      + (this.zero ? \"0\" : \"\")\n      + (this.width === undefined ? \"\" : Math.max(1, this.width | 0))\n      + (this.comma ? \",\" : \"\")\n      + (this.precision === undefined ? \"\" : \".\" + Math.max(0, this.precision | 0))\n      + (this.trim ? \"~\" : \"\")\n      + this.type;\n};\n", "// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.\nexport default function(s) {\n  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {\n    switch (s[i]) {\n      case \".\": i0 = i1 = i; break;\n      case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;\n    }\n  }\n  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;\n}\n", "import {formatDecimalParts} from \"./formatDecimal.js\";\n\nexport var prefixExponent;\n\nexport default function(x, p) {\n  var d = formatDecimalParts(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1],\n      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n      n = coefficient.length;\n  return i === n ? coefficient\n      : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n      : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n      : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!\n}\n", "import {formatDecimalParts} from \"./formatDecimal.js\";\n\nexport default function(x, p) {\n  var d = formatDecimalParts(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1];\n  return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n      : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n}\n", "import formatDecimal from \"./formatDecimal.js\";\nimport formatPrefixAuto from \"./formatPrefixAuto.js\";\nimport formatRounded from \"./formatRounded.js\";\n\nexport default {\n  \"%\": (x, p) => (x * 100).toFixed(p),\n  \"b\": (x) => Math.round(x).toString(2),\n  \"c\": (x) => x + \"\",\n  \"d\": formatDecimal,\n  \"e\": (x, p) => x.toExponential(p),\n  \"f\": (x, p) => x.toFixed(p),\n  \"g\": (x, p) => x.toPrecision(p),\n  \"o\": (x) => Math.round(x).toString(8),\n  \"p\": (x, p) => formatRounded(x * 100, p),\n  \"r\": formatRounded,\n  \"s\": formatPrefixAuto,\n  \"X\": (x) => Math.round(x).toString(16).toUpperCase(),\n  \"x\": (x) => Math.round(x).toString(16)\n};\n", "export default function(x) {\n  return x;\n}\n", "import exponent from \"./exponent.js\";\nimport formatGroup from \"./formatGroup.js\";\nimport formatNumerals from \"./formatNumerals.js\";\nimport formatSpecifier from \"./formatSpecifier.js\";\nimport formatTrim from \"./formatTrim.js\";\nimport formatTypes from \"./formatTypes.js\";\nimport {prefixExponent} from \"./formatPrefixAuto.js\";\nimport identity from \"./identity.js\";\n\nvar map = Array.prototype.map,\n    prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\nexport default function(locale) {\n  var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + \"\"),\n      currencyPrefix = locale.currency === undefined ? \"\" : locale.currency[0] + \"\",\n      currencySuffix = locale.currency === undefined ? \"\" : locale.currency[1] + \"\",\n      decimal = locale.decimal === undefined ? \".\" : locale.decimal + \"\",\n      numerals = locale.numerals === undefined ? identity : formatNumerals(map.call(locale.numerals, String)),\n      percent = locale.percent === undefined ? \"%\" : locale.percent + \"\",\n      minus = locale.minus === undefined ? \"\" : locale.minus + \"\",\n      nan = locale.nan === undefined ? \"NaN\" : locale.nan + \"\";\n\n  function newFormat(specifier) {\n    specifier = formatSpecifier(specifier);\n\n    var fill = specifier.fill,\n        align = specifier.align,\n        sign = specifier.sign,\n        symbol = specifier.symbol,\n        zero = specifier.zero,\n        width = specifier.width,\n        comma = specifier.comma,\n        precision = specifier.precision,\n        trim = specifier.trim,\n        type = specifier.type;\n\n    // The \"n\" type is an alias for \",g\".\n    if (type === \"n\") comma = true, type = \"g\";\n\n    // The \"\" type, and any invalid type, is an alias for \".12~g\".\n    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = \"g\";\n\n    // If zero fill is specified, padding goes after sign and before digits.\n    if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n    // Compute the prefix and suffix.\n    // For SI-prefix, the suffix is lazily computed.\n    var prefix = symbol === \"$\" ? currencyPrefix : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n        suffix = symbol === \"$\" ? currencySuffix : /[%p]/.test(type) ? percent : \"\";\n\n    // What format function should we use?\n    // Is this an integer type?\n    // Can this type generate exponential notation?\n    var formatType = formatTypes[type],\n        maybeSuffix = /[defgprs%]/.test(type);\n\n    // Set the default precision if not specified,\n    // or clamp the specified precision to the supported range.\n    // For significant precision, it must be in [1, 21].\n    // For fixed precision, it must be in [0, 20].\n    precision = precision === undefined ? 6\n        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n        : Math.max(0, Math.min(20, precision));\n\n    function format(value) {\n      var valuePrefix = prefix,\n          valueSuffix = suffix,\n          i, n, c;\n\n      if (type === \"c\") {\n        valueSuffix = formatType(value) + valueSuffix;\n        value = \"\";\n      } else {\n        value = +value;\n\n        // Determine the sign. -0 is not less than 0, but 1 / -0 is!\n        var valueNegative = value < 0 || 1 / value < 0;\n\n        // Perform the initial formatting.\n        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);\n\n        // Trim insignificant zeros.\n        if (trim) value = formatTrim(value);\n\n        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.\n        if (valueNegative && +value === 0 && sign !== \"+\") valueNegative = false;\n\n        // Compute the prefix and suffix.\n        valuePrefix = (valueNegative ? (sign === \"(\" ? sign : minus) : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n        valueSuffix = (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + valueSuffix + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n        // Break the formatted value into the integer value part that can be\n        // grouped, and fractional or exponential suffix part that is not.\n        if (maybeSuffix) {\n          i = -1, n = value.length;\n          while (++i < n) {\n            if (c = value.charCodeAt(i), 48 > c || c > 57) {\n              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n              value = value.slice(0, i);\n              break;\n            }\n          }\n        }\n      }\n\n      // If the fill character is not \"0\", grouping is applied before padding.\n      if (comma && !zero) value = group(value, Infinity);\n\n      // Compute the padding.\n      var length = valuePrefix.length + value.length + valueSuffix.length,\n          padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n      // If the fill character is \"0\", grouping is applied after padding.\n      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n      // Reconstruct the final output based on the desired alignment.\n      switch (align) {\n        case \"<\": value = valuePrefix + value + valueSuffix + padding; break;\n        case \"=\": value = valuePrefix + padding + value + valueSuffix; break;\n        case \"^\": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;\n        default: value = padding + valuePrefix + value + valueSuffix; break;\n      }\n\n      return numerals(value);\n    }\n\n    format.toString = function() {\n      return specifier + \"\";\n    };\n\n    return format;\n  }\n\n  function formatPrefix(specifier, value) {\n    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n        k = Math.pow(10, -e),\n        prefix = prefixes[8 + e / 3];\n    return function(value) {\n      return f(k * value) + prefix;\n    };\n  }\n\n  return {\n    format: newFormat,\n    formatPrefix: formatPrefix\n  };\n}\n", "import formatLocale from \"./locale.js\";\n\nvar locale;\nexport var format;\nexport var formatPrefix;\n\ndefaultLocale({\n  thousands: \",\",\n  grouping: [3],\n  currency: [\"$\", \"\"]\n});\n\nexport default function defaultLocale(definition) {\n  locale = formatLocale(definition);\n  format = locale.format;\n  formatPrefix = locale.formatPrefix;\n  return locale;\n}\n", "import exponent from \"./exponent.js\";\n\nexport default function(step) {\n  return Math.max(0, -exponent(Math.abs(step)));\n}\n", "import exponent from \"./exponent.js\";\n\nexport default function(step, value) {\n  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));\n}\n", "import exponent from \"./exponent.js\";\n\nexport default function(step, max) {\n  step = Math.abs(step), max = Math.abs(max) - step;\n  return Math.max(0, exponent(max) - exponent(step)) + 1;\n}\n", "export var epsilon = 1e-6;\nexport var epsilon2 = 1e-12;\nexport var pi = Math.PI;\nexport var halfPi = pi / 2;\nexport var quarterPi = pi / 4;\nexport var tau = pi * 2;\n\nexport var degrees = 180 / pi;\nexport var radians = pi / 180;\n\nexport var abs = Math.abs;\nexport var atan = Math.atan;\nexport var atan2 = Math.atan2;\nexport var cos = Math.cos;\nexport var ceil = Math.ceil;\nexport var exp = Math.exp;\nexport var floor = Math.floor;\nexport var hypot = Math.hypot;\nexport var log = Math.log;\nexport var pow = Math.pow;\nexport var sin = Math.sin;\nexport var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };\nexport var sqrt = Math.sqrt;\nexport var tan = Math.tan;\n\nexport function acos(x) {\n  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n}\n\nexport function asin(x) {\n  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);\n}\n\nexport function haversin(x) {\n  return (x = sin(x / 2)) * x;\n}\n", "export default function noop() {}\n", "import {Adder} from \"d3-array\";\nimport {atan2, cos, quarterPi, radians, sin, tau} from \"./math.js\";\nimport noop from \"./noop.js\";\nimport stream from \"./stream.js\";\n\nexport var areaRingSum = new Adder();\n\n// hello?\n\nvar areaSum = new Adder(),\n    lambda00,\n    phi00,\n    lambda0,\n    cosPhi0,\n    sinPhi0;\n\nexport var areaStream = {\n  point: noop,\n  lineStart: noop,\n  lineEnd: noop,\n  polygonStart: function() {\n    areaRingSum = new Adder();\n    areaStream.lineStart = areaRingStart;\n    areaStream.lineEnd = areaRingEnd;\n  },\n  polygonEnd: function() {\n    var areaRing = +areaRingSum;\n    areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);\n    this.lineStart = this.lineEnd = this.point = noop;\n  },\n  sphere: function() {\n    areaSum.add(tau);\n  }\n};\n\nfunction areaRingStart() {\n  areaStream.point = areaPointFirst;\n}\n\nfunction areaRingEnd() {\n  areaPoint(lambda00, phi00);\n}\n\nfunction areaPointFirst(lambda, phi) {\n  areaStream.point = areaPoint;\n  lambda00 = lambda, phi00 = phi;\n  lambda *= radians, phi *= radians;\n  lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);\n}\n\nfunction areaPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  phi = phi / 2 + quarterPi; // half the angular distance from south pole\n\n  // Spherical excess E for a spherical triangle with vertices: south pole,\n  // previous point, current point.  Uses a formula derived from Cagnolis\n  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n  var dLambda = lambda - lambda0,\n      sdLambda = dLambda >= 0 ? 1 : -1,\n      adLambda = sdLambda * dLambda,\n      cosPhi = cos(phi),\n      sinPhi = sin(phi),\n      k = sinPhi0 * sinPhi,\n      u = cosPhi0 * cosPhi + k * cos(adLambda),\n      v = k * sdLambda * sin(adLambda);\n  areaRingSum.add(atan2(v, u));\n\n  // Advance the previous points.\n  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;\n}\n\nexport default function(object) {\n  areaSum = new Adder();\n  stream(object, areaStream);\n  return areaSum * 2;\n}\n", "import {asin, atan2, cos, sin, sqrt} from \"./math.js\";\n\nexport function spherical(cartesian) {\n  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];\n}\n\nexport function cartesian(spherical) {\n  var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);\n  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];\n}\n\nexport function cartesianDot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\nexport function cartesianCross(a, b) {\n  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n}\n\n// TODO return a\nexport function cartesianAddInPlace(a, b) {\n  a[0] += b[0], a[1] += b[1], a[2] += b[2];\n}\n\nexport function cartesianScale(vector, k) {\n  return [vector[0] * k, vector[1] * k, vector[2] * k];\n}\n\n// TODO return d\nexport function cartesianNormalizeInPlace(d) {\n  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n  d[0] /= l, d[1] /= l, d[2] /= l;\n}\n", "import compose from \"./compose.js\";\nimport {abs, asin, atan2, cos, degrees, pi, radians, sin, tau} from \"./math.js\";\n\nfunction rotationIdentity(lambda, phi) {\n  if (abs(lambda) > pi) lambda -= Math.round(lambda / tau) * tau;\n  return [lambda, phi];\n}\n\nrotationIdentity.invert = rotationIdentity;\n\nexport function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n  return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))\n    : rotationLambda(deltaLambda))\n    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)\n    : rotationIdentity);\n}\n\nfunction forwardRotationLambda(deltaLambda) {\n  return function(lambda, phi) {\n    lambda += deltaLambda;\n    if (abs(lambda) > pi) lambda -= Math.round(lambda / tau) * tau;\n    return [lambda, phi];\n  };\n}\n\nfunction rotationLambda(deltaLambda) {\n  var rotation = forwardRotationLambda(deltaLambda);\n  rotation.invert = forwardRotationLambda(-deltaLambda);\n  return rotation;\n}\n\nfunction rotationPhiGamma(deltaPhi, deltaGamma) {\n  var cosDeltaPhi = cos(deltaPhi),\n      sinDeltaPhi = sin(deltaPhi),\n      cosDeltaGamma = cos(deltaGamma),\n      sinDeltaGamma = sin(deltaGamma);\n\n  function rotation(lambda, phi) {\n    var cosPhi = cos(phi),\n        x = cos(lambda) * cosPhi,\n        y = sin(lambda) * cosPhi,\n        z = sin(phi),\n        k = z * cosDeltaPhi + x * sinDeltaPhi;\n    return [\n      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),\n      asin(k * cosDeltaGamma + y * sinDeltaGamma)\n    ];\n  }\n\n  rotation.invert = function(lambda, phi) {\n    var cosPhi = cos(phi),\n        x = cos(lambda) * cosPhi,\n        y = sin(lambda) * cosPhi,\n        z = sin(phi),\n        k = z * cosDeltaGamma - y * sinDeltaGamma;\n    return [\n      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),\n      asin(k * cosDeltaPhi - x * sinDeltaPhi)\n    ];\n  };\n\n  return rotation;\n}\n\nexport default function(rotate) {\n  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);\n\n  function forward(coordinates) {\n    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);\n    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n  }\n\n  forward.invert = function(coordinates) {\n    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);\n    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n  };\n\n  return forward;\n}\n", "import noop from \"../noop.js\";\n\nexport default function() {\n  var lines = [],\n      line;\n  return {\n    point: function(x, y, m) {\n      line.push([x, y, m]);\n    },\n    lineStart: function() {\n      lines.push(line = []);\n    },\n    lineEnd: noop,\n    rejoin: function() {\n      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n    },\n    result: function() {\n      var result = lines;\n      lines = [];\n      line = null;\n      return result;\n    }\n  };\n}\n", "import {abs, epsilon} from \"./math.js\";\n\nexport default function(a, b) {\n  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n}\n", "import pointEqual from \"../pointEqual.js\";\nimport {epsilon} from \"../math.js\";\n\nfunction Intersection(point, points, other, entry) {\n  this.x = point;\n  this.z = points;\n  this.o = other; // another intersection\n  this.e = entry; // is an entry?\n  this.v = false; // visited\n  this.n = this.p = null; // next & previous\n}\n\n// A generalized polygon clipping algorithm: given a polygon that has been cut\n// into its visible line segments, and rejoins the segments by interpolating\n// along the clip edge.\nexport default function(segments, compareIntersection, startInside, interpolate, stream) {\n  var subject = [],\n      clip = [],\n      i,\n      n;\n\n  segments.forEach(function(segment) {\n    if ((n = segment.length - 1) <= 0) return;\n    var n, p0 = segment[0], p1 = segment[n], x;\n\n    if (pointEqual(p0, p1)) {\n      if (!p0[2] && !p1[2]) {\n        stream.lineStart();\n        for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);\n        stream.lineEnd();\n        return;\n      }\n      // handle degenerate cases by moving the point\n      p1[0] += 2 * epsilon;\n    }\n\n    subject.push(x = new Intersection(p0, segment, null, true));\n    clip.push(x.o = new Intersection(p0, null, x, false));\n    subject.push(x = new Intersection(p1, segment, null, false));\n    clip.push(x.o = new Intersection(p1, null, x, true));\n  });\n\n  if (!subject.length) return;\n\n  clip.sort(compareIntersection);\n  link(subject);\n  link(clip);\n\n  for (i = 0, n = clip.length; i < n; ++i) {\n    clip[i].e = startInside = !startInside;\n  }\n\n  var start = subject[0],\n      points,\n      point;\n\n  while (1) {\n    // Find first unvisited intersection.\n    var current = start,\n        isSubject = true;\n    while (current.v) if ((current = current.n) === start) return;\n    points = current.z;\n    stream.lineStart();\n    do {\n      current.v = current.o.v = true;\n      if (current.e) {\n        if (isSubject) {\n          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);\n        } else {\n          interpolate(current.x, current.n.x, 1, stream);\n        }\n        current = current.n;\n      } else {\n        if (isSubject) {\n          points = current.p.z;\n          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);\n        } else {\n          interpolate(current.x, current.p.x, -1, stream);\n        }\n        current = current.p;\n      }\n      current = current.o;\n      points = current.z;\n      isSubject = !isSubject;\n    } while (!current.v);\n    stream.lineEnd();\n  }\n}\n\nfunction link(array) {\n  if (!(n = array.length)) return;\n  var n,\n      i = 0,\n      a = array[0],\n      b;\n  while (++i < n) {\n    a.n = b = array[i];\n    b.p = a;\n    a = b;\n  }\n  a.n = b = array[0];\n  b.p = a;\n}\n", "import {Adder} from \"d3-array\";\nimport {cartesian, cartesianCross, cartesianNormalizeInPlace} from \"./cartesian.js\";\nimport {abs, asin, atan2, cos, epsilon, epsilon2, halfPi, pi, quarterPi, sign, sin, tau} from \"./math.js\";\n\nfunction longitude(point) {\n  return abs(point[0]) <= pi ? point[0] : sign(point[0]) * ((abs(point[0]) + pi) % tau - pi);\n}\n\nexport default function(polygon, point) {\n  var lambda = longitude(point),\n      phi = point[1],\n      sinPhi = sin(phi),\n      normal = [sin(lambda), -cos(lambda), 0],\n      angle = 0,\n      winding = 0;\n\n  var sum = new Adder();\n\n  if (sinPhi === 1) phi = halfPi + epsilon;\n  else if (sinPhi === -1) phi = -halfPi - epsilon;\n\n  for (var i = 0, n = polygon.length; i < n; ++i) {\n    if (!(m = (ring = polygon[i]).length)) continue;\n    var ring,\n        m,\n        point0 = ring[m - 1],\n        lambda0 = longitude(point0),\n        phi0 = point0[1] / 2 + quarterPi,\n        sinPhi0 = sin(phi0),\n        cosPhi0 = cos(phi0);\n\n    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n      var point1 = ring[j],\n          lambda1 = longitude(point1),\n          phi1 = point1[1] / 2 + quarterPi,\n          sinPhi1 = sin(phi1),\n          cosPhi1 = cos(phi1),\n          delta = lambda1 - lambda0,\n          sign = delta >= 0 ? 1 : -1,\n          absDelta = sign * delta,\n          antimeridian = absDelta > pi,\n          k = sinPhi0 * sinPhi1;\n\n      sum.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));\n      angle += antimeridian ? delta + sign * tau : delta;\n\n      // Are the longitudes either side of the points meridian (lambda),\n      // and are the latitudes smaller than the parallel (phi)?\n      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n        var arc = cartesianCross(cartesian(point0), cartesian(point1));\n        cartesianNormalizeInPlace(arc);\n        var intersection = cartesianCross(normal, arc);\n        cartesianNormalizeInPlace(intersection);\n        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);\n        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n          winding += antimeridian ^ delta >= 0 ? 1 : -1;\n        }\n      }\n    }\n  }\n\n  // First, determine whether the South pole is inside or outside:\n  //\n  // It is inside if:\n  // * the polygon winds around it in a clockwise direction.\n  // * the polygon does not (cumulatively) wind around it, but has a negative\n  //   (counter-clockwise) area.\n  //\n  // Second, count the (signed) number of times a segment crosses a lambda\n  // from the point to the South pole.  If it is zero, then the point is the\n  // same side as the South pole.\n\n  return (angle < -epsilon || angle < epsilon && sum < -epsilon2) ^ (winding & 1);\n}\n", "import clipBuffer from \"./buffer.js\";\nimport clipRejoin from \"./rejoin.js\";\nimport {epsilon, halfPi} from \"../math.js\";\nimport polygonContains from \"../polygonContains.js\";\nimport {merge} from \"d3-array\";\n\nexport default function(pointVisible, clipLine, interpolate, start) {\n  return function(sink) {\n    var line = clipLine(sink),\n        ringBuffer = clipBuffer(),\n        ringSink = clipLine(ringBuffer),\n        polygonStarted = false,\n        polygon,\n        segments,\n        ring;\n\n    var clip = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function() {\n        clip.point = point;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge(segments);\n        var startInside = polygonContains(polygon, start);\n        if (segments.length) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function() {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n\n    function point(lambda, phi) {\n      if (pointVisible(lambda, phi)) sink.point(lambda, phi);\n    }\n\n    function pointLine(lambda, phi) {\n      line.point(lambda, phi);\n    }\n\n    function lineStart() {\n      clip.point = pointLine;\n      line.lineStart();\n    }\n\n    function lineEnd() {\n      clip.point = point;\n      line.lineEnd();\n    }\n\n    function pointRing(lambda, phi) {\n      ring.push([lambda, phi]);\n      ringSink.point(lambda, phi);\n    }\n\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n\n      var clean = ringSink.clean(),\n          ringSegments = ringBuffer.result(),\n          i, n = ringSegments.length, m,\n          segment,\n          point;\n\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n\n      if (!n) return;\n\n      // No intersections.\n      if (clean & 1) {\n        segment = ringSegments[0];\n        if ((m = segment.length - 1) > 0) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\n          sink.lineEnd();\n        }\n        return;\n      }\n\n      // Rejoin connected segments.\n      // TODO reuse ringBuffer.rejoin()?\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n\n      segments.push(ringSegments.filter(validSegment));\n    }\n\n    return clip;\n  };\n}\n\nfunction validSegment(segment) {\n  return segment.length > 1;\n}\n\n// Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\nfunction compareIntersection(a, b) {\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])\n       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n}\n", "import clip from \"./index.js\";\nimport {abs, atan, cos, epsilon, halfPi, pi, sin} from \"../math.js\";\n\nexport default clip(\n  function() { return true; },\n  clipAntimeridianLine,\n  clipAntimeridianInterpolate,\n  [-pi, -halfPi]\n);\n\n// Takes a line and cuts into visible segments. Return values: 0 - there were\n// intersections or the line was empty; 1 - no intersections; 2 - there were\n// intersections, and the first and last segments should be rejoined.\nfunction clipAntimeridianLine(stream) {\n  var lambda0 = NaN,\n      phi0 = NaN,\n      sign0 = NaN,\n      clean; // no intersections\n\n  return {\n    lineStart: function() {\n      stream.lineStart();\n      clean = 1;\n    },\n    point: function(lambda1, phi1) {\n      var sign1 = lambda1 > 0 ? pi : -pi,\n          delta = abs(lambda1 - lambda0);\n      if (abs(delta - pi) < epsilon) { // line crosses a pole\n        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        stream.point(lambda1, phi0);\n        clean = 0;\n      } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian\n        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies\n        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;\n        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        clean = 0;\n      }\n      stream.point(lambda0 = lambda1, phi0 = phi1);\n      sign0 = sign1;\n    },\n    lineEnd: function() {\n      stream.lineEnd();\n      lambda0 = phi0 = NaN;\n    },\n    clean: function() {\n      return 2 - clean; // if intersections, rejoin first and last segments\n    }\n  };\n}\n\nfunction clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n  var cosPhi0,\n      cosPhi1,\n      sinLambda0Lambda1 = sin(lambda0 - lambda1);\n  return abs(sinLambda0Lambda1) > epsilon\n      ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)\n          - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))\n          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))\n      : (phi0 + phi1) / 2;\n}\n\nfunction clipAntimeridianInterpolate(from, to, direction, stream) {\n  var phi;\n  if (from == null) {\n    phi = direction * halfPi;\n    stream.point(-pi, phi);\n    stream.point(0, phi);\n    stream.point(pi, phi);\n    stream.point(pi, 0);\n    stream.point(pi, -phi);\n    stream.point(0, -phi);\n    stream.point(-pi, -phi);\n    stream.point(-pi, 0);\n    stream.point(-pi, phi);\n  } else if (abs(from[0] - to[0]) > epsilon) {\n    var lambda = from[0] < to[0] ? pi : -pi;\n    phi = direction * lambda / 2;\n    stream.point(-lambda, phi);\n    stream.point(0, phi);\n    stream.point(lambda, phi);\n  } else {\n    stream.point(to[0], to[1]);\n  }\n}\n", "import {abs, epsilon} from \"../math.js\";\nimport clipBuffer from \"./buffer.js\";\nimport clipLine from \"./line.js\";\nimport clipRejoin from \"./rejoin.js\";\nimport {merge} from \"d3-array\";\n\nvar clipMax = 1e9, clipMin = -clipMax;\n\n// TODO Use d3-polygons polygonContains here for the ring check?\n// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n\nexport default function clipRectangle(x0, y0, x1, y1) {\n\n  function visible(x, y) {\n    return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n  }\n\n  function interpolate(from, to, direction, stream) {\n    var a = 0, a1 = 0;\n    if (from == null\n        || (a = corner(from, direction)) !== (a1 = corner(to, direction))\n        || comparePoint(from, to) < 0 ^ direction > 0) {\n      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n      while ((a = (a + direction + 4) % 4) !== a1);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n\n  function corner(p, direction) {\n    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3\n        : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1\n        : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0\n        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n  }\n\n  function compareIntersection(a, b) {\n    return comparePoint(a.x, b.x);\n  }\n\n  function comparePoint(a, b) {\n    var ca = corner(a, 1),\n        cb = corner(b, 1);\n    return ca !== cb ? ca - cb\n        : ca === 0 ? b[1] - a[1]\n        : ca === 1 ? a[0] - b[0]\n        : ca === 2 ? a[1] - b[1]\n        : b[0] - a[0];\n  }\n\n  return function(stream) {\n    var activeStream = stream,\n        bufferStream = clipBuffer(),\n        segments,\n        polygon,\n        ring,\n        x__, y__, v__, // first point\n        x_, y_, v_, // previous point\n        first,\n        clean;\n\n    var clipStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: polygonStart,\n      polygonEnd: polygonEnd\n    };\n\n    function point(x, y) {\n      if (visible(x, y)) activeStream.point(x, y);\n    }\n\n    function polygonInside() {\n      var winding = 0;\n\n      for (var i = 0, n = polygon.length; i < n; ++i) {\n        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }\n          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }\n        }\n      }\n\n      return winding;\n    }\n\n    // Buffer geometry within a polygon and then clip it en masse.\n    function polygonStart() {\n      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n    }\n\n    function polygonEnd() {\n      var startInside = polygonInside(),\n          cleanInside = clean && startInside,\n          visible = (segments = merge(segments)).length;\n      if (cleanInside || visible) {\n        stream.polygonStart();\n        if (cleanInside) {\n          stream.lineStart();\n          interpolate(null, null, 1, stream);\n          stream.lineEnd();\n        }\n        if (visible) {\n          clipRejoin(segments, compareIntersection, startInside, interpolate, stream);\n        }\n        stream.polygonEnd();\n      }\n      activeStream = stream, segments = polygon = ring = null;\n    }\n\n    function lineStart() {\n      clipStream.point = linePoint;\n      if (polygon) polygon.push(ring = []);\n      first = true;\n      v_ = false;\n      x_ = y_ = NaN;\n    }\n\n    // TODO rather than special-case polygons, simply handle them separately.\n    // Ideally, coincident intersection points should be jittered to avoid\n    // clipping issues.\n    function lineEnd() {\n      if (segments) {\n        linePoint(x__, y__);\n        if (v__ && v_) bufferStream.rejoin();\n        segments.push(bufferStream.result());\n      }\n      clipStream.point = point;\n      if (v_) activeStream.lineEnd();\n    }\n\n    function linePoint(x, y) {\n      var v = visible(x, y);\n      if (polygon) ring.push([x, y]);\n      if (first) {\n        x__ = x, y__ = y, v__ = v;\n        first = false;\n        if (v) {\n          activeStream.lineStart();\n          activeStream.point(x, y);\n        }\n      } else {\n        if (v && v_) activeStream.point(x, y);\n        else {\n          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n          if (clipLine(a, b, x0, y0, x1, y1)) {\n            if (!v_) {\n              activeStream.lineStart();\n              activeStream.point(a[0], a[1]);\n            }\n            activeStream.point(b[0], b[1]);\n            if (!v) activeStream.lineEnd();\n            clean = false;\n          } else if (v) {\n            activeStream.lineStart();\n            activeStream.point(x, y);\n            clean = false;\n          }\n        }\n      }\n      x_ = x, y_ = y, v_ = v;\n    }\n\n    return clipStream;\n  };\n}\n", "import {Adder} from \"d3-array\";\nimport {abs} from \"../math.js\";\nimport noop from \"../noop.js\";\n\nvar areaSum = new Adder(),\n    areaRingSum = new Adder(),\n    x00,\n    y00,\n    x0,\n    y0;\n\nvar areaStream = {\n  point: noop,\n  lineStart: noop,\n  lineEnd: noop,\n  polygonStart: function() {\n    areaStream.lineStart = areaRingStart;\n    areaStream.lineEnd = areaRingEnd;\n  },\n  polygonEnd: function() {\n    areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop;\n    areaSum.add(abs(areaRingSum));\n    areaRingSum = new Adder();\n  },\n  result: function() {\n    var area = areaSum / 2;\n    areaSum = new Adder();\n    return area;\n  }\n};\n\nfunction areaRingStart() {\n  areaStream.point = areaPointFirst;\n}\n\nfunction areaPointFirst(x, y) {\n  areaStream.point = areaPoint;\n  x00 = x0 = x, y00 = y0 = y;\n}\n\nfunction areaPoint(x, y) {\n  areaRingSum.add(y0 * x - x0 * y);\n  x0 = x, y0 = y;\n}\n\nfunction areaRingEnd() {\n  areaPoint(x00, y00);\n}\n\nexport default areaStream;\n", "import noop from \"../noop.js\";\n\nvar x0 = Infinity,\n    y0 = x0,\n    x1 = -x0,\n    y1 = x1;\n\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: noop,\n  lineEnd: noop,\n  polygonStart: noop,\n  polygonEnd: noop,\n  result: function() {\n    var bounds = [[x0, y0], [x1, y1]];\n    x1 = y1 = -(y0 = x0 = Infinity);\n    return bounds;\n  }\n};\n\nfunction boundsPoint(x, y) {\n  if (x < x0) x0 = x;\n  if (x > x1) x1 = x;\n  if (y < y0) y0 = y;\n  if (y > y1) y1 = y;\n}\n\nexport default boundsStream;\n", "import {tau} from \"../math.js\";\nimport noop from \"../noop.js\";\n\nexport default function PathContext(context) {\n  this._context = context;\n}\n\nPathContext.prototype = {\n  _radius: 4.5,\n  pointRadius: function(_) {\n    return this._radius = _, this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line === 0) this._context.closePath();\n    this._point = NaN;\n  },\n  point: function(x, y) {\n    switch (this._point) {\n      case 0: {\n        this._context.moveTo(x, y);\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._context.lineTo(x, y);\n        break;\n      }\n      default: {\n        this._context.moveTo(x + this._radius, y);\n        this._context.arc(x, y, this._radius, 0, tau);\n        break;\n      }\n    }\n  },\n  result: noop\n};\n", "import {Adder} from \"d3-array\";\nimport {sqrt} from \"../math.js\";\nimport noop from \"../noop.js\";\n\nvar lengthSum = new Adder(),\n    lengthRing,\n    x00,\n    y00,\n    x0,\n    y0;\n\nvar lengthStream = {\n  point: noop,\n  lineStart: function() {\n    lengthStream.point = lengthPointFirst;\n  },\n  lineEnd: function() {\n    if (lengthRing) lengthPoint(x00, y00);\n    lengthStream.point = noop;\n  },\n  polygonStart: function() {\n    lengthRing = true;\n  },\n  polygonEnd: function() {\n    lengthRing = null;\n  },\n  result: function() {\n    var length = +lengthSum;\n    lengthSum = new Adder();\n    return length;\n  }\n};\n\nfunction lengthPointFirst(x, y) {\n  lengthStream.point = lengthPoint;\n  x00 = x0 = x, y00 = y0 = y;\n}\n\nfunction lengthPoint(x, y) {\n  x0 -= x, y0 -= y;\n  lengthSum.add(sqrt(x0 * x0 + y0 * y0));\n  x0 = x, y0 = y;\n}\n\nexport default lengthStream;\n", "export default function(methods) {\n  return {\n    stream: transformer(methods)\n  };\n}\n\nexport function transformer(methods) {\n  return function(stream) {\n    var s = new TransformStream;\n    for (var key in methods) s[key] = methods[key];\n    s.stream = stream;\n    return s;\n  };\n}\n\nfunction TransformStream() {}\n\nTransformStream.prototype = {\n  constructor: TransformStream,\n  point: function(x, y) { this.stream.point(x, y); },\n  sphere: function() { this.stream.sphere(); },\n  lineStart: function() { this.stream.lineStart(); },\n  lineEnd: function() { this.stream.lineEnd(); },\n  polygonStart: function() { this.stream.polygonStart(); },\n  polygonEnd: function() { this.stream.polygonEnd(); }\n};\n", "import {cartesian} from \"../cartesian.js\";\nimport {abs, asin, atan2, cos, epsilon, radians, sqrt} from \"../math.js\";\nimport {transformer} from \"../transform.js\";\n\nvar maxDepth = 16, // maximum depth of subdivision\n    cosMinDistance = cos(30 * radians); // cos(minimum angular distance)\n\nexport default function(project, delta2) {\n  return +delta2 ? resample(project, delta2) : resampleNone(project);\n}\n\nfunction resampleNone(project) {\n  return transformer({\n    point: function(x, y) {\n      x = project(x, y);\n      this.stream.point(x[0], x[1]);\n    }\n  });\n}\n\nfunction resample(project, delta2) {\n\n  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {\n    var dx = x1 - x0,\n        dy = y1 - y0,\n        d2 = dx * dx + dy * dy;\n    if (d2 > 4 * delta2 && depth--) {\n      var a = a0 + a1,\n          b = b0 + b1,\n          c = c0 + c1,\n          m = sqrt(a * a + b * b + c * c),\n          phi2 = asin(c /= m),\n          lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),\n          p = project(lambda2, phi2),\n          x2 = p[0],\n          y2 = p[1],\n          dx2 = x2 - x0,\n          dy2 = y2 - y0,\n          dz = dy * dx2 - dx * dy2;\n      if (dz * dz / d2 > delta2 // perpendicular projected distance\n          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end\n          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance\n        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);\n        stream.point(x2, y2);\n        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);\n      }\n    }\n  }\n  return function(stream) {\n    var lambda00, x00, y00, a00, b00, c00, // first point\n        lambda0, x0, y0, a0, b0, c0; // previous point\n\n    var resampleStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },\n      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }\n    };\n\n    function point(x, y) {\n      x = project(x, y);\n      stream.point(x[0], x[1]);\n    }\n\n    function lineStart() {\n      x0 = NaN;\n      resampleStream.point = linePoint;\n      stream.lineStart();\n    }\n\n    function linePoint(lambda, phi) {\n      var c = cartesian([lambda, phi]), p = project(lambda, phi);\n      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n      stream.point(x0, y0);\n    }\n\n    function lineEnd() {\n      resampleStream.point = point;\n      stream.lineEnd();\n    }\n\n    function ringStart() {\n      lineStart();\n      resampleStream.point = ringPoint;\n      resampleStream.lineEnd = ringEnd;\n    }\n\n    function ringPoint(lambda, phi) {\n      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n      resampleStream.point = linePoint;\n    }\n\n    function ringEnd() {\n      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);\n      resampleStream.lineEnd = lineEnd;\n      lineEnd();\n    }\n\n    return resampleStream;\n  };\n}\n", "import clipAntimeridian from \"../clip/antimeridian.js\";\nimport clipCircle from \"../clip/circle.js\";\nimport clipRectangle from \"../clip/rectangle.js\";\nimport compose from \"../compose.js\";\nimport identity from \"../identity.js\";\nimport {cos, degrees, radians, sin, sqrt} from \"../math.js\";\nimport {rotateRadians} from \"../rotation.js\";\nimport {transformer} from \"../transform.js\";\nimport {fitExtent, fitSize, fitWidth, fitHeight} from \"./fit.js\";\nimport resample from \"./resample.js\";\n\nvar transformRadians = transformer({\n  point: function(x, y) {\n    this.stream.point(x * radians, y * radians);\n  }\n});\n\nfunction transformRotate(rotate) {\n  return transformer({\n    point: function(x, y) {\n      var r = rotate(x, y);\n      return this.stream.point(r[0], r[1]);\n    }\n  });\n}\n\nfunction scaleTranslate(k, dx, dy, sx, sy) {\n  function transform(x, y) {\n    x *= sx; y *= sy;\n    return [dx + k * x, dy - k * y];\n  }\n  transform.invert = function(x, y) {\n    return [(x - dx) / k * sx, (dy - y) / k * sy];\n  };\n  return transform;\n}\n\nfunction scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {\n  if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);\n  var cosAlpha = cos(alpha),\n      sinAlpha = sin(alpha),\n      a = cosAlpha * k,\n      b = sinAlpha * k,\n      ai = cosAlpha / k,\n      bi = sinAlpha / k,\n      ci = (sinAlpha * dy - cosAlpha * dx) / k,\n      fi = (sinAlpha * dx + cosAlpha * dy) / k;\n  function transform(x, y) {\n    x *= sx; y *= sy;\n    return [a * x - b * y + dx, dy - b * x - a * y];\n  }\n  transform.invert = function(x, y) {\n    return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];\n  };\n  return transform;\n}\n\nexport default function projection(project) {\n  return projectionMutator(function() { return project; })();\n}\n\nexport function projectionMutator(projectAt) {\n  var project,\n      k = 150, // scale\n      x = 480, y = 250, // translate\n      lambda = 0, phi = 0, // center\n      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate\n      alpha = 0, // post-rotate angle\n      sx = 1, // reflectX\n      sy = 1, // reflectX\n      theta = null, preclip = clipAntimeridian, // pre-clip angle\n      x0 = null, y0, x1, y1, postclip = identity, // post-clip extent\n      delta2 = 0.5, // precision\n      projectResample,\n      projectTransform,\n      projectRotateTransform,\n      cache,\n      cacheStream;\n\n  function projection(point) {\n    return projectRotateTransform(point[0] * radians, point[1] * radians);\n  }\n\n  function invert(point) {\n    point = projectRotateTransform.invert(point[0], point[1]);\n    return point && [point[0] * degrees, point[1] * degrees];\n  }\n\n  projection.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));\n  };\n\n  projection.preclip = function(_) {\n    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;\n  };\n\n  projection.postclip = function(_) {\n    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;\n  };\n\n  projection.clipAngle = function(_) {\n    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;\n  };\n\n  projection.clipExtent = function(_) {\n    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n  };\n\n  projection.scale = function(_) {\n    return arguments.length ? (k = +_, recenter()) : k;\n  };\n\n  projection.translate = function(_) {\n    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];\n  };\n\n  projection.center = function(_) {\n    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];\n  };\n\n  projection.rotate = function(_) {\n    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];\n  };\n\n  projection.angle = function(_) {\n    return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;\n  };\n\n  projection.reflectX = function(_) {\n    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;\n  };\n\n  projection.reflectY = function(_) {\n    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;\n  };\n\n  projection.precision = function(_) {\n    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);\n  };\n\n  projection.fitExtent = function(extent, object) {\n    return fitExtent(projection, extent, object);\n  };\n\n  projection.fitSize = function(size, object) {\n    return fitSize(projection, size, object);\n  };\n\n  projection.fitWidth = function(width, object) {\n    return fitWidth(projection, width, object);\n  };\n\n  projection.fitHeight = function(height, object) {\n    return fitHeight(projection, height, object);\n  };\n\n  function recenter() {\n    var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),\n        transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);\n    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);\n    projectTransform = compose(project, transform);\n    projectRotateTransform = compose(rotate, projectTransform);\n    projectResample = resample(projectTransform, delta2);\n    return reset();\n  }\n\n  function reset() {\n    cache = cacheStream = null;\n    return projection;\n  }\n\n  return function() {\n    project = projectAt.apply(this, arguments);\n    projection.invert = project.invert && invert;\n    return recenter();\n  };\n}\n", "import {asin, atan2, cos, sin, sqrt} from \"../math.js\";\n\nexport function azimuthalRaw(scale) {\n  return function(x, y) {\n    var cx = cos(x),\n        cy = cos(y),\n        k = scale(cx * cy);\n        if (k === Infinity) return [2, 0];\n    return [\n      k * cy * sin(x),\n      k * sin(y)\n    ];\n  }\n}\n\nexport function azimuthalInvert(angle) {\n  return function(x, y) {\n    var z = sqrt(x * x + y * y),\n        c = angle(z),\n        sc = sin(c),\n        cc = cos(c);\n    return [\n      atan2(x * sc, z * cc),\n      asin(z && y * sc / z)\n    ];\n  }\n}\n", "import {asin, sqrt} from \"../math.js\";\nimport {azimuthalRaw, azimuthalInvert} from \"./azimuthal.js\";\nimport projection from \"./index.js\";\n\nexport var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {\n  return sqrt(2 / (1 + cxcy));\n});\n\nazimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {\n  return 2 * asin(z / 2);\n});\n\nexport default function() {\n  return projection(azimuthalEqualAreaRaw)\n      .scale(124.75)\n      .clipAngle(180 - 1e-3);\n}\n", "import {acos, sin} from \"../math.js\";\nimport {azimuthalRaw, azimuthalInvert} from \"./azimuthal.js\";\nimport projection from \"./index.js\";\n\nexport var azimuthalEquidistantRaw = azimuthalRaw(function(c) {\n  return (c = acos(c)) && c / sin(c);\n});\n\nazimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {\n  return z;\n});\n\nexport default function() {\n  return projection(azimuthalEquidistantRaw)\n      .scale(79.4188)\n      .clipAngle(180 - 1e-3);\n}\n", "import {atan, exp, halfPi, log, pi, tan, tau} from \"../math.js\";\nimport rotation from \"../rotation.js\";\nimport projection from \"./index.js\";\n\nexport function mercatorRaw(lambda, phi) {\n  return [lambda, log(tan((halfPi + phi) / 2))];\n}\n\nmercatorRaw.invert = function(x, y) {\n  return [x, 2 * atan(exp(y)) - halfPi];\n};\n\nexport default function() {\n  return mercatorProjection(mercatorRaw)\n      .scale(961 / tau);\n}\n\nexport function mercatorProjection(project) {\n  var m = projection(project),\n      center = m.center,\n      scale = m.scale,\n      translate = m.translate,\n      clipExtent = m.clipExtent,\n      x0 = null, y0, x1, y1; // clip extent\n\n  m.scale = function(_) {\n    return arguments.length ? (scale(_), reclip()) : scale();\n  };\n\n  m.translate = function(_) {\n    return arguments.length ? (translate(_), reclip()) : translate();\n  };\n\n  m.center = function(_) {\n    return arguments.length ? (center(_), reclip()) : center();\n  };\n\n  m.clipExtent = function(_) {\n    return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n  };\n\n  function reclip() {\n    var k = pi * scale(),\n        t = m(rotation(m.rotate()).invert([0, 0]));\n    return clipExtent(x0 == null\n        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw\n        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]\n        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);\n  }\n\n  return reclip();\n}\n", "import projection from \"./index.js\";\n\nexport function equirectangularRaw(lambda, phi) {\n  return [lambda, phi];\n}\n\nequirectangularRaw.invert = equirectangularRaw;\n\nexport default function() {\n  return projection(equirectangularRaw)\n      .scale(152.63);\n}\n", "import projection from \"./index.js\";\nimport {abs, asin, cos, epsilon2, sin, sqrt} from \"../math.js\";\n\nvar A1 = 1.340264,\n    A2 = -0.081106,\n    A3 = 0.000893,\n    A4 = 0.003796,\n    M = sqrt(3) / 2,\n    iterations = 12;\n\nexport function equalEarthRaw(lambda, phi) {\n  var l = asin(M * sin(phi)), l2 = l * l, l6 = l2 * l2 * l2;\n  return [\n    lambda * cos(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),\n    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))\n  ];\n}\n\nequalEarthRaw.invert = function(x, y) {\n  var l = y, l2 = l * l, l6 = l2 * l2 * l2;\n  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {\n    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;\n    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);\n    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;\n    if (abs(delta) < epsilon2) break;\n  }\n  return [\n    M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos(l),\n    asin(sin(l) / M)\n  ];\n};\n\nexport default function() {\n  return projection(equalEarthRaw)\n      .scale(177.158);\n}\n", "import {atan, cos, sin} from \"../math.js\";\nimport {azimuthalInvert} from \"./azimuthal.js\";\nimport projection from \"./index.js\";\n\nexport function gnomonicRaw(x, y) {\n  var cy = cos(y), k = cos(x) * cy;\n  return [cy * sin(x) / k, sin(y) / k];\n}\n\ngnomonicRaw.invert = azimuthalInvert(atan);\n\nexport default function() {\n  return projection(gnomonicRaw)\n      .scale(144.049)\n      .clipAngle(60);\n}\n", "import projection from \"./index.js\";\nimport {abs, epsilon} from \"../math.js\";\n\nexport function naturalEarth1Raw(lambda, phi) {\n  var phi2 = phi * phi, phi4 = phi2 * phi2;\n  return [\n    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),\n    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))\n  ];\n}\n\nnaturalEarth1Raw.invert = function(x, y) {\n  var phi = y, i = 25, delta;\n  do {\n    var phi2 = phi * phi, phi4 = phi2 * phi2;\n    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /\n        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));\n  } while (abs(delta) > epsilon && --i > 0);\n  return [\n    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),\n    phi\n  ];\n};\n\nexport default function() {\n  return projection(naturalEarth1Raw)\n      .scale(175.295);\n}\n", "import {asin, cos, epsilon, sin} from \"../math.js\";\nimport {azimuthalInvert} from \"./azimuthal.js\";\nimport projection from \"./index.js\";\n\nexport function orthographicRaw(x, y) {\n  return [cos(y) * sin(x), sin(y)];\n}\n\northographicRaw.invert = azimuthalInvert(asin);\n\nexport default function() {\n  return projection(orthographicRaw)\n      .scale(249.5)\n      .clipAngle(90 + epsilon);\n}\n", "import {atan, cos, sin} from \"../math.js\";\nimport {azimuthalInvert} from \"./azimuthal.js\";\nimport projection from \"./index.js\";\n\nexport function stereographicRaw(x, y) {\n  var cy = cos(y), k = 1 + cos(x) * cy;\n  return [cy * sin(x) / k, sin(y) / k];\n}\n\nstereographicRaw.invert = azimuthalInvert(function(z) {\n  return 2 * atan(z);\n});\n\nexport default function() {\n  return projection(stereographicRaw)\n      .scale(250)\n      .clipAngle(142);\n}\n", "import {atan, exp, halfPi, log, tan} from \"../math.js\";\nimport {mercatorProjection} from \"./mercator.js\";\n\nexport function transverseMercatorRaw(lambda, phi) {\n  return [log(tan((halfPi + phi) / 2)), -lambda];\n}\n\ntransverseMercatorRaw.invert = function(x, y) {\n  return [-y, 2 * atan(exp(x)) - halfPi];\n};\n\nexport default function() {\n  var m = mercatorProjection(transverseMercatorRaw),\n      center = m.center,\n      rotate = m.rotate;\n\n  m.center = function(_) {\n    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);\n  };\n\n  m.rotate = function(_) {\n    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n  };\n\n  return rotate([0, 0, 90])\n      .scale(159.155);\n}\n", "function count(node) {\n  var sum = 0,\n      children = node.children,\n      i = children && children.length;\n  if (!i) sum = 1;\n  else while (--i >= 0) sum += children[i].value;\n  node.value = sum;\n}\n\nexport default function() {\n  return this.eachAfter(count);\n}\n", "export default function(callback, that) {\n  let index = -1;\n  for (const node of this) {\n    callback.call(that, node, ++index, this);\n  }\n  return this;\n}\n", "export default function(callback, that) {\n  var node = this, nodes = [node], children, i, index = -1;\n  while (node = nodes.pop()) {\n    callback.call(that, node, ++index, this);\n    if (children = node.children) {\n      for (i = children.length - 1; i >= 0; --i) {\n        nodes.push(children[i]);\n      }\n    }\n  }\n  return this;\n}\n", "export default function(callback, that) {\n  var node = this, nodes = [node], next = [], children, i, n, index = -1;\n  while (node = nodes.pop()) {\n    next.push(node);\n    if (children = node.children) {\n      for (i = 0, n = children.length; i < n; ++i) {\n        nodes.push(children[i]);\n      }\n    }\n  }\n  while (node = next.pop()) {\n    callback.call(that, node, ++index, this);\n  }\n  return this;\n}\n", "export default function(callback, that) {\n  let index = -1;\n  for (const node of this) {\n    if (callback.call(that, node, ++index, this)) {\n      return node;\n    }\n  }\n}\n", "export default function(value) {\n  return this.eachAfter(function(node) {\n    var sum = +value(node.data) || 0,\n        children = node.children,\n        i = children && children.length;\n    while (--i >= 0) sum += children[i].value;\n    node.value = sum;\n  });\n}\n", "export default function(compare) {\n  return this.eachBefore(function(node) {\n    if (node.children) {\n      node.children.sort(compare);\n    }\n  });\n}\n", "export default function(end) {\n  var start = this,\n      ancestor = leastCommonAncestor(start, end),\n      nodes = [start];\n  while (start !== ancestor) {\n    start = start.parent;\n    nodes.push(start);\n  }\n  var k = nodes.length;\n  while (end !== ancestor) {\n    nodes.splice(k, 0, end);\n    end = end.parent;\n  }\n  return nodes;\n}\n\nfunction leastCommonAncestor(a, b) {\n  if (a === b) return a;\n  var aNodes = a.ancestors(),\n      bNodes = b.ancestors(),\n      c = null;\n  a = aNodes.pop();\n  b = bNodes.pop();\n  while (a === b) {\n    c = a;\n    a = aNodes.pop();\n    b = bNodes.pop();\n  }\n  return c;\n}\n", "export default function() {\n  var node = this, nodes = [node];\n  while (node = node.parent) {\n    nodes.push(node);\n  }\n  return nodes;\n}\n", "export default function() {\n  return Array.from(this);\n}\n", "export default function() {\n  var leaves = [];\n  this.eachBefore(function(node) {\n    if (!node.children) {\n      leaves.push(node);\n    }\n  });\n  return leaves;\n}\n", "export default function() {\n  var root = this, links = [];\n  root.each(function(node) {\n    if (node !== root) { // Dont include the roots parent, if any.\n      links.push({source: node.parent, target: node});\n    }\n  });\n  return links;\n}\n", "export default function*() {\n  var node = this, current, next = [node], children, i, n;\n  do {\n    current = next.reverse(), next = [];\n    while (node = current.pop()) {\n      yield node;\n      if (children = node.children) {\n        for (i = 0, n = children.length; i < n; ++i) {\n          next.push(children[i]);\n        }\n      }\n    }\n  } while (next.length);\n}\n", "import node_count from \"./count.js\";\nimport node_each from \"./each.js\";\nimport node_eachBefore from \"./eachBefore.js\";\nimport node_eachAfter from \"./eachAfter.js\";\nimport node_find from \"./find.js\";\nimport node_sum from \"./sum.js\";\nimport node_sort from \"./sort.js\";\nimport node_path from \"./path.js\";\nimport node_ancestors from \"./ancestors.js\";\nimport node_descendants from \"./descendants.js\";\nimport node_leaves from \"./leaves.js\";\nimport node_links from \"./links.js\";\nimport node_iterator from \"./iterator.js\";\n\nexport default function hierarchy(data, children) {\n  if (data instanceof Map) {\n    data = [undefined, data];\n    if (children === undefined) children = mapChildren;\n  } else if (children === undefined) {\n    children = objectChildren;\n  }\n\n  var root = new Node(data),\n      node,\n      nodes = [root],\n      child,\n      childs,\n      i,\n      n;\n\n  while (node = nodes.pop()) {\n    if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {\n      node.children = childs;\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = childs[i] = new Node(childs[i]));\n        child.parent = node;\n        child.depth = node.depth + 1;\n      }\n    }\n  }\n\n  return root.eachBefore(computeHeight);\n}\n\nfunction node_copy() {\n  return hierarchy(this).eachBefore(copyData);\n}\n\nfunction objectChildren(d) {\n  return d.children;\n}\n\nfunction mapChildren(d) {\n  return Array.isArray(d) ? d[1] : null;\n}\n\nfunction copyData(node) {\n  if (node.data.value !== undefined) node.value = node.data.value;\n  node.data = node.data.data;\n}\n\nexport function computeHeight(node) {\n  var height = 0;\n  do node.height = height;\n  while ((node = node.parent) && (node.height < ++height));\n}\n\nexport function Node(data) {\n  this.data = data;\n  this.depth =\n  this.height = 0;\n  this.parent = null;\n}\n\nNode.prototype = hierarchy.prototype = {\n  constructor: Node,\n  count: node_count,\n  each: node_each,\n  eachAfter: node_eachAfter,\n  eachBefore: node_eachBefore,\n  find: node_find,\n  sum: node_sum,\n  sort: node_sort,\n  path: node_path,\n  ancestors: node_ancestors,\n  descendants: node_descendants,\n  leaves: node_leaves,\n  links: node_links,\n  copy: node_copy,\n  [Symbol.iterator]: node_iterator\n};\n", "export default function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      node,\n      i = -1,\n      n = nodes.length,\n      k = parent.value && (x1 - x0) / parent.value;\n\n  while (++i < n) {\n    node = nodes[i], node.y0 = y0, node.y1 = y1;\n    node.x0 = x0, node.x1 = x0 += node.value * k;\n  }\n}\n", "import {Node} from \"./hierarchy/index.js\";\n\nfunction defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n\n// function radialSeparation(a, b) {\n//   return (a.parent === b.parent ? 1 : 2) / a.depth;\n// }\n\n// This function is used to traverse the left contour of a subtree (or\n// subforest). It returns the successor of v on this contour. This successor is\n// either given by the leftmost child of v or by the thread of v. The function\n// returns null if and only if v is on the highest level of its subtree.\nfunction nextLeft(v) {\n  var children = v.children;\n  return children ? children[0] : v.t;\n}\n\n// This function works analogously to nextLeft.\nfunction nextRight(v) {\n  var children = v.children;\n  return children ? children[children.length - 1] : v.t;\n}\n\n// Shifts the current subtree rooted at w+. This is done by increasing\n// prelim(w+) and mod(w+) by shift.\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n}\n\n// All other shifts, applied to the smaller subtrees between w- and w+, are\n// performed by this function. To prepare the shifts, we have to adjust\n// change(w+), shift(w+), and change(w-).\nfunction executeShifts(v) {\n  var shift = 0,\n      change = 0,\n      children = v.children,\n      i = children.length,\n      w;\n  while (--i >= 0) {\n    w = children[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n}\n\n// If vi-s ancestor is a sibling of v, returns vi-s ancestor. Otherwise,\n// returns the specified (default) ancestor.\nfunction nextAncestor(vim, v, ancestor) {\n  return vim.a.parent === v.parent ? vim.a : ancestor;\n}\n\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null; // default ancestor\n  this.a = this; // ancestor\n  this.z = 0; // prelim\n  this.m = 0; // mod\n  this.c = 0; // change\n  this.s = 0; // shift\n  this.t = null; // thread\n  this.i = i; // number\n}\n\nTreeNode.prototype = Object.create(Node.prototype);\n\nfunction treeRoot(root) {\n  var tree = new TreeNode(root, 0),\n      node,\n      nodes = [tree],\n      child,\n      children,\n      i,\n      n;\n\n  while (node = nodes.pop()) {\n    if (children = node._.children) {\n      node.children = new Array(n = children.length);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n        child.parent = node;\n      }\n    }\n  }\n\n  (tree.parent = new TreeNode(null, 0)).children = [tree];\n  return tree;\n}\n\n// Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\nexport default function() {\n  var separation = defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = null;\n\n  function tree(root) {\n    var t = treeRoot(root);\n\n    // Compute the layout using Buchheim et al.s algorithm.\n    t.eachAfter(firstWalk), t.parent.m = -t.z;\n    t.eachBefore(secondWalk);\n\n    // If a fixed node size is specified, scale x and y.\n    if (nodeSize) root.eachBefore(sizeNode);\n\n    // If a fixed tree size is specified, scale x and y based on the extent.\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    else {\n      var left = root,\n          right = root,\n          bottom = root;\n      root.eachBefore(function(node) {\n        if (node.x < left.x) left = node;\n        if (node.x > right.x) right = node;\n        if (node.depth > bottom.depth) bottom = node;\n      });\n      var s = left === right ? 1 : separation(left, right) / 2,\n          tx = s - left.x,\n          kx = dx / (right.x + s + tx),\n          ky = dy / (bottom.depth || 1);\n      root.eachBefore(function(node) {\n        node.x = (node.x + tx) * kx;\n        node.y = node.depth * ky;\n      });\n    }\n\n    return root;\n  }\n\n  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n  // applied recursively to the children of v, as well as the function\n  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n  // node v is placed to the midpoint of its outermost children.\n  function firstWalk(v) {\n    var children = v.children,\n        siblings = v.parent.children,\n        w = v.i ? siblings[v.i - 1] : null;\n    if (children) {\n      executeShifts(v);\n      var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n      if (w) {\n        v.z = w.z + separation(v._, w._);\n        v.m = v.z - midpoint;\n      } else {\n        v.z = midpoint;\n      }\n    } else if (w) {\n      v.z = w.z + separation(v._, w._);\n    }\n    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n  }\n\n  // Computes all real x-coordinates by summing up the modifiers recursively.\n  function secondWalk(v) {\n    v._.x = v.z + v.parent.m;\n    v.m += v.parent.m;\n  }\n\n  // The core of the algorithm. Here, a new subtree is combined with the\n  // previous subtrees. Threads are used to traverse the inside and outside\n  // contours of the left and right subtree up to the highest common level. The\n  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n  // superscript o means outside and i means inside, the subscript - means left\n  // subtree and + means right subtree. For summing up the modifiers along the\n  // contour, we use respective variables si+, si-, so-, and so+. Whenever two\n  // nodes of the inside contours conflict, we compute the left one of the\n  // greatest uncommon ancestors using the function ANCESTOR and call MOVE\n  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n  // Finally, we add a new thread (if necessary).\n  function apportion(v, w, ancestor) {\n    if (w) {\n      var vip = v,\n          vop = v,\n          vim = w,\n          vom = vip.parent.children[0],\n          sip = vip.m,\n          sop = vop.m,\n          sim = vim.m,\n          som = vom.m,\n          shift;\n      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n          sip += shift;\n          sop += shift;\n        }\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v;\n      }\n    }\n    return ancestor;\n  }\n\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n\n  tree.separation = function(x) {\n    return arguments.length ? (separation = x, tree) : separation;\n  };\n\n  tree.size = function(x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);\n  };\n\n  tree.nodeSize = function(x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);\n  };\n\n  return tree;\n}\n", "export default function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      node,\n      i = -1,\n      n = nodes.length,\n      k = parent.value && (y1 - y0) / parent.value;\n\n  while (++i < n) {\n    node = nodes[i], node.x0 = x0, node.x1 = x1;\n    node.y0 = y0, node.y1 = y0 += node.value * k;\n  }\n}\n", "import treemapDice from \"./dice.js\";\nimport treemapSlice from \"./slice.js\";\n\nexport var phi = (1 + Math.sqrt(5)) / 2;\n\nexport function squarifyRatio(ratio, parent, x0, y0, x1, y1) {\n  var rows = [],\n      nodes = parent.children,\n      row,\n      nodeValue,\n      i0 = 0,\n      i1 = 0,\n      n = nodes.length,\n      dx, dy,\n      value = parent.value,\n      sumValue,\n      minValue,\n      maxValue,\n      newRatio,\n      minRatio,\n      alpha,\n      beta;\n\n  while (i0 < n) {\n    dx = x1 - x0, dy = y1 - y0;\n\n    // Find the next non-empty node.\n    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);\n    minValue = maxValue = sumValue;\n    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n    beta = sumValue * sumValue * alpha;\n    minRatio = Math.max(maxValue / beta, beta / minValue);\n\n    // Keep adding nodes while the aspect ratio maintains or improves.\n    for (; i1 < n; ++i1) {\n      sumValue += nodeValue = nodes[i1].value;\n      if (nodeValue < minValue) minValue = nodeValue;\n      if (nodeValue > maxValue) maxValue = nodeValue;\n      beta = sumValue * sumValue * alpha;\n      newRatio = Math.max(maxValue / beta, beta / minValue);\n      if (newRatio > minRatio) { sumValue -= nodeValue; break; }\n      minRatio = newRatio;\n    }\n\n    // Position and record the row orientation.\n    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});\n    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);\n    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\n    value -= sumValue, i0 = i1;\n  }\n\n  return rows;\n}\n\nexport default (function custom(ratio) {\n\n  function squarify(parent, x0, y0, x1, y1) {\n    squarifyRatio(ratio, parent, x0, y0, x1, y1);\n  }\n\n  squarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return squarify;\n})(phi);\n", "import treemapDice from \"./dice.js\";\nimport treemapSlice from \"./slice.js\";\nimport {phi, squarifyRatio} from \"./squarify.js\";\n\nexport default (function custom(ratio) {\n\n  function resquarify(parent, x0, y0, x1, y1) {\n    if ((rows = parent._squarify) && (rows.ratio === ratio)) {\n      var rows,\n          row,\n          nodes,\n          i,\n          j = -1,\n          n,\n          m = rows.length,\n          value = parent.value;\n\n      while (++j < m) {\n        row = rows[j], nodes = row.children;\n        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;\n        if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += (y1 - y0) * row.value / value : y1);\n        else treemapSlice(row, x0, y0, value ? x0 += (x1 - x0) * row.value / value : x1, y1);\n        value -= row.value;\n      }\n    } else {\n      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);\n      rows.ratio = ratio;\n    }\n  }\n\n  resquarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return resquarify;\n})(phi);\n", "export default Math.random;\n", "import defaultSource from \"./defaultSource.js\";\n\nexport default (function sourceRandomUniform(source) {\n  function randomUniform(min, max) {\n    min = min == null ? 0 : +min;\n    max = max == null ? 1 : +max;\n    if (arguments.length === 1) max = min, min = 0;\n    else max -= min;\n    return function() {\n      return source() * max + min;\n    };\n  }\n\n  randomUniform.source = sourceRandomUniform;\n\n  return randomUniform;\n})(defaultSource);\n", "import defaultSource from \"./defaultSource.js\";\n\nexport default (function sourceRandomInt(source) {\n  function randomInt(min, max) {\n    if (arguments.length < 2) max = min, min = 0;\n    min = Math.floor(min);\n    max = Math.floor(max) - min;\n    return function() {\n      return Math.floor(source() * max + min);\n    };\n  }\n\n  randomInt.source = sourceRandomInt;\n\n  return randomInt;\n})(defaultSource);\n", "import defaultSource from \"./defaultSource.js\";\n\nexport default (function sourceRandomNormal(source) {\n  function randomNormal(mu, sigma) {\n    var x, r;\n    mu = mu == null ? 0 : +mu;\n    sigma = sigma == null ? 1 : +sigma;\n    return function() {\n      var y;\n\n      // If available, use the second previously-generated uniform random.\n      if (x != null) y = x, x = null;\n\n      // Otherwise, generate a new x and y.\n      else do {\n        x = source() * 2 - 1;\n        y = source() * 2 - 1;\n        r = x * x + y * y;\n      } while (!r || r > 1);\n\n      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);\n    };\n  }\n\n  randomNormal.source = sourceRandomNormal;\n\n  return randomNormal;\n})(defaultSource);\n", "import defaultSource from \"./defaultSource.js\";\nimport normal from \"./normal.js\";\n\nexport default (function sourceRandomLogNormal(source) {\n  var N = normal.source(source);\n\n  function randomLogNormal() {\n    var randomNormal = N.apply(this, arguments);\n    return function() {\n      return Math.exp(randomNormal());\n    };\n  }\n\n  randomLogNormal.source = sourceRandomLogNormal;\n\n  return randomLogNormal;\n})(defaultSource);\n", "import defaultSource from \"./defaultSource.js\";\n\nexport default (function sourceRandomIrwinHall(source) {\n  function randomIrwinHall(n) {\n    if ((n = +n) <= 0) return () => 0;\n    return function() {\n      for (var sum = 0, i = n; i > 1; --i) sum += source();\n      return sum + i * source();\n    };\n  }\n\n  randomIrwinHall.source = sourceRandomIrwinHall;\n\n  return randomIrwinHall;\n})(defaultSource);\n", "import defaultSource from \"./defaultSource.js\";\nimport irwinHall from \"./irwinHall.js\";\n\nexport default (function sourceRandomBates(source) {\n  var I = irwinHall.source(source);\n\n  function randomBates(n) {\n    // use limiting distribution at n === 0\n    if ((n = +n) === 0) return source;\n    var randomIrwinHall = I(n);\n    return function() {\n      return randomIrwinHall() / n;\n    };\n  }\n\n  randomBates.source = sourceRandomBates;\n\n  return randomBates;\n})(defaultSource);\n", "import defaultSource from \"./defaultSource.js\";\n\nexport default (function sourceRandomExponential(source) {\n  function randomExponential(lambda) {\n    return function() {\n      return -Math.log1p(-source()) / lambda;\n    };\n  }\n\n  randomExponential.source = sourceRandomExponential;\n\n  return randomExponential;\n})(defaultSource);\n", "import defaultSource from \"./defaultSource.js\";\n\nexport default (function sourceRandomPareto(source) {\n  function randomPareto(alpha) {\n    if ((alpha = +alpha) < 0) throw new RangeError(\"invalid alpha\");\n    alpha = 1 / -alpha;\n    return function() {\n      return Math.pow(1 - source(), alpha);\n    };\n  }\n\n  randomPareto.source = sourceRandomPareto;\n\n  return randomPareto;\n})(defaultSource);\n", "import defaultSource from \"./defaultSource.js\";\n\nexport default (function sourceRandomBernoulli(source) {\n  function randomBernoulli(p) {\n    if ((p = +p) < 0 || p > 1) throw new RangeError(\"invalid p\");\n    return function() {\n      return Math.floor(source() + p);\n    };\n  }\n\n  randomBernoulli.source = sourceRandomBernoulli;\n\n  return randomBernoulli;\n})(defaultSource);\n", "import defaultSource from \"./defaultSource.js\";\n\nexport default (function sourceRandomGeometric(source) {\n  function randomGeometric(p) {\n    if ((p = +p) < 0 || p > 1) throw new RangeError(\"invalid p\");\n    if (p === 0) return () => Infinity;\n    if (p === 1) return () => 1;\n    p = Math.log1p(-p);\n    return function() {\n      return 1 + Math.floor(Math.log1p(-source()) / p);\n    };\n  }\n\n  randomGeometric.source = sourceRandomGeometric;\n\n  return randomGeometric;\n})(defaultSource);\n", "import defaultSource from \"./defaultSource.js\";\nimport normal from \"./normal.js\";\n\nexport default (function sourceRandomGamma(source) {\n  var randomNormal = normal.source(source)();\n\n  function randomGamma(k, theta) {\n    if ((k = +k) < 0) throw new RangeError(\"invalid k\");\n    // degenerate distribution if k === 0\n    if (k === 0) return () => 0;\n    theta = theta == null ? 1 : +theta;\n    // exponential distribution if k === 1\n    if (k === 1) return () => -Math.log1p(-source()) * theta;\n\n    var d = (k < 1 ? k + 1 : k) - 1 / 3,\n        c = 1 / (3 * Math.sqrt(d)),\n        multiplier = k < 1 ? () => Math.pow(source(), 1 / k) : () => 1;\n    return function() {\n      do {\n        do {\n          var x = randomNormal(),\n              v = 1 + c * x;\n        } while (v <= 0);\n        v *= v * v;\n        var u = 1 - source();\n      } while (u >= 1 - 0.0331 * x * x * x * x && Math.log(u) >= 0.5 * x * x + d * (1 - v + Math.log(v)));\n      return d * v * multiplier() * theta;\n    };\n  }\n\n  randomGamma.source = sourceRandomGamma;\n\n  return randomGamma;\n})(defaultSource);\n", "import defaultSource from \"./defaultSource.js\";\nimport gamma from \"./gamma.js\";\n\nexport default (function sourceRandomBeta(source) {\n  var G = gamma.source(source);\n\n  function randomBeta(alpha, beta) {\n    var X = G(alpha),\n        Y = G(beta);\n    return function() {\n      var x = X();\n      return x === 0 ? 0 : x / (x + Y());\n    };\n  }\n\n  randomBeta.source = sourceRandomBeta;\n\n  return randomBeta;\n})(defaultSource);\n", "import defaultSource from \"./defaultSource.js\";\nimport beta from \"./beta.js\";\nimport geometric from \"./geometric.js\";\n\nexport default (function sourceRandomBinomial(source) {\n  var G = geometric.source(source),\n      B = beta.source(source);\n\n  function randomBinomial(n, p) {\n    n = +n;\n    if ((p = +p) >= 1) return () => n;\n    if (p <= 0) return () => 0;\n    return function() {\n      var acc = 0, nn = n, pp = p;\n      while (nn * pp > 16 && nn * (1 - pp) > 16) {\n        var i = Math.floor((nn + 1) * pp),\n            y = B(i, nn - i + 1)();\n        if (y <= pp) {\n          acc += i;\n          nn -= i;\n          pp = (pp - y) / (1 - y);\n        } else {\n          nn = i - 1;\n          pp /= y;\n        }\n      }\n      var sign = pp < 0.5,\n          pFinal = sign ? pp : 1 - pp,\n          g = G(pFinal);\n      for (var s = g(), k = 0; s <= nn; ++k) s += g();\n      return acc + (sign ? k : nn - k);\n    };\n  }\n\n  randomBinomial.source = sourceRandomBinomial;\n\n  return randomBinomial;\n})(defaultSource);\n", "import defaultSource from \"./defaultSource.js\";\n\nexport default (function sourceRandomWeibull(source) {\n  function randomWeibull(k, a, b) {\n    var outerFunc;\n    if ((k = +k) === 0) {\n      outerFunc = x => -Math.log(x);\n    } else {\n      k = 1 / k;\n      outerFunc = x => Math.pow(x, k);\n    }\n    a = a == null ? 0 : +a;\n    b = b == null ? 1 : +b;\n    return function() {\n      return a + b * outerFunc(-Math.log1p(-source()));\n    };\n  }\n\n  randomWeibull.source = sourceRandomWeibull;\n\n  return randomWeibull;\n})(defaultSource);\n", "import defaultSource from \"./defaultSource.js\";\n\nexport default (function sourceRandomCauchy(source) {\n  function randomCauchy(a, b) {\n    a = a == null ? 0 : +a;\n    b = b == null ? 1 : +b;\n    return function() {\n      return a + b * Math.tan(Math.PI * source());\n    };\n  }\n\n  randomCauchy.source = sourceRandomCauchy;\n\n  return randomCauchy;\n})(defaultSource);\n", "import defaultSource from \"./defaultSource.js\";\n\nexport default (function sourceRandomLogistic(source) {\n  function randomLogistic(a, b) {\n    a = a == null ? 0 : +a;\n    b = b == null ? 1 : +b;\n    return function() {\n      var u = source();\n      return a + b * Math.log(u / (1 - u));\n    };\n  }\n\n  randomLogistic.source = sourceRandomLogistic;\n\n  return randomLogistic;\n})(defaultSource);\n", "import defaultSource from \"./defaultSource.js\";\nimport binomial from \"./binomial.js\";\nimport gamma from \"./gamma.js\";\n\nexport default (function sourceRandomPoisson(source) {\n  var G = gamma.source(source),\n      B = binomial.source(source);\n\n  function randomPoisson(lambda) {\n    return function() {\n      var acc = 0, l = lambda;\n      while (l > 16) {\n        var n = Math.floor(0.875 * l),\n            t = G(n)();\n        if (t > l) return acc + B(n - 1, l / t)();\n        acc += n;\n        l -= t;\n      }\n      for (var s = -Math.log1p(-source()), k = 0; s <= l; ++k) s -= Math.log1p(-source());\n      return acc + k;\n    };\n  }\n\n  randomPoisson.source = sourceRandomPoisson;\n\n  return randomPoisson;\n})(defaultSource);\n", "// https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use\nconst mul = 0x19660D;\nconst inc = 0x3C6EF35F;\nconst eps = 1 / 0x100000000;\n\nexport default function lcg(seed = Math.random()) {\n  let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;\n  return () => (state = mul * state + inc | 0, eps * (state >>> 0));\n}\n", "export function initRange(domain, range) {\n  switch (arguments.length) {\n    case 0: break;\n    case 1: this.range(domain); break;\n    default: this.range(range).domain(domain); break;\n  }\n  return this;\n}\n\nexport function initInterpolator(domain, interpolator) {\n  switch (arguments.length) {\n    case 0: break;\n    case 1: {\n      if (typeof domain === \"function\") this.interpolator(domain);\n      else this.range(domain);\n      break;\n    }\n    default: {\n      this.domain(domain);\n      if (typeof interpolator === \"function\") this.interpolator(interpolator);\n      else this.range(interpolator);\n      break;\n    }\n  }\n  return this;\n}\n", "import {InternMap} from \"d3-array\";\nimport {initRange} from \"./init.js\";\n\nexport const implicit = Symbol(\"implicit\");\n\nexport default function ordinal() {\n  var index = new InternMap(),\n      domain = [],\n      range = [],\n      unknown = implicit;\n\n  function scale(d) {\n    let i = index.get(d);\n    if (i === undefined) {\n      if (unknown !== implicit) return unknown;\n      index.set(d, i = domain.push(d) - 1);\n    }\n    return range[i % range.length];\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [], index = new InternMap();\n    for (const value of _) {\n      if (index.has(value)) continue;\n      index.set(value, domain.push(value) - 1);\n    }\n    return scale;\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = Array.from(_), scale) : range.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return ordinal(domain, range).unknown(unknown);\n  };\n\n  initRange.apply(scale, arguments);\n\n  return scale;\n}\n", "import {range as sequence} from \"d3-array\";\nimport {initRange} from \"./init.js\";\nimport ordinal from \"./ordinal.js\";\n\nexport default function band() {\n  var scale = ordinal().unknown(undefined),\n      domain = scale.domain,\n      ordinalRange = scale.range,\n      r0 = 0,\n      r1 = 1,\n      step,\n      bandwidth,\n      round = false,\n      paddingInner = 0,\n      paddingOuter = 0,\n      align = 0.5;\n\n  delete scale.unknown;\n\n  function rescale() {\n    var n = domain().length,\n        reverse = r1 < r0,\n        start = reverse ? r1 : r0,\n        stop = reverse ? r0 : r1;\n    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);\n    if (round) step = Math.floor(step);\n    start += (stop - start - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);\n    var values = sequence(n).map(function(i) { return start + step * i; });\n    return ordinalRange(reverse ? values.reverse() : values);\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];\n  };\n\n  scale.rangeRound = function(_) {\n    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();\n  };\n\n  scale.bandwidth = function() {\n    return bandwidth;\n  };\n\n  scale.step = function() {\n    return step;\n  };\n\n  scale.round = function(_) {\n    return arguments.length ? (round = !!_, rescale()) : round;\n  };\n\n  scale.padding = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;\n  };\n\n  scale.paddingInner = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;\n  };\n\n  scale.paddingOuter = function(_) {\n    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;\n  };\n\n  scale.align = function(_) {\n    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;\n  };\n\n  scale.copy = function() {\n    return band(domain(), [r0, r1])\n        .round(round)\n        .paddingInner(paddingInner)\n        .paddingOuter(paddingOuter)\n        .align(align);\n  };\n\n  return initRange.apply(rescale(), arguments);\n}\n\nfunction pointish(scale) {\n  var copy = scale.copy;\n\n  scale.padding = scale.paddingOuter;\n  delete scale.paddingInner;\n  delete scale.paddingOuter;\n\n  scale.copy = function() {\n    return pointish(copy());\n  };\n\n  return scale;\n}\n\nexport function point() {\n  return pointish(band.apply(null, arguments).paddingInner(1));\n}\n", "export default function constants(x) {\n  return function() {\n    return x;\n  };\n}\n", "export default function number(x) {\n  return +x;\n}\n", "import {bisect} from \"d3-array\";\nimport {interpolate as interpolateValue, interpolateNumber, interpolateRound} from \"d3-interpolate\";\nimport constant from \"./constant.js\";\nimport number from \"./number.js\";\n\nvar unit = [0, 1];\n\nexport function identity(x) {\n  return x;\n}\n\nfunction normalize(a, b) {\n  return (b -= (a = +a))\n      ? function(x) { return (x - a) / b; }\n      : constant(isNaN(b) ? NaN : 0.5);\n}\n\nfunction clamper(a, b) {\n  var t;\n  if (a > b) t = a, a = b, b = t;\n  return function(x) { return Math.max(a, Math.min(b, x)); };\n}\n\n// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].\n// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].\nfunction bimap(domain, range, interpolate) {\n  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];\n  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);\n  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);\n  return function(x) { return r0(d0(x)); };\n}\n\nfunction polymap(domain, range, interpolate) {\n  var j = Math.min(domain.length, range.length) - 1,\n      d = new Array(j),\n      r = new Array(j),\n      i = -1;\n\n  // Reverse descending domains.\n  if (domain[j] < domain[0]) {\n    domain = domain.slice().reverse();\n    range = range.slice().reverse();\n  }\n\n  while (++i < j) {\n    d[i] = normalize(domain[i], domain[i + 1]);\n    r[i] = interpolate(range[i], range[i + 1]);\n  }\n\n  return function(x) {\n    var i = bisect(domain, x, 1, j) - 1;\n    return r[i](d[i](x));\n  };\n}\n\nexport function copy(source, target) {\n  return target\n      .domain(source.domain())\n      .range(source.range())\n      .interpolate(source.interpolate())\n      .clamp(source.clamp())\n      .unknown(source.unknown());\n}\n\nexport function transformer() {\n  var domain = unit,\n      range = unit,\n      interpolate = interpolateValue,\n      transform,\n      untransform,\n      unknown,\n      clamp = identity,\n      piecewise,\n      output,\n      input;\n\n  function rescale() {\n    var n = Math.min(domain.length, range.length);\n    if (clamp !== identity) clamp = clamper(domain[0], domain[n - 1]);\n    piecewise = n > 2 ? polymap : bimap;\n    output = input = null;\n    return scale;\n  }\n\n  function scale(x) {\n    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));\n  }\n\n  scale.invert = function(y) {\n    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = Array.from(_, number), rescale()) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = Array.from(_), interpolate = interpolateRound, rescale();\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = _ ? true : identity, rescale()) : clamp !== identity;\n  };\n\n  scale.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, rescale()) : interpolate;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t, u) {\n    transform = t, untransform = u;\n    return rescale();\n  };\n}\n\nexport default function continuous() {\n  return transformer()(identity, identity);\n}\n", "import {tickStep} from \"d3-array\";\nimport {format, formatPrefix, formatSpecifier, precisionFixed, precisionPrefix, precisionRound} from \"d3-format\";\n\nexport default function tickFormat(start, stop, count, specifier) {\n  var step = tickStep(start, stop, count),\n      precision;\n  specifier = formatSpecifier(specifier == null ? \",f\" : specifier);\n  switch (specifier.type) {\n    case \"s\": {\n      var value = Math.max(Math.abs(start), Math.abs(stop));\n      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;\n      return formatPrefix(specifier, value);\n    }\n    case \"\":\n    case \"e\":\n    case \"g\":\n    case \"p\":\n    case \"r\": {\n      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === \"e\");\n      break;\n    }\n    case \"f\":\n    case \"%\": {\n      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === \"%\") * 2;\n      break;\n    }\n  }\n  return format(specifier);\n}\n", "import {ticks, tickIncrement} from \"d3-array\";\nimport continuous, {copy} from \"./continuous.js\";\nimport {initRange} from \"./init.js\";\nimport tickFormat from \"./tickFormat.js\";\n\nexport function linearish(scale) {\n  var domain = scale.domain;\n\n  scale.ticks = function(count) {\n    var d = domain();\n    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    var d = domain();\n    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);\n  };\n\n  scale.nice = function(count) {\n    if (count == null) count = 10;\n\n    var d = domain();\n    var i0 = 0;\n    var i1 = d.length - 1;\n    var start = d[i0];\n    var stop = d[i1];\n    var prestep;\n    var step;\n    var maxIter = 10;\n\n    if (stop < start) {\n      step = start, start = stop, stop = step;\n      step = i0, i0 = i1, i1 = step;\n    }\n    \n    while (maxIter-- > 0) {\n      step = tickIncrement(start, stop, count);\n      if (step === prestep) {\n        d[i0] = start\n        d[i1] = stop\n        return domain(d);\n      } else if (step > 0) {\n        start = Math.floor(start / step) * step;\n        stop = Math.ceil(stop / step) * step;\n      } else if (step < 0) {\n        start = Math.ceil(start * step) / step;\n        stop = Math.floor(stop * step) / step;\n      } else {\n        break;\n      }\n      prestep = step;\n    }\n\n    return scale;\n  };\n\n  return scale;\n}\n\nexport default function linear() {\n  var scale = continuous();\n\n  scale.copy = function() {\n    return copy(scale, linear());\n  };\n\n  initRange.apply(scale, arguments);\n\n  return linearish(scale);\n}\n", "const t0 = new Date, t1 = new Date;\n\nexport function timeInterval(floori, offseti, count, field) {\n\n  function interval(date) {\n    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;\n  }\n\n  interval.floor = (date) => {\n    return floori(date = new Date(+date)), date;\n  };\n\n  interval.ceil = (date) => {\n    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;\n  };\n\n  interval.round = (date) => {\n    const d0 = interval(date), d1 = interval.ceil(date);\n    return date - d0 < d1 - date ? d0 : d1;\n  };\n\n  interval.offset = (date, step) => {\n    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n  };\n\n  interval.range = (start, stop, step) => {\n    const range = [];\n    start = interval.ceil(start);\n    step = step == null ? 1 : Math.floor(step);\n    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n    let previous;\n    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);\n    while (previous < start && start < stop);\n    return range;\n  };\n\n  interval.filter = (test) => {\n    return timeInterval((date) => {\n      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);\n    }, (date, step) => {\n      if (date >= date) {\n        if (step < 0) while (++step <= 0) {\n          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty\n        } else while (--step >= 0) {\n          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty\n        }\n      }\n    });\n  };\n\n  if (count) {\n    interval.count = (start, end) => {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    interval.every = (step) => {\n      step = Math.floor(step);\n      return !isFinite(step) || !(step > 0) ? null\n          : !(step > 1) ? interval\n          : interval.filter(field\n              ? (d) => field(d) % step === 0\n              : (d) => interval.count(0, d) % step === 0);\n    };\n  }\n\n  return interval;\n}\n", "import {timeInterval} from \"./interval.js\";\n\nexport const millisecond = timeInterval(() => {\n  // noop\n}, (date, step) => {\n  date.setTime(+date + step);\n}, (start, end) => {\n  return end - start;\n});\n\n// An optimized implementation for this simple case.\nmillisecond.every = (k) => {\n  k = Math.floor(k);\n  if (!isFinite(k) || !(k > 0)) return null;\n  if (!(k > 1)) return millisecond;\n  return timeInterval((date) => {\n    date.setTime(Math.floor(date / k) * k);\n  }, (date, step) => {\n    date.setTime(+date + step * k);\n  }, (start, end) => {\n    return (end - start) / k;\n  });\n};\n\nexport const milliseconds = millisecond.range;\n", "export const durationSecond = 1000;\nexport const durationMinute = durationSecond * 60;\nexport const durationHour = durationMinute * 60;\nexport const durationDay = durationHour * 24;\nexport const durationWeek = durationDay * 7;\nexport const durationMonth = durationDay * 30;\nexport const durationYear = durationDay * 365;\n", "import {timeInterval} from \"./interval.js\";\nimport {durationSecond} from \"./duration.js\";\n\nexport const second = timeInterval((date) => {\n  date.setTime(date - date.getMilliseconds());\n}, (date, step) => {\n  date.setTime(+date + step * durationSecond);\n}, (start, end) => {\n  return (end - start) / durationSecond;\n}, (date) => {\n  return date.getUTCSeconds();\n});\n\nexport const seconds = second.range;\n", "import {timeInterval} from \"./interval.js\";\nimport {durationMinute, durationSecond} from \"./duration.js\";\n\nexport const timeMinute = timeInterval((date) => {\n  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);\n}, (date, step) => {\n  date.setTime(+date + step * durationMinute);\n}, (start, end) => {\n  return (end - start) / durationMinute;\n}, (date) => {\n  return date.getMinutes();\n});\n\nexport const timeMinutes = timeMinute.range;\n\nexport const utcMinute = timeInterval((date) => {\n  date.setUTCSeconds(0, 0);\n}, (date, step) => {\n  date.setTime(+date + step * durationMinute);\n}, (start, end) => {\n  return (end - start) / durationMinute;\n}, (date) => {\n  return date.getUTCMinutes();\n});\n\nexport const utcMinutes = utcMinute.range;\n", "import {timeInterval} from \"./interval.js\";\nimport {durationHour, durationMinute, durationSecond} from \"./duration.js\";\n\nexport const timeHour = timeInterval((date) => {\n  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);\n}, (date, step) => {\n  date.setTime(+date + step * durationHour);\n}, (start, end) => {\n  return (end - start) / durationHour;\n}, (date) => {\n  return date.getHours();\n});\n\nexport const timeHours = timeHour.range;\n\nexport const utcHour = timeInterval((date) => {\n  date.setUTCMinutes(0, 0, 0);\n}, (date, step) => {\n  date.setTime(+date + step * durationHour);\n}, (start, end) => {\n  return (end - start) / durationHour;\n}, (date) => {\n  return date.getUTCHours();\n});\n\nexport const utcHours = utcHour.range;\n", "import {timeInterval} from \"./interval.js\";\nimport {durationDay, durationMinute} from \"./duration.js\";\n\nexport const timeDay = timeInterval(\n  date => date.setHours(0, 0, 0, 0),\n  (date, step) => date.setDate(date.getDate() + step),\n  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,\n  date => date.getDate() - 1\n);\n\nexport const timeDays = timeDay.range;\n\nexport const utcDay = timeInterval((date) => {\n  date.setUTCHours(0, 0, 0, 0);\n}, (date, step) => {\n  date.setUTCDate(date.getUTCDate() + step);\n}, (start, end) => {\n  return (end - start) / durationDay;\n}, (date) => {\n  return date.getUTCDate() - 1;\n});\n\nexport const utcDays = utcDay.range;\n\nexport const unixDay = timeInterval((date) => {\n  date.setUTCHours(0, 0, 0, 0);\n}, (date, step) => {\n  date.setUTCDate(date.getUTCDate() + step);\n}, (start, end) => {\n  return (end - start) / durationDay;\n}, (date) => {\n  return Math.floor(date / durationDay);\n});\n\nexport const unixDays = unixDay.range;\n", "import {timeInterval} from \"./interval.js\";\nimport {durationMinute, durationWeek} from \"./duration.js\";\n\nfunction timeWeekday(i) {\n  return timeInterval((date) => {\n    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    date.setHours(0, 0, 0, 0);\n  }, (date, step) => {\n    date.setDate(date.getDate() + step * 7);\n  }, (start, end) => {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;\n  });\n}\n\nexport const timeSunday = timeWeekday(0);\nexport const timeMonday = timeWeekday(1);\nexport const timeTuesday = timeWeekday(2);\nexport const timeWednesday = timeWeekday(3);\nexport const timeThursday = timeWeekday(4);\nexport const timeFriday = timeWeekday(5);\nexport const timeSaturday = timeWeekday(6);\n\nexport const timeSundays = timeSunday.range;\nexport const timeMondays = timeMonday.range;\nexport const timeTuesdays = timeTuesday.range;\nexport const timeWednesdays = timeWednesday.range;\nexport const timeThursdays = timeThursday.range;\nexport const timeFridays = timeFriday.range;\nexport const timeSaturdays = timeSaturday.range;\n\nfunction utcWeekday(i) {\n  return timeInterval((date) => {\n    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    date.setUTCHours(0, 0, 0, 0);\n  }, (date, step) => {\n    date.setUTCDate(date.getUTCDate() + step * 7);\n  }, (start, end) => {\n    return (end - start) / durationWeek;\n  });\n}\n\nexport const utcSunday = utcWeekday(0);\nexport const utcMonday = utcWeekday(1);\nexport const utcTuesday = utcWeekday(2);\nexport const utcWednesday = utcWeekday(3);\nexport const utcThursday = utcWeekday(4);\nexport const utcFriday = utcWeekday(5);\nexport const utcSaturday = utcWeekday(6);\n\nexport const utcSundays = utcSunday.range;\nexport const utcMondays = utcMonday.range;\nexport const utcTuesdays = utcTuesday.range;\nexport const utcWednesdays = utcWednesday.range;\nexport const utcThursdays = utcThursday.range;\nexport const utcFridays = utcFriday.range;\nexport const utcSaturdays = utcSaturday.range;\n", "import {timeInterval} from \"./interval.js\";\n\nexport const timeMonth = timeInterval((date) => {\n  date.setDate(1);\n  date.setHours(0, 0, 0, 0);\n}, (date, step) => {\n  date.setMonth(date.getMonth() + step);\n}, (start, end) => {\n  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n}, (date) => {\n  return date.getMonth();\n});\n\nexport const timeMonths = timeMonth.range;\n\nexport const utcMonth = timeInterval((date) => {\n  date.setUTCDate(1);\n  date.setUTCHours(0, 0, 0, 0);\n}, (date, step) => {\n  date.setUTCMonth(date.getUTCMonth() + step);\n}, (start, end) => {\n  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n}, (date) => {\n  return date.getUTCMonth();\n});\n\nexport const utcMonths = utcMonth.range;\n", "import {timeInterval} from \"./interval.js\";\n\nexport const timeYear = timeInterval((date) => {\n  date.setMonth(0, 1);\n  date.setHours(0, 0, 0, 0);\n}, (date, step) => {\n  date.setFullYear(date.getFullYear() + step);\n}, (start, end) => {\n  return end.getFullYear() - start.getFullYear();\n}, (date) => {\n  return date.getFullYear();\n});\n\n// An optimized implementation for this simple case.\ntimeYear.every = (k) => {\n  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date) => {\n    date.setFullYear(Math.floor(date.getFullYear() / k) * k);\n    date.setMonth(0, 1);\n    date.setHours(0, 0, 0, 0);\n  }, (date, step) => {\n    date.setFullYear(date.getFullYear() + step * k);\n  });\n};\n\nexport const timeYears = timeYear.range;\n\nexport const utcYear = timeInterval((date) => {\n  date.setUTCMonth(0, 1);\n  date.setUTCHours(0, 0, 0, 0);\n}, (date, step) => {\n  date.setUTCFullYear(date.getUTCFullYear() + step);\n}, (start, end) => {\n  return end.getUTCFullYear() - start.getUTCFullYear();\n}, (date) => {\n  return date.getUTCFullYear();\n});\n\n// An optimized implementation for this simple case.\nutcYear.every = (k) => {\n  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date) => {\n    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);\n    date.setUTCMonth(0, 1);\n    date.setUTCHours(0, 0, 0, 0);\n  }, (date, step) => {\n    date.setUTCFullYear(date.getUTCFullYear() + step * k);\n  });\n};\n\nexport const utcYears = utcYear.range;\n", "import {bisector, tickStep} from \"d3-array\";\nimport {durationDay, durationHour, durationMinute, durationMonth, durationSecond, durationWeek, durationYear} from \"./duration.js\";\nimport {millisecond} from \"./millisecond.js\";\nimport {second} from \"./second.js\";\nimport {timeMinute, utcMinute} from \"./minute.js\";\nimport {timeHour, utcHour} from \"./hour.js\";\nimport {timeDay, unixDay} from \"./day.js\";\nimport {timeSunday, utcSunday} from \"./week.js\";\nimport {timeMonth, utcMonth} from \"./month.js\";\nimport {timeYear, utcYear} from \"./year.js\";\n\nfunction ticker(year, month, week, day, hour, minute) {\n\n  const tickIntervals = [\n    [second,  1,      durationSecond],\n    [second,  5,  5 * durationSecond],\n    [second, 15, 15 * durationSecond],\n    [second, 30, 30 * durationSecond],\n    [minute,  1,      durationMinute],\n    [minute,  5,  5 * durationMinute],\n    [minute, 15, 15 * durationMinute],\n    [minute, 30, 30 * durationMinute],\n    [  hour,  1,      durationHour  ],\n    [  hour,  3,  3 * durationHour  ],\n    [  hour,  6,  6 * durationHour  ],\n    [  hour, 12, 12 * durationHour  ],\n    [   day,  1,      durationDay   ],\n    [   day,  2,  2 * durationDay   ],\n    [  week,  1,      durationWeek  ],\n    [ month,  1,      durationMonth ],\n    [ month,  3,  3 * durationMonth ],\n    [  year,  1,      durationYear  ]\n  ];\n\n  function ticks(start, stop, count) {\n    const reverse = stop < start;\n    if (reverse) [start, stop] = [stop, start];\n    const interval = count && typeof count.range === \"function\" ? count : tickInterval(start, stop, count);\n    const ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop\n    return reverse ? ticks.reverse() : ticks;\n  }\n\n  function tickInterval(start, stop, count) {\n    const target = Math.abs(stop - start) / count;\n    const i = bisector(([,, step]) => step).right(tickIntervals, target);\n    if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));\n    if (i === 0) return millisecond.every(Math.max(tickStep(start, stop, count), 1));\n    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n    return t.every(step);\n  }\n\n  return [ticks, tickInterval];\n}\n\nconst [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);\nconst [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);\n\nexport {utcTicks, utcTickInterval, timeTicks, timeTickInterval};\n", "import {\n  timeDay,\n  timeSunday,\n  timeMonday,\n  timeThursday,\n  timeYear,\n  utcDay,\n  utcSunday,\n  utcMonday,\n  utcThursday,\n  utcYear\n} from \"d3-time\";\n\nfunction localDate(d) {\n  if (0 <= d.y && d.y < 100) {\n    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n    date.setFullYear(d.y);\n    return date;\n  }\n  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n}\n\nfunction utcDate(d) {\n  if (0 <= d.y && d.y < 100) {\n    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n    date.setUTCFullYear(d.y);\n    return date;\n  }\n  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n}\n\nfunction newDate(y, m, d) {\n  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};\n}\n\nexport default function formatLocale(locale) {\n  var locale_dateTime = locale.dateTime,\n      locale_date = locale.date,\n      locale_time = locale.time,\n      locale_periods = locale.periods,\n      locale_weekdays = locale.days,\n      locale_shortWeekdays = locale.shortDays,\n      locale_months = locale.months,\n      locale_shortMonths = locale.shortMonths;\n\n  var periodRe = formatRe(locale_periods),\n      periodLookup = formatLookup(locale_periods),\n      weekdayRe = formatRe(locale_weekdays),\n      weekdayLookup = formatLookup(locale_weekdays),\n      shortWeekdayRe = formatRe(locale_shortWeekdays),\n      shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n      monthRe = formatRe(locale_months),\n      monthLookup = formatLookup(locale_months),\n      shortMonthRe = formatRe(locale_shortMonths),\n      shortMonthLookup = formatLookup(locale_shortMonths);\n\n  var formats = {\n    \"a\": formatShortWeekday,\n    \"A\": formatWeekday,\n    \"b\": formatShortMonth,\n    \"B\": formatMonth,\n    \"c\": null,\n    \"d\": formatDayOfMonth,\n    \"e\": formatDayOfMonth,\n    \"f\": formatMicroseconds,\n    \"g\": formatYearISO,\n    \"G\": formatFullYearISO,\n    \"H\": formatHour24,\n    \"I\": formatHour12,\n    \"j\": formatDayOfYear,\n    \"L\": formatMilliseconds,\n    \"m\": formatMonthNumber,\n    \"M\": formatMinutes,\n    \"p\": formatPeriod,\n    \"q\": formatQuarter,\n    \"Q\": formatUnixTimestamp,\n    \"s\": formatUnixTimestampSeconds,\n    \"S\": formatSeconds,\n    \"u\": formatWeekdayNumberMonday,\n    \"U\": formatWeekNumberSunday,\n    \"V\": formatWeekNumberISO,\n    \"w\": formatWeekdayNumberSunday,\n    \"W\": formatWeekNumberMonday,\n    \"x\": null,\n    \"X\": null,\n    \"y\": formatYear,\n    \"Y\": formatFullYear,\n    \"Z\": formatZone,\n    \"%\": formatLiteralPercent\n  };\n\n  var utcFormats = {\n    \"a\": formatUTCShortWeekday,\n    \"A\": formatUTCWeekday,\n    \"b\": formatUTCShortMonth,\n    \"B\": formatUTCMonth,\n    \"c\": null,\n    \"d\": formatUTCDayOfMonth,\n    \"e\": formatUTCDayOfMonth,\n    \"f\": formatUTCMicroseconds,\n    \"g\": formatUTCYearISO,\n    \"G\": formatUTCFullYearISO,\n    \"H\": formatUTCHour24,\n    \"I\": formatUTCHour12,\n    \"j\": formatUTCDayOfYear,\n    \"L\": formatUTCMilliseconds,\n    \"m\": formatUTCMonthNumber,\n    \"M\": formatUTCMinutes,\n    \"p\": formatUTCPeriod,\n    \"q\": formatUTCQuarter,\n    \"Q\": formatUnixTimestamp,\n    \"s\": formatUnixTimestampSeconds,\n    \"S\": formatUTCSeconds,\n    \"u\": formatUTCWeekdayNumberMonday,\n    \"U\": formatUTCWeekNumberSunday,\n    \"V\": formatUTCWeekNumberISO,\n    \"w\": formatUTCWeekdayNumberSunday,\n    \"W\": formatUTCWeekNumberMonday,\n    \"x\": null,\n    \"X\": null,\n    \"y\": formatUTCYear,\n    \"Y\": formatUTCFullYear,\n    \"Z\": formatUTCZone,\n    \"%\": formatLiteralPercent\n  };\n\n  var parses = {\n    \"a\": parseShortWeekday,\n    \"A\": parseWeekday,\n    \"b\": parseShortMonth,\n    \"B\": parseMonth,\n    \"c\": parseLocaleDateTime,\n    \"d\": parseDayOfMonth,\n    \"e\": parseDayOfMonth,\n    \"f\": parseMicroseconds,\n    \"g\": parseYear,\n    \"G\": parseFullYear,\n    \"H\": parseHour24,\n    \"I\": parseHour24,\n    \"j\": parseDayOfYear,\n    \"L\": parseMilliseconds,\n    \"m\": parseMonthNumber,\n    \"M\": parseMinutes,\n    \"p\": parsePeriod,\n    \"q\": parseQuarter,\n    \"Q\": parseUnixTimestamp,\n    \"s\": parseUnixTimestampSeconds,\n    \"S\": parseSeconds,\n    \"u\": parseWeekdayNumberMonday,\n    \"U\": parseWeekNumberSunday,\n    \"V\": parseWeekNumberISO,\n    \"w\": parseWeekdayNumberSunday,\n    \"W\": parseWeekNumberMonday,\n    \"x\": parseLocaleDate,\n    \"X\": parseLocaleTime,\n    \"y\": parseYear,\n    \"Y\": parseFullYear,\n    \"Z\": parseZone,\n    \"%\": parseLiteralPercent\n  };\n\n  // These recursive directive definitions must be deferred.\n  formats.x = newFormat(locale_date, formats);\n  formats.X = newFormat(locale_time, formats);\n  formats.c = newFormat(locale_dateTime, formats);\n  utcFormats.x = newFormat(locale_date, utcFormats);\n  utcFormats.X = newFormat(locale_time, utcFormats);\n  utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\n  function newFormat(specifier, formats) {\n    return function(date) {\n      var string = [],\n          i = -1,\n          j = 0,\n          n = specifier.length,\n          c,\n          pad,\n          format;\n\n      if (!(date instanceof Date)) date = new Date(+date);\n\n      while (++i < n) {\n        if (specifier.charCodeAt(i) === 37) {\n          string.push(specifier.slice(j, i));\n          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n          else pad = c === \"e\" ? \" \" : \"0\";\n          if (format = formats[c]) c = format(date, pad);\n          string.push(c);\n          j = i + 1;\n        }\n      }\n\n      string.push(specifier.slice(j, i));\n      return string.join(\"\");\n    };\n  }\n\n  function newParse(specifier, Z) {\n    return function(string) {\n      var d = newDate(1900, undefined, 1),\n          i = parseSpecifier(d, specifier, string += \"\", 0),\n          week, day;\n      if (i != string.length) return null;\n\n      // If a UNIX timestamp is specified, return it.\n      if (\"Q\" in d) return new Date(d.Q);\n      if (\"s\" in d) return new Date(d.s * 1000 + (\"L\" in d ? d.L : 0));\n\n      // If this is utcParse, never use the local timezone.\n      if (Z && !(\"Z\" in d)) d.Z = 0;\n\n      // The am-pm flag is 0 for AM, and 1 for PM.\n      if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n      // If the month was not specified, inherit from the quarter.\n      if (d.m === undefined) d.m = \"q\" in d ? d.q : 0;\n\n      // Convert day-of-week and week-of-year to day-of-year.\n      if (\"V\" in d) {\n        if (d.V < 1 || d.V > 53) return null;\n        if (!(\"w\" in d)) d.w = 1;\n        if (\"Z\" in d) {\n          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();\n          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);\n          week = utcDay.offset(week, (d.V - 1) * 7);\n          d.y = week.getUTCFullYear();\n          d.m = week.getUTCMonth();\n          d.d = week.getUTCDate() + (d.w + 6) % 7;\n        } else {\n          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();\n          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);\n          week = timeDay.offset(week, (d.V - 1) * 7);\n          d.y = week.getFullYear();\n          d.m = week.getMonth();\n          d.d = week.getDate() + (d.w + 6) % 7;\n        }\n      } else if (\"W\" in d || \"U\" in d) {\n        if (!(\"w\" in d)) d.w = \"u\" in d ? d.u % 7 : \"W\" in d ? 1 : 0;\n        day = \"Z\" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();\n        d.m = 0;\n        d.d = \"W\" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;\n      }\n\n      // If a time zone is specified, all fields are interpreted as UTC and then\n      // offset according to the specified time zone.\n      if (\"Z\" in d) {\n        d.H += d.Z / 100 | 0;\n        d.M += d.Z % 100;\n        return utcDate(d);\n      }\n\n      // Otherwise, all fields are in local time.\n      return localDate(d);\n    };\n  }\n\n  function parseSpecifier(d, specifier, string, j) {\n    var i = 0,\n        n = specifier.length,\n        m = string.length,\n        c,\n        parse;\n\n    while (i < n) {\n      if (j >= m) return -1;\n      c = specifier.charCodeAt(i++);\n      if (c === 37) {\n        c = specifier.charAt(i++);\n        parse = parses[c in pads ? specifier.charAt(i++) : c];\n        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n      } else if (c != string.charCodeAt(j++)) {\n        return -1;\n      }\n    }\n\n    return j;\n  }\n\n  function parsePeriod(d, string, i) {\n    var n = periodRe.exec(string.slice(i));\n    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n  }\n\n  function parseShortWeekday(d, string, i) {\n    var n = shortWeekdayRe.exec(string.slice(i));\n    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n  }\n\n  function parseWeekday(d, string, i) {\n    var n = weekdayRe.exec(string.slice(i));\n    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n  }\n\n  function parseShortMonth(d, string, i) {\n    var n = shortMonthRe.exec(string.slice(i));\n    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n  }\n\n  function parseMonth(d, string, i) {\n    var n = monthRe.exec(string.slice(i));\n    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n  }\n\n  function parseLocaleDateTime(d, string, i) {\n    return parseSpecifier(d, locale_dateTime, string, i);\n  }\n\n  function parseLocaleDate(d, string, i) {\n    return parseSpecifier(d, locale_date, string, i);\n  }\n\n  function parseLocaleTime(d, string, i) {\n    return parseSpecifier(d, locale_time, string, i);\n  }\n\n  function formatShortWeekday(d) {\n    return locale_shortWeekdays[d.getDay()];\n  }\n\n  function formatWeekday(d) {\n    return locale_weekdays[d.getDay()];\n  }\n\n  function formatShortMonth(d) {\n    return locale_shortMonths[d.getMonth()];\n  }\n\n  function formatMonth(d) {\n    return locale_months[d.getMonth()];\n  }\n\n  function formatPeriod(d) {\n    return locale_periods[+(d.getHours() >= 12)];\n  }\n\n  function formatQuarter(d) {\n    return 1 + ~~(d.getMonth() / 3);\n  }\n\n  function formatUTCShortWeekday(d) {\n    return locale_shortWeekdays[d.getUTCDay()];\n  }\n\n  function formatUTCWeekday(d) {\n    return locale_weekdays[d.getUTCDay()];\n  }\n\n  function formatUTCShortMonth(d) {\n    return locale_shortMonths[d.getUTCMonth()];\n  }\n\n  function formatUTCMonth(d) {\n    return locale_months[d.getUTCMonth()];\n  }\n\n  function formatUTCPeriod(d) {\n    return locale_periods[+(d.getUTCHours() >= 12)];\n  }\n\n  function formatUTCQuarter(d) {\n    return 1 + ~~(d.getUTCMonth() / 3);\n  }\n\n  return {\n    format: function(specifier) {\n      var f = newFormat(specifier += \"\", formats);\n      f.toString = function() { return specifier; };\n      return f;\n    },\n    parse: function(specifier) {\n      var p = newParse(specifier += \"\", false);\n      p.toString = function() { return specifier; };\n      return p;\n    },\n    utcFormat: function(specifier) {\n      var f = newFormat(specifier += \"\", utcFormats);\n      f.toString = function() { return specifier; };\n      return f;\n    },\n    utcParse: function(specifier) {\n      var p = newParse(specifier += \"\", true);\n      p.toString = function() { return specifier; };\n      return p;\n    }\n  };\n}\n\nvar pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"},\n    numberRe = /^\\s*\\d+/, // note: ignores next directive\n    percentRe = /^%/,\n    requoteRe = /[\\\\^$*+?|[\\]().{}]/g;\n\nfunction pad(value, fill, width) {\n  var sign = value < 0 ? \"-\" : \"\",\n      string = (sign ? -value : value) + \"\",\n      length = string.length;\n  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n}\n\nfunction requote(s) {\n  return s.replace(requoteRe, \"\\\\$&\");\n}\n\nfunction formatRe(names) {\n  return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n}\n\nfunction formatLookup(names) {\n  return new Map(names.map((name, i) => [name.toLowerCase(), i]));\n}\n\nfunction parseWeekdayNumberSunday(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 1));\n  return n ? (d.w = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseWeekdayNumberMonday(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 1));\n  return n ? (d.u = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseWeekNumberSunday(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.U = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseWeekNumberISO(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.V = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseWeekNumberMonday(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.W = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseFullYear(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 4));\n  return n ? (d.y = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseYear(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n}\n\nfunction parseZone(d, string, i) {\n  var n = /^(Z)|([+-]\\d\\d)(?::?(\\d\\d))?/.exec(string.slice(i, i + 6));\n  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || \"00\")), i + n[0].length) : -1;\n}\n\nfunction parseQuarter(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 1));\n  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;\n}\n\nfunction parseMonthNumber(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n}\n\nfunction parseDayOfMonth(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.d = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseDayOfYear(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 3));\n  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseHour24(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.H = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseMinutes(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.M = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseSeconds(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.S = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseMilliseconds(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 3));\n  return n ? (d.L = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseMicroseconds(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 6));\n  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;\n}\n\nfunction parseLiteralPercent(d, string, i) {\n  var n = percentRe.exec(string.slice(i, i + 1));\n  return n ? i + n[0].length : -1;\n}\n\nfunction parseUnixTimestamp(d, string, i) {\n  var n = numberRe.exec(string.slice(i));\n  return n ? (d.Q = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseUnixTimestampSeconds(d, string, i) {\n  var n = numberRe.exec(string.slice(i));\n  return n ? (d.s = +n[0], i + n[0].length) : -1;\n}\n\nfunction formatDayOfMonth(d, p) {\n  return pad(d.getDate(), p, 2);\n}\n\nfunction formatHour24(d, p) {\n  return pad(d.getHours(), p, 2);\n}\n\nfunction formatHour12(d, p) {\n  return pad(d.getHours() % 12 || 12, p, 2);\n}\n\nfunction formatDayOfYear(d, p) {\n  return pad(1 + timeDay.count(timeYear(d), d), p, 3);\n}\n\nfunction formatMilliseconds(d, p) {\n  return pad(d.getMilliseconds(), p, 3);\n}\n\nfunction formatMicroseconds(d, p) {\n  return formatMilliseconds(d, p) + \"000\";\n}\n\nfunction formatMonthNumber(d, p) {\n  return pad(d.getMonth() + 1, p, 2);\n}\n\nfunction formatMinutes(d, p) {\n  return pad(d.getMinutes(), p, 2);\n}\n\nfunction formatSeconds(d, p) {\n  return pad(d.getSeconds(), p, 2);\n}\n\nfunction formatWeekdayNumberMonday(d) {\n  var day = d.getDay();\n  return day === 0 ? 7 : day;\n}\n\nfunction formatWeekNumberSunday(d, p) {\n  return pad(timeSunday.count(timeYear(d) - 1, d), p, 2);\n}\n\nfunction dISO(d) {\n  var day = d.getDay();\n  return (day >= 4 || day === 0) ? timeThursday(d) : timeThursday.ceil(d);\n}\n\nfunction formatWeekNumberISO(d, p) {\n  d = dISO(d);\n  return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);\n}\n\nfunction formatWeekdayNumberSunday(d) {\n  return d.getDay();\n}\n\nfunction formatWeekNumberMonday(d, p) {\n  return pad(timeMonday.count(timeYear(d) - 1, d), p, 2);\n}\n\nfunction formatYear(d, p) {\n  return pad(d.getFullYear() % 100, p, 2);\n}\n\nfunction formatYearISO(d, p) {\n  d = dISO(d);\n  return pad(d.getFullYear() % 100, p, 2);\n}\n\nfunction formatFullYear(d, p) {\n  return pad(d.getFullYear() % 10000, p, 4);\n}\n\nfunction formatFullYearISO(d, p) {\n  var day = d.getDay();\n  d = (day >= 4 || day === 0) ? timeThursday(d) : timeThursday.ceil(d);\n  return pad(d.getFullYear() % 10000, p, 4);\n}\n\nfunction formatZone(d) {\n  var z = d.getTimezoneOffset();\n  return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n      + pad(z / 60 | 0, \"0\", 2)\n      + pad(z % 60, \"0\", 2);\n}\n\nfunction formatUTCDayOfMonth(d, p) {\n  return pad(d.getUTCDate(), p, 2);\n}\n\nfunction formatUTCHour24(d, p) {\n  return pad(d.getUTCHours(), p, 2);\n}\n\nfunction formatUTCHour12(d, p) {\n  return pad(d.getUTCHours() % 12 || 12, p, 2);\n}\n\nfunction formatUTCDayOfYear(d, p) {\n  return pad(1 + utcDay.count(utcYear(d), d), p, 3);\n}\n\nfunction formatUTCMilliseconds(d, p) {\n  return pad(d.getUTCMilliseconds(), p, 3);\n}\n\nfunction formatUTCMicroseconds(d, p) {\n  return formatUTCMilliseconds(d, p) + \"000\";\n}\n\nfunction formatUTCMonthNumber(d, p) {\n  return pad(d.getUTCMonth() + 1, p, 2);\n}\n\nfunction formatUTCMinutes(d, p) {\n  return pad(d.getUTCMinutes(), p, 2);\n}\n\nfunction formatUTCSeconds(d, p) {\n  return pad(d.getUTCSeconds(), p, 2);\n}\n\nfunction formatUTCWeekdayNumberMonday(d) {\n  var dow = d.getUTCDay();\n  return dow === 0 ? 7 : dow;\n}\n\nfunction formatUTCWeekNumberSunday(d, p) {\n  return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);\n}\n\nfunction UTCdISO(d) {\n  var day = d.getUTCDay();\n  return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);\n}\n\nfunction formatUTCWeekNumberISO(d, p) {\n  d = UTCdISO(d);\n  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);\n}\n\nfunction formatUTCWeekdayNumberSunday(d) {\n  return d.getUTCDay();\n}\n\nfunction formatUTCWeekNumberMonday(d, p) {\n  return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);\n}\n\nfunction formatUTCYear(d, p) {\n  return pad(d.getUTCFullYear() % 100, p, 2);\n}\n\nfunction formatUTCYearISO(d, p) {\n  d = UTCdISO(d);\n  return pad(d.getUTCFullYear() % 100, p, 2);\n}\n\nfunction formatUTCFullYear(d, p) {\n  return pad(d.getUTCFullYear() % 10000, p, 4);\n}\n\nfunction formatUTCFullYearISO(d, p) {\n  var day = d.getUTCDay();\n  d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);\n  return pad(d.getUTCFullYear() % 10000, p, 4);\n}\n\nfunction formatUTCZone() {\n  return \"+0000\";\n}\n\nfunction formatLiteralPercent() {\n  return \"%\";\n}\n\nfunction formatUnixTimestamp(d) {\n  return +d;\n}\n\nfunction formatUnixTimestampSeconds(d) {\n  return Math.floor(+d / 1000);\n}\n", "import formatLocale from \"./locale.js\";\n\nvar locale;\nexport var timeFormat;\nexport var timeParse;\nexport var utcFormat;\nexport var utcParse;\n\ndefaultLocale({\n  dateTime: \"%x, %X\",\n  date: \"%-m/%-d/%Y\",\n  time: \"%-I:%M:%S %p\",\n  periods: [\"AM\", \"PM\"],\n  days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n  shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n  months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n  shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n});\n\nexport default function defaultLocale(definition) {\n  locale = formatLocale(definition);\n  timeFormat = locale.format;\n  timeParse = locale.parse;\n  utcFormat = locale.utcFormat;\n  utcParse = locale.utcParse;\n  return locale;\n}\n", "import {utcFormat} from \"./defaultLocale.js\";\n\nexport var isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\nfunction formatIsoNative(date) {\n  return date.toISOString();\n}\n\nvar formatIso = Date.prototype.toISOString\n    ? formatIsoNative\n    : utcFormat(isoSpecifier);\n\nexport default formatIso;\n", "import {isoSpecifier} from \"./isoFormat.js\";\nimport {utcParse} from \"./defaultLocale.js\";\n\nfunction parseIsoNative(string) {\n  var date = new Date(string);\n  return isNaN(date) ? null : date;\n}\n\nvar parseIso = +new Date(\"2000-01-01T00:00:00.000Z\")\n    ? parseIsoNative\n    : utcParse(isoSpecifier);\n\nexport default parseIso;\n", "export default function(specifier) {\n  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;\n  while (i < n) colors[i] = \"#\" + specifier.slice(i * 6, ++i * 6);\n  return colors;\n}\n", "import colors from \"../colors.js\";\n\nexport default colors(\"1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf\");\n", "import colors from \"../colors.js\";\n\nexport default colors(\"7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666\");\n", "import colors from \"../colors.js\";\n\nexport default colors(\"1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666\");\n", "import colors from \"../colors.js\";\n\nexport default colors(\"a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928\");\n", "import colors from \"../colors.js\";\n\nexport default colors(\"fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2\");\n", "import colors from \"../colors.js\";\n\nexport default colors(\"b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc\");\n", "import colors from \"../colors.js\";\n\nexport default colors(\"e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999\");\n", "import colors from \"../colors.js\";\n\nexport default colors(\"66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3\");\n", "import colors from \"../colors.js\";\n\nexport default colors(\"8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f\");\n", "import colors from \"../colors.js\";\n\nexport default colors(\"4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab\");\n", "import {interpolateRgbBasis} from \"d3-interpolate\";\n\nexport default scheme => interpolateRgbBasis(scheme[scheme.length - 1]);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"d8b365f5f5f55ab4ac\",\n  \"a6611adfc27d80cdc1018571\",\n  \"a6611adfc27df5f5f580cdc1018571\",\n  \"8c510ad8b365f6e8c3c7eae55ab4ac01665e\",\n  \"8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e\",\n  \"8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e\",\n  \"8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e\",\n  \"5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30\",\n  \"5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"af8dc3f7f7f77fbf7b\",\n  \"7b3294c2a5cfa6dba0008837\",\n  \"7b3294c2a5cff7f7f7a6dba0008837\",\n  \"762a83af8dc3e7d4e8d9f0d37fbf7b1b7837\",\n  \"762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837\",\n  \"762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837\",\n  \"762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837\",\n  \"40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b\",\n  \"40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"e9a3c9f7f7f7a1d76a\",\n  \"d01c8bf1b6dab8e1864dac26\",\n  \"d01c8bf1b6daf7f7f7b8e1864dac26\",\n  \"c51b7de9a3c9fde0efe6f5d0a1d76a4d9221\",\n  \"c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221\",\n  \"c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221\",\n  \"c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221\",\n  \"8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419\",\n  \"8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"998ec3f7f7f7f1a340\",\n  \"5e3c99b2abd2fdb863e66101\",\n  \"5e3c99b2abd2f7f7f7fdb863e66101\",\n  \"542788998ec3d8daebfee0b6f1a340b35806\",\n  \"542788998ec3d8daebf7f7f7fee0b6f1a340b35806\",\n  \"5427888073acb2abd2d8daebfee0b6fdb863e08214b35806\",\n  \"5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806\",\n  \"2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08\",\n  \"2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"ef8a62f7f7f767a9cf\",\n  \"ca0020f4a58292c5de0571b0\",\n  \"ca0020f4a582f7f7f792c5de0571b0\",\n  \"b2182bef8a62fddbc7d1e5f067a9cf2166ac\",\n  \"b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac\",\n  \"b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac\",\n  \"b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac\",\n  \"67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061\",\n  \"67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"ef8a62ffffff999999\",\n  \"ca0020f4a582bababa404040\",\n  \"ca0020f4a582ffffffbababa404040\",\n  \"b2182bef8a62fddbc7e0e0e09999994d4d4d\",\n  \"b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d\",\n  \"b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d\",\n  \"b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d\",\n  \"67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a\",\n  \"67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"fc8d59ffffbf91bfdb\",\n  \"d7191cfdae61abd9e92c7bb6\",\n  \"d7191cfdae61ffffbfabd9e92c7bb6\",\n  \"d73027fc8d59fee090e0f3f891bfdb4575b4\",\n  \"d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4\",\n  \"d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4\",\n  \"d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4\",\n  \"a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695\",\n  \"a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"fc8d59ffffbf91cf60\",\n  \"d7191cfdae61a6d96a1a9641\",\n  \"d7191cfdae61ffffbfa6d96a1a9641\",\n  \"d73027fc8d59fee08bd9ef8b91cf601a9850\",\n  \"d73027fc8d59fee08bffffbfd9ef8b91cf601a9850\",\n  \"d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850\",\n  \"d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850\",\n  \"a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837\",\n  \"a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"fc8d59ffffbf99d594\",\n  \"d7191cfdae61abdda42b83ba\",\n  \"d7191cfdae61ffffbfabdda42b83ba\",\n  \"d53e4ffc8d59fee08be6f59899d5943288bd\",\n  \"d53e4ffc8d59fee08bffffbfe6f59899d5943288bd\",\n  \"d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd\",\n  \"d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd\",\n  \"9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2\",\n  \"9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"e5f5f999d8c92ca25f\",\n  \"edf8fbb2e2e266c2a4238b45\",\n  \"edf8fbb2e2e266c2a42ca25f006d2c\",\n  \"edf8fbccece699d8c966c2a42ca25f006d2c\",\n  \"edf8fbccece699d8c966c2a441ae76238b45005824\",\n  \"f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824\",\n  \"f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"e0ecf49ebcda8856a7\",\n  \"edf8fbb3cde38c96c688419d\",\n  \"edf8fbb3cde38c96c68856a7810f7c\",\n  \"edf8fbbfd3e69ebcda8c96c68856a7810f7c\",\n  \"edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b\",\n  \"f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b\",\n  \"f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"e0f3dba8ddb543a2ca\",\n  \"f0f9e8bae4bc7bccc42b8cbe\",\n  \"f0f9e8bae4bc7bccc443a2ca0868ac\",\n  \"f0f9e8ccebc5a8ddb57bccc443a2ca0868ac\",\n  \"f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e\",\n  \"f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e\",\n  \"f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"fee8c8fdbb84e34a33\",\n  \"fef0d9fdcc8afc8d59d7301f\",\n  \"fef0d9fdcc8afc8d59e34a33b30000\",\n  \"fef0d9fdd49efdbb84fc8d59e34a33b30000\",\n  \"fef0d9fdd49efdbb84fc8d59ef6548d7301f990000\",\n  \"fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000\",\n  \"fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"ece2f0a6bddb1c9099\",\n  \"f6eff7bdc9e167a9cf02818a\",\n  \"f6eff7bdc9e167a9cf1c9099016c59\",\n  \"f6eff7d0d1e6a6bddb67a9cf1c9099016c59\",\n  \"f6eff7d0d1e6a6bddb67a9cf3690c002818a016450\",\n  \"fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450\",\n  \"fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"ece7f2a6bddb2b8cbe\",\n  \"f1eef6bdc9e174a9cf0570b0\",\n  \"f1eef6bdc9e174a9cf2b8cbe045a8d\",\n  \"f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d\",\n  \"f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b\",\n  \"fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b\",\n  \"fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"e7e1efc994c7dd1c77\",\n  \"f1eef6d7b5d8df65b0ce1256\",\n  \"f1eef6d7b5d8df65b0dd1c77980043\",\n  \"f1eef6d4b9dac994c7df65b0dd1c77980043\",\n  \"f1eef6d4b9dac994c7df65b0e7298ace125691003f\",\n  \"f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f\",\n  \"f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"fde0ddfa9fb5c51b8a\",\n  \"feebe2fbb4b9f768a1ae017e\",\n  \"feebe2fbb4b9f768a1c51b8a7a0177\",\n  \"feebe2fcc5c0fa9fb5f768a1c51b8a7a0177\",\n  \"feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177\",\n  \"fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177\",\n  \"fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"edf8b17fcdbb2c7fb8\",\n  \"ffffcca1dab441b6c4225ea8\",\n  \"ffffcca1dab441b6c42c7fb8253494\",\n  \"ffffccc7e9b47fcdbb41b6c42c7fb8253494\",\n  \"ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84\",\n  \"ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84\",\n  \"ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"f7fcb9addd8e31a354\",\n  \"ffffccc2e69978c679238443\",\n  \"ffffccc2e69978c67931a354006837\",\n  \"ffffccd9f0a3addd8e78c67931a354006837\",\n  \"ffffccd9f0a3addd8e78c67941ab5d238443005a32\",\n  \"ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32\",\n  \"ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"fff7bcfec44fd95f0e\",\n  \"ffffd4fed98efe9929cc4c02\",\n  \"ffffd4fed98efe9929d95f0e993404\",\n  \"ffffd4fee391fec44ffe9929d95f0e993404\",\n  \"ffffd4fee391fec44ffe9929ec7014cc4c028c2d04\",\n  \"ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04\",\n  \"ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"ffeda0feb24cf03b20\",\n  \"ffffb2fecc5cfd8d3ce31a1c\",\n  \"ffffb2fecc5cfd8d3cf03b20bd0026\",\n  \"ffffb2fed976feb24cfd8d3cf03b20bd0026\",\n  \"ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026\",\n  \"ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026\",\n  \"ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"deebf79ecae13182bd\",\n  \"eff3ffbdd7e76baed62171b5\",\n  \"eff3ffbdd7e76baed63182bd08519c\",\n  \"eff3ffc6dbef9ecae16baed63182bd08519c\",\n  \"eff3ffc6dbef9ecae16baed64292c62171b5084594\",\n  \"f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594\",\n  \"f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"e5f5e0a1d99b31a354\",\n  \"edf8e9bae4b374c476238b45\",\n  \"edf8e9bae4b374c47631a354006d2c\",\n  \"edf8e9c7e9c0a1d99b74c47631a354006d2c\",\n  \"edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32\",\n  \"f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32\",\n  \"f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"f0f0f0bdbdbd636363\",\n  \"f7f7f7cccccc969696525252\",\n  \"f7f7f7cccccc969696636363252525\",\n  \"f7f7f7d9d9d9bdbdbd969696636363252525\",\n  \"f7f7f7d9d9d9bdbdbd969696737373525252252525\",\n  \"fffffff0f0f0d9d9d9bdbdbd969696737373525252252525\",\n  \"fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"efedf5bcbddc756bb1\",\n  \"f2f0f7cbc9e29e9ac86a51a3\",\n  \"f2f0f7cbc9e29e9ac8756bb154278f\",\n  \"f2f0f7dadaebbcbddc9e9ac8756bb154278f\",\n  \"f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486\",\n  \"fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486\",\n  \"fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"fee0d2fc9272de2d26\",\n  \"fee5d9fcae91fb6a4acb181d\",\n  \"fee5d9fcae91fb6a4ade2d26a50f15\",\n  \"fee5d9fcbba1fc9272fb6a4ade2d26a50f15\",\n  \"fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d\",\n  \"fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d\",\n  \"fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import colors from \"../colors.js\";\nimport ramp from \"../ramp.js\";\n\nexport var scheme = new Array(3).concat(\n  \"fee6cefdae6be6550d\",\n  \"feeddefdbe85fd8d3cd94701\",\n  \"feeddefdbe85fd8d3ce6550da63603\",\n  \"feeddefdd0a2fdae6bfd8d3ce6550da63603\",\n  \"feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04\",\n  \"fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04\",\n  \"fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704\"\n).map(colors);\n\nexport default ramp(scheme);\n", "import {cubehelix} from \"d3-color\";\nimport {interpolateCubehelixLong} from \"d3-interpolate\";\n\nexport default interpolateCubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));\n", "import {cubehelix} from \"d3-color\";\nimport {interpolateCubehelixLong} from \"d3-interpolate\";\n\nexport var warm = interpolateCubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));\n\nexport var cool = interpolateCubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));\n\nvar c = cubehelix();\n\nexport default function(t) {\n  if (t < 0 || t > 1) t -= Math.floor(t);\n  var ts = Math.abs(t - 0.5);\n  c.h = 360 * t - 100;\n  c.s = 1.5 - 1.5 * ts;\n  c.l = 0.8 - 0.9 * ts;\n  return c + \"\";\n}\n", "import {rgb} from \"d3-color\";\n\nvar c = rgb(),\n    pi_1_3 = Math.PI / 3,\n    pi_2_3 = Math.PI * 2 / 3;\n\nexport default function(t) {\n  var x;\n  t = (0.5 - t) * Math.PI;\n  c.r = 255 * (x = Math.sin(t)) * x;\n  c.g = 255 * (x = Math.sin(t + pi_1_3)) * x;\n  c.b = 255 * (x = Math.sin(t + pi_2_3)) * x;\n  return c + \"\";\n}\n", "import colors from \"../colors.js\";\n\nfunction ramp(range) {\n  var n = range.length;\n  return function(t) {\n    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];\n  };\n}\n\nexport default ramp(colors(\"44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725\"));\n\nexport var magma = ramp(colors(\"00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf\"));\n\nexport var inferno = ramp(colors(\"00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4\"));\n\nexport var plasma = ramp(colors(\"0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921\"));\n", "export default function(x) {\n  return function constant() {\n    return x;\n  };\n}\n", "export const abs = Math.abs;\nexport const atan2 = Math.atan2;\nexport const cos = Math.cos;\nexport const max = Math.max;\nexport const min = Math.min;\nexport const sin = Math.sin;\nexport const sqrt = Math.sqrt;\n\nexport const epsilon = 1e-12;\nexport const pi = Math.PI;\nexport const halfPi = pi / 2;\nexport const tau = 2 * pi;\n\nexport function acos(x) {\n  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n}\n\nexport function asin(x) {\n  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);\n}\n", "import {Path} from \"d3-path\";\n\nexport function withPath(shape) {\n  let digits = 3;\n\n  shape.digits = function(_) {\n    if (!arguments.length) return digits;\n    if (_ == null) {\n      digits = null;\n    } else {\n      const d = Math.floor(_);\n      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);\n      digits = d;\n    }\n    return shape;\n  };\n\n  return () => new Path(digits);\n}\n", "import constant from \"./constant.js\";\nimport {abs, acos, asin, atan2, cos, epsilon, halfPi, max, min, pi, sin, sqrt, tau} from \"./math.js\";\nimport {withPath} from \"./path.js\";\n\nfunction arcInnerRadius(d) {\n  return d.innerRadius;\n}\n\nfunction arcOuterRadius(d) {\n  return d.outerRadius;\n}\n\nfunction arcStartAngle(d) {\n  return d.startAngle;\n}\n\nfunction arcEndAngle(d) {\n  return d.endAngle;\n}\n\nfunction arcPadAngle(d) {\n  return d && d.padAngle; // Note: optional!\n}\n\nfunction intersect(x0, y0, x1, y1, x2, y2, x3, y3) {\n  var x10 = x1 - x0, y10 = y1 - y0,\n      x32 = x3 - x2, y32 = y3 - y2,\n      t = y32 * x10 - x32 * y10;\n  if (t * t < epsilon) return;\n  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;\n  return [x0 + t * x10, y0 + t * y10];\n}\n\n// Compute perpendicular offset line of length rc.\n// http://mathworld.wolfram.com/Circle-LineIntersection.html\nfunction cornerTangents(x0, y0, x1, y1, r1, rc, cw) {\n  var x01 = x0 - x1,\n      y01 = y0 - y1,\n      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),\n      ox = lo * y01,\n      oy = -lo * x01,\n      x11 = x0 + ox,\n      y11 = y0 + oy,\n      x10 = x1 + ox,\n      y10 = y1 + oy,\n      x00 = (x11 + x10) / 2,\n      y00 = (y11 + y10) / 2,\n      dx = x10 - x11,\n      dy = y10 - y11,\n      d2 = dx * dx + dy * dy,\n      r = r1 - rc,\n      D = x11 * y10 - x10 * y11,\n      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),\n      cx0 = (D * dy - dx * d) / d2,\n      cy0 = (-D * dx - dy * d) / d2,\n      cx1 = (D * dy + dx * d) / d2,\n      cy1 = (-D * dx + dy * d) / d2,\n      dx0 = cx0 - x00,\n      dy0 = cy0 - y00,\n      dx1 = cx1 - x00,\n      dy1 = cy1 - y00;\n\n  // Pick the closer of the two intersection points.\n  // TODO Is there a faster way to determine which intersection to use?\n  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;\n\n  return {\n    cx: cx0,\n    cy: cy0,\n    x01: -ox,\n    y01: -oy,\n    x11: cx0 * (r1 / r - 1),\n    y11: cy0 * (r1 / r - 1)\n  };\n}\n\nexport default function() {\n  var innerRadius = arcInnerRadius,\n      outerRadius = arcOuterRadius,\n      cornerRadius = constant(0),\n      padRadius = null,\n      startAngle = arcStartAngle,\n      endAngle = arcEndAngle,\n      padAngle = arcPadAngle,\n      context = null,\n      path = withPath(arc);\n\n  function arc() {\n    var buffer,\n        r,\n        r0 = +innerRadius.apply(this, arguments),\n        r1 = +outerRadius.apply(this, arguments),\n        a0 = startAngle.apply(this, arguments) - halfPi,\n        a1 = endAngle.apply(this, arguments) - halfPi,\n        da = abs(a1 - a0),\n        cw = a1 > a0;\n\n    if (!context) context = buffer = path();\n\n    // Ensure that the outer radius is always larger than the inner radius.\n    if (r1 < r0) r = r1, r1 = r0, r0 = r;\n\n    // Is it a point?\n    if (!(r1 > epsilon)) context.moveTo(0, 0);\n\n    // Or is it a circle or annulus?\n    else if (da > tau - epsilon) {\n      context.moveTo(r1 * cos(a0), r1 * sin(a0));\n      context.arc(0, 0, r1, a0, a1, !cw);\n      if (r0 > epsilon) {\n        context.moveTo(r0 * cos(a1), r0 * sin(a1));\n        context.arc(0, 0, r0, a1, a0, cw);\n      }\n    }\n\n    // Or is it a circular or annular sector?\n    else {\n      var a01 = a0,\n          a11 = a1,\n          a00 = a0,\n          a10 = a1,\n          da0 = da,\n          da1 = da,\n          ap = padAngle.apply(this, arguments) / 2,\n          rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),\n          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),\n          rc0 = rc,\n          rc1 = rc,\n          t0,\n          t1;\n\n      // Apply padding? Note that since r1  r0, da1  da0.\n      if (rp > epsilon) {\n        var p0 = asin(rp / r0 * sin(ap)),\n            p1 = asin(rp / r1 * sin(ap));\n        if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;\n        else da0 = 0, a00 = a10 = (a0 + a1) / 2;\n        if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;\n        else da1 = 0, a01 = a11 = (a0 + a1) / 2;\n      }\n\n      var x01 = r1 * cos(a01),\n          y01 = r1 * sin(a01),\n          x10 = r0 * cos(a10),\n          y10 = r0 * sin(a10);\n\n      // Apply rounded corners?\n      if (rc > epsilon) {\n        var x11 = r1 * cos(a11),\n            y11 = r1 * sin(a11),\n            x00 = r0 * cos(a00),\n            y00 = r0 * sin(a00),\n            oc;\n\n        // Restrict the corner radius according to the sector angle. If this\n        // intersection fails, its probably because the arc is too small, so\n        // disable the corner radius entirely.\n        if (da < pi) {\n          if (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {\n            var ax = x01 - oc[0],\n                ay = y01 - oc[1],\n                bx = x11 - oc[0],\n                by = y11 - oc[1],\n                kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),\n                lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\n            rc0 = min(rc, (r0 - lc) / (kc - 1));\n            rc1 = min(rc, (r1 - lc) / (kc + 1));\n          } else {\n            rc0 = rc1 = 0;\n          }\n        }\n      }\n\n      // Is the sector collapsed to a line?\n      if (!(da1 > epsilon)) context.moveTo(x01, y01);\n\n      // Does the sectors outer ring have rounded corners?\n      else if (rc1 > epsilon) {\n        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);\n        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);\n\n        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\n        // Have the corners merged?\n        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);\n\n        // Otherwise, draw the two corners and the ring.\n        else {\n          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);\n          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);\n        }\n      }\n\n      // Or is the outer ring just a circular arc?\n      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);\n\n      // Is there no inner ring, and its a circular sector?\n      // Or perhaps its an annular sector collapsed due to padding?\n      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);\n\n      // Does the sectors inner ring (or point) have rounded corners?\n      else if (rc0 > epsilon) {\n        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);\n        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);\n\n        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\n        // Have the corners merged?\n        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);\n\n        // Otherwise, draw the two corners and the ring.\n        else {\n          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);\n          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);\n        }\n      }\n\n      // Or is the inner ring just a circular arc?\n      else context.arc(0, 0, r0, a10, a00, cw);\n    }\n\n    context.closePath();\n\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  arc.centroid = function() {\n    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,\n        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;\n    return [cos(a) * r, sin(a) * r];\n  };\n\n  arc.innerRadius = function(_) {\n    return arguments.length ? (innerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : innerRadius;\n  };\n\n  arc.outerRadius = function(_) {\n    return arguments.length ? (outerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : outerRadius;\n  };\n\n  arc.cornerRadius = function(_) {\n    return arguments.length ? (cornerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : cornerRadius;\n  };\n\n  arc.padRadius = function(_) {\n    return arguments.length ? (padRadius = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), arc) : padRadius;\n  };\n\n  arc.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : startAngle;\n  };\n\n  arc.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : endAngle;\n  };\n\n  arc.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : padAngle;\n  };\n\n  arc.context = function(_) {\n    return arguments.length ? ((context = _ == null ? null : _), arc) : context;\n  };\n\n  return arc;\n}\n", "export var slice = Array.prototype.slice;\n\nexport default function(x) {\n  return typeof x === \"object\" && \"length\" in x\n    ? x // Array, TypedArray, NodeList, array-like\n    : Array.from(x); // Map, Set, iterable, string, or anything else\n}\n", "function Linear(context) {\n  this._context = context;\n}\n\nLinear.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; // falls through\n      default: this._context.lineTo(x, y); break;\n    }\n  }\n};\n\nexport default function(context) {\n  return new Linear(context);\n}\n", "export default function(a, b) {\n  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n}\n", "export default function(d) {\n  return d;\n}\n", "import array from \"./array.js\";\nimport constant from \"./constant.js\";\nimport descending from \"./descending.js\";\nimport identity from \"./identity.js\";\nimport {tau} from \"./math.js\";\n\nexport default function() {\n  var value = identity,\n      sortValues = descending,\n      sort = null,\n      startAngle = constant(0),\n      endAngle = constant(tau),\n      padAngle = constant(0);\n\n  function pie(data) {\n    var i,\n        n = (data = array(data)).length,\n        j,\n        k,\n        sum = 0,\n        index = new Array(n),\n        arcs = new Array(n),\n        a0 = +startAngle.apply(this, arguments),\n        da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),\n        a1,\n        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),\n        pa = p * (da < 0 ? -1 : 1),\n        v;\n\n    for (i = 0; i < n; ++i) {\n      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {\n        sum += v;\n      }\n    }\n\n    // Optionally sort the arcs by previously-computed values or by data.\n    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });\n    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });\n\n    // Compute the arcs! They are stored in the original data's order.\n    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {\n      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {\n        data: data[j],\n        index: i,\n        value: v,\n        startAngle: a0,\n        endAngle: a1,\n        padAngle: p\n      };\n    }\n\n    return arcs;\n  }\n\n  pie.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(+_), pie) : value;\n  };\n\n  pie.sortValues = function(_) {\n    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;\n  };\n\n  pie.sort = function(_) {\n    return arguments.length ? (sort = _, sortValues = null, pie) : sort;\n  };\n\n  pie.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : startAngle;\n  };\n\n  pie.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : endAngle;\n  };\n\n  pie.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : padAngle;\n  };\n\n  return pie;\n}\n", "import curveLinear from \"./linear.js\";\n\nexport var curveRadialLinear = curveRadial(curveLinear);\n\nfunction Radial(curve) {\n  this._curve = curve;\n}\n\nRadial.prototype = {\n  areaStart: function() {\n    this._curve.areaStart();\n  },\n  areaEnd: function() {\n    this._curve.areaEnd();\n  },\n  lineStart: function() {\n    this._curve.lineStart();\n  },\n  lineEnd: function() {\n    this._curve.lineEnd();\n  },\n  point: function(a, r) {\n    this._curve.point(r * Math.sin(a), r * -Math.cos(a));\n  }\n};\n\nexport default function curveRadial(curve) {\n\n  function radial(context) {\n    return new Radial(curve(context));\n  }\n\n  radial._curve = curve;\n\n  return radial;\n}\n", "import {min, sqrt} from \"../math.js\";\n\nconst sqrt3 = sqrt(3);\n\nexport default {\n  draw(context, size) {\n    const r = sqrt(size + min(size / 28, 0.75)) * 0.59436;\n    const t = r / 2;\n    const u = t * sqrt3;\n    context.moveTo(0, r);\n    context.lineTo(0, -r);\n    context.moveTo(-u, -t);\n    context.lineTo(u, t);\n    context.moveTo(-u, t);\n    context.lineTo(u, -t);\n  }\n};\n", "import {sqrt} from \"../math.js\";\n\nconst tan30 = sqrt(1 / 3);\nconst tan30_2 = tan30 * 2;\n\nexport default {\n  draw(context, size) {\n    const y = sqrt(size / tan30_2);\n    const x = y * tan30;\n    context.moveTo(0, -y);\n    context.lineTo(x, 0);\n    context.lineTo(0, y);\n    context.lineTo(-x, 0);\n    context.closePath();\n  }\n};\n", "import {sin, cos, sqrt, pi, tau} from \"../math.js\";\n\nconst ka = 0.89081309152928522810;\nconst kr = sin(pi / 10) / sin(7 * pi / 10);\nconst kx = sin(tau / 10) * kr;\nconst ky = -cos(tau / 10) * kr;\n\nexport default {\n  draw(context, size) {\n    const r = sqrt(size * ka);\n    const x = kx * r;\n    const y = ky * r;\n    context.moveTo(0, -r);\n    context.lineTo(x, y);\n    for (let i = 1; i < 5; ++i) {\n      const a = tau * i / 5;\n      const c = cos(a);\n      const s = sin(a);\n      context.lineTo(s * r, -c * r);\n      context.lineTo(c * x - s * y, s * x + c * y);\n    }\n    context.closePath();\n  }\n};\n", "import {sqrt} from \"../math.js\";\n\nconst sqrt3 = sqrt(3);\n\nexport default {\n  draw(context, size) {\n    const y = -sqrt(size / (sqrt3 * 3));\n    context.moveTo(0, y * 2);\n    context.lineTo(-sqrt3 * y, -y);\n    context.lineTo(sqrt3 * y, -y);\n    context.closePath();\n  }\n};\n", "import {sqrt} from \"../math.js\";\n\nconst sqrt3 = sqrt(3);\n\nexport default {\n  draw(context, size) {\n    const s = sqrt(size) * 0.6824;\n    const t = s  / 2;\n    const u = (s * sqrt3) / 2; // cos(Math.PI / 6)\n    context.moveTo(0, -s);\n    context.lineTo(u, t);\n    context.lineTo(-u, t);\n    context.closePath();\n  }\n};\n", "import {sqrt} from \"../math.js\";\n\nconst c = -0.5;\nconst s = sqrt(3) / 2;\nconst k = 1 / sqrt(12);\nconst a = (k / 2 + 1) * 3;\n\nexport default {\n  draw(context, size) {\n    const r = sqrt(size / a);\n    const x0 = r / 2, y0 = r * k;\n    const x1 = x0, y1 = r * k + r;\n    const x2 = -x1, y2 = y1;\n    context.moveTo(x0, y0);\n    context.lineTo(x1, y1);\n    context.lineTo(x2, y2);\n    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);\n    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);\n    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);\n    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);\n    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);\n    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);\n    context.closePath();\n  }\n};\n", "export default function() {}\n", "export function point(that, x, y) {\n  that._context.bezierCurveTo(\n    (2 * that._x0 + that._x1) / 3,\n    (2 * that._y0 + that._y1) / 3,\n    (that._x0 + 2 * that._x1) / 3,\n    (that._y0 + 2 * that._y1) / 3,\n    (that._x0 + 4 * that._x1 + x) / 6,\n    (that._y0 + 4 * that._y1 + y) / 6\n  );\n}\n\nexport function Basis(context) {\n  this._context = context;\n}\n\nBasis.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 3: point(this, this._x1, this._y1); // falls through\n      case 2: this._context.lineTo(this._x1, this._y1); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // falls through\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\nexport default function(context) {\n  return new Basis(context);\n}\n", "import noop from \"../noop.js\";\nimport {point} from \"./basis.js\";\n\nfunction BasisClosed(context) {\n  this._context = context;\n}\n\nBasisClosed.prototype = {\n  areaStart: noop,\n  areaEnd: noop,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x2, this._y2);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);\n        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x2, this._y2);\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;\n      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;\n      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\nexport default function(context) {\n  return new BasisClosed(context);\n}\n", "import {point} from \"./basis.js\";\n\nfunction BasisOpen(context) {\n  this._context = context;\n}\n\nBasisOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;\n      case 3: this._point = 4; // falls through\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\nexport default function(context) {\n  return new BasisOpen(context);\n}\n", "import {Basis} from \"./basis.js\";\n\nfunction Bundle(context, beta) {\n  this._basis = new Basis(context);\n  this._beta = beta;\n}\n\nBundle.prototype = {\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n    this._basis.lineStart();\n  },\n  lineEnd: function() {\n    var x = this._x,\n        y = this._y,\n        j = x.length - 1;\n\n    if (j > 0) {\n      var x0 = x[0],\n          y0 = y[0],\n          dx = x[j] - x0,\n          dy = y[j] - y0,\n          i = -1,\n          t;\n\n      while (++i <= j) {\n        t = i / j;\n        this._basis.point(\n          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),\n          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)\n        );\n      }\n    }\n\n    this._x = this._y = null;\n    this._basis.lineEnd();\n  },\n  point: function(x, y) {\n    this._x.push(+x);\n    this._y.push(+y);\n  }\n};\n\nexport default (function custom(beta) {\n\n  function bundle(context) {\n    return beta === 1 ? new Basis(context) : new Bundle(context, beta);\n  }\n\n  bundle.beta = function(beta) {\n    return custom(+beta);\n  };\n\n  return bundle;\n})(0.85);\n", "export function point(that, x, y) {\n  that._context.bezierCurveTo(\n    that._x1 + that._k * (that._x2 - that._x0),\n    that._y1 + that._k * (that._y2 - that._y0),\n    that._x2 + that._k * (that._x1 - x),\n    that._y2 + that._k * (that._y1 - y),\n    that._x2,\n    that._y2\n  );\n}\n\nexport function Cardinal(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinal.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x2, this._y2); break;\n      case 3: point(this, this._x1, this._y1); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;\n      case 2: this._point = 3; // falls through\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nexport default (function custom(tension) {\n\n  function cardinal(context) {\n    return new Cardinal(context, tension);\n  }\n\n  cardinal.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal;\n})(0);\n", "import noop from \"../noop.js\";\nimport {point} from \"./cardinal.js\";\n\nexport function CardinalClosed(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinalClosed.prototype = {\n  areaStart: noop,\n  areaEnd: noop,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;\n      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;\n      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nexport default (function custom(tension) {\n\n  function cardinal(context) {\n    return new CardinalClosed(context, tension);\n  }\n\n  cardinal.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal;\n})(0);\n", "import {point} from \"./cardinal.js\";\n\nexport function CardinalOpen(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinalOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;\n      case 3: this._point = 4; // falls through\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nexport default (function custom(tension) {\n\n  function cardinal(context) {\n    return new CardinalOpen(context, tension);\n  }\n\n  cardinal.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal;\n})(0);\n", "import {epsilon} from \"../math.js\";\nimport {Cardinal} from \"./cardinal.js\";\n\nexport function point(that, x, y) {\n  var x1 = that._x1,\n      y1 = that._y1,\n      x2 = that._x2,\n      y2 = that._y2;\n\n  if (that._l01_a > epsilon) {\n    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,\n        n = 3 * that._l01_a * (that._l01_a + that._l12_a);\n    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;\n    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;\n  }\n\n  if (that._l23_a > epsilon) {\n    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,\n        m = 3 * that._l23_a * (that._l23_a + that._l12_a);\n    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;\n    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;\n  }\n\n  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);\n}\n\nfunction CatmullRom(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRom.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x2, this._y2); break;\n      case 3: this.point(this._x2, this._y2); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; // falls through\n      default: point(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nexport default (function custom(alpha) {\n\n  function catmullRom(context) {\n    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);\n  }\n\n  catmullRom.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom;\n})(0.5);\n", "import {CardinalClosed} from \"./cardinalClosed.js\";\nimport noop from \"../noop.js\";\nimport {point} from \"./catmullRom.js\";\n\nfunction CatmullRomClosed(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRomClosed.prototype = {\n  areaStart: noop,\n  areaEnd: noop,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;\n      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;\n      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;\n      default: point(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nexport default (function custom(alpha) {\n\n  function catmullRom(context) {\n    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);\n  }\n\n  catmullRom.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom;\n})(0.5);\n", "import {CardinalOpen} from \"./cardinalOpen.js\";\nimport {point} from \"./catmullRom.js\";\n\nfunction CatmullRomOpen(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRomOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;\n      case 3: this._point = 4; // falls through\n      default: point(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nexport default (function custom(alpha) {\n\n  function catmullRom(context) {\n    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);\n  }\n\n  catmullRom.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom;\n})(0.5);\n", "import noop from \"../noop.js\";\n\nfunction LinearClosed(context) {\n  this._context = context;\n}\n\nLinearClosed.prototype = {\n  areaStart: noop,\n  areaEnd: noop,\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._point) this._context.closePath();\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    if (this._point) this._context.lineTo(x, y);\n    else this._point = 1, this._context.moveTo(x, y);\n  }\n};\n\nexport default function(context) {\n  return new LinearClosed(context);\n}\n", "function sign(x) {\n  return x < 0 ? -1 : 1;\n}\n\n// Calculate the slopes of the tangents (Hermite-type interpolation) based on\n// the following paper: Steffen, M. 1990. A Simple Method for Monotonic\n// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.\n// NOV(II), P. 443, 1990.\nfunction slope3(that, x2, y2) {\n  var h0 = that._x1 - that._x0,\n      h1 = x2 - that._x1,\n      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),\n      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),\n      p = (s0 * h1 + s1 * h0) / (h0 + h1);\n  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;\n}\n\n// Calculate a one-sided slope.\nfunction slope2(that, t) {\n  var h = that._x1 - that._x0;\n  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;\n}\n\n// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations\n// \"you can express cubic Hermite interpolation in terms of cubic Bzier curves\n// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1\".\nfunction point(that, t0, t1) {\n  var x0 = that._x0,\n      y0 = that._y0,\n      x1 = that._x1,\n      y1 = that._y1,\n      dx = (x1 - x0) / 3;\n  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);\n}\n\nfunction MonotoneX(context) {\n  this._context = context;\n}\n\nMonotoneX.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 =\n    this._t0 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x1, this._y1); break;\n      case 3: point(this, this._t0, slope2(this, this._t0)); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    var t1 = NaN;\n\n    x = +x, y = +y;\n    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;\n      default: point(this, this._t0, t1 = slope3(this, x, y)); break;\n    }\n\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n    this._t0 = t1;\n  }\n}\n\nfunction MonotoneY(context) {\n  this._context = new ReflectContext(context);\n}\n\n(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {\n  MonotoneX.prototype.point.call(this, y, x);\n};\n\nfunction ReflectContext(context) {\n  this._context = context;\n}\n\nReflectContext.prototype = {\n  moveTo: function(x, y) { this._context.moveTo(y, x); },\n  closePath: function() { this._context.closePath(); },\n  lineTo: function(x, y) { this._context.lineTo(y, x); },\n  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }\n};\n\nexport function monotoneX(context) {\n  return new MonotoneX(context);\n}\n\nexport function monotoneY(context) {\n  return new MonotoneY(context);\n}\n", "function Natural(context) {\n  this._context = context;\n}\n\nNatural.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n  },\n  lineEnd: function() {\n    var x = this._x,\n        y = this._y,\n        n = x.length;\n\n    if (n) {\n      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);\n      if (n === 2) {\n        this._context.lineTo(x[1], y[1]);\n      } else {\n        var px = controlPoints(x),\n            py = controlPoints(y);\n        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {\n          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);\n        }\n      }\n    }\n\n    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n    this._x = this._y = null;\n  },\n  point: function(x, y) {\n    this._x.push(+x);\n    this._y.push(+y);\n  }\n};\n\n// See https://www.particleincell.com/2012/bezier-splines/ for derivation.\nfunction controlPoints(x) {\n  var i,\n      n = x.length - 1,\n      m,\n      a = new Array(n),\n      b = new Array(n),\n      r = new Array(n);\n  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];\n  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];\n  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];\n  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];\n  a[n - 1] = r[n - 1] / b[n - 1];\n  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];\n  b[n - 1] = (x[n] + a[n - 1]) / 2;\n  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];\n  return [a, b];\n}\n\nexport default function(context) {\n  return new Natural(context);\n}\n", "function Step(context, t) {\n  this._context = context;\n  this._t = t;\n}\n\nStep.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = this._y = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; // falls through\n      default: {\n        if (this._t <= 0) {\n          this._context.lineTo(this._x, y);\n          this._context.lineTo(x, y);\n        } else {\n          var x1 = this._x * (1 - this._t) + x * this._t;\n          this._context.lineTo(x1, this._y);\n          this._context.lineTo(x1, y);\n        }\n        break;\n      }\n    }\n    this._x = x, this._y = y;\n  }\n};\n\nexport default function(context) {\n  return new Step(context, 0.5);\n}\n\nexport function stepBefore(context) {\n  return new Step(context, 0);\n}\n\nexport function stepAfter(context) {\n  return new Step(context, 1);\n}\n"],
  "mappings": "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",
  "names": ["type", "SELECTION_CHANGE_COMMAND", "INSERT_PARAGRAPH_COMMAND", "FORMAT_TEXT_COMMAND", "$getSelection", "$isRangeSelection", "s", "$setSelection", "format", "mutatedNodes", "copy", "leftTree", "rightTree", "point", "value", "anchorNode", "$createParagraphNode", "a", "index", "x", "c", "range", "newElement", "dirtyElements", "dirtyLeaves", "self", "resolvedNode", "left", "right", "TextNode", "mode", "COMMAND_PRIORITY_LOW", "map", "activeEditor", "name", "useLexicalComposerContext", "React", "LexicalComposer", "LexicalComposer", "React", "_setPrototypeOf", "o", "p", "changedArray", "a", "index", "ErrorBoundary", "LexicalErrorBoundary", "LexicalErrorBoundary", "range", "value", "point", "createElement", "selection", "x", "React", "HorizontalRuleNode", "Prism", "_self", "v", "lang", "value", "type", "name", "s", "k", "count", "array", "range", "Prism", "html", "value", "Prism", "Prism", "Prism", "Prism", "Prism", "Prism", "self", "format", "count", "type", "range", "LexicalCode", "value", "append", "index", "self", "LexicalList", "selection", "html", "selection", "parser", "c", "range", "x", "y", "range", "selection", "format", "LexicalRichText", "linkNode", "LexicalLink", "link", "list", "index", "transformer", "format", "maxIndex", "type", "exportChildren", "QUOTE", "LexicalMarkdown", "MarkdownShortcutPlugin", "subscription", "value", "s", "React", "RichTextPlugin", "TabIndentationPlugin", "React", "React", "React", "React", "React", "React", "React", "import_react", "import_jsx_runtime", "a", "a", "x", "left", "a", "right", "center", "x", "blur", "y", "x", "sum", "s", "x", "y", "key", "value", "count", "reverse", "ticks", "max", "value", "index", "array", "range", "shuffle", "array", "map", "value", "index", "x", "x", "y", "number", "scale", "tickFormat", "k", "axis", "format", "range", "path", "scale", "max", "min", "number2", "x", "y", "pi", "tau", "epsilon", "k", "x", "y", "x1", "x2", "y2", "x0", "da", "slice", "array", "slice", "epsilon", "epsilon", "epsilon", "epsilon", "u", "epsilon", "bc", "ca", "ab", "u", "abt", "bct", "cat", "_8", "_16", "fin", "fin2", "epsilon", "ab", "bc", "_8", "_8b", "_16", "_48", "fin", "tau", "name", "value", "s", "seconds", "milliseconds", "parse", "c", "format", "parse", "csv", "tsv", "type", "x", "y", "x0", "x1", "right", "bottom", "x", "y", "x0", "x1", "x0", "x1", "x", "y", "x0", "x1", "x2", "y2", "x3", "y3", "x", "y", "x0", "x1", "right", "bottom", "x0", "x1", "x0", "x1", "x", "y", "x0", "x1", "copy", "x", "x", "value", "value", "s", "x", "x", "x", "identity_default", "x", "map", "locale", "group", "identity_default", "sign", "zero", "type", "format", "value", "c", "formatPrefix", "k", "value", "max", "epsilon", "epsilon2", "pi", "halfPi", "tau", "abs", "cos", "sin", "x", "pi", "halfPi", "spherical", "phi", "cos", "sin", "a", "phi", "abs", "pi", "tau", "buffer_default", "x", "y", "a", "abs", "epsilon", "point", "compareIntersection", "n", "x", "epsilon", "array", "a", "point", "abs", "pi", "tau", "phi", "sin", "cos", "sum", "halfPi", "epsilon", "sign", "k", "intersection", "epsilon2", "buffer_default", "point", "phi", "a", "halfPi", "epsilon", "pi", "halfPi", "abs", "epsilon", "sin", "cos", "phi", "areaSum", "areaRingSum", "x", "y", "tau", "s", "x", "y", "cos", "x", "y", "scale", "x", "y", "cos", "k", "sin", "c", "cc", "c", "sin", "phi", "halfPi", "x", "y", "phi", "phi", "sin", "cos", "x", "y", "abs", "epsilon2", "x", "y", "cos", "k", "sin", "phi", "phi2", "x", "y", "abs", "epsilon", "x", "y", "cos", "sin", "x", "y", "cos", "k", "sin", "phi", "halfPi", "x", "y", "count", "sum", "index", "index", "index", "find_default", "index", "value", "sum", "path_default", "k", "a", "c", "Node", "find_default", "path_default", "x0", "x1", "k", "Node", "x0", "x1", "k", "x0", "x1", "value", "x", "custom", "x0", "x1", "value", "x", "min", "max", "min", "max", "x", "y", "sum", "k", "c", "x", "v", "u", "X", "Y", "x", "B", "y", "sign", "s", "k", "k", "a", "x", "a", "a", "u", "B", "s", "k", "range", "index", "range", "scale", "value", "scale", "reverse", "x", "number", "x", "identity", "x", "a", "range", "i", "transformer", "piecewise", "scale", "y", "number", "u", "count", "value", "scale", "count", "count", "range", "k", "k", "ticks", "count", "reverse", "step", "y", "locale", "formatYear", "formats", "c", "pad", "format", "parse", "value", "sign", "s", "name", "locale", "defaultLocale", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "scheme", "c", "range", "constant_default", "x", "constant", "abs", "atan2", "cos", "max", "min", "sin", "sqrt", "epsilon", "pi", "halfPi", "tau", "acos", "x", "asin", "x0", "x1", "x2", "y2", "x3", "y3", "x32", "y32", "epsilon", "sqrt", "D", "max", "innerRadius", "constant_default", "path", "halfPi", "da", "abs", "tau", "cos", "sin", "min", "t0", "t1", "asin", "pi", "acos", "atan2", "a", "slice", "array_default", "x", "x", "y", "a", "identity_default", "value", "identity_default", "sort", "constant_default", "tau", "array_default", "k", "sum", "index", "da", "v", "i", "j", "a", "radial", "sqrt3", "sqrt", "sqrt", "sin", "pi", "tau", "cos", "sqrt3", "sqrt", "sqrt3", "sqrt", "sqrt", "noop_default", "point", "x", "y", "noop_default", "x", "y", "point", "x", "y", "x0", "point", "x", "y", "x0", "custom", "beta", "point", "x", "y", "custom", "tension", "noop_default", "x", "y", "point", "custom", "tension", "x", "y", "point", "custom", "tension", "point", "x", "y", "x1", "x2", "y2", "epsilon", "a", "custom", "alpha", "noop_default", "x", "y", "point", "custom", "alpha", "x", "y", "point", "custom", "alpha", "noop_default", "x", "y", "sign", "x", "x2", "y2", "point", "t0", "t1", "x0", "x1", "y", "x", "y", "a", "x", "y", "x1", "x", "y", "X", "map", "Y", "svg", "format", "value2", "v", "value", "React", "index", "HelpOutlineOutlined", "value2", "s", "normalize", "value2", "gql", "Fragment$1", "max", "DeleteIcon", "v", "type", "name", "s", "k", "count", "array", "range", "html", "require$$1", "point", "require$$1", "x", "require$$1", "format", "count", "type", "range", "require$$1", "require$$1", "value2", "append", "index", "require$$1", "html", "require$$1", "parser", "c", "range", "require$$1", "x", "y", "range", "format", "require$$1", "link", "index", "transformer", "format", "maxIndex", "type", "QUOTE", "type", "SubjectIcon", "TitleIcon", "FormatListBulletedIcon", "FormatListNumberedIcon", "FormatBoldIcon", "FormatItalicIcon", "CodeIcon", "StrikethroughSIcon", "value2", "LexicalErrorBoundary", "index", "value22", "ExpandMoreIcon", "ChevronRightIcon", "group", "React", "Fragment$1"]
}
