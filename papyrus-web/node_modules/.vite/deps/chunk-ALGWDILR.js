import {
  require_MoreVert
} from "./chunk-G2STZICV.js";
import {
  require_Delete
} from "./chunk-S7GHAAFQ.js";
import {
  require_ChevronRight
} from "./chunk-6QAZUADE.js";
import {
  require_ExpandMore
} from "./chunk-S2Y5JDGU.js";
import {
  require_Edit
} from "./chunk-T775FBGK.js";
import {
  InputAdornment_default
} from "./chunk-XFHPGFUQ.js";
import {
  TextField_default
} from "./chunk-KKAIIBQI.js";
import {
  MenuItem_default
} from "./chunk-BPTBL6MC.js";
import {
  ListItemIcon_default
} from "./chunk-2T45WZ2P.js";
import {
  ListItemText_default
} from "./chunk-3Z2XKYYI.js";
import {
  Menu_default
} from "./chunk-CF7T5PES.js";
import {
  DRAG_SOURCES_TYPE,
  IconOverlay,
  Toast,
  useDeletionConfirmationDialog,
  useMultiToast,
  useSelection
} from "./chunk-NYSHD5KH.js";
import {
  require_jsx_runtime
} from "./chunk-MN6XLW6Q.js";
import {
  useMachine
} from "./chunk-J34WXHB4.js";
import {
  Machine,
  assign
} from "./chunk-SRTTMZV5.js";
import {
  require_Close
} from "./chunk-KRCK54RH.js";
import {
  require_createSvgIcon
} from "./chunk-7AV4KTZL.js";
import {
  FilterList_default,
  SwapHoriz_default
} from "./chunk-DJCLTQTG.js";
import {
  require_interopRequireDefault,
  require_interopRequireWildcard
} from "./chunk-7RCLPMH3.js";
import {
  makeStyles_default
} from "./chunk-VM2MZLUW.js";
import {
  Typography_default
} from "./chunk-OSUJ7GDT.js";
import {
  IconButton_default
} from "./chunk-TSYRDUXI.js";
import {
  useLazyQuery,
  useMutation,
  useQuery,
  useSubscription
} from "./chunk-Z2MHMT5I.js";
import {
  gql
} from "./chunk-JJXTUFQN.js";
import {
  require_react
} from "./chunk-QCWLDGW7.js";
import {
  __commonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// ../node_modules/@material-ui/icons/UnfoldMore.js
var require_UnfoldMore = __commonJS({
  "../node_modules/@material-ui/icons/UnfoldMore.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _interopRequireWildcard = require_interopRequireWildcard();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var React2 = _interopRequireWildcard(require_react());
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _default = (0, _createSvgIcon.default)(React2.createElement("path", {
      d: "M12 5.83L15.17 9l1.41-1.41L12 3 7.41 7.59 8.83 9 12 5.83zm0 12.34L8.83 15l-1.41 1.41L12 21l4.59-4.59L15.17 15 12 18.17z"
    }), "UnfoldMore");
    exports.default = _default;
  }
});

// ../node_modules/@material-ui/icons/CropDin.js
var require_CropDin = __commonJS({
  "../node_modules/@material-ui/icons/CropDin.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _interopRequireWildcard = require_interopRequireWildcard();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var React2 = _interopRequireWildcard(require_react());
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _default = (0, _createSvgIcon.default)(React2.createElement("path", {
      d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z"
    }), "CropDin");
    exports.default = _default;
  }
});

// ../node_modules/@eclipse-sirius/sirius-components-trees/dist/sirius-components-trees.es.js
var import_react = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_Delete = __toESM(require_Delete());
var import_Edit = __toESM(require_Edit());
var import_UnfoldMore = __toESM(require_UnfoldMore());
var import_Close = __toESM(require_Close());
var import_CropDin = __toESM(require_CropDin());
var import_MoreVert = __toESM(require_MoreVert());
var import_ChevronRight = __toESM(require_ChevronRight());
var import_ExpandMore = __toESM(require_ExpandMore());
var TreeToolBarContext = import_react.default.createContext([]);
var TreeToolBarContribution = ({}) => {
  return null;
};
var deleteTreeItemMutation = gql`
  mutation deleteTreeItem($input: DeleteTreeItemInput!) {
    deleteTreeItem(input: $input) {
      __typename
      ... on ErrorPayload {
        message
      }
    }
  }
`;
var isErrorPayload = (payload) => payload.__typename === "ErrorPayload";
var TreeItemContextMenuContext = import_react.default.createContext([]);
var TreeItemContextMenu = ({
  menuAnchor,
  editingContextId,
  treeId,
  item,
  readOnly,
  treeItemMenuContributionComponents,
  depth,
  onExpand,
  onExpandAll,
  enterEditingMode,
  onClose
}) => {
  const [state, setState] = (0, import_react.useState)({ message: null });
  const { showDeletionConfirmation } = useDeletionConfirmationDialog();
  const expandItem = () => {
    if (!item.expanded && item.hasChildren) {
      onExpand(item.id, depth);
    }
  };
  const [deleteTreeItem, { loading: deleteTreeItemLoading, data: deleteTreeItemData, error: deleteTreeItemError }] = useMutation(deleteTreeItemMutation);
  const deleteItem = () => {
    const input = {
      id: crypto.randomUUID(),
      editingContextId,
      representationId: treeId,
      treeItemId: item.id
    };
    showDeletionConfirmation(() => {
      deleteTreeItem({ variables: { input } });
      onClose();
    });
  };
  (0, import_react.useEffect)(() => {
    if (!deleteTreeItemLoading) {
      if (deleteTreeItemError) {
        setState({
          message: "An error has occurred while executing this action, please contact the server administrator"
        });
      }
      if (deleteTreeItemData) {
        const { deleteTreeItem: deleteTreeItem2 } = deleteTreeItemData;
        if (isErrorPayload(deleteTreeItem2)) {
          const { message } = deleteTreeItem2;
          setState({ message });
        }
      }
    }
  }, [deleteTreeItemLoading, deleteTreeItemError, deleteTreeItemData]);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    (0, import_jsx_runtime.jsxs)(
      Menu_default,
      {
        id: "treeitem-contextmenu",
        anchorEl: menuAnchor,
        keepMounted: true,
        open: true,
        onClose,
        "data-testid": "treeitem-contextmenu",
        disableRestoreFocus: true,
        getContentAnchorEl: null,
        anchorOrigin: {
          vertical: "bottom",
          horizontal: "right"
        },
        children: [
          treeItemMenuContributionComponents.map((component, index) => {
            const props = {
              editingContextId,
              item,
              readOnly,
              onClose,
              expandItem,
              key: index.toString(),
              treeId
            };
            const element = import_react.default.createElement(component, props);
            return element;
          }),
          item.hasChildren ? (0, import_jsx_runtime.jsxs)(
            MenuItem_default,
            {
              "data-testid": "expand-all",
              onClick: () => {
                onExpandAll(item);
                onClose();
              },
              disabled: readOnly,
              "aria-disabled": true,
              children: [
                (0, import_jsx_runtime.jsx)(ListItemIcon_default, { children: (0, import_jsx_runtime.jsx)(import_UnfoldMore.default, { fontSize: "small" }) }),
                (0, import_jsx_runtime.jsx)(ListItemText_default, { primary: "Expand all" })
              ]
            },
            "expand-all"
          ) : null,
          item.editable ? (0, import_jsx_runtime.jsxs)(
            MenuItem_default,
            {
              onClick: enterEditingMode,
              "data-testid": "rename-tree-item",
              disabled: readOnly,
              "aria-disabled": true,
              children: [
                (0, import_jsx_runtime.jsx)(ListItemIcon_default, { children: (0, import_jsx_runtime.jsx)(import_Edit.default, { fontSize: "small" }) }),
                (0, import_jsx_runtime.jsx)(ListItemText_default, { primary: "Rename" })
              ]
            },
            "rename"
          ) : null,
          item.deletable ? (0, import_jsx_runtime.jsxs)(MenuItem_default, { onClick: deleteItem, "data-testid": "delete", disabled: readOnly, "aria-disabled": true, children: [
            (0, import_jsx_runtime.jsx)(ListItemIcon_default, { children: (0, import_jsx_runtime.jsx)(import_Delete.default, { fontSize: "small" }) }),
            (0, import_jsx_runtime.jsx)(ListItemText_default, { primary: "Delete" })
          ] }, "delete-tree-item") : null
        ]
      }
    ),
    (0, import_jsx_runtime.jsx)(Toast, { message: state.message, open: !!state.message, onClose: () => setState({ message: null }) })
  ] });
};
var TreeItemContextMenuContribution = ({}) => {
  return null;
};
var splitText = (label, userInput) => {
  if (!userInput) {
    return [label];
  }
  const caseInsensitiveSplitLabel = label.toLocaleLowerCase().split(userInput.toLocaleLowerCase()).flatMap((value, index2, array) => {
    if (index2 === 0 && value === "") {
      return [];
    } else if (index2 === array.length - 1 && value === "") {
      return [userInput.toLocaleLowerCase()];
    } else if (index2 === 0) {
      return [value];
    }
    return [userInput.toLocaleLowerCase(), value];
  });
  const splitLabel = [];
  let index = 0;
  for (const caseInsensitiveSegment of caseInsensitiveSplitLabel) {
    const caseSensitiveSegment = label.substring(index, index + caseInsensitiveSegment.length);
    splitLabel.push(caseSensitiveSegment);
    index = index + caseInsensitiveSegment.length;
  }
  return splitLabel;
};
var isFilterCandidate = (treeItem, textToFilter) => {
  let filter = false;
  const splitLabelWithTextToHighlight = splitText(treeItem.label, textToFilter);
  if (textToFilter === null || textToFilter === "") {
    filter = false;
  } else if (splitLabelWithTextToHighlight.length > 1) {
    filter = false;
  } else if (!treeItem.hasChildren && splitLabelWithTextToHighlight.length === 1 && splitLabelWithTextToHighlight[0].toLocaleLowerCase() !== textToFilter.toLocaleLowerCase()) {
    filter = true;
  } else if (splitLabelWithTextToHighlight.length === 1 && splitLabelWithTextToHighlight[0].toLocaleLowerCase() === textToFilter.toLocaleLowerCase()) {
    filter = false;
  } else if (textToFilter && treeItem.hasChildren && treeItem.expanded && treeItem.children.map((child) => child.label.toLocaleLowerCase().split(textToFilter.toLocaleLowerCase()).length).every((v) => v === 1)) {
    filter = treeItem.children.map((child) => isFilterCandidate(child, textToFilter)).every((v) => v === true);
  }
  return filter;
};
var useTreeToolbarStyles = makeStyles_default((theme) => ({
  toolbar: {
    display: "flex",
    flexDirection: "row",
    overflow: "hidden",
    height: theme.spacing(4),
    paddingLeft: theme.spacing(1),
    paddingRight: theme.spacing(1),
    borderBottomWidth: "1px",
    borderBottomStyle: "solid",
    justifyContent: "right",
    borderBottomColor: theme.palette.divider
  }
}));
var TreeToolBar = ({
  editingContextId,
  onSynchronizedClick,
  synchronized,
  treeToolBarContributionComponents,
  readOnly
}) => {
  const classes = useTreeToolbarStyles();
  const preferenceButtonSynchroniseTitle = synchronized ? "Disable synchronisation with representation" : "Enable synchronisation with representation";
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (0, import_jsx_runtime.jsxs)("div", { className: classes.toolbar, children: [
    treeToolBarContributionComponents.map((component, index) => {
      const props = {
        editingContextId,
        disabled: readOnly,
        key: index.toString()
      };
      const element = import_react.default.createElement(component, props);
      return element;
    }),
    (0, import_jsx_runtime.jsx)(
      IconButton_default,
      {
        color: "inherit",
        size: "small",
        "aria-label": preferenceButtonSynchroniseTitle,
        title: preferenceButtonSynchroniseTitle,
        onClick: onSynchronizedClick,
        "data-testid": "tree-synchronise",
        children: (0, import_jsx_runtime.jsx)(SwapHoriz_default, { color: synchronized ? "inherit" : "disabled" })
      }
    )
  ] }) });
};
var useFilterBarStyles = makeStyles_default((theme) => ({
  filterbar: {
    display: "flex",
    flexDirection: "row",
    overflow: "hidden",
    paddingLeft: theme.spacing(1),
    paddingRight: theme.spacing(1),
    paddingBottom: theme.spacing(1)
  },
  textfield: {
    height: theme.spacing(3),
    fontSize: theme.typography.fontSize
  }
}));
var FilterBar = ({ onTextChange, onFilterButtonClick, onClose }) => {
  const classes = useFilterBarStyles();
  const initialState = {
    filterEnabled: false
  };
  const [state, setState] = (0, import_react.useState)(initialState);
  return (0, import_jsx_runtime.jsxs)("div", { className: classes.filterbar, children: [
    (0, import_jsx_runtime.jsx)(
      TextField_default,
      {
        id: "filterbar-textfield",
        "data-testid": "filterbar-textfield",
        name: "filterbar-textfield",
        placeholder: "Type to filter",
        spellCheck: false,
        variant: "outlined",
        size: "small",
        margin: "none",
        autoFocus: true,
        multiline: false,
        fullWidth: true,
        onChange: onTextChange,
        InputProps: {
          endAdornment: (0, import_jsx_runtime.jsx)(InputAdornment_default, { position: "end", children: (0, import_jsx_runtime.jsx)(
            IconButton_default,
            {
              "data-testid": "filterbar-filter-button",
              "aria-label": "filter",
              size: "small",
              onClick: () => {
                onFilterButtonClick(!state.filterEnabled);
                setState((prevState) => {
                  return { filterEnabled: !prevState.filterEnabled };
                });
              },
              children: (0, import_jsx_runtime.jsx)(FilterList_default, { fontSize: "small", color: state.filterEnabled ? "primary" : "secondary" })
            }
          ) }),
          className: classes.textfield
        }
      }
    ),
    (0, import_jsx_runtime.jsx)(
      IconButton_default,
      {
        "data-testid": "filterbar-close-button",
        size: "small",
        "aria-label": "close",
        color: "inherit",
        onClick: onClose,
        children: (0, import_jsx_runtime.jsx)(import_Close.default, { fontSize: "small" })
      }
    )
  ] });
};
var converter = {
  convert: (tree) => tree
};
var defaultContext = {
  converter
};
var ExplorerViewContext = import_react.default.createContext(defaultContext);
var ExplorerViewConfiguration = ({ children, converter: converter2 }) => {
  return (0, import_jsx_runtime.jsx)(ExplorerViewContext.Provider, { value: { converter: converter2 }, children });
};
var useExplorerViewConfiguration = () => {
  const { converter: converter2 } = (0, import_react.useContext)(ExplorerViewContext);
  return {
    converter: converter2
  };
};
var useTreeItemArrowStyle = makeStyles_default(() => ({
  arrow: {
    cursor: "pointer"
  },
  noChildren: {
    paddingLeft: "20px"
  }
}));
var TreeItemArrow = ({ item, depth, onExpand, "data-testid": dataTestid }) => {
  const classes = useTreeItemArrowStyle();
  if (item.hasChildren) {
    const onClick = () => onExpand(item.id, depth);
    if (item.expanded) {
      return (0, import_jsx_runtime.jsx)(import_ExpandMore.default, { className: classes.arrow, style: { fontSize: 20 }, onClick, "data-testid": dataTestid });
    } else {
      return (0, import_jsx_runtime.jsx)(
        import_ChevronRight.default,
        {
          className: classes.arrow,
          style: { fontSize: 20 },
          onClick,
          "data-testid": dataTestid
        }
      );
    }
  }
  return (0, import_jsx_runtime.jsx)("div", { className: classes.noChildren });
};
var renameTreeItemMutation = gql`
  mutation renameTreeItem($input: RenameTreeItemInput!) {
    renameTreeItem(input: $input) {
      __typename
      ... on ErrorPayload {
        message
      }
    }
  }
`;
var initialDirectEditElementLabeQuery = gql`
  query initialDirectEditElementLabel($editingContextId: ID!, $representationId: ID!, $treeItemId: ID!) {
    viewer {
      editingContext(editingContextId: $editingContextId) {
        representation(representationId: $representationId) {
          description {
            ... on TreeDescription {
              initialDirectEditTreeItemLabel(treeItemId: $treeItemId)
            }
          }
        }
      }
    }
  }
`;
var TreeItemDirectEditInput = ({
  editingContextId,
  treeId,
  treeItemId,
  editingkey,
  onClose
}) => {
  const [state, setState] = (0, import_react.useState)({
    newLabel: editingkey
  });
  const { addErrorMessage } = useMultiToast();
  const isErrorPayload2 = (payload) => payload.__typename === "ErrorPayload";
  const isSuccessPayload = (payload) => payload.__typename === "SuccessPayload";
  const textInput = (0, import_react.useRef)(null);
  const { data: initialLabelTreeItemItemData, error: initialLabelTreeItemItemError } = useQuery(initialDirectEditElementLabeQuery, {
    variables: {
      editingContextId,
      representationId: treeId,
      treeItemId
    }
  });
  (0, import_react.useEffect)(() => {
    let cleanup = void 0;
    if (initialLabelTreeItemItemError) {
      addErrorMessage("An unexpected error has occurred, please refresh the page");
    }
    if (initialLabelTreeItemItemData == null ? void 0 : initialLabelTreeItemItemData.viewer.editingContext.representation.description.initialDirectEditTreeItemLabel) {
      const initialLabel = initialLabelTreeItemItemData == null ? void 0 : initialLabelTreeItemItemData.viewer.editingContext.representation.description.initialDirectEditTreeItemLabel;
      if (!editingkey) {
        setState((prevState) => {
          return { ...prevState, newLabel: initialLabel };
        });
        const timeOutId = setTimeout(() => {
          textInput.current.select();
        }, 0);
        cleanup = () => clearTimeout(timeOutId);
      }
    }
    return cleanup;
  }, [initialLabelTreeItemItemError, initialLabelTreeItemItemData]);
  const [renameTreeItem, { data: renameTreeItemData, error: renameTreeItemError }] = useMutation(renameTreeItemMutation);
  (0, import_react.useEffect)(() => {
    if (renameTreeItemError) {
      addErrorMessage("An unexpected error has occurred, please refresh the page");
    }
    if (renameTreeItemData) {
      const { renameTreeItem: renameTreeItem2 } = renameTreeItemData;
      if (isErrorPayload2(renameTreeItem2)) {
        addErrorMessage(renameTreeItem2.message);
      } else if (isSuccessPayload(renameTreeItem2)) {
        if (renameTreeItem2.__typename === "SuccessPayload") {
          onClose();
        }
      }
    }
  }, [renameTreeItemData, renameTreeItemError]);
  const doRename = () => {
    renameTreeItem({
      variables: {
        input: {
          id: crypto.randomUUID(),
          editingContextId,
          representationId: treeId,
          treeItemId,
          newLabel: state.newLabel
        }
      }
    });
  };
  const handleChange = (event) => {
    const newLabel = event.target.value;
    setState((prevState) => {
      return { ...prevState, newLabel };
    });
  };
  const onFinishEditing = (event) => {
    const { key } = event;
    if (key === "Enter") {
      doRename();
    } else if (key === "Escape") {
      onClose();
    }
  };
  const onFocusIn = (event) => event.target.select();
  (0, import_react.useEffect)(() => {
    document.addEventListener("mousedown", doRename);
    return () => document.removeEventListener("mousedown", doRename);
  });
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (0, import_jsx_runtime.jsx)(
    TextField_default,
    {
      name: "name",
      size: "small",
      inputRef: textInput,
      placeholder: "Enter the new value",
      value: state.newLabel,
      onChange: handleChange,
      onFocus: onFocusIn,
      onKeyDown: onFinishEditing,
      autoFocus: true,
      "data-testid": "name-edit"
    }
  ) });
};
var useTreeItemStyle = makeStyles_default((theme) => ({
  treeItem: {
    display: "flex",
    flexDirection: "row",
    height: "24px",
    gap: theme.spacing(0.5),
    alignItems: "center",
    userSelect: "none",
    "&:focus-within": {
      borderWidth: "1px",
      borderColor: "black",
      borderStyle: "dotted"
    }
  },
  treeItemHover: {
    backgroundColor: theme.palette.action.hover
  },
  selected: {
    backgroundColor: theme.palette.action.selected,
    "&:hover": {
      backgroundColor: theme.palette.action.selected
    }
  },
  nonSelectable: {
    opacity: 0.6
  },
  arrow: {
    cursor: "pointer"
  },
  more: {
    hover: {
      backgroundColor: theme.palette.action.hover
    },
    focus: {
      backgroundColor: theme.palette.action.selected
    }
  },
  expandIcon: {
    marginLeft: "auto",
    marginRight: theme.spacing(1)
  },
  content: {
    display: "grid",
    gridTemplateRows: "1fr",
    gridTemplateColumns: "1fr 20px",
    columnGap: "8px",
    alignItems: "center",
    gridColumnStart: "2",
    gridColumnEnd: "3"
  },
  imageAndLabel: {
    display: "flex",
    flexDirection: "row",
    gap: "4px",
    alignItems: "center"
  },
  imageAndLabelSelectable: {
    cursor: "pointer"
  },
  label: {
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    maxWidth: "100ch"
  },
  selectedLabel: {
    fontWeight: "bold"
  },
  marked: {
    fontWeight: "bold"
  },
  ul: {
    marginLeft: theme.spacing(3)
  },
  highlight: {
    backgroundColor: theme.palette.navigation.leftBackground
  }
}));
var directEditActivationValidCharacters = /[\w&é§èàùçÔØÁÛÊË"«»’”„´$¥€£\\¿?!=+-,;:%/{}[\]–#@*.]/;
var TreeItem = ({
  editingContextId,
  treeId,
  item,
  depth,
  onExpand,
  onExpandAll,
  readOnly,
  textToHighlight,
  textToFilter,
  enableMultiSelection,
  markedItemIds
}) => {
  var _a;
  const classes = useTreeItemStyle();
  const treeItemMenuContributionComponents = (0, import_react.useContext)(TreeItemContextMenuContext).filter((contribution) => contribution.props.canHandle(treeId, item)).map((contribution) => contribution.props.component);
  const initialState = {
    showContextMenu: false,
    menuAnchor: null,
    editingMode: false,
    label: item.label,
    prevSelectionId: null,
    editingkey: ""
  };
  const [state, setState] = (0, import_react.useState)(initialState);
  const { showContextMenu, menuAnchor, editingMode } = state;
  const refDom = (0, import_react.useRef)();
  const { selection, setSelection } = useSelection();
  const [isHovered, setIsHovered] = (0, import_react.useState)(false);
  const handleMouseEnter = () => {
    setIsHovered(true);
  };
  const handleMouseLeave = () => {
    setIsHovered(false);
  };
  const openContextMenu = (event) => {
    if (!showContextMenu) {
      const { currentTarget } = event;
      setState((prevState) => {
        return {
          showContextMenu: true,
          menuAnchor: currentTarget,
          editingMode: false,
          editingkey: prevState.editingkey,
          label: item.label,
          prevSelectionId: prevState.prevSelectionId
        };
      });
    }
  };
  let contextMenu = null;
  if (showContextMenu) {
    const closeContextMenu = () => {
      setState((prevState) => {
        return {
          modalDisplayed: null,
          showContextMenu: false,
          menuAnchor: null,
          editingMode: false,
          editingkey: prevState.editingkey,
          label: item.label,
          prevSelectionId: prevState.prevSelectionId
        };
      });
    };
    const enterEditingMode = () => {
      setState((prevState) => {
        return {
          modalDisplayed: null,
          showContextMenu: false,
          menuAnchor: null,
          editingMode: true,
          editingkey: prevState.editingkey,
          label: item.label,
          prevSelectionId: prevState.prevSelectionId
        };
      });
    };
    contextMenu = (0, import_jsx_runtime.jsx)(
      TreeItemContextMenu,
      {
        menuAnchor,
        editingContextId,
        treeId,
        item,
        readOnly,
        treeItemMenuContributionComponents,
        depth,
        onExpand,
        onExpandAll,
        enterEditingMode,
        onClose: closeContextMenu
      }
    );
  }
  let children = null;
  if (item.expanded && item.children) {
    children = (0, import_jsx_runtime.jsx)("ul", { className: classes.ul, children: item.children.map((childItem) => {
      return (0, import_jsx_runtime.jsx)("li", { children: (0, import_jsx_runtime.jsx)(
        TreeItem,
        {
          editingContextId,
          treeId,
          item: childItem,
          depth: depth + 1,
          onExpand,
          onExpandAll,
          enableMultiSelection,
          readOnly,
          textToHighlight,
          textToFilter,
          markedItemIds
        }
      ) }, childItem.id);
    }) });
  }
  let className = classes.treeItem;
  let dataTestid = void 0;
  const selected = selection.entries.find((entry) => entry.id === item.id);
  if (selected) {
    className = `${className} ${classes.selected}`;
    dataTestid = "selected";
  }
  if (isHovered && item.selectable) {
    className = `${className} ${classes.treeItemHover}`;
  }
  (0, import_react.useEffect)(() => {
    var _a2, _b;
    if (selected) {
      if ((_a2 = refDom.current) == null ? void 0 : _a2.scrollIntoViewIfNeeded) {
        refDom.current.scrollIntoViewIfNeeded(true);
      } else {
        (_b = refDom.current) == null ? void 0 : _b.scrollIntoView({ behavior: "smooth" });
      }
    }
  }, [selected]);
  let image = (0, import_jsx_runtime.jsx)(import_CropDin.default, {});
  if (((_a = item.iconURL) == null ? void 0 : _a.length) > 0) {
    image = (0, import_jsx_runtime.jsx)(IconOverlay, { iconURL: item.iconURL, alt: item.kind });
  }
  let text;
  const onCloseEditingMode = () => {
    setState((prevState) => {
      return { ...prevState, editingMode: false };
    });
    refDom.current.focus();
  };
  const marked = markedItemIds.some((id) => id === item.id);
  if (editingMode) {
    text = (0, import_jsx_runtime.jsx)(
      TreeItemDirectEditInput,
      {
        editingContextId,
        treeId,
        treeItemId: item.id,
        editingkey: state.editingkey,
        onClose: onCloseEditingMode
      }
    );
  } else {
    let itemLabel;
    const splitLabelWithTextToHighlight = splitText(item.label, textToHighlight);
    if (textToHighlight === null || textToHighlight === "" || splitLabelWithTextToHighlight.length === 1 && splitLabelWithTextToHighlight[0].toLocaleLowerCase() !== item.label.toLocaleLowerCase()) {
      itemLabel = (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: item.label });
    } else {
      const languages = Array.from(navigator.languages);
      itemLabel = (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: splitLabelWithTextToHighlight.map((value, index) => {
        const shouldHighlight = value.localeCompare(textToHighlight, languages, { sensitivity: "base" }) === 0;
        return (0, import_jsx_runtime.jsx)(
          "span",
          {
            "data-testid": `${item.label}-${value}-${index}`,
            className: shouldHighlight ? classes.highlight : "",
            children: value
          },
          value + index
        );
      }) });
    }
    text = (0, import_jsx_runtime.jsx)(
      Typography_default,
      {
        variant: "body2",
        className: `${classes.label} ${selected ? classes.selectedLabel : ""} ${marked ? classes.marked : ""}`,
        children: itemLabel
      }
    );
  }
  const onClick = (event) => {
    if (!state.editingMode) {
      refDom.current.focus();
      if (!item.selectable) {
        return;
      }
      if ((event.ctrlKey || event.metaKey) && enableMultiSelection) {
        event.stopPropagation();
        const isItemInSelection = selection.entries.find((entry) => entry.id === item.id);
        if (isItemInSelection) {
          const newSelection = { entries: selection.entries.filter((entry) => entry.id !== item.id) };
          setSelection(newSelection);
        } else {
          const { id, label, kind } = item;
          const newEntry = { id, label, kind };
          const newSelection = { entries: [...selection.entries, newEntry] };
          setSelection(newSelection);
        }
      } else {
        const { id, label, kind } = item;
        setSelection({ entries: [{ id, label, kind }] });
      }
    }
  };
  const onBeginEditing = (event) => {
    if (!item.editable || editingMode || readOnly) {
      return;
    }
    const { key } = event;
    if ((event.altKey || event.shiftKey) && event.getModifierState(key)) {
      return;
    }
    const validFirstInputChar = !event.metaKey && !event.ctrlKey && key.length === 1 && directEditActivationValidCharacters.test(key);
    if (validFirstInputChar) {
      setState((prevState) => {
        return { ...prevState, editingMode: true, editingkey: key };
      });
    }
  };
  const dragStart = (event) => {
    const isDraggedItemSelected = selection.entries.map((entry) => entry.id).includes(item.id);
    if (!isDraggedItemSelected) {
      const itemEntry = { id: item.id, label: item.label, kind: item.kind };
      event.dataTransfer.setData(DRAG_SOURCES_TYPE, JSON.stringify([itemEntry]));
    } else if (selection.entries.length > 0) {
      event.dataTransfer.setData(DRAG_SOURCES_TYPE, JSON.stringify(selection.entries));
    }
  };
  const dragOver = (event) => {
    event.stopPropagation();
  };
  let tooltipText = "";
  if (item.kind.startsWith("siriusComponents://semantic")) {
    const query = item.kind.substring(item.kind.indexOf("?") + 1, item.kind.length);
    const params = new URLSearchParams(query);
    if (params.has("domain") && params.has("entity")) {
      tooltipText = params.get("domain") + "::" + params.get("entity");
    }
  } else if (item.kind.startsWith("siriusComponents://representation")) {
    const query = item.kind.substring(item.kind.indexOf("?") + 1, item.kind.length);
    const params = new URLSearchParams(query);
    if (params.has("type")) {
      tooltipText = params.get("type");
    }
  }
  const shouldDisplayMoreButton = item.deletable || item.editable || treeItemMenuContributionComponents.length > 0;
  let currentTreeItem;
  if (textToFilter && isFilterCandidate(item, textToFilter)) {
    currentTreeItem = null;
  } else {
    currentTreeItem = (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
      (0, import_jsx_runtime.jsxs)(
        "div",
        {
          className,
          draggable: true,
          onClick,
          onDragStart: dragStart,
          onDragOver: dragOver,
          onMouseEnter: handleMouseEnter,
          onMouseLeave: handleMouseLeave,
          children: [
            (0, import_jsx_runtime.jsx)(TreeItemArrow, { item, depth, onExpand, "data-testid": `${item.label}-toggle` }),
            (0, import_jsx_runtime.jsx)(
              "div",
              {
                ref: refDom,
                tabIndex: 0,
                onKeyDown: onBeginEditing,
                "data-treeitemid": item.id,
                "data-treeitemlabel": item.label,
                "data-treeitemkind": item.kind,
                "data-haschildren": item.hasChildren.toString(),
                "data-depth": depth,
                "data-expanded": item.expanded.toString(),
                "data-testid": dataTestid,
                children: (0, import_jsx_runtime.jsxs)("div", { className: `${classes.content} ${item.selectable ? "" : classes.nonSelectable}`, children: [
                  (0, import_jsx_runtime.jsxs)(
                    "div",
                    {
                      className: `${classes.imageAndLabel} ${item.selectable ? classes.imageAndLabelSelectable : ""}`,
                      onDoubleClick: () => item.hasChildren && onExpand(item.id, depth),
                      title: tooltipText,
                      "data-testid": item.label,
                      children: [
                        image,
                        text
                      ]
                    }
                  ),
                  shouldDisplayMoreButton ? (0, import_jsx_runtime.jsx)(
                    IconButton_default,
                    {
                      className: classes.more,
                      size: "small",
                      onClick: openContextMenu,
                      "data-testid": `${item.label}-more`,
                      children: (0, import_jsx_runtime.jsx)(import_MoreVert.default, { style: { fontSize: 12 } })
                    }
                  ) : null
                ] })
              }
            ),
            !shouldDisplayMoreButton && isHovered && item.hasChildren && (0, import_jsx_runtime.jsx)(
              IconButton_default,
              {
                className: classes.expandIcon,
                size: "small",
                "data-testid": "expand-all",
                title: "expand all",
                onClick: () => {
                  onExpandAll(item);
                },
                children: (0, import_jsx_runtime.jsx)(import_UnfoldMore.default, { style: { fontSize: 12 } })
              }
            )
          ]
        }
      ),
      children,
      contextMenu
    ] });
  }
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: currentTreeItem });
};
var useTreeStyle = makeStyles_default((_) => ({
  ul: {
    width: "inherit",
    minWidth: "fit-content"
  }
}));
var Tree = ({
  editingContextId,
  tree,
  onExpand,
  onExpandAll,
  readOnly,
  enableMultiSelection = true,
  textToHighlight,
  textToFilter,
  markedItemIds
}) => {
  const classes = useTreeStyle();
  const treeElement = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(() => {
    const downHandler = (event) => {
      if ((event.key === "ArrowLeft" || event.key === "ArrowRight" || event.key === "ArrowUp" || event.key === "ArrowDown") && event.target.tagName !== "INPUT") {
        event.preventDefault();
        const previousItem = document.activeElement;
        const dataset = previousItem.dataset;
        if (dataset.treeitemid) {
          const treeItemDomElements = document.querySelectorAll("[data-treeitemid]");
          const index = Array.from(treeItemDomElements).indexOf(previousItem);
          const id = dataset.treeitemid;
          const hasChildren = dataset.haschildren === "true";
          const isExpanded = dataset.expanded === "true";
          switch (event.key) {
            case "ArrowLeft":
              if (hasChildren && isExpanded) {
                onExpand(id, dataset.depth);
              } else if (index > 0) {
                const parentDepth = (dataset.depth - 1).toString();
                let positionFromParent = 0;
                while (!(treeItemDomElements[index - positionFromParent].dataset.depth === parentDepth)) {
                  positionFromParent++;
                }
                treeItemDomElements[index - positionFromParent].click();
              }
              break;
            case "ArrowRight":
              if (hasChildren && !isExpanded) {
                onExpand(id, dataset.depth);
              } else if (index < treeItemDomElements.length - 1) {
                treeItemDomElements[index + 1].click();
              }
              break;
            case "ArrowUp":
              if (index > 0) {
                treeItemDomElements[index - 1].click();
              }
              break;
            case "ArrowDown":
              if (index < treeItemDomElements.length - 1) {
                treeItemDomElements[index + 1].click();
              }
              break;
          }
        }
      }
    };
    const element = treeElement == null ? void 0 : treeElement.current;
    if (element) {
      element.addEventListener("keydown", downHandler);
      return () => {
        element.removeEventListener("keydown", downHandler);
      };
    }
    return null;
  }, [treeElement, onExpand]);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (0, import_jsx_runtime.jsx)("div", { ref: treeElement, children: (0, import_jsx_runtime.jsx)("ul", { className: classes.ul, "data-testid": "tree-root-elements", children: tree.children.map((item) => (0, import_jsx_runtime.jsx)("li", { children: (0, import_jsx_runtime.jsx)(
    TreeItem,
    {
      editingContextId,
      treeId: tree.id,
      item,
      depth: 1,
      onExpand,
      onExpandAll,
      enableMultiSelection,
      readOnly,
      textToHighlight,
      textToFilter,
      markedItemIds
    }
  ) }, item.id)) }) }) });
};
var isTreeRefreshedEventPayload = (payload) => payload.__typename === "TreeRefreshedEventPayload";
var treeViewMachine = Machine(
  {
    type: "parallel",
    context: {
      id: crypto.randomUUID(),
      tree: null,
      expanded: [],
      maxDepth: 1,
      autoExpandToRevealSelection: true,
      treeItemToExpandAll: null,
      synchronizedWithSelection: true,
      message: null
    },
    states: {
      toast: {
        initial: "hidden",
        states: {
          hidden: {
            on: {
              SHOW_TOAST: {
                target: "visible",
                actions: "setMessage"
              }
            }
          },
          visible: {
            on: {
              HIDE_TOAST: {
                target: "hidden",
                actions: "clearMessage"
              }
            }
          }
        }
      },
      treeView: {
        initial: "idle",
        states: {
          idle: {
            on: {
              HANDLE_SUBSCRIPTION_RESULT: [
                {
                  cond: "isTreeRefreshedEventPayload",
                  target: "ready",
                  actions: "handleSubscriptionResult"
                },
                {
                  target: "idle",
                  actions: "handleSubscriptionResult"
                }
              ]
            }
          },
          ready: {
            on: {
              HANDLE_SUBSCRIPTION_RESULT: {
                target: "ready",
                actions: "handleSubscriptionResult"
              },
              AUTO_EXPAND_TO_REVEAL_SELECTION: {
                actions: "autoExpandToRevealSelection"
              },
              HANDLE_EXPANDED: {
                actions: "expand"
              },
              HANDLE_ON_EXPAND_ALL: {
                actions: "onExpandAll"
              },
              HANDLE_EXPAND_ALL_TREE_PATH: {
                actions: "expandAllTreePath"
              },
              HANDLE_TREE_PATH: {
                actions: "handleTreePath"
              },
              HANDLE_COMPLETE: {
                target: "complete"
              },
              SYNCHRONIZE_WITH_SELECTION: {
                actions: "synchronizeWithSelection"
              }
            }
          },
          complete: {
            type: "final"
          }
        }
      }
    }
  },
  {
    guards: {
      isTreeRefreshedEventPayload: (_, event) => {
        const { result } = event;
        const { data } = result;
        return isTreeRefreshedEventPayload(data.treeEvent);
      }
    },
    actions: {
      handleSubscriptionResult: assign((_, event) => {
        const { result } = event;
        const { data } = result;
        if (isTreeRefreshedEventPayload(data.treeEvent)) {
          const { tree } = data.treeEvent;
          return { tree };
        }
        return {};
      }),
      synchronizeWithSelection: assign((_, event) => {
        const { synchronizedWithSelection } = event;
        if (synchronizedWithSelection) {
          return { synchronizedWithSelection, autoExpandToRevealSelection: true };
        }
        return { synchronizedWithSelection, autoExpandToRevealSelection: false };
      }),
      autoExpandToRevealSelection: assign((context, event) => {
        const { autoExpandToRevealSelection } = event;
        const { synchronizedWithSelection } = context;
        if (synchronizedWithSelection) {
          return { autoExpandToRevealSelection };
        }
        return {};
      }),
      expand: assign((context, event) => {
        const { expanded, maxDepth } = context;
        const { id, depth } = event;
        if (expanded.includes(id)) {
          const newExpanded = [...expanded];
          newExpanded.splice(newExpanded.indexOf(id), 1);
          return { expanded: newExpanded, autoExpandToRevealSelection: false, maxDepth: Math.max(maxDepth, depth) };
        }
        return { expanded: [...expanded, id], maxDepth: Math.max(maxDepth, depth) };
      }),
      onExpandAll: assign((_, event) => {
        const { treeItemId } = event;
        return { treeItemToExpandAll: treeItemId };
      }),
      expandAllTreePath: assign((context, event) => {
        var _a, _b;
        const { expanded, maxDepth } = context;
        const { expandAllTreePathData } = event;
        if ((_b = (_a = expandAllTreePathData.viewer) == null ? void 0 : _a.editingContext) == null ? void 0 : _b.expandAllTreePath) {
          const { treeItemIdsToExpand, maxDepth: expandedMaxDepth } = expandAllTreePathData.viewer.editingContext.expandAllTreePath;
          const newExpanded = [...expanded];
          treeItemIdsToExpand == null ? void 0 : treeItemIdsToExpand.forEach((itemToExpand) => {
            if (!expanded.includes(itemToExpand)) {
              newExpanded.push(itemToExpand);
            }
          });
          return {
            expanded: newExpanded,
            maxDepth: Math.max(expandedMaxDepth, maxDepth),
            treeItemToExpandAll: null
          };
        }
        return { treeItemToExpandAll: null };
      }),
      handleTreePath: assign((context, event) => {
        var _a, _b;
        const { expanded, maxDepth } = context;
        const { treePathData } = event;
        if ((_b = (_a = treePathData.viewer) == null ? void 0 : _a.editingContext) == null ? void 0 : _b.treePath) {
          const { treeItemIdsToExpand, maxDepth: expandedMaxDepth } = treePathData.viewer.editingContext.treePath;
          const newExpanded = [...expanded];
          treeItemIdsToExpand == null ? void 0 : treeItemIdsToExpand.forEach((itemToExpand) => {
            if (!expanded.includes(itemToExpand)) {
              newExpanded.push(itemToExpand);
            }
          });
          return { expanded: newExpanded, maxDepth: Math.max(expandedMaxDepth, maxDepth) };
        }
        return {};
      }),
      setMessage: assign((_, event) => {
        const { message } = event;
        return { message };
      }),
      clearMessage: assign((_) => {
        return { message: null };
      })
    }
  }
);
var getTreeEventSubscription = (depth) => {
  const treeChildren = recursiveGetChildren(depth);
  const subscription = `
subscription treeEvent($input: TreeEventInput!) {
  treeEvent(input: $input) {
    __typename
    ... on TreeRefreshedEventPayload {
      id
      tree {
        id
        children {
          ${treeChildren}
        }
      }
    }
  }
}
`;
  return subscription + fragment;
};
var fragment = `
fragment treeItemFields on TreeItem {
  id
  hasChildren
  expanded
  label
  editable
  deletable
  selectable
  kind
  iconURL
}
`;
var recursiveGetChildren = (depth) => {
  let children = "";
  if (depth > 0) {
    children = `
    children {
      ${recursiveGetChildren(depth - 1)}
    }`;
  }
  return `...treeItemFields${children}`;
};
var getTreePathQuery = gql`
  query getTreePath($editingContextId: ID!, $treeId: ID!, $selectionEntryIds: [ID!]!) {
    viewer {
      editingContext(editingContextId: $editingContextId) {
        treePath(treeId: $treeId, selectionEntryIds: $selectionEntryIds) {
          treeItemIdsToExpand
          maxDepth
        }
      }
    }
  }
`;
var getExpandAllTreePathQuery = gql`
  query getExpandAllTreePath($editingContextId: ID!, $treeId: ID!, $treeItemId: ID!) {
    viewer {
      editingContext(editingContextId: $editingContextId) {
        expandAllTreePath(treeId: $treeId, treeItemId: $treeItemId) {
          treeItemIdsToExpand
          maxDepth
        }
      }
    }
  }
`;
var TreeView = ({
  editingContextId,
  readOnly,
  treeId,
  enableMultiSelection,
  synchronizedWithSelection,
  textToHighlight,
  textToFilter,
  markedItemIds = [],
  converter: converter2
}) => {
  const [{ value, context }, dispatch] = useMachine(treeViewMachine, {
    context: {
      synchronizedWithSelection
    }
  });
  const { selection } = useSelection();
  const { toast, treeView } = value;
  const { id, tree, expanded, maxDepth, autoExpandToRevealSelection, treeItemToExpandAll, message } = context;
  const [getTreePath, { loading: treePathLoading, data: treePathData, error: treePathError }] = useLazyQuery(getTreePathQuery);
  const [
    getExpandAllTreePath,
    { loading: expandAllTreePathLoading, data: expandAllTreePathData, error: expandAllTreePathError }
  ] = useLazyQuery(getExpandAllTreePathQuery);
  const selectionKey = selection == null ? void 0 : selection.entries.map((entry) => entry.id).sort().join(":");
  (0, import_react.useEffect)(() => {
    if (tree && autoExpandToRevealSelection) {
      const variables = {
        editingContextId,
        treeId: tree.id,
        selectionEntryIds: selection.entries.map((entry) => entry.id)
      };
      getTreePath({ variables });
    }
  }, [editingContextId, tree, selectionKey, autoExpandToRevealSelection, getTreePath]);
  (0, import_react.useEffect)(() => {
    if (!treePathLoading) {
      if (treePathData) {
        const handleTreePathEvent = { type: "HANDLE_TREE_PATH", treePathData };
        dispatch(handleTreePathEvent);
      }
      if (treePathError) {
        const { message: message2 } = treePathError;
        const showToastEvent = { type: "SHOW_TOAST", message: message2 };
        dispatch(showToastEvent);
      }
    }
  }, [treePathLoading, treePathData, treePathError]);
  (0, import_react.useEffect)(() => {
    if (tree && treeItemToExpandAll) {
      const variables = {
        editingContextId,
        treeId: tree.id,
        treeItemId: treeItemToExpandAll
      };
      getExpandAllTreePath({ variables });
    }
  }, [editingContextId, tree, treeItemToExpandAll, getExpandAllTreePathQuery]);
  (0, import_react.useEffect)(() => {
    if (!expandAllTreePathLoading) {
      if (expandAllTreePathData) {
        const handleExpandAllTreePathEvent = {
          type: "HANDLE_EXPAND_ALL_TREE_PATH",
          expandAllTreePathData
        };
        dispatch(handleExpandAllTreePathEvent);
      }
      if (expandAllTreePathError) {
        const { message: message2 } = expandAllTreePathError;
        const showToastEvent = { type: "SHOW_TOAST", message: message2 };
        dispatch(showToastEvent);
      }
    }
  }, [expandAllTreePathLoading, expandAllTreePathData, expandAllTreePathError]);
  const { error } = useSubscription(gql(getTreeEventSubscription(maxDepth)), {
    variables: {
      input: {
        id,
        treeId,
        editingContextId,
        expanded
      }
    },
    fetchPolicy: "no-cache",
    skip: treeView === "complete",
    onData: ({ data }) => {
      const handleDataEvent = {
        type: "HANDLE_SUBSCRIPTION_RESULT",
        result: data
      };
      dispatch(handleDataEvent);
    },
    onComplete: () => {
      const completeEvent = { type: "HANDLE_COMPLETE" };
      dispatch(completeEvent);
    }
  });
  (0, import_react.useEffect)(() => {
    if (error) {
      const { message: message2 } = error;
      const showToastEvent = { type: "SHOW_TOAST", message: message2 };
      dispatch(showToastEvent);
    }
  }, [error, dispatch]);
  (0, import_react.useEffect)(() => {
    const autoExpandToRevealSelectionEvent = {
      type: "AUTO_EXPAND_TO_REVEAL_SELECTION",
      autoExpandToRevealSelection: true
    };
    dispatch(autoExpandToRevealSelectionEvent);
  }, [selection]);
  (0, import_react.useEffect)(() => {
    const synchronizeWithSelectionEvent = {
      type: "SYNCHRONIZE_WITH_SELECTION",
      synchronizedWithSelection
    };
    dispatch(synchronizeWithSelectionEvent);
  }, [synchronizedWithSelection]);
  const onExpand = (id2, depth) => {
    const handleExpandedEvent = { type: "HANDLE_EXPANDED", id: id2, depth };
    dispatch(handleExpandedEvent);
  };
  const onExpandAll = (treeItem) => {
    const handleOnExpandAllEvent = { type: "HANDLE_ON_EXPAND_ALL", treeItemId: treeItem.id };
    dispatch(handleOnExpandAllEvent);
  };
  const treeConverter = converter2 ? converter2 : { convert: (gqlTree) => gqlTree };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    (0, import_jsx_runtime.jsx)("div", { "data-testid": treeId, children: tree ? (0, import_jsx_runtime.jsx)(
      Tree,
      {
        editingContextId,
        tree: treeConverter.convert(tree),
        onExpand,
        onExpandAll,
        readOnly,
        enableMultiSelection,
        markedItemIds,
        textToFilter,
        textToHighlight
      }
    ) : null }),
    (0, import_jsx_runtime.jsx)(
      Toast,
      {
        message,
        open: toast === "visible",
        onClose: () => dispatch({ type: "HIDE_TOAST" })
      }
    )
  ] });
};
var useStyles = makeStyles_default((theme) => ({
  treeView: {
    display: "flex",
    flexDirection: "column"
  },
  treeContent: {
    paddingTop: theme.spacing(1),
    flexGrow: 1,
    overflow: "auto"
  }
}));
var ExplorerView = (props) => {
  const styles = useStyles();
  const { converter: converter2 } = useExplorerViewConfiguration();
  const initialState = {
    synchronizedWithSelection: true,
    filterBar: false,
    filterBarText: "",
    filterBarTreeFiltering: false
  };
  const [state, setState] = (0, import_react.useState)(initialState);
  const treeToolBarContributionComponents = (0, import_react.useContext)(TreeToolBarContext).map(
    (contribution) => contribution.props.component
  );
  const treeElement = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(() => {
    const downHandler = (event) => {
      if ((event.ctrlKey === true || event.metaKey === true) && event.key === "f" && event.target.tagName !== "INPUT") {
        event.preventDefault();
        setState((prevState) => {
          return { ...prevState, filterBar: true, filterBarText: "", filterBarTreeFiltering: false };
        });
      }
    };
    const element = treeElement == null ? void 0 : treeElement.current;
    if (element) {
      element.addEventListener("keydown", downHandler);
      return () => {
        element.removeEventListener("keydown", downHandler);
      };
    }
    return null;
  }, [treeElement]);
  let filterBar;
  if (state.filterBar) {
    filterBar = (0, import_jsx_runtime.jsx)(
      FilterBar,
      {
        onTextChange: (event) => {
          const {
            target: { value }
          } = event;
          setState((prevState) => {
            return { ...prevState, filterBarText: value };
          });
        },
        onFilterButtonClick: (enabled) => setState((prevState) => {
          return { ...prevState, filterBarTreeFiltering: enabled };
        }),
        onClose: () => setState((prevState) => {
          return { ...prevState, filterBar: false, filterBarText: "", filterBarTreeFiltering: false };
        })
      }
    );
  }
  return (0, import_jsx_runtime.jsxs)("div", { className: styles.treeView, ref: treeElement, children: [
    (0, import_jsx_runtime.jsx)(
      TreeToolBar,
      {
        ...props,
        onSynchronizedClick: () => setState((prevState) => {
          return { ...prevState, synchronizedWithSelection: !state.synchronizedWithSelection };
        }),
        synchronized: state.synchronizedWithSelection,
        treeToolBarContributionComponents
      }
    ),
    (0, import_jsx_runtime.jsxs)("div", { className: styles.treeContent, children: [
      filterBar,
      (0, import_jsx_runtime.jsx)(
        TreeView,
        {
          ...props,
          treeId: "explorer://",
          enableMultiSelection: true,
          synchronizedWithSelection: state.synchronizedWithSelection,
          textToHighlight: state.filterBarText,
          textToFilter: state.filterBarTreeFiltering ? state.filterBarText : null,
          converter: converter2
        }
      )
    ] })
  ] });
};

export {
  TreeToolBarContext,
  TreeToolBarContribution,
  TreeItemContextMenuContext,
  TreeItemContextMenu,
  TreeItemContextMenuContribution,
  splitText,
  isFilterCandidate,
  ExplorerViewConfiguration,
  useExplorerViewConfiguration,
  TreeView,
  ExplorerView
};
//# sourceMappingURL=chunk-ALGWDILR.js.map
