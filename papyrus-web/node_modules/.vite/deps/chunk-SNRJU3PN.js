import {
  ToggleButtonGroup_default,
  ToggleButton_default,
  TreeItem_default,
  TreeView_default
} from "./chunk-LU4ZSRGR.js";
import {
  require_FormatListBulleted
} from "./chunk-IBH2YODD.js";
import {
  require_HelpOutlineOutlined
} from "./chunk-MYBT6HDQ.js";
import {
  cubehelix,
  cubehelixLong,
  number_default,
  quantize_default,
  rgb,
  rgbBasis,
  round_default,
  select_default,
  value_default
} from "./chunk-LGRVFEH5.js";
import {
  require_Delete
} from "./chunk-S7GHAAFQ.js";
import {
  require_ChevronRight
} from "./chunk-6QAZUADE.js";
import {
  require_ExpandMore
} from "./chunk-S2Y5JDGU.js";
import {
  Avatar_default
} from "./chunk-TDY4KRIT.js";
import {
  TableRow_default
} from "./chunk-QO66DLHO.js";
import {
  Table_default
} from "./chunk-RERSTXQB.js";
import {
  TableBody_default
} from "./chunk-5Q7WZCR7.js";
import {
  TableCell_default
} from "./chunk-DVDDEJSR.js";
import {
  Radio_default
} from "./chunk-B6IKDWVX.js";
import {
  RadioGroup_default
} from "./chunk-X6VMBKYA.js";
import {
  Link_default
} from "./chunk-M2CPW4JE.js";
import {
  CircularProgress_default
} from "./chunk-O3JXNHKG.js";
import {
  TextField_default
} from "./chunk-KKAIIBQI.js";
import {
  MenuItem_default
} from "./chunk-BPTBL6MC.js";
import {
  ListItemIcon_default
} from "./chunk-2T45WZ2P.js";
import {
  Select_default
} from "./chunk-UZDCVM6R.js";
import {
  ListItemText_default
} from "./chunk-3Z2XKYYI.js";
import {
  MenuList_default,
  Popover_default
} from "./chunk-CF7T5PES.js";
import {
  FormHelperText_default
} from "./chunk-CXISOORH.js";
import {
  Divider_default
} from "./chunk-W7IDD2LB.js";
import {
  IconOverlay,
  ServerContext,
  Toast,
  getCSSColor,
  useDeletionConfirmationDialog,
  useMultiToast,
  useSelection
} from "./chunk-NYSHD5KH.js";
import {
  require_jsx_runtime
} from "./chunk-MN6XLW6Q.js";
import {
  useMachine
} from "./chunk-J34WXHB4.js";
import {
  Machine,
  assign
} from "./chunk-SRTTMZV5.js";
import {
  require_createSvgIcon
} from "./chunk-7AV4KTZL.js";
import {
  require_interopRequireDefault,
  require_interopRequireWildcard
} from "./chunk-7RCLPMH3.js";
import {
  Tab_default,
  Tabs_default
} from "./chunk-LJHHLN5M.js";
import {
  Tooltip_default
} from "./chunk-B6AM2NKK.js";
import {
  makeStyles_default
} from "./chunk-VM2MZLUW.js";
import {
  FormControlLabel_default
} from "./chunk-MJ6MIMBS.js";
import {
  FormControl_default
} from "./chunk-CMDS46FL.js";
import {
  Checkbox_default
} from "./chunk-RFR2NZND.js";
import {
  Typography_default
} from "./chunk-OSUJ7GDT.js";
import {
  IconButton_default
} from "./chunk-TSYRDUXI.js";
import {
  Button_default
} from "./chunk-BADD6I46.js";
import {
  useTheme
} from "./chunk-JE5XHEFL.js";
import {
  require_react_dom
} from "./chunk-K5M3XRFO.js";
import {
  Paper_default
} from "./chunk-QYGHSHYC.js";
import {
  withStyles_default
} from "./chunk-YGDE4KKL.js";
import {
  useLazyQuery,
  useMutation,
  useSubscription
} from "./chunk-Z2MHMT5I.js";
import {
  gql
} from "./chunk-JJXTUFQN.js";
import {
  require_react
} from "./chunk-QCWLDGW7.js";
import {
  parse
} from "./chunk-XSD2GIWA.js";
import {
  __commonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// ../node_modules/lexical/Lexical.dev.js
var require_Lexical_dev = __commonJS({
  "../node_modules/lexical/Lexical.dev.js"(exports) {
    "use strict";
    function createCommand(type2) {
      return {
        type: type2
      };
    }
    var SELECTION_CHANGE_COMMAND2 = createCommand("SELECTION_CHANGE_COMMAND");
    var CLICK_COMMAND = createCommand("CLICK_COMMAND");
    var DELETE_CHARACTER_COMMAND = createCommand("DELETE_CHARACTER_COMMAND");
    var INSERT_LINE_BREAK_COMMAND = createCommand("INSERT_LINE_BREAK_COMMAND");
    var INSERT_PARAGRAPH_COMMAND2 = createCommand("INSERT_PARAGRAPH_COMMAND");
    var CONTROLLED_TEXT_INSERTION_COMMAND = createCommand("CONTROLLED_TEXT_INSERTION_COMMAND");
    var PASTE_COMMAND = createCommand("PASTE_COMMAND");
    var REMOVE_TEXT_COMMAND = createCommand("REMOVE_TEXT_COMMAND");
    var DELETE_WORD_COMMAND = createCommand("DELETE_WORD_COMMAND");
    var DELETE_LINE_COMMAND = createCommand("DELETE_LINE_COMMAND");
    var FORMAT_TEXT_COMMAND2 = createCommand("FORMAT_TEXT_COMMAND");
    var UNDO_COMMAND = createCommand("UNDO_COMMAND");
    var REDO_COMMAND = createCommand("REDO_COMMAND");
    var KEY_DOWN_COMMAND = createCommand("KEYDOWN_COMMAND");
    var KEY_ARROW_RIGHT_COMMAND = createCommand("KEY_ARROW_RIGHT_COMMAND");
    var MOVE_TO_END = createCommand("MOVE_TO_END");
    var KEY_ARROW_LEFT_COMMAND = createCommand("KEY_ARROW_LEFT_COMMAND");
    var MOVE_TO_START = createCommand("MOVE_TO_START");
    var KEY_ARROW_UP_COMMAND = createCommand("KEY_ARROW_UP_COMMAND");
    var KEY_ARROW_DOWN_COMMAND = createCommand("KEY_ARROW_DOWN_COMMAND");
    var KEY_ENTER_COMMAND = createCommand("KEY_ENTER_COMMAND");
    var KEY_SPACE_COMMAND = createCommand("KEY_SPACE_COMMAND");
    var KEY_BACKSPACE_COMMAND = createCommand("KEY_BACKSPACE_COMMAND");
    var KEY_ESCAPE_COMMAND = createCommand("KEY_ESCAPE_COMMAND");
    var KEY_DELETE_COMMAND = createCommand("KEY_DELETE_COMMAND");
    var KEY_TAB_COMMAND = createCommand("KEY_TAB_COMMAND");
    var INDENT_CONTENT_COMMAND = createCommand("INDENT_CONTENT_COMMAND");
    var OUTDENT_CONTENT_COMMAND = createCommand("OUTDENT_CONTENT_COMMAND");
    var DROP_COMMAND = createCommand("DROP_COMMAND");
    var FORMAT_ELEMENT_COMMAND = createCommand("FORMAT_ELEMENT_COMMAND");
    var DRAGSTART_COMMAND = createCommand("DRAGSTART_COMMAND");
    var DRAGOVER_COMMAND = createCommand("DRAGOVER_COMMAND");
    var DRAGEND_COMMAND = createCommand("DRAGEND_COMMAND");
    var COPY_COMMAND = createCommand("COPY_COMMAND");
    var CUT_COMMAND = createCommand("CUT_COMMAND");
    var CLEAR_EDITOR_COMMAND = createCommand("CLEAR_EDITOR_COMMAND");
    var CLEAR_HISTORY_COMMAND = createCommand("CLEAR_HISTORY_COMMAND");
    var CAN_REDO_COMMAND = createCommand("CAN_REDO_COMMAND");
    var CAN_UNDO_COMMAND = createCommand("CAN_UNDO_COMMAND");
    var FOCUS_COMMAND = createCommand("FOCUS_COMMAND");
    var BLUR_COMMAND = createCommand("BLUR_COMMAND");
    var KEY_MODIFIER_COMMAND = createCommand("KEY_MODIFIER_COMMAND");
    var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    var documentMode = CAN_USE_DOM && "documentMode" in document ? document.documentMode : null;
    var IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
    var IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
    var CAN_USE_BEFORE_INPUT = CAN_USE_DOM && "InputEvent" in window && !documentMode ? "getTargetRanges" in new window.InputEvent("input") : false;
    var IS_SAFARI = CAN_USE_DOM && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    var IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    var IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);
    var IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME;
    var DOM_ELEMENT_TYPE = 1;
    var DOM_TEXT_TYPE = 3;
    var NO_DIRTY_NODES = 0;
    var HAS_DIRTY_NODES = 1;
    var FULL_RECONCILE = 2;
    var IS_NORMAL = 0;
    var IS_TOKEN = 1;
    var IS_SEGMENTED = 2;
    var IS_BOLD = 1;
    var IS_ITALIC = 1 << 1;
    var IS_STRIKETHROUGH = 1 << 2;
    var IS_UNDERLINE = 1 << 3;
    var IS_CODE = 1 << 4;
    var IS_SUBSCRIPT = 1 << 5;
    var IS_SUPERSCRIPT = 1 << 6;
    var IS_HIGHLIGHT = 1 << 7;
    var IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT;
    var IS_DIRECTIONLESS = 1;
    var IS_UNMERGEABLE = 1 << 1;
    var IS_ALIGN_LEFT = 1;
    var IS_ALIGN_CENTER = 2;
    var IS_ALIGN_RIGHT = 3;
    var IS_ALIGN_JUSTIFY = 4;
    var IS_ALIGN_START = 5;
    var IS_ALIGN_END = 6;
    var NON_BREAKING_SPACE = " ";
    var ZERO_WIDTH_SPACE = "​";
    var COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;
    var DOUBLE_LINE_BREAK = "\n\n";
    var COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;
    var RTL = "֑-߿יִ-﷽ﹰ-ﻼ";
    var LTR = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿";
    var RTL_REGEX = new RegExp("^[^" + LTR + "]*[" + RTL + "]");
    var LTR_REGEX = new RegExp("^[^" + RTL + "]*[" + LTR + "]");
    var TEXT_TYPE_TO_FORMAT = {
      bold: IS_BOLD,
      code: IS_CODE,
      highlight: IS_HIGHLIGHT,
      italic: IS_ITALIC,
      strikethrough: IS_STRIKETHROUGH,
      subscript: IS_SUBSCRIPT,
      superscript: IS_SUPERSCRIPT,
      underline: IS_UNDERLINE
    };
    var DETAIL_TYPE_TO_DETAIL = {
      directionless: IS_DIRECTIONLESS,
      unmergeable: IS_UNMERGEABLE
    };
    var ELEMENT_TYPE_TO_FORMAT = {
      center: IS_ALIGN_CENTER,
      end: IS_ALIGN_END,
      justify: IS_ALIGN_JUSTIFY,
      left: IS_ALIGN_LEFT,
      right: IS_ALIGN_RIGHT,
      start: IS_ALIGN_START
    };
    var ELEMENT_FORMAT_TO_TYPE = {
      [IS_ALIGN_CENTER]: "center",
      [IS_ALIGN_END]: "end",
      [IS_ALIGN_JUSTIFY]: "justify",
      [IS_ALIGN_LEFT]: "left",
      [IS_ALIGN_RIGHT]: "right",
      [IS_ALIGN_START]: "start"
    };
    var TEXT_MODE_TO_TYPE = {
      normal: IS_NORMAL,
      segmented: IS_SEGMENTED,
      token: IS_TOKEN
    };
    var TEXT_TYPE_TO_MODE = {
      [IS_NORMAL]: "normal",
      [IS_SEGMENTED]: "segmented",
      [IS_TOKEN]: "token"
    };
    var TEXT_MUTATION_VARIANCE = 100;
    var isProcessingMutations = false;
    var lastTextEntryTimeStamp = 0;
    function getIsProcesssingMutations() {
      return isProcessingMutations;
    }
    function updateTimeStamp(event) {
      lastTextEntryTimeStamp = event.timeStamp;
    }
    function initTextEntryListener(editor) {
      if (lastTextEntryTimeStamp === 0) {
        getWindow(editor).addEventListener("textInput", updateTimeStamp, true);
      }
    }
    function isManagedLineBreak(dom, target, editor) {
      return (
        // @ts-expect-error: internal field
        target.__lexicalLineBreak === dom || // @ts-ignore We intentionally add this to the Node.
        dom[`__lexicalKey_${editor._key}`] !== void 0
      );
    }
    function getLastSelection(editor) {
      return editor.getEditorState().read(() => {
        const selection = $getSelection2();
        return selection !== null ? selection.clone() : null;
      });
    }
    function handleTextMutation(target, node, editor) {
      const domSelection = getDOMSelection(editor._window);
      let anchorOffset = null;
      let focusOffset = null;
      if (domSelection !== null && domSelection.anchorNode === target) {
        anchorOffset = domSelection.anchorOffset;
        focusOffset = domSelection.focusOffset;
      }
      const text = target.nodeValue;
      if (text !== null) {
        $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);
      }
    }
    function shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {
      if ($isRangeSelection2(selection)) {
        const anchorNode = selection.anchor.getNode();
        if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {
          return false;
        }
      }
      return targetDOM.nodeType === DOM_TEXT_TYPE && targetNode.isAttached();
    }
    function $flushMutations$1(editor, mutations, observer) {
      isProcessingMutations = true;
      const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;
      try {
        updateEditor(editor, () => {
          const selection = $getSelection2() || getLastSelection(editor);
          const badDOMTargets = /* @__PURE__ */ new Map();
          const rootElement = editor.getRootElement();
          const currentEditorState = editor._editorState;
          const blockCursorElement = editor._blockCursorElement;
          let shouldRevertSelection = false;
          let possibleTextForFirefoxPaste = "";
          for (let i = 0; i < mutations.length; i++) {
            const mutation = mutations[i];
            const type2 = mutation.type;
            const targetDOM = mutation.target;
            let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);
            if (targetNode === null && targetDOM !== rootElement || $isDecoratorNode(targetNode)) {
              continue;
            }
            if (type2 === "characterData") {
              if (shouldFlushTextMutations && $isTextNode(targetNode) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {
                handleTextMutation(
                  // nodeType === DOM_TEXT_TYPE is a Text DOM node
                  targetDOM,
                  targetNode,
                  editor
                );
              }
            } else if (type2 === "childList") {
              shouldRevertSelection = true;
              const addedDOMs = mutation.addedNodes;
              for (let s2 = 0; s2 < addedDOMs.length; s2++) {
                const addedDOM = addedDOMs[s2];
                const node = getNodeFromDOMNode(addedDOM);
                const parentDOM = addedDOM.parentNode;
                if (parentDOM != null && addedDOM !== blockCursorElement && node === null && (addedDOM.nodeName !== "BR" || !isManagedLineBreak(addedDOM, parentDOM, editor))) {
                  if (IS_FIREFOX) {
                    const possibleText = addedDOM.innerText || addedDOM.nodeValue;
                    if (possibleText) {
                      possibleTextForFirefoxPaste += possibleText;
                    }
                  }
                  parentDOM.removeChild(addedDOM);
                }
              }
              const removedDOMs = mutation.removedNodes;
              const removedDOMsLength = removedDOMs.length;
              if (removedDOMsLength > 0) {
                let unremovedBRs = 0;
                for (let s2 = 0; s2 < removedDOMsLength; s2++) {
                  const removedDOM = removedDOMs[s2];
                  if (removedDOM.nodeName === "BR" && isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {
                    targetDOM.appendChild(removedDOM);
                    unremovedBRs++;
                  }
                }
                if (removedDOMsLength !== unremovedBRs) {
                  if (targetDOM === rootElement) {
                    targetNode = internalGetRoot(currentEditorState);
                  }
                  badDOMTargets.set(targetDOM, targetNode);
                }
              }
            }
          }
          if (badDOMTargets.size > 0) {
            for (const [targetDOM, targetNode] of badDOMTargets) {
              if ($isElementNode(targetNode)) {
                const childKeys = targetNode.getChildrenKeys();
                let currentDOM = targetDOM.firstChild;
                for (let s2 = 0; s2 < childKeys.length; s2++) {
                  const key = childKeys[s2];
                  const correctDOM = editor.getElementByKey(key);
                  if (correctDOM === null) {
                    continue;
                  }
                  if (currentDOM == null) {
                    targetDOM.appendChild(correctDOM);
                    currentDOM = correctDOM;
                  } else if (currentDOM !== correctDOM) {
                    targetDOM.replaceChild(correctDOM, currentDOM);
                  }
                  currentDOM = currentDOM.nextSibling;
                }
              } else if ($isTextNode(targetNode)) {
                targetNode.markDirty();
              }
            }
          }
          const records = observer.takeRecords();
          if (records.length > 0) {
            for (let i = 0; i < records.length; i++) {
              const record = records[i];
              const addedNodes = record.addedNodes;
              const target = record.target;
              for (let s2 = 0; s2 < addedNodes.length; s2++) {
                const addedDOM = addedNodes[s2];
                const parentDOM = addedDOM.parentNode;
                if (parentDOM != null && addedDOM.nodeName === "BR" && !isManagedLineBreak(addedDOM, target, editor)) {
                  parentDOM.removeChild(addedDOM);
                }
              }
            }
            observer.takeRecords();
          }
          if (selection !== null) {
            if (shouldRevertSelection) {
              selection.dirty = true;
              $setSelection2(selection);
            }
            if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {
              selection.insertRawText(possibleTextForFirefoxPaste);
            }
          }
        });
      } finally {
        isProcessingMutations = false;
      }
    }
    function flushRootMutations(editor) {
      const observer = editor._observer;
      if (observer !== null) {
        const mutations = observer.takeRecords();
        $flushMutations$1(editor, mutations, observer);
      }
    }
    function initMutationObserver(editor) {
      initTextEntryListener(editor);
      editor._observer = new MutationObserver((mutations, observer) => {
        $flushMutations$1(editor, mutations, observer);
      });
    }
    var keyCounter = 1;
    function generateRandomKey() {
      return "" + keyCounter++;
    }
    function getRegisteredNodeOrThrow(editor, nodeType) {
      const registeredNode = editor._nodes.get(nodeType);
      if (registeredNode === void 0) {
        {
          throw Error(`registeredNode: Type ${nodeType} not found`);
        }
      }
      return registeredNode;
    }
    var scheduleMicroTask = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => {
      Promise.resolve().then(fn);
    };
    function $isSelectionCapturedInDecorator(node) {
      return $isDecoratorNode($getNearestNodeFromDOMNode(node));
    }
    function isSelectionCapturedInDecoratorInput(anchorDOM) {
      const activeElement = document.activeElement;
      if (activeElement === null) {
        return false;
      }
      const nodeName = activeElement.nodeName;
      return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === "INPUT" || nodeName === "TEXTAREA" || activeElement.contentEditable === "true" && // @ts-ignore iternal field
      activeElement.__lexicalEditor == null);
    }
    function isSelectionWithinEditor(editor, anchorDOM, focusDOM) {
      const rootElement = editor.getRootElement();
      try {
        return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) && // Ignore if selection is within nested editor
        anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;
      } catch (error) {
        return false;
      }
    }
    function getNearestEditorFromDOMNode(node) {
      let currentNode = node;
      while (currentNode != null) {
        const editor = currentNode.__lexicalEditor;
        if (editor != null) {
          return editor;
        }
        currentNode = getParentElement(currentNode);
      }
      return null;
    }
    function getTextDirection(text) {
      if (RTL_REGEX.test(text)) {
        return "rtl";
      }
      if (LTR_REGEX.test(text)) {
        return "ltr";
      }
      return null;
    }
    function $isTokenOrSegmented(node) {
      return node.isToken() || node.isSegmented();
    }
    function isDOMNodeLexicalTextNode(node) {
      return node.nodeType === DOM_TEXT_TYPE;
    }
    function getDOMTextNode(element) {
      let node = element;
      while (node != null) {
        if (isDOMNodeLexicalTextNode(node)) {
          return node;
        }
        node = node.firstChild;
      }
      return null;
    }
    function toggleTextFormatType(format3, type2, alignWithFormat) {
      const activeFormat = TEXT_TYPE_TO_FORMAT[type2];
      const isStateFlagPresent = format3 & activeFormat;
      if (isStateFlagPresent && (alignWithFormat === null || (alignWithFormat & activeFormat) === 0)) {
        return format3 ^ activeFormat;
      }
      if (alignWithFormat === null || alignWithFormat & activeFormat) {
        return format3 | activeFormat;
      }
      return format3;
    }
    function $isLeafNode(node) {
      return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);
    }
    function $setNodeKey(node, existingKey) {
      if (existingKey != null) {
        node.__key = existingKey;
        return;
      }
      errorOnReadOnly();
      errorOnInfiniteTransforms();
      const editor = getActiveEditor();
      const editorState = getActiveEditorState();
      const key = generateRandomKey();
      editorState._nodeMap.set(key, node);
      if ($isElementNode(node)) {
        editor._dirtyElements.set(key, true);
      } else {
        editor._dirtyLeaves.add(key);
      }
      editor._cloneNotNeeded.add(key);
      editor._dirtyType = HAS_DIRTY_NODES;
      node.__key = key;
    }
    function internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {
      let nextParentKey = parentKey;
      while (nextParentKey !== null) {
        if (dirtyElements.has(nextParentKey)) {
          return;
        }
        const node = nodeMap.get(nextParentKey);
        if (node === void 0) {
          break;
        }
        dirtyElements.set(nextParentKey, false);
        nextParentKey = node.__parent;
      }
    }
    function removeFromParent(node) {
      const oldParent = node.getParent();
      if (oldParent !== null) {
        const writableNode = node.getWritable();
        const writableParent = oldParent.getWritable();
        const prevSibling = node.getPreviousSibling();
        const nextSibling = node.getNextSibling();
        if (prevSibling === null) {
          if (nextSibling !== null) {
            const writableNextSibling = nextSibling.getWritable();
            writableParent.__first = nextSibling.__key;
            writableNextSibling.__prev = null;
          } else {
            writableParent.__first = null;
          }
        } else {
          const writablePrevSibling = prevSibling.getWritable();
          if (nextSibling !== null) {
            const writableNextSibling = nextSibling.getWritable();
            writableNextSibling.__prev = writablePrevSibling.__key;
            writablePrevSibling.__next = writableNextSibling.__key;
          } else {
            writablePrevSibling.__next = null;
          }
          writableNode.__prev = null;
        }
        if (nextSibling === null) {
          if (prevSibling !== null) {
            const writablePrevSibling = prevSibling.getWritable();
            writableParent.__last = prevSibling.__key;
            writablePrevSibling.__next = null;
          } else {
            writableParent.__last = null;
          }
        } else {
          const writableNextSibling = nextSibling.getWritable();
          if (prevSibling !== null) {
            const writablePrevSibling = prevSibling.getWritable();
            writablePrevSibling.__next = writableNextSibling.__key;
            writableNextSibling.__prev = writablePrevSibling.__key;
          } else {
            writableNextSibling.__prev = null;
          }
          writableNode.__next = null;
        }
        writableParent.__size--;
        writableNode.__parent = null;
      }
    }
    function internalMarkNodeAsDirty(node) {
      errorOnInfiniteTransforms();
      const latest = node.getLatest();
      const parent = latest.__parent;
      const editorState = getActiveEditorState();
      const editor = getActiveEditor();
      const nodeMap = editorState._nodeMap;
      const dirtyElements = editor._dirtyElements;
      if (parent !== null) {
        internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);
      }
      const key = latest.__key;
      editor._dirtyType = HAS_DIRTY_NODES;
      if ($isElementNode(node)) {
        dirtyElements.set(key, true);
      } else {
        editor._dirtyLeaves.add(key);
      }
    }
    function internalMarkSiblingsAsDirty(node) {
      const previousNode = node.getPreviousSibling();
      const nextNode = node.getNextSibling();
      if (previousNode !== null) {
        internalMarkNodeAsDirty(previousNode);
      }
      if (nextNode !== null) {
        internalMarkNodeAsDirty(nextNode);
      }
    }
    function $setCompositionKey(compositionKey) {
      errorOnReadOnly();
      const editor = getActiveEditor();
      const previousCompositionKey = editor._compositionKey;
      if (compositionKey !== previousCompositionKey) {
        editor._compositionKey = compositionKey;
        if (previousCompositionKey !== null) {
          const node = $getNodeByKey(previousCompositionKey);
          if (node !== null) {
            node.getWritable();
          }
        }
        if (compositionKey !== null) {
          const node = $getNodeByKey(compositionKey);
          if (node !== null) {
            node.getWritable();
          }
        }
      }
    }
    function $getCompositionKey() {
      if (isCurrentlyReadOnlyMode()) {
        return null;
      }
      const editor = getActiveEditor();
      return editor._compositionKey;
    }
    function $getNodeByKey(key, _editorState) {
      const editorState = _editorState || getActiveEditorState();
      const node = editorState._nodeMap.get(key);
      if (node === void 0) {
        return null;
      }
      return node;
    }
    function getNodeFromDOMNode(dom, editorState) {
      const editor = getActiveEditor();
      const key = dom[`__lexicalKey_${editor._key}`];
      if (key !== void 0) {
        return $getNodeByKey(key, editorState);
      }
      return null;
    }
    function $getNearestNodeFromDOMNode(startingDOM, editorState) {
      let dom = startingDOM;
      while (dom != null) {
        const node = getNodeFromDOMNode(dom, editorState);
        if (node !== null) {
          return node;
        }
        dom = getParentElement(dom);
      }
      return null;
    }
    function cloneDecorators(editor) {
      const currentDecorators = editor._decorators;
      const pendingDecorators = Object.assign({}, currentDecorators);
      editor._pendingDecorators = pendingDecorators;
      return pendingDecorators;
    }
    function getEditorStateTextContent(editorState) {
      return editorState.read(() => $getRoot().getTextContent());
    }
    function markAllNodesAsDirty(editor, type2) {
      updateEditor(editor, () => {
        const editorState = getActiveEditorState();
        if (editorState.isEmpty()) {
          return;
        }
        if (type2 === "root") {
          $getRoot().markDirty();
          return;
        }
        const nodeMap = editorState._nodeMap;
        for (const [, node] of nodeMap) {
          node.markDirty();
        }
      }, editor._pendingEditorState === null ? {
        tag: "history-merge"
      } : void 0);
    }
    function $getRoot() {
      return internalGetRoot(getActiveEditorState());
    }
    function internalGetRoot(editorState) {
      return editorState._nodeMap.get("root");
    }
    function $setSelection2(selection) {
      errorOnReadOnly();
      const editorState = getActiveEditorState();
      if (selection !== null) {
        {
          if (Object.isFrozen(selection)) {
            {
              throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);
            }
          }
        }
        selection.dirty = true;
        selection._cachedNodes = null;
      }
      editorState._selection = selection;
    }
    function $flushMutations() {
      errorOnReadOnly();
      const editor = getActiveEditor();
      flushRootMutations(editor);
    }
    function getNodeFromDOM(dom) {
      const editor = getActiveEditor();
      const nodeKey = getNodeKeyFromDOM(dom, editor);
      if (nodeKey === null) {
        const rootElement = editor.getRootElement();
        if (dom === rootElement) {
          return $getNodeByKey("root");
        }
        return null;
      }
      return $getNodeByKey(nodeKey);
    }
    function getTextNodeOffset(node, moveSelectionToEnd) {
      return moveSelectionToEnd ? node.getTextContentSize() : 0;
    }
    function getNodeKeyFromDOM(dom, editor) {
      let node = dom;
      while (node != null) {
        const key = node[`__lexicalKey_${editor._key}`];
        if (key !== void 0) {
          return key;
        }
        node = getParentElement(node);
      }
      return null;
    }
    function doesContainGrapheme(str) {
      return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(str);
    }
    function getEditorsToPropagate(editor) {
      const editorsToPropagate = [];
      let currentEditor = editor;
      while (currentEditor !== null) {
        editorsToPropagate.push(currentEditor);
        currentEditor = currentEditor._parentEditor;
      }
      return editorsToPropagate;
    }
    function createUID() {
      return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
    }
    function getAnchorTextFromDOM(anchorNode) {
      if (anchorNode.nodeType === DOM_TEXT_TYPE) {
        return anchorNode.nodeValue;
      }
      return null;
    }
    function $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {
      const domSelection = getDOMSelection(editor._window);
      if (domSelection === null) {
        return;
      }
      const anchorNode = domSelection.anchorNode;
      let {
        anchorOffset,
        focusOffset
      } = domSelection;
      if (anchorNode !== null) {
        let textContent = getAnchorTextFromDOM(anchorNode);
        const node = $getNearestNodeFromDOMNode(anchorNode);
        if (textContent !== null && $isTextNode(node)) {
          if (node.canContainTabs()) {
            const hasTabCharacter = textContent.includes("	");
            if (data && data.length > 0 && hasTabCharacter) {
              const selectionOffset = data.length;
              const insertionOffset = anchorOffset + selectionOffset - 1;
              const beforeInsertion = textContent.slice(0, insertionOffset);
              const afterInsertion = textContent.slice(insertionOffset, textContent.length);
              textContent = `${beforeInsertion}${data}${afterInsertion}`;
              anchorOffset += selectionOffset;
              focusOffset += selectionOffset;
            }
          }
          if (textContent === COMPOSITION_SUFFIX && data) {
            const offset = data.length;
            textContent = data;
            anchorOffset = offset;
            focusOffset = offset;
          }
          if (textContent !== null) {
            $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);
          }
        }
      }
    }
    function $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {
      let node = textNode;
      if (node.isAttached() && (compositionEnd || !node.isDirty())) {
        const isComposing = node.isComposing();
        let normalizedTextContent = textContent;
        if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {
          normalizedTextContent = textContent.slice(0, -1);
        }
        const prevTextContent = node.getTextContent();
        if (compositionEnd || normalizedTextContent !== prevTextContent) {
          if (normalizedTextContent === "") {
            $setCompositionKey(null);
            if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {
              const editor = getActiveEditor();
              setTimeout(() => {
                editor.update(() => {
                  if (node.isAttached()) {
                    node.remove();
                  }
                });
              }, 20);
            } else {
              node.remove();
            }
            return;
          }
          const parent = node.getParent();
          const prevSelection = $getPreviousSelection();
          const compositionKey = $getCompositionKey();
          const nodeKey = node.getKey();
          if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing || // Check if character was added at the start, and we need
          // to clear this input from occurring as that action wasn't
          // permitted.
          parent !== null && $isRangeSelection2(prevSelection) && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0) {
            node.markDirty();
            return;
          }
          const selection = $getSelection2();
          if (!$isRangeSelection2(selection) || anchorOffset === null || focusOffset === null) {
            node.setTextContent(normalizedTextContent);
            return;
          }
          selection.setTextNodeRange(node, anchorOffset, node, focusOffset);
          if (node.isSegmented()) {
            const originalTextContent = node.getTextContent();
            const replacement = $createTextNode(originalTextContent);
            node.replace(replacement);
            node = replacement;
          }
          node.setTextContent(normalizedTextContent);
        }
      }
    }
    function $previousSiblingDoesNotAcceptText(node) {
      const previousSibling = node.getPreviousSibling();
      return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();
    }
    function $shouldInsertTextAfterOrBeforeTextNode(selection, node) {
      if (node.isSegmented()) {
        return true;
      }
      if (!selection.isCollapsed()) {
        return false;
      }
      const offset = selection.anchor.offset;
      const parent = node.getParentOrThrow();
      const isToken = node.isToken();
      if (offset === 0) {
        return !node.canInsertTextBefore() || !parent.canInsertTextBefore() || isToken || $previousSiblingDoesNotAcceptText(node);
      } else if (offset === node.getTextContentSize()) {
        return !node.canInsertTextAfter() || !parent.canInsertTextAfter() || isToken;
      } else {
        return false;
      }
    }
    function isTab(keyCode, altKey, ctrlKey, metaKey) {
      return keyCode === 9 && !altKey && !ctrlKey && !metaKey;
    }
    function isBold(keyCode, altKey, metaKey, ctrlKey) {
      return keyCode === 66 && !altKey && controlOrMeta(metaKey, ctrlKey);
    }
    function isItalic(keyCode, altKey, metaKey, ctrlKey) {
      return keyCode === 73 && !altKey && controlOrMeta(metaKey, ctrlKey);
    }
    function isUnderline(keyCode, altKey, metaKey, ctrlKey) {
      return keyCode === 85 && !altKey && controlOrMeta(metaKey, ctrlKey);
    }
    function isParagraph(keyCode, shiftKey) {
      return isReturn(keyCode) && !shiftKey;
    }
    function isLineBreak(keyCode, shiftKey) {
      return isReturn(keyCode) && shiftKey;
    }
    function isOpenLineBreak(keyCode, ctrlKey) {
      return IS_APPLE && ctrlKey && keyCode === 79;
    }
    function isDeleteWordBackward(keyCode, altKey, ctrlKey) {
      return isBackspace(keyCode) && (IS_APPLE ? altKey : ctrlKey);
    }
    function isDeleteWordForward(keyCode, altKey, ctrlKey) {
      return isDelete(keyCode) && (IS_APPLE ? altKey : ctrlKey);
    }
    function isDeleteLineBackward(keyCode, metaKey) {
      return IS_APPLE && metaKey && isBackspace(keyCode);
    }
    function isDeleteLineForward(keyCode, metaKey) {
      return IS_APPLE && metaKey && isDelete(keyCode);
    }
    function isDeleteBackward(keyCode, altKey, metaKey, ctrlKey) {
      if (IS_APPLE) {
        if (altKey || metaKey) {
          return false;
        }
        return isBackspace(keyCode) || keyCode === 72 && ctrlKey;
      }
      if (ctrlKey || altKey || metaKey) {
        return false;
      }
      return isBackspace(keyCode);
    }
    function isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {
      if (IS_APPLE) {
        if (shiftKey || altKey || metaKey) {
          return false;
        }
        return isDelete(keyCode) || keyCode === 68 && ctrlKey;
      }
      if (ctrlKey || altKey || metaKey) {
        return false;
      }
      return isDelete(keyCode);
    }
    function isUndo(keyCode, shiftKey, metaKey, ctrlKey) {
      return keyCode === 90 && !shiftKey && controlOrMeta(metaKey, ctrlKey);
    }
    function isRedo(keyCode, shiftKey, metaKey, ctrlKey) {
      if (IS_APPLE) {
        return keyCode === 90 && metaKey && shiftKey;
      }
      return keyCode === 89 && ctrlKey || keyCode === 90 && ctrlKey && shiftKey;
    }
    function isCopy(keyCode, shiftKey, metaKey, ctrlKey) {
      if (shiftKey) {
        return false;
      }
      if (keyCode === 67) {
        return IS_APPLE ? metaKey : ctrlKey;
      }
      return false;
    }
    function isCut(keyCode, shiftKey, metaKey, ctrlKey) {
      if (shiftKey) {
        return false;
      }
      if (keyCode === 88) {
        return IS_APPLE ? metaKey : ctrlKey;
      }
      return false;
    }
    function isArrowLeft(keyCode) {
      return keyCode === 37;
    }
    function isArrowRight(keyCode) {
      return keyCode === 39;
    }
    function isArrowUp(keyCode) {
      return keyCode === 38;
    }
    function isArrowDown(keyCode) {
      return keyCode === 40;
    }
    function isMoveBackward(keyCode, ctrlKey, altKey, metaKey) {
      return isArrowLeft(keyCode) && !ctrlKey && !metaKey && !altKey;
    }
    function isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey) {
      return isArrowLeft(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);
    }
    function isMoveForward(keyCode, ctrlKey, altKey, metaKey) {
      return isArrowRight(keyCode) && !ctrlKey && !metaKey && !altKey;
    }
    function isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey) {
      return isArrowRight(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);
    }
    function isMoveUp(keyCode, ctrlKey, metaKey) {
      return isArrowUp(keyCode) && !ctrlKey && !metaKey;
    }
    function isMoveDown(keyCode, ctrlKey, metaKey) {
      return isArrowDown(keyCode) && !ctrlKey && !metaKey;
    }
    function isModifier(ctrlKey, shiftKey, altKey, metaKey) {
      return ctrlKey || shiftKey || altKey || metaKey;
    }
    function isSpace(keyCode) {
      return keyCode === 32;
    }
    function controlOrMeta(metaKey, ctrlKey) {
      if (IS_APPLE) {
        return metaKey;
      }
      return ctrlKey;
    }
    function isReturn(keyCode) {
      return keyCode === 13;
    }
    function isBackspace(keyCode) {
      return keyCode === 8;
    }
    function isEscape(keyCode) {
      return keyCode === 27;
    }
    function isDelete(keyCode) {
      return keyCode === 46;
    }
    function getCachedClassNameArray(classNamesTheme, classNameThemeType) {
      const classNames = classNamesTheme[classNameThemeType];
      if (typeof classNames === "string") {
        const classNamesArr = classNames.split(" ");
        classNamesTheme[classNameThemeType] = classNamesArr;
        return classNamesArr;
      }
      return classNames;
    }
    function setMutatedNode(mutatedNodes2, registeredNodes, mutationListeners, node, mutation) {
      if (mutationListeners.size === 0) {
        return;
      }
      const nodeType = node.__type;
      const nodeKey = node.__key;
      const registeredNode = registeredNodes.get(nodeType);
      if (registeredNode === void 0) {
        {
          throw Error(`Type ${nodeType} not in registeredNodes`);
        }
      }
      const klass = registeredNode.klass;
      let mutatedNodesByType = mutatedNodes2.get(klass);
      if (mutatedNodesByType === void 0) {
        mutatedNodesByType = /* @__PURE__ */ new Map();
        mutatedNodes2.set(klass, mutatedNodesByType);
      }
      const prevMutation = mutatedNodesByType.get(nodeKey);
      const isMove = prevMutation === "destroyed" && mutation === "created";
      if (prevMutation === void 0 || isMove) {
        mutatedNodesByType.set(nodeKey, isMove ? "updated" : mutation);
      }
    }
    function $nodesOfType(klass) {
      const editorState = getActiveEditorState();
      const readOnly = editorState._readOnly;
      const klassType = klass.getType();
      const nodes = editorState._nodeMap;
      const nodesOfType = [];
      for (const [, node] of nodes) {
        if (node instanceof klass && node.__type === klassType && (readOnly || node.isAttached())) {
          nodesOfType.push(node);
        }
      }
      return nodesOfType;
    }
    function resolveElement(element, isBackward, focusOffset) {
      const parent = element.getParent();
      let offset = focusOffset;
      let block = element;
      if (parent !== null) {
        if (isBackward && focusOffset === 0) {
          offset = block.getIndexWithinParent();
          block = parent;
        } else if (!isBackward && focusOffset === block.getChildrenSize()) {
          offset = block.getIndexWithinParent() + 1;
          block = parent;
        }
      }
      return block.getChildAtIndex(isBackward ? offset - 1 : offset);
    }
    function $getAdjacentNode(focus, isBackward) {
      const focusOffset = focus.offset;
      if (focus.type === "element") {
        const block = focus.getNode();
        return resolveElement(block, isBackward, focusOffset);
      } else {
        const focusNode = focus.getNode();
        if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {
          const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();
          if (possibleNode === null) {
            return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));
          }
          return possibleNode;
        }
      }
      return null;
    }
    function isFirefoxClipboardEvents(editor) {
      const event = getWindow(editor).event;
      const inputType = event && event.inputType;
      return inputType === "insertFromPaste" || inputType === "insertFromPasteAsQuotation";
    }
    function dispatchCommand(editor, command, payload) {
      return triggerCommandListeners(editor, command, payload);
    }
    function $textContentRequiresDoubleLinebreakAtEnd(node) {
      return !$isRootNode(node) && !node.isLastChild() && !node.isInline();
    }
    function getElementByKeyOrThrow(editor, key) {
      const element = editor._keyToDOMMap.get(key);
      if (element === void 0) {
        {
          throw Error(`Reconciliation: could not find DOM element for node key ${key}`);
        }
      }
      return element;
    }
    function getParentElement(node) {
      const parentElement = node.assignedSlot || node.parentElement;
      return parentElement !== null && parentElement.nodeType === 11 ? parentElement.host : parentElement;
    }
    function scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {
      const doc = rootElement.ownerDocument;
      const defaultView = doc.defaultView;
      if (defaultView === null) {
        return;
      }
      let {
        top: currentTop,
        bottom: currentBottom
      } = selectionRect;
      let targetTop = 0;
      let targetBottom = 0;
      let element = rootElement;
      while (element !== null) {
        const isBodyElement = element === doc.body;
        if (isBodyElement) {
          targetTop = 0;
          targetBottom = getWindow(editor).innerHeight;
        } else {
          const targetRect = element.getBoundingClientRect();
          targetTop = targetRect.top;
          targetBottom = targetRect.bottom;
        }
        let diff = 0;
        if (currentTop < targetTop) {
          diff = -(targetTop - currentTop);
        } else if (currentBottom > targetBottom) {
          diff = currentBottom - targetBottom;
        }
        if (diff !== 0) {
          if (isBodyElement) {
            defaultView.scrollBy(0, diff);
          } else {
            const scrollTop = element.scrollTop;
            element.scrollTop += diff;
            const yOffset = element.scrollTop - scrollTop;
            currentTop -= yOffset;
            currentBottom -= yOffset;
          }
        }
        if (isBodyElement) {
          break;
        }
        element = getParentElement(element);
      }
    }
    function $addUpdateTag(tag) {
      errorOnReadOnly();
      const editor = getActiveEditor();
      editor._updateTags.add(tag);
    }
    function $maybeMoveChildrenSelectionToParent(parentNode, offset = 0) {
      if (offset !== 0) {
        {
          throw Error(`TODO`);
        }
      }
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection) || !$isElementNode(parentNode)) {
        return selection;
      }
      const {
        anchor,
        focus
      } = selection;
      const anchorNode = anchor.getNode();
      const focusNode = focus.getNode();
      if ($hasAncestor(anchorNode, parentNode)) {
        anchor.set(parentNode.__key, 0, "element");
      }
      if ($hasAncestor(focusNode, parentNode)) {
        focus.set(parentNode.__key, 0, "element");
      }
      return selection;
    }
    function $hasAncestor(child, targetNode) {
      let parent = child.getParent();
      while (parent !== null) {
        if (parent.is(targetNode)) {
          return true;
        }
        parent = parent.getParent();
      }
      return false;
    }
    function getDefaultView(domElem) {
      const ownerDoc = domElem.ownerDocument;
      return ownerDoc && ownerDoc.defaultView || null;
    }
    function getWindow(editor) {
      const windowObj = editor._window;
      if (windowObj === null) {
        {
          throw Error(`window object not found`);
        }
      }
      return windowObj;
    }
    function $isInlineElementOrDecoratorNode(node) {
      return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();
    }
    function $getNearestRootOrShadowRoot(node) {
      let parent = node.getParentOrThrow();
      while (parent !== null) {
        if ($isRootOrShadowRoot(parent)) {
          return parent;
        }
        parent = parent.getParentOrThrow();
      }
      return parent;
    }
    function $isRootOrShadowRoot(node) {
      return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();
    }
    function $copyNode(node) {
      const copy3 = node.constructor.clone(node);
      $setNodeKey(copy3, null);
      return copy3;
    }
    function $applyNodeReplacement(node) {
      const editor = getActiveEditor();
      const nodeType = node.constructor.getType();
      const registeredNode = editor._nodes.get(nodeType);
      if (registeredNode === void 0) {
        {
          throw Error(`$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the "nodes" array in the editor config.`);
        }
      }
      const replaceFunc = registeredNode.replace;
      if (replaceFunc !== null) {
        const replacementNode = replaceFunc(node);
        if (!(replacementNode instanceof node.constructor)) {
          {
            throw Error(`$initializeNode failed. Ensure replacement node is a subclass of the original node.`);
          }
        }
        return replacementNode;
      }
      return node;
    }
    function errorOnInsertTextNodeOnRoot(node, insertNode) {
      const parentNode = node.getParent();
      if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {
        {
          throw Error(`Only element or decorator nodes can be inserted in to the root node`);
        }
      }
    }
    function createBlockCursorElement(editorConfig) {
      const theme = editorConfig.theme;
      const element = document.createElement("div");
      element.contentEditable = "false";
      element.setAttribute("data-lexical-cursor", "true");
      let blockCursorTheme = theme.blockCursor;
      if (blockCursorTheme !== void 0) {
        if (typeof blockCursorTheme === "string") {
          const classNamesArr = blockCursorTheme.split(" ");
          blockCursorTheme = theme.blockCursor = classNamesArr;
        }
        if (blockCursorTheme !== void 0) {
          element.classList.add(...blockCursorTheme);
        }
      }
      return element;
    }
    function needsBlockCursor(node) {
      return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();
    }
    function removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {
      rootElement.style.removeProperty("caret-color");
      editor._blockCursorElement = null;
      const parentElement = blockCursorElement.parentElement;
      if (parentElement !== null) {
        parentElement.removeChild(blockCursorElement);
      }
    }
    function updateDOMBlockCursorElement(editor, rootElement, nextSelection) {
      let blockCursorElement = editor._blockCursorElement;
      if ($isRangeSelection2(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === "element" && rootElement.contains(document.activeElement)) {
        const anchor = nextSelection.anchor;
        const elementNode = anchor.getNode();
        const offset = anchor.offset;
        const elementNodeSize = elementNode.getChildrenSize();
        let isBlockCursor = false;
        let insertBeforeElement = null;
        if (offset === elementNodeSize) {
          const child = elementNode.getChildAtIndex(offset - 1);
          if (needsBlockCursor(child)) {
            isBlockCursor = true;
          }
        } else {
          const child = elementNode.getChildAtIndex(offset);
          if (needsBlockCursor(child)) {
            const sibling = child.getPreviousSibling();
            if (sibling === null || needsBlockCursor(sibling)) {
              isBlockCursor = true;
              insertBeforeElement = editor.getElementByKey(child.__key);
            }
          }
        }
        if (isBlockCursor) {
          const elementDOM = editor.getElementByKey(elementNode.__key);
          if (blockCursorElement === null) {
            editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);
          }
          rootElement.style.caretColor = "transparent";
          if (insertBeforeElement === null) {
            elementDOM.appendChild(blockCursorElement);
          } else {
            elementDOM.insertBefore(blockCursorElement, insertBeforeElement);
          }
          return;
        }
      }
      if (blockCursorElement !== null) {
        removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
      }
    }
    function getDOMSelection(targetWindow) {
      return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();
    }
    function $splitNode(node, offset) {
      let startNode = node.getChildAtIndex(offset);
      if (startNode == null) {
        startNode = node;
      }
      if (!!$isRootOrShadowRoot(node)) {
        throw Error(`Can not call $splitNode() on root element`);
      }
      const recurse = (currentNode) => {
        const parent = currentNode.getParentOrThrow();
        const isParentRoot = $isRootOrShadowRoot(parent);
        const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);
        if (isParentRoot) {
          currentNode.insertAfter(nodeToMove);
          return [currentNode, nodeToMove, nodeToMove];
        } else {
          const [leftTree2, rightTree2, newParent] = recurse(parent);
          const nextSiblings = currentNode.getNextSiblings();
          newParent.append(nodeToMove, ...nextSiblings);
          return [leftTree2, rightTree2, nodeToMove];
        }
      };
      const [leftTree, rightTree] = recurse(startNode);
      return [leftTree, rightTree];
    }
    function $garbageCollectDetachedDecorators(editor, pendingEditorState) {
      const currentDecorators = editor._decorators;
      const pendingDecorators = editor._pendingDecorators;
      let decorators = pendingDecorators || currentDecorators;
      const nodeMap = pendingEditorState._nodeMap;
      let key;
      for (key in decorators) {
        if (!nodeMap.has(key)) {
          if (decorators === currentDecorators) {
            decorators = cloneDecorators(editor);
          }
          delete decorators[key];
        }
      }
    }
    function $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, dirtyNodes) {
      let child = node.getFirstChild();
      while (child !== null) {
        const childKey = child.__key;
        if (child !== void 0 && child.__parent === parentKey) {
          if ($isElementNode(child)) {
            $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, dirtyNodes);
          }
          if (!prevNodeMap.has(childKey)) {
            dirtyNodes.delete(childKey);
          }
          nodeMap.delete(childKey);
        }
        child = child.isAttached() ? child.getNextSibling() : null;
      }
    }
    function $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {
      const prevNodeMap = prevEditorState._nodeMap;
      const nodeMap = editorState._nodeMap;
      for (const nodeKey of dirtyLeaves) {
        const node = nodeMap.get(nodeKey);
        if (node !== void 0 && !node.isAttached()) {
          if (!prevNodeMap.has(nodeKey)) {
            dirtyLeaves.delete(nodeKey);
          }
          nodeMap.delete(nodeKey);
        }
      }
      for (const [nodeKey] of dirtyElements) {
        const node = nodeMap.get(nodeKey);
        if (node !== void 0) {
          if (!node.isAttached()) {
            if ($isElementNode(node)) {
              $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, dirtyElements);
            }
            if (!prevNodeMap.has(nodeKey)) {
              dirtyElements.delete(nodeKey);
            }
            nodeMap.delete(nodeKey);
          }
        }
      }
    }
    function $canSimpleTextNodesBeMerged(node1, node2) {
      const node1Mode = node1.__mode;
      const node1Format = node1.__format;
      const node1Style = node1.__style;
      const node2Mode = node2.__mode;
      const node2Format = node2.__format;
      const node2Style = node2.__style;
      return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);
    }
    function $mergeTextNodes(node1, node2) {
      const writableNode1 = node1.mergeWithSibling(node2);
      const normalizedNodes = getActiveEditor()._normalizedNodes;
      normalizedNodes.add(node1.__key);
      normalizedNodes.add(node2.__key);
      return writableNode1;
    }
    function $normalizeTextNode(textNode) {
      let node = textNode;
      if (node.__text === "" && node.isSimpleText() && !node.isUnmergeable()) {
        node.remove();
        return;
      }
      let previousNode;
      while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {
        if (previousNode.__text === "") {
          previousNode.remove();
        } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {
          node = $mergeTextNodes(previousNode, node);
          break;
        } else {
          break;
        }
      }
      let nextNode;
      while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {
        if (nextNode.__text === "") {
          nextNode.remove();
        } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {
          node = $mergeTextNodes(node, nextNode);
          break;
        } else {
          break;
        }
      }
    }
    function $normalizeSelection(selection) {
      $normalizePoint(selection.anchor);
      $normalizePoint(selection.focus);
      return selection;
    }
    function $normalizePoint(point6) {
      while (point6.type === "element") {
        const node = point6.getNode();
        const offset = point6.offset;
        let nextNode;
        let nextOffsetAtEnd;
        if (offset === node.getChildrenSize()) {
          nextNode = node.getChildAtIndex(offset - 1);
          nextOffsetAtEnd = true;
        } else {
          nextNode = node.getChildAtIndex(offset);
          nextOffsetAtEnd = false;
        }
        if ($isTextNode(nextNode)) {
          point6.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, "text");
          break;
        } else if (!$isElementNode(nextNode)) {
          break;
        }
        point6.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, "element");
      }
    }
    var subTreeTextContent = "";
    var subTreeDirectionedTextContent = "";
    var editorTextContent = "";
    var activeEditorConfig;
    var activeEditor$1;
    var activeEditorNodes;
    var treatAllNodesAsDirty = false;
    var activeEditorStateReadOnly = false;
    var activeMutationListeners;
    var activeTextDirection = null;
    var activeDirtyElements;
    var activeDirtyLeaves;
    var activePrevNodeMap;
    var activeNextNodeMap;
    var activePrevKeyToDOMMap;
    var mutatedNodes;
    function destroyNode(key, parentDOM) {
      const node = activePrevNodeMap.get(key);
      if (parentDOM !== null) {
        const dom = getPrevElementByKeyOrThrow(key);
        if (dom.parentNode === parentDOM) {
          parentDOM.removeChild(dom);
        }
      }
      if (!activeNextNodeMap.has(key)) {
        activeEditor$1._keyToDOMMap.delete(key);
      }
      if ($isElementNode(node)) {
        const children = createChildrenArray(node, activePrevNodeMap);
        destroyChildren(children, 0, children.length - 1, null);
      }
      if (node !== void 0) {
        setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, "destroyed");
      }
    }
    function destroyChildren(children, _startIndex, endIndex, dom) {
      let startIndex = _startIndex;
      for (; startIndex <= endIndex; ++startIndex) {
        const child = children[startIndex];
        if (child !== void 0) {
          destroyNode(child, dom);
        }
      }
    }
    function setTextAlign(domStyle, value3) {
      domStyle.setProperty("text-align", value3);
    }
    var DEFAULT_INDENT_VALUE = "20px";
    function setElementIndent(dom, indent) {
      const indentClassName = activeEditorConfig.theme.indent;
      if (typeof indentClassName === "string") {
        const elementHasClassName = dom.classList.contains(indentClassName);
        if (indent > 0 && !elementHasClassName) {
          dom.classList.add(indentClassName);
        } else if (indent < 1 && elementHasClassName) {
          dom.classList.remove(indentClassName);
        }
      }
      const indentationBaseValue = getComputedStyle(dom).getPropertyValue("--lexical-indent-base-value") || DEFAULT_INDENT_VALUE;
      dom.style.setProperty("padding-inline-start", indent === 0 ? "" : `calc(${indent} * ${indentationBaseValue})`);
    }
    function setElementFormat(dom, format3) {
      const domStyle = dom.style;
      if (format3 === 0) {
        setTextAlign(domStyle, "");
      } else if (format3 === IS_ALIGN_LEFT) {
        setTextAlign(domStyle, "left");
      } else if (format3 === IS_ALIGN_CENTER) {
        setTextAlign(domStyle, "center");
      } else if (format3 === IS_ALIGN_RIGHT) {
        setTextAlign(domStyle, "right");
      } else if (format3 === IS_ALIGN_JUSTIFY) {
        setTextAlign(domStyle, "justify");
      } else if (format3 === IS_ALIGN_START) {
        setTextAlign(domStyle, "start");
      } else if (format3 === IS_ALIGN_END) {
        setTextAlign(domStyle, "end");
      }
    }
    function createNode(key, parentDOM, insertDOM) {
      const node = activeNextNodeMap.get(key);
      if (node === void 0) {
        {
          throw Error(`createNode: node does not exist in nodeMap`);
        }
      }
      const dom = node.createDOM(activeEditorConfig, activeEditor$1);
      storeDOMWithKey(key, dom, activeEditor$1);
      if ($isTextNode(node)) {
        dom.setAttribute("data-lexical-text", "true");
      } else if ($isDecoratorNode(node)) {
        dom.setAttribute("data-lexical-decorator", "true");
      }
      if ($isElementNode(node)) {
        const indent = node.__indent;
        const childrenSize = node.__size;
        if (indent !== 0) {
          setElementIndent(dom, indent);
        }
        if (childrenSize !== 0) {
          const endIndex = childrenSize - 1;
          const children = createChildrenArray(node, activeNextNodeMap);
          createChildrenWithDirection(children, endIndex, node, dom);
        }
        const format3 = node.__format;
        if (format3 !== 0) {
          setElementFormat(dom, format3);
        }
        if (!node.isInline()) {
          reconcileElementTerminatingLineBreak(null, node, dom);
        }
        if ($textContentRequiresDoubleLinebreakAtEnd(node)) {
          subTreeTextContent += DOUBLE_LINE_BREAK;
          editorTextContent += DOUBLE_LINE_BREAK;
        }
      } else {
        const text = node.getTextContent();
        if ($isDecoratorNode(node)) {
          const decorator = node.decorate(activeEditor$1, activeEditorConfig);
          if (decorator !== null) {
            reconcileDecorator(key, decorator);
          }
          dom.contentEditable = "false";
        } else if ($isTextNode(node)) {
          if (!node.isDirectionless()) {
            subTreeDirectionedTextContent += text;
          }
        }
        subTreeTextContent += text;
        editorTextContent += text;
      }
      if (parentDOM !== null) {
        if (insertDOM != null) {
          parentDOM.insertBefore(dom, insertDOM);
        } else {
          const possibleLineBreak = parentDOM.__lexicalLineBreak;
          if (possibleLineBreak != null) {
            parentDOM.insertBefore(dom, possibleLineBreak);
          } else {
            parentDOM.appendChild(dom);
          }
        }
      }
      {
        Object.freeze(node);
      }
      setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, "created");
      return dom;
    }
    function createChildrenWithDirection(children, endIndex, element, dom) {
      const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;
      subTreeDirectionedTextContent = "";
      createChildren(children, element, 0, endIndex, dom, null);
      reconcileBlockDirection(element, dom);
      subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;
    }
    function createChildren(children, element, _startIndex, endIndex, dom, insertDOM) {
      const previousSubTreeTextContent = subTreeTextContent;
      subTreeTextContent = "";
      let startIndex = _startIndex;
      for (; startIndex <= endIndex; ++startIndex) {
        createNode(children[startIndex], dom, insertDOM);
      }
      if ($textContentRequiresDoubleLinebreakAtEnd(element)) {
        subTreeTextContent += DOUBLE_LINE_BREAK;
      }
      dom.__lexicalTextContent = subTreeTextContent;
      subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;
    }
    function isLastChildLineBreakOrDecorator(childKey, nodeMap) {
      const node = nodeMap.get(childKey);
      return $isLineBreakNode(node) || $isDecoratorNode(node) && node.isInline();
    }
    function reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {
      const prevLineBreak = prevElement !== null && (prevElement.__size === 0 || isLastChildLineBreakOrDecorator(prevElement.__last, activePrevNodeMap));
      const nextLineBreak = nextElement.__size === 0 || isLastChildLineBreakOrDecorator(nextElement.__last, activeNextNodeMap);
      if (prevLineBreak) {
        if (!nextLineBreak) {
          const element = dom.__lexicalLineBreak;
          if (element != null) {
            dom.removeChild(element);
          }
          dom.__lexicalLineBreak = null;
        }
      } else if (nextLineBreak) {
        const element = document.createElement("br");
        dom.__lexicalLineBreak = element;
        dom.appendChild(element);
      }
    }
    function reconcileBlockDirection(element, dom) {
      const previousSubTreeDirectionTextContent = (
        // @ts-expect-error: internal field
        dom.__lexicalDirTextContent
      );
      const previousDirection = dom.__lexicalDir;
      if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {
        const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === "";
        const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);
        if (direction !== previousDirection) {
          const classList = dom.classList;
          const theme = activeEditorConfig.theme;
          let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : void 0;
          let nextDirectionTheme = direction !== null ? theme[direction] : void 0;
          if (previousDirectionTheme !== void 0) {
            if (typeof previousDirectionTheme === "string") {
              const classNamesArr = previousDirectionTheme.split(" ");
              previousDirectionTheme = theme[previousDirection] = classNamesArr;
            }
            classList.remove(...previousDirectionTheme);
          }
          if (direction === null || hasEmptyDirectionedTextContent && direction === "ltr") {
            dom.removeAttribute("dir");
          } else {
            if (nextDirectionTheme !== void 0) {
              if (typeof nextDirectionTheme === "string") {
                const classNamesArr = nextDirectionTheme.split(" ");
                nextDirectionTheme = theme[direction] = classNamesArr;
              }
              if (nextDirectionTheme !== void 0) {
                classList.add(...nextDirectionTheme);
              }
            }
            dom.dir = direction;
          }
          if (!activeEditorStateReadOnly) {
            const writableNode = element.getWritable();
            writableNode.__dir = direction;
          }
        }
        activeTextDirection = direction;
        dom.__lexicalDirTextContent = subTreeDirectionedTextContent;
        dom.__lexicalDir = direction;
      }
    }
    function reconcileChildrenWithDirection(prevElement, nextElement, dom) {
      const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;
      subTreeDirectionedTextContent = "";
      reconcileChildren(prevElement, nextElement, dom);
      reconcileBlockDirection(nextElement, dom);
      subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;
    }
    function createChildrenArray(element, nodeMap) {
      const children = [];
      let nodeKey = element.__first;
      while (nodeKey !== null) {
        const node = nodeMap.get(nodeKey);
        if (node === void 0) {
          {
            throw Error(`createChildrenArray: node does not exist in nodeMap`);
          }
        }
        children.push(nodeKey);
        nodeKey = node.__next;
      }
      return children;
    }
    function reconcileChildren(prevElement, nextElement, dom) {
      const previousSubTreeTextContent = subTreeTextContent;
      const prevChildrenSize = prevElement.__size;
      const nextChildrenSize = nextElement.__size;
      subTreeTextContent = "";
      if (prevChildrenSize === 1 && nextChildrenSize === 1) {
        const prevFirstChildKey = prevElement.__first;
        const nextFrstChildKey = nextElement.__first;
        if (prevFirstChildKey === nextFrstChildKey) {
          reconcileNode(prevFirstChildKey, dom);
        } else {
          const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);
          const replacementDOM = createNode(nextFrstChildKey, null, null);
          dom.replaceChild(replacementDOM, lastDOM);
          destroyNode(prevFirstChildKey, null);
        }
      } else {
        const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);
        const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);
        if (prevChildrenSize === 0) {
          if (nextChildrenSize !== 0) {
            createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, dom, null);
          }
        } else if (nextChildrenSize === 0) {
          if (prevChildrenSize !== 0) {
            const lexicalLineBreak = dom.__lexicalLineBreak;
            const canUseFastPath = lexicalLineBreak == null;
            destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);
            if (canUseFastPath) {
              dom.textContent = "";
            }
          }
        } else {
          reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, dom);
        }
      }
      if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {
        subTreeTextContent += DOUBLE_LINE_BREAK;
      }
      dom.__lexicalTextContent = subTreeTextContent;
      subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;
    }
    function reconcileNode(key, parentDOM) {
      const prevNode = activePrevNodeMap.get(key);
      let nextNode = activeNextNodeMap.get(key);
      if (prevNode === void 0 || nextNode === void 0) {
        {
          throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);
        }
      }
      const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);
      const dom = getElementByKeyOrThrow(activeEditor$1, key);
      if (prevNode === nextNode && !isDirty) {
        if ($isElementNode(prevNode)) {
          const previousSubTreeTextContent = dom.__lexicalTextContent;
          if (previousSubTreeTextContent !== void 0) {
            subTreeTextContent += previousSubTreeTextContent;
            editorTextContent += previousSubTreeTextContent;
          }
          const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;
          if (previousSubTreeDirectionTextContent !== void 0) {
            subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;
          }
        } else {
          const text = prevNode.getTextContent();
          if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {
            subTreeDirectionedTextContent += text;
          }
          editorTextContent += text;
          subTreeTextContent += text;
        }
        return dom;
      }
      if (prevNode !== nextNode && isDirty) {
        setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, "updated");
      }
      if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {
        const replacementDOM = createNode(key, null, null);
        if (parentDOM === null) {
          {
            throw Error(`reconcileNode: parentDOM is null`);
          }
        }
        parentDOM.replaceChild(replacementDOM, dom);
        destroyNode(key, null);
        return replacementDOM;
      }
      if ($isElementNode(prevNode) && $isElementNode(nextNode)) {
        const nextIndent = nextNode.__indent;
        if (nextIndent !== prevNode.__indent) {
          setElementIndent(dom, nextIndent);
        }
        const nextFormat = nextNode.__format;
        if (nextFormat !== prevNode.__format) {
          setElementFormat(dom, nextFormat);
        }
        if (isDirty) {
          reconcileChildrenWithDirection(prevNode, nextNode, dom);
          if (!$isRootNode(nextNode) && !nextNode.isInline()) {
            reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);
          }
        }
        if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {
          subTreeTextContent += DOUBLE_LINE_BREAK;
          editorTextContent += DOUBLE_LINE_BREAK;
        }
      } else {
        const text = nextNode.getTextContent();
        if ($isDecoratorNode(nextNode)) {
          const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);
          if (decorator !== null) {
            reconcileDecorator(key, decorator);
          }
        } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {
          subTreeDirectionedTextContent += text;
        }
        subTreeTextContent += text;
        editorTextContent += text;
      }
      if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {
        nextNode = nextNode.getWritable();
        nextNode.__cachedText = editorTextContent;
      }
      {
        Object.freeze(nextNode);
      }
      return dom;
    }
    function reconcileDecorator(key, decorator) {
      let pendingDecorators = activeEditor$1._pendingDecorators;
      const currentDecorators = activeEditor$1._decorators;
      if (pendingDecorators === null) {
        if (currentDecorators[key] === decorator) {
          return;
        }
        pendingDecorators = cloneDecorators(activeEditor$1);
      }
      pendingDecorators[key] = decorator;
    }
    function getFirstChild(element) {
      return element.firstChild;
    }
    function getNextSibling(element) {
      let nextSibling = element.nextSibling;
      if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {
        nextSibling = nextSibling.nextSibling;
      }
      return nextSibling;
    }
    function reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom) {
      const prevEndIndex = prevChildrenLength - 1;
      const nextEndIndex = nextChildrenLength - 1;
      let prevChildrenSet;
      let nextChildrenSet;
      let siblingDOM = getFirstChild(dom);
      let prevIndex = 0;
      let nextIndex = 0;
      while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {
        const prevKey = prevChildren[prevIndex];
        const nextKey = nextChildren[nextIndex];
        if (prevKey === nextKey) {
          siblingDOM = getNextSibling(reconcileNode(nextKey, dom));
          prevIndex++;
          nextIndex++;
        } else {
          if (prevChildrenSet === void 0) {
            prevChildrenSet = new Set(prevChildren);
          }
          if (nextChildrenSet === void 0) {
            nextChildrenSet = new Set(nextChildren);
          }
          const nextHasPrevKey = nextChildrenSet.has(prevKey);
          const prevHasNextKey = prevChildrenSet.has(nextKey);
          if (!nextHasPrevKey) {
            siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));
            destroyNode(prevKey, dom);
            prevIndex++;
          } else if (!prevHasNextKey) {
            createNode(nextKey, dom, siblingDOM);
            nextIndex++;
          } else {
            const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);
            if (childDOM === siblingDOM) {
              siblingDOM = getNextSibling(reconcileNode(nextKey, dom));
            } else {
              if (siblingDOM != null) {
                dom.insertBefore(childDOM, siblingDOM);
              } else {
                dom.appendChild(childDOM);
              }
              reconcileNode(nextKey, dom);
            }
            prevIndex++;
            nextIndex++;
          }
        }
      }
      const appendNewChildren = prevIndex > prevEndIndex;
      const removeOldChildren = nextIndex > nextEndIndex;
      if (appendNewChildren && !removeOldChildren) {
        const previousNode = nextChildren[nextEndIndex + 1];
        const insertDOM = previousNode === void 0 ? null : activeEditor$1.getElementByKey(previousNode);
        createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, dom, insertDOM);
      } else if (removeOldChildren && !appendNewChildren) {
        destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);
      }
    }
    function reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {
      subTreeTextContent = "";
      editorTextContent = "";
      subTreeDirectionedTextContent = "";
      treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;
      activeTextDirection = null;
      activeEditor$1 = editor;
      activeEditorConfig = editor._config;
      activeEditorNodes = editor._nodes;
      activeMutationListeners = activeEditor$1._listeners.mutation;
      activeDirtyElements = dirtyElements;
      activeDirtyLeaves = dirtyLeaves;
      activePrevNodeMap = prevEditorState._nodeMap;
      activeNextNodeMap = nextEditorState._nodeMap;
      activeEditorStateReadOnly = nextEditorState._readOnly;
      activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);
      const currentMutatedNodes = /* @__PURE__ */ new Map();
      mutatedNodes = currentMutatedNodes;
      reconcileNode("root", null);
      activeEditor$1 = void 0;
      activeEditorNodes = void 0;
      activeDirtyElements = void 0;
      activeDirtyLeaves = void 0;
      activePrevNodeMap = void 0;
      activeNextNodeMap = void 0;
      activeEditorConfig = void 0;
      activePrevKeyToDOMMap = void 0;
      mutatedNodes = void 0;
      return currentMutatedNodes;
    }
    function storeDOMWithKey(key, dom, editor) {
      const keyToDOMMap = editor._keyToDOMMap;
      dom["__lexicalKey_" + editor._key] = key;
      keyToDOMMap.set(key, dom);
    }
    function getPrevElementByKeyOrThrow(key) {
      const element = activePrevKeyToDOMMap.get(key);
      if (element === void 0) {
        {
          throw Error(`Reconciliation: could not find DOM element for node key ${key}`);
        }
      }
      return element;
    }
    var PASS_THROUGH_COMMAND = Object.freeze({});
    var ANDROID_COMPOSITION_LATENCY = 30;
    var rootElementEvents = [["keydown", onKeyDown], ["pointerdown", onPointerDown], ["compositionstart", onCompositionStart], ["compositionend", onCompositionEnd], ["input", onInput], ["click", onClick], ["cut", PASS_THROUGH_COMMAND], ["copy", PASS_THROUGH_COMMAND], ["dragstart", PASS_THROUGH_COMMAND], ["dragover", PASS_THROUGH_COMMAND], ["dragend", PASS_THROUGH_COMMAND], ["paste", PASS_THROUGH_COMMAND], ["focus", PASS_THROUGH_COMMAND], ["blur", PASS_THROUGH_COMMAND], ["drop", PASS_THROUGH_COMMAND]];
    if (CAN_USE_BEFORE_INPUT) {
      rootElementEvents.push(["beforeinput", (event, editor) => onBeforeInput(event, editor)]);
    }
    var lastKeyDownTimeStamp = 0;
    var lastKeyCode = 0;
    var lastBeforeInputInsertTextTimeStamp = 0;
    var unprocessedBeforeInputData = null;
    var rootElementsRegistered = 0;
    var isSelectionChangeFromDOMUpdate = false;
    var isSelectionChangeFromMouseDown = false;
    var isInsertLineBreak = false;
    var isFirefoxEndingComposition = false;
    var collapsedSelectionFormat = [0, "", 0, "root", 0];
    function $shouldPreventDefaultAndInsertText(selection, text, timeStamp, isBeforeInput) {
      const anchor = selection.anchor;
      const focus = selection.focus;
      const anchorNode = anchor.getNode();
      const editor = getActiveEditor();
      const domSelection = getDOMSelection(editor._window);
      const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;
      const anchorKey = anchor.key;
      const backingAnchorElement = editor.getElementByKey(anchorKey);
      const textLength = text.length;
      return anchorKey !== focus.key || // If we're working with a non-text node.
      !$isTextNode(anchorNode) || // If we are replacing a range with a single character or grapheme, and not composing.
      (!isBeforeInput && (!CAN_USE_BEFORE_INPUT || // We check to see if there has been
      // a recent beforeinput event for "textInput". If there has been one in the last
      // 50ms then we proceed as normal. However, if there is not, then this is likely
      // a dangling `input` event caused by execCommand('insertText').
      lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() || // Any non standard text node.
      $isTokenOrSegmented(anchorNode) || // If the text length is more than a single character and we're either
      // dealing with this in "beforeinput" or where the node has already recently
      // been changed (thus is dirty).
      anchorNode.isDirty() && textLength > 1 || // If the DOM selection element is not the same as the backing node during beforeinput.
      (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) || // Check if we're changing from bold to italics, or some other format.
      anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style || // One last set of heuristics to check against.
      $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);
    }
    function shouldSkipSelectionChange(domNode, offset) {
      return domNode !== null && domNode.nodeValue !== null && domNode.nodeType === DOM_TEXT_TYPE && offset !== 0 && offset !== domNode.nodeValue.length;
    }
    function onSelectionChange(domSelection, editor, isActive) {
      const {
        anchorNode: anchorDOM,
        anchorOffset,
        focusNode: focusDOM,
        focusOffset
      } = domSelection;
      if (isSelectionChangeFromDOMUpdate) {
        isSelectionChangeFromDOMUpdate = false;
        if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {
          return;
        }
      }
      updateEditor(editor, () => {
        if (!isActive) {
          $setSelection2(null);
          return;
        }
        if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
          return;
        }
        const selection = $getSelection2();
        if ($isRangeSelection2(selection)) {
          const anchor = selection.anchor;
          const anchorNode = anchor.getNode();
          if (selection.isCollapsed()) {
            if (domSelection.type === "Range" && domSelection.anchorNode === domSelection.focusNode) {
              selection.dirty = true;
            }
            const windowEvent = getWindow(editor).event;
            const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();
            const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;
            if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {
              selection.format = lastFormat;
              selection.style = lastStyle;
            } else {
              if (anchor.type === "text") {
                selection.format = anchorNode.getFormat();
                selection.style = anchorNode.getStyle();
              } else if (anchor.type === "element") {
                selection.format = 0;
                selection.style = "";
              }
            }
          } else {
            let combinedFormat = IS_ALL_FORMATTING;
            let hasTextNodes = false;
            const nodes = selection.getNodes();
            const nodesLength = nodes.length;
            for (let i = 0; i < nodesLength; i++) {
              const node = nodes[i];
              if ($isTextNode(node)) {
                hasTextNodes = true;
                combinedFormat &= node.getFormat();
                if (combinedFormat === 0) {
                  break;
                }
              }
            }
            selection.format = hasTextNodes ? combinedFormat : 0;
          }
        }
        dispatchCommand(editor, SELECTION_CHANGE_COMMAND2, void 0);
      });
    }
    function onClick(event, editor) {
      updateEditor(editor, () => {
        const selection = $getSelection2();
        const domSelection = getDOMSelection(editor._window);
        const lastSelection = $getPreviousSelection();
        if ($isRangeSelection2(selection)) {
          const anchor = selection.anchor;
          const anchorNode = anchor.getNode();
          if (domSelection && anchor.type === "element" && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {
            domSelection.removeAllRanges();
            selection.dirty = true;
          }
        }
        dispatchCommand(editor, CLICK_COMMAND, event);
      });
    }
    function onPointerDown(event, editor) {
      const target = event.target;
      const pointerType = event.pointerType;
      if (target instanceof Node && pointerType !== "touch") {
        updateEditor(editor, () => {
          if (!$isSelectionCapturedInDecorator(target)) {
            isSelectionChangeFromMouseDown = true;
          }
        });
      }
    }
    function $applyTargetRange(selection, event) {
      if (event.getTargetRanges) {
        const targetRange = event.getTargetRanges()[0];
        if (targetRange) {
          selection.applyDOMRange(targetRange);
        }
      }
    }
    function $canRemoveText(anchorNode, focusNode) {
      return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();
    }
    function isPossiblyAndroidKeyPress(timeStamp) {
      return lastKeyCode === 229 && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;
    }
    function onBeforeInput(event, editor) {
      const inputType = event.inputType;
      if (inputType === "deleteCompositionText" || // If we're pasting in FF, we shouldn't get this event
      // as the `paste` event should have triggered, unless the
      // user has dom.event.clipboardevents.enabled disabled in
      // about:config. In that case, we need to process the
      // pasted content in the DOM mutation phase.
      IS_FIREFOX && isFirefoxClipboardEvents(editor)) {
        return;
      } else if (inputType === "insertCompositionText") {
        return;
      }
      updateEditor(editor, () => {
        const selection = $getSelection2();
        if (inputType === "deleteContentBackward") {
          if (selection === null) {
            const prevSelection = $getPreviousSelection();
            if (!$isRangeSelection2(prevSelection)) {
              return;
            }
            $setSelection2(prevSelection.clone());
          }
          if ($isRangeSelection2(selection)) {
            if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && selection.anchor.key === selection.focus.key) {
              $setCompositionKey(null);
              lastKeyDownTimeStamp = 0;
              setTimeout(() => {
                updateEditor(editor, () => {
                  $setCompositionKey(null);
                });
              }, ANDROID_COMPOSITION_LATENCY);
              if ($isRangeSelection2(selection)) {
                const anchorNode2 = selection.anchor.getNode();
                anchorNode2.markDirty();
                selection.format = anchorNode2.getFormat();
                selection.style = anchorNode2.getStyle();
              }
            } else {
              event.preventDefault();
              dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);
            }
            return;
          }
        }
        if (!$isRangeSelection2(selection)) {
          return;
        }
        const data = event.data;
        if (unprocessedBeforeInputData !== null) {
          $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);
        }
        if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode())) {
          $applyTargetRange(selection, event);
        }
        unprocessedBeforeInputData = null;
        const anchor = selection.anchor;
        const focus = selection.focus;
        const anchorNode = anchor.getNode();
        const focusNode = focus.getNode();
        if (inputType === "insertText" || inputType === "insertTranspose") {
          if (data === "\n") {
            event.preventDefault();
            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
          } else if (data === DOUBLE_LINE_BREAK) {
            event.preventDefault();
            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND2, void 0);
          } else if (data == null && event.dataTransfer) {
            const text = event.dataTransfer.getData("text/plain");
            event.preventDefault();
            selection.insertRawText(text);
          } else if (data != null && $shouldPreventDefaultAndInsertText(selection, data, event.timeStamp, true)) {
            event.preventDefault();
            dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);
          } else {
            unprocessedBeforeInputData = data;
          }
          lastBeforeInputInsertTextTimeStamp = event.timeStamp;
          return;
        }
        event.preventDefault();
        switch (inputType) {
          case "insertFromYank":
          case "insertFromDrop":
          case "insertReplacementText": {
            dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);
            break;
          }
          case "insertFromComposition": {
            $setCompositionKey(null);
            dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);
            break;
          }
          case "insertLineBreak": {
            $setCompositionKey(null);
            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
            break;
          }
          case "insertParagraph": {
            $setCompositionKey(null);
            if (isInsertLineBreak) {
              isInsertLineBreak = false;
              dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
            } else {
              dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND2, void 0);
            }
            break;
          }
          case "insertFromPaste":
          case "insertFromPasteAsQuotation": {
            dispatchCommand(editor, PASTE_COMMAND, event);
            break;
          }
          case "deleteByComposition": {
            if ($canRemoveText(anchorNode, focusNode)) {
              dispatchCommand(editor, REMOVE_TEXT_COMMAND, void 0);
            }
            break;
          }
          case "deleteByDrag":
          case "deleteByCut": {
            dispatchCommand(editor, REMOVE_TEXT_COMMAND, void 0);
            break;
          }
          case "deleteContent": {
            dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);
            break;
          }
          case "deleteWordBackward": {
            dispatchCommand(editor, DELETE_WORD_COMMAND, true);
            break;
          }
          case "deleteWordForward": {
            dispatchCommand(editor, DELETE_WORD_COMMAND, false);
            break;
          }
          case "deleteHardLineBackward":
          case "deleteSoftLineBackward": {
            dispatchCommand(editor, DELETE_LINE_COMMAND, true);
            break;
          }
          case "deleteContentForward":
          case "deleteHardLineForward":
          case "deleteSoftLineForward": {
            dispatchCommand(editor, DELETE_LINE_COMMAND, false);
            break;
          }
          case "formatStrikeThrough": {
            dispatchCommand(editor, FORMAT_TEXT_COMMAND2, "strikethrough");
            break;
          }
          case "formatBold": {
            dispatchCommand(editor, FORMAT_TEXT_COMMAND2, "bold");
            break;
          }
          case "formatItalic": {
            dispatchCommand(editor, FORMAT_TEXT_COMMAND2, "italic");
            break;
          }
          case "formatUnderline": {
            dispatchCommand(editor, FORMAT_TEXT_COMMAND2, "underline");
            break;
          }
          case "historyUndo": {
            dispatchCommand(editor, UNDO_COMMAND, void 0);
            break;
          }
          case "historyRedo": {
            dispatchCommand(editor, REDO_COMMAND, void 0);
            break;
          }
        }
      });
    }
    function onInput(event, editor) {
      event.stopPropagation();
      updateEditor(editor, () => {
        const selection = $getSelection2();
        const data = event.data;
        if (data != null && $isRangeSelection2(selection) && $shouldPreventDefaultAndInsertText(selection, data, event.timeStamp, false)) {
          if (isFirefoxEndingComposition) {
            onCompositionEndImpl(editor, data);
            isFirefoxEndingComposition = false;
          }
          const anchor = selection.anchor;
          const anchorNode = anchor.getNode();
          const domSelection = getDOMSelection(editor._window);
          if (domSelection === null) {
            return;
          }
          const offset = anchor.offset;
          if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, offset) + data + anchorNode.getTextContent().slice(offset + selection.focus.offset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {
            dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);
          }
          const textLength = data.length;
          if (IS_FIREFOX && textLength > 1 && event.inputType === "insertCompositionText" && !editor.isComposing()) {
            selection.anchor.offset -= textLength;
          }
          if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {
            lastKeyDownTimeStamp = 0;
            $setCompositionKey(null);
          }
        } else {
          const characterData = data !== null ? data : void 0;
          $updateSelectedTextFromDOM(false, editor, characterData);
          if (isFirefoxEndingComposition) {
            onCompositionEndImpl(editor, data || void 0);
            isFirefoxEndingComposition = false;
          }
        }
        $flushMutations();
      });
      unprocessedBeforeInputData = null;
    }
    function onCompositionStart(event, editor) {
      updateEditor(editor, () => {
        const selection = $getSelection2();
        if ($isRangeSelection2(selection) && !editor.isComposing()) {
          const anchor = selection.anchor;
          const node = selection.anchor.getNode();
          $setCompositionKey(anchor.key);
          if (
            // If it has been 30ms since the last keydown, then we should
            // apply the empty space heuristic. We can't do this for Safari,
            // as the keydown fires after composition start.
            event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY || // FF has issues around composing multibyte characters, so we also
            // need to invoke the empty space heuristic below.
            anchor.type === "element" || !selection.isCollapsed() || node.getFormat() !== selection.format || node.getStyle() !== selection.style
          ) {
            dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);
          }
        }
      });
    }
    function onCompositionEndImpl(editor, data) {
      const compositionKey = editor._compositionKey;
      $setCompositionKey(null);
      if (compositionKey !== null && data != null) {
        if (data === "") {
          const node = $getNodeByKey(compositionKey);
          const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));
          if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {
            $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);
          }
          return;
        }
        if (data[data.length - 1] === "\n") {
          const selection = $getSelection2();
          if ($isRangeSelection2(selection)) {
            const focus = selection.focus;
            selection.anchor.set(focus.key, focus.offset, focus.type);
            dispatchCommand(editor, KEY_ENTER_COMMAND, null);
            return;
          }
        }
      }
      $updateSelectedTextFromDOM(true, editor, data);
    }
    function onCompositionEnd(event, editor) {
      if (IS_FIREFOX) {
        isFirefoxEndingComposition = true;
      } else {
        updateEditor(editor, () => {
          onCompositionEndImpl(editor, event.data);
        });
      }
    }
    function onKeyDown(event, editor) {
      lastKeyDownTimeStamp = event.timeStamp;
      lastKeyCode = event.keyCode;
      if (editor.isComposing()) {
        return;
      }
      const {
        keyCode,
        shiftKey,
        ctrlKey,
        metaKey,
        altKey
      } = event;
      if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {
        return;
      }
      if (isMoveForward(keyCode, ctrlKey, altKey, metaKey)) {
        dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);
      } else if (isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {
        dispatchCommand(editor, MOVE_TO_END, event);
      } else if (isMoveBackward(keyCode, ctrlKey, altKey, metaKey)) {
        dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);
      } else if (isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {
        dispatchCommand(editor, MOVE_TO_START, event);
      } else if (isMoveUp(keyCode, ctrlKey, metaKey)) {
        dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);
      } else if (isMoveDown(keyCode, ctrlKey, metaKey)) {
        dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);
      } else if (isLineBreak(keyCode, shiftKey)) {
        isInsertLineBreak = true;
        dispatchCommand(editor, KEY_ENTER_COMMAND, event);
      } else if (isSpace(keyCode)) {
        dispatchCommand(editor, KEY_SPACE_COMMAND, event);
      } else if (isOpenLineBreak(keyCode, ctrlKey)) {
        event.preventDefault();
        isInsertLineBreak = true;
        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);
      } else if (isParagraph(keyCode, shiftKey)) {
        isInsertLineBreak = false;
        dispatchCommand(editor, KEY_ENTER_COMMAND, event);
      } else if (isDeleteBackward(keyCode, altKey, metaKey, ctrlKey)) {
        if (isBackspace(keyCode)) {
          dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);
        } else {
          event.preventDefault();
          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);
        }
      } else if (isEscape(keyCode)) {
        dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);
      } else if (isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {
        if (isDelete(keyCode)) {
          dispatchCommand(editor, KEY_DELETE_COMMAND, event);
        } else {
          event.preventDefault();
          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);
        }
      } else if (isDeleteWordBackward(keyCode, altKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, DELETE_WORD_COMMAND, true);
      } else if (isDeleteWordForward(keyCode, altKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, DELETE_WORD_COMMAND, false);
      } else if (isDeleteLineBackward(keyCode, metaKey)) {
        event.preventDefault();
        dispatchCommand(editor, DELETE_LINE_COMMAND, true);
      } else if (isDeleteLineForward(keyCode, metaKey)) {
        event.preventDefault();
        dispatchCommand(editor, DELETE_LINE_COMMAND, false);
      } else if (isBold(keyCode, altKey, metaKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, FORMAT_TEXT_COMMAND2, "bold");
      } else if (isUnderline(keyCode, altKey, metaKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, FORMAT_TEXT_COMMAND2, "underline");
      } else if (isItalic(keyCode, altKey, metaKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, FORMAT_TEXT_COMMAND2, "italic");
      } else if (isTab(keyCode, altKey, ctrlKey, metaKey)) {
        dispatchCommand(editor, KEY_TAB_COMMAND, event);
      } else if (isUndo(keyCode, shiftKey, metaKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, UNDO_COMMAND, void 0);
      } else if (isRedo(keyCode, shiftKey, metaKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, REDO_COMMAND, void 0);
      } else {
        const prevSelection = editor._editorState._selection;
        if ($isNodeSelection(prevSelection)) {
          if (isCopy(keyCode, shiftKey, metaKey, ctrlKey)) {
            event.preventDefault();
            dispatchCommand(editor, COPY_COMMAND, event);
          } else if (isCut(keyCode, shiftKey, metaKey, ctrlKey)) {
            event.preventDefault();
            dispatchCommand(editor, CUT_COMMAND, event);
          }
        }
      }
      if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {
        dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);
      }
    }
    function getRootElementRemoveHandles(rootElement) {
      let eventHandles = rootElement.__lexicalEventHandles;
      if (eventHandles === void 0) {
        eventHandles = [];
        rootElement.__lexicalEventHandles = eventHandles;
      }
      return eventHandles;
    }
    var activeNestedEditorsMap = /* @__PURE__ */ new Map();
    function onDocumentSelectionChange(event) {
      const target = event.target;
      const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;
      const domSelection = getDOMSelection(targetWindow);
      if (domSelection === null) {
        return;
      }
      const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);
      if (nextActiveEditor === null) {
        return;
      }
      if (isSelectionChangeFromMouseDown) {
        isSelectionChangeFromMouseDown = false;
        updateEditor(nextActiveEditor, () => {
          const lastSelection = $getPreviousSelection();
          const domAnchorNode = domSelection.anchorNode;
          if (domAnchorNode === null) {
            return;
          }
          const nodeType = domAnchorNode.nodeType;
          if (nodeType !== DOM_ELEMENT_TYPE && nodeType !== DOM_TEXT_TYPE) {
            return;
          }
          const newSelection = internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor);
          $setSelection2(newSelection);
        });
      }
      const editors = getEditorsToPropagate(nextActiveEditor);
      const rootEditor = editors[editors.length - 1];
      const rootEditorKey = rootEditor._key;
      const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);
      const prevActiveEditor = activeNestedEditor || rootEditor;
      if (prevActiveEditor !== nextActiveEditor) {
        onSelectionChange(domSelection, prevActiveEditor, false);
      }
      onSelectionChange(domSelection, nextActiveEditor, true);
      if (nextActiveEditor !== rootEditor) {
        activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);
      } else if (activeNestedEditor) {
        activeNestedEditorsMap.delete(rootEditorKey);
      }
    }
    function stopLexicalPropagation(event) {
      event._lexicalHandled = true;
    }
    function hasStoppedLexicalPropagation(event) {
      const stopped = event._lexicalHandled === true;
      return stopped;
    }
    function addRootElementEvents(rootElement, editor) {
      if (rootElementsRegistered === 0) {
        const doc = rootElement.ownerDocument;
        doc.addEventListener("selectionchange", onDocumentSelectionChange);
      }
      rootElementsRegistered++;
      rootElement.__lexicalEditor = editor;
      const removeHandles = getRootElementRemoveHandles(rootElement);
      for (let i = 0; i < rootElementEvents.length; i++) {
        const [eventName, onEvent] = rootElementEvents[i];
        const eventHandler = typeof onEvent === "function" ? (event) => {
          if (hasStoppedLexicalPropagation(event)) {
            return;
          }
          stopLexicalPropagation(event);
          if (editor.isEditable()) {
            onEvent(event, editor);
          }
        } : (event) => {
          if (hasStoppedLexicalPropagation(event)) {
            return;
          }
          stopLexicalPropagation(event);
          if (editor.isEditable()) {
            switch (eventName) {
              case "cut":
                return dispatchCommand(editor, CUT_COMMAND, event);
              case "copy":
                return dispatchCommand(editor, COPY_COMMAND, event);
              case "paste":
                return dispatchCommand(editor, PASTE_COMMAND, event);
              case "dragstart":
                return dispatchCommand(editor, DRAGSTART_COMMAND, event);
              case "dragover":
                return dispatchCommand(editor, DRAGOVER_COMMAND, event);
              case "dragend":
                return dispatchCommand(editor, DRAGEND_COMMAND, event);
              case "focus":
                return dispatchCommand(editor, FOCUS_COMMAND, event);
              case "blur": {
                return dispatchCommand(editor, BLUR_COMMAND, event);
              }
              case "drop":
                return dispatchCommand(editor, DROP_COMMAND, event);
            }
          }
        };
        rootElement.addEventListener(eventName, eventHandler);
        removeHandles.push(() => {
          rootElement.removeEventListener(eventName, eventHandler);
        });
      }
    }
    function removeRootElementEvents(rootElement) {
      if (rootElementsRegistered !== 0) {
        rootElementsRegistered--;
        if (rootElementsRegistered === 0) {
          const doc = rootElement.ownerDocument;
          doc.removeEventListener("selectionchange", onDocumentSelectionChange);
        }
      }
      const editor = rootElement.__lexicalEditor;
      if (editor !== null && editor !== void 0) {
        cleanActiveNestedEditorsMap(editor);
        rootElement.__lexicalEditor = null;
      }
      const removeHandles = getRootElementRemoveHandles(rootElement);
      for (let i = 0; i < removeHandles.length; i++) {
        removeHandles[i]();
      }
      rootElement.__lexicalEventHandles = [];
    }
    function cleanActiveNestedEditorsMap(editor) {
      if (editor._parentEditor !== null) {
        const editors = getEditorsToPropagate(editor);
        const rootEditor = editors[editors.length - 1];
        const rootEditorKey = rootEditor._key;
        if (activeNestedEditorsMap.get(rootEditorKey) === editor) {
          activeNestedEditorsMap.delete(rootEditorKey);
        }
      } else {
        activeNestedEditorsMap.delete(editor._key);
      }
    }
    function markSelectionChangeFromDOMUpdate() {
      isSelectionChangeFromDOMUpdate = true;
    }
    function markCollapsedSelectionFormat(format3, style, offset, key, timeStamp) {
      collapsedSelectionFormat = [format3, style, offset, key, timeStamp];
    }
    var Point = class {
      constructor(key, offset, type2) {
        this._selection = null;
        this.key = key;
        this.offset = offset;
        this.type = type2;
      }
      is(point6) {
        return this.key === point6.key && this.offset === point6.offset && this.type === point6.type;
      }
      isBefore(b) {
        let aNode = this.getNode();
        let bNode = b.getNode();
        const aOffset = this.offset;
        const bOffset = b.offset;
        if ($isElementNode(aNode)) {
          const aNodeDescendant = aNode.getDescendantByIndex(aOffset);
          aNode = aNodeDescendant != null ? aNodeDescendant : aNode;
        }
        if ($isElementNode(bNode)) {
          const bNodeDescendant = bNode.getDescendantByIndex(bOffset);
          bNode = bNodeDescendant != null ? bNodeDescendant : bNode;
        }
        if (aNode === bNode) {
          return aOffset < bOffset;
        }
        return aNode.isBefore(bNode);
      }
      getNode() {
        const key = this.key;
        const node = $getNodeByKey(key);
        if (node === null) {
          {
            throw Error(`Point.getNode: node not found`);
          }
        }
        return node;
      }
      set(key, offset, type2) {
        const selection = this._selection;
        const oldKey = this.key;
        this.key = key;
        this.offset = offset;
        this.type = type2;
        if (!isCurrentlyReadOnlyMode()) {
          if ($getCompositionKey() === oldKey) {
            $setCompositionKey(key);
          }
          if (selection !== null) {
            selection._cachedNodes = null;
            selection.dirty = true;
          }
        }
      }
    };
    function $createPoint(key, offset, type2) {
      return new Point(key, offset, type2);
    }
    function selectPointOnNode(point6, node) {
      let key = node.__key;
      let offset = point6.offset;
      let type2 = "element";
      if ($isTextNode(node)) {
        type2 = "text";
        const textContentLength = node.getTextContentSize();
        if (offset > textContentLength) {
          offset = textContentLength;
        }
      } else if (!$isElementNode(node)) {
        const nextSibling = node.getNextSibling();
        if ($isTextNode(nextSibling)) {
          key = nextSibling.__key;
          offset = 0;
          type2 = "text";
        } else {
          const parentNode = node.getParent();
          if (parentNode) {
            key = parentNode.__key;
            offset = node.getIndexWithinParent() + 1;
          }
        }
      }
      point6.set(key, offset, type2);
    }
    function $moveSelectionPointToEnd(point6, node) {
      if ($isElementNode(node)) {
        const lastNode = node.getLastDescendant();
        if ($isElementNode(lastNode) || $isTextNode(lastNode)) {
          selectPointOnNode(point6, lastNode);
        } else {
          selectPointOnNode(point6, node);
        }
      } else {
        selectPointOnNode(point6, node);
      }
    }
    function $transferStartingElementPointToTextPoint(start, end, format3, style) {
      const element = start.getNode();
      const placementNode = element.getChildAtIndex(start.offset);
      const textNode = $createTextNode();
      const target = $isRootNode(element) ? $createParagraphNode2().append(textNode) : textNode;
      textNode.setFormat(format3);
      textNode.setStyle(style);
      if (placementNode === null) {
        element.append(target);
      } else {
        placementNode.insertBefore(target);
      }
      if (start.is(end)) {
        end.set(textNode.__key, 0, "text");
      }
      start.set(textNode.__key, 0, "text");
    }
    function $setPointValues(point6, key, offset, type2) {
      point6.key = key;
      point6.offset = offset;
      point6.type = type2;
    }
    var NodeSelection = class _NodeSelection {
      constructor(objects) {
        this.dirty = false;
        this._nodes = objects;
        this._cachedNodes = null;
      }
      is(selection) {
        if (!$isNodeSelection(selection)) {
          return false;
        }
        const a2 = this._nodes;
        const b = selection._nodes;
        return a2.size === b.size && Array.from(a2).every((key) => b.has(key));
      }
      add(key) {
        this.dirty = true;
        this._nodes.add(key);
        this._cachedNodes = null;
      }
      delete(key) {
        this.dirty = true;
        this._nodes.delete(key);
        this._cachedNodes = null;
      }
      clear() {
        this.dirty = true;
        this._nodes.clear();
        this._cachedNodes = null;
      }
      has(key) {
        return this._nodes.has(key);
      }
      clone() {
        return new _NodeSelection(new Set(this._nodes));
      }
      extract() {
        return this.getNodes();
      }
      insertRawText(text) {
      }
      insertText() {
      }
      insertNodes(nodes, selectStart) {
        const selectedNodes = this.getNodes();
        const selectedNodesLength = selectedNodes.length;
        const lastSelectedNode = selectedNodes[selectedNodesLength - 1];
        let selectionAtEnd;
        if ($isTextNode(lastSelectedNode)) {
          selectionAtEnd = lastSelectedNode.select();
        } else {
          const index2 = lastSelectedNode.getIndexWithinParent() + 1;
          selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index2, index2);
        }
        selectionAtEnd.insertNodes(nodes, selectStart);
        for (let i = 0; i < selectedNodesLength; i++) {
          selectedNodes[i].remove();
        }
        return true;
      }
      getNodes() {
        const cachedNodes = this._cachedNodes;
        if (cachedNodes !== null) {
          return cachedNodes;
        }
        const objects = this._nodes;
        const nodes = [];
        for (const object of objects) {
          const node = $getNodeByKey(object);
          if (node !== null) {
            nodes.push(node);
          }
        }
        if (!isCurrentlyReadOnlyMode()) {
          this._cachedNodes = nodes;
        }
        return nodes;
      }
      getTextContent() {
        const nodes = this.getNodes();
        let textContent = "";
        for (let i = 0; i < nodes.length; i++) {
          textContent += nodes[i].getTextContent();
        }
        return textContent;
      }
    };
    function $isRangeSelection2(x4) {
      return x4 instanceof RangeSelection;
    }
    var GridSelection = class _GridSelection {
      constructor(gridKey, anchor, focus) {
        this.gridKey = gridKey;
        this.anchor = anchor;
        this.focus = focus;
        this.dirty = false;
        this._cachedNodes = null;
        anchor._selection = this;
        focus._selection = this;
      }
      is(selection) {
        if (!DEPRECATED_$isGridSelection(selection)) {
          return false;
        }
        return this.gridKey === selection.gridKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);
      }
      set(gridKey, anchorCellKey, focusCellKey) {
        this.dirty = true;
        this.gridKey = gridKey;
        this.anchor.key = anchorCellKey;
        this.focus.key = focusCellKey;
        this._cachedNodes = null;
      }
      clone() {
        return new _GridSelection(this.gridKey, this.anchor, this.focus);
      }
      isCollapsed() {
        return false;
      }
      isBackward() {
        return this.focus.isBefore(this.anchor);
      }
      getCharacterOffsets() {
        return getCharacterOffsets(this);
      }
      extract() {
        return this.getNodes();
      }
      insertRawText(text) {
      }
      insertText() {
      }
      insertNodes(nodes, selectStart) {
        const focusNode = this.focus.getNode();
        const selection = $normalizeSelection(focusNode.select(0, focusNode.getChildrenSize()));
        return selection.insertNodes(nodes, selectStart);
      }
      getShape() {
        const anchorCellNode = $getNodeByKey(this.anchor.key);
        if (!(anchorCellNode !== null)) {
          throw Error(`getNodes: expected to find AnchorNode`);
        }
        const anchorCellNodeIndex = anchorCellNode.getIndexWithinParent();
        const anchorCelRoweIndex = anchorCellNode.getParentOrThrow().getIndexWithinParent();
        const focusCellNode = $getNodeByKey(this.focus.key);
        if (!(focusCellNode !== null)) {
          throw Error(`getNodes: expected to find FocusNode`);
        }
        const focusCellNodeIndex = focusCellNode.getIndexWithinParent();
        const focusCellRowIndex = focusCellNode.getParentOrThrow().getIndexWithinParent();
        const startX = Math.min(anchorCellNodeIndex, focusCellNodeIndex);
        const stopX = Math.max(anchorCellNodeIndex, focusCellNodeIndex);
        const startY = Math.min(anchorCelRoweIndex, focusCellRowIndex);
        const stopY = Math.max(anchorCelRoweIndex, focusCellRowIndex);
        return {
          fromX: Math.min(startX, stopX),
          fromY: Math.min(startY, stopY),
          toX: Math.max(startX, stopX),
          toY: Math.max(startY, stopY)
        };
      }
      getNodes() {
        const cachedNodes = this._cachedNodes;
        if (cachedNodes !== null) {
          return cachedNodes;
        }
        const nodesSet = /* @__PURE__ */ new Set();
        const {
          fromX,
          fromY,
          toX,
          toY
        } = this.getShape();
        const gridNode = $getNodeByKey(this.gridKey);
        if (!DEPRECATED_$isGridNode(gridNode)) {
          {
            throw Error(`getNodes: expected to find GridNode`);
          }
        }
        nodesSet.add(gridNode);
        const gridRowNodes = gridNode.getChildren();
        for (let r = fromY; r <= toY; r++) {
          const gridRowNode = gridRowNodes[r];
          nodesSet.add(gridRowNode);
          if (!DEPRECATED_$isGridRowNode(gridRowNode)) {
            {
              throw Error(`getNodes: expected to find GridRowNode`);
            }
          }
          const gridCellNodes = gridRowNode.getChildren();
          for (let c3 = fromX; c3 <= toX; c3++) {
            const gridCellNode = gridCellNodes[c3];
            if (!DEPRECATED_$isGridCellNode(gridCellNode)) {
              {
                throw Error(`getNodes: expected to find GridCellNode`);
              }
            }
            nodesSet.add(gridCellNode);
            const children = gridCellNode.getChildren();
            while (children.length > 0) {
              const child = children.shift();
              nodesSet.add(child);
              if ($isElementNode(child)) {
                children.unshift(...child.getChildren());
              }
            }
          }
        }
        const nodes = Array.from(nodesSet);
        if (!isCurrentlyReadOnlyMode()) {
          this._cachedNodes = nodes;
        }
        return nodes;
      }
      getTextContent() {
        const nodes = this.getNodes();
        let textContent = "";
        for (let i = 0; i < nodes.length; i++) {
          textContent += nodes[i].getTextContent();
        }
        return textContent;
      }
    };
    function DEPRECATED_$isGridSelection(x4) {
      return x4 instanceof GridSelection;
    }
    var RangeSelection = class _RangeSelection {
      constructor(anchor, focus, format3, style) {
        this.anchor = anchor;
        this.focus = focus;
        this.dirty = false;
        this.format = format3;
        this.style = style;
        this._cachedNodes = null;
        anchor._selection = this;
        focus._selection = this;
      }
      is(selection) {
        if (!$isRangeSelection2(selection)) {
          return false;
        }
        return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;
      }
      isBackward() {
        return this.focus.isBefore(this.anchor);
      }
      isCollapsed() {
        return this.anchor.is(this.focus);
      }
      getNodes() {
        const cachedNodes = this._cachedNodes;
        if (cachedNodes !== null) {
          return cachedNodes;
        }
        const anchor = this.anchor;
        const focus = this.focus;
        let firstNode = anchor.getNode();
        let lastNode = focus.getNode();
        if ($isElementNode(firstNode)) {
          const firstNodeDescendant = firstNode.getDescendantByIndex(anchor.offset);
          firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;
        }
        if ($isElementNode(lastNode)) {
          let lastNodeDescendant = lastNode.getDescendantByIndex(focus.offset);
          if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(focus.offset) === lastNodeDescendant) {
            lastNodeDescendant = lastNodeDescendant.getPreviousSibling();
          }
          lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;
        }
        let nodes;
        if (firstNode.is(lastNode)) {
          if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {
            nodes = [];
          } else {
            nodes = [firstNode];
          }
        } else {
          nodes = firstNode.getNodesBetween(lastNode);
        }
        if (!isCurrentlyReadOnlyMode()) {
          this._cachedNodes = nodes;
        }
        return nodes;
      }
      setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {
        $setPointValues(this.anchor, anchorNode.__key, anchorOffset, "text");
        $setPointValues(this.focus, focusNode.__key, focusOffset, "text");
        this._cachedNodes = null;
        this.dirty = true;
      }
      getTextContent() {
        const nodes = this.getNodes();
        if (nodes.length === 0) {
          return "";
        }
        const firstNode = nodes[0];
        const lastNode = nodes[nodes.length - 1];
        const anchor = this.anchor;
        const focus = this.focus;
        const isBefore = anchor.isBefore(focus);
        const [anchorOffset, focusOffset] = getCharacterOffsets(this);
        let textContent = "";
        let prevWasElement = true;
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if ($isElementNode(node) && !node.isInline()) {
            if (!prevWasElement) {
              textContent += "\n";
            }
            if (node.isEmpty()) {
              prevWasElement = false;
            } else {
              prevWasElement = true;
            }
          } else {
            prevWasElement = false;
            if ($isTextNode(node)) {
              let text = node.getTextContent();
              if (node === firstNode) {
                if (node === lastNode) {
                  if (anchor.type !== "element" || focus.type !== "element" || focus.offset === anchor.offset) {
                    text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);
                  }
                } else {
                  text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);
                }
              } else if (node === lastNode) {
                text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);
              }
              textContent += text;
            } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {
              textContent += node.getTextContent();
            }
          }
        }
        return textContent;
      }
      applyDOMRange(range2) {
        const editor = getActiveEditor();
        const currentEditorState = editor.getEditorState();
        const lastSelection = currentEditorState._selection;
        const resolvedSelectionPoints = internalResolveSelectionPoints(range2.startContainer, range2.startOffset, range2.endContainer, range2.endOffset, editor, lastSelection);
        if (resolvedSelectionPoints === null) {
          return;
        }
        const [anchorPoint, focusPoint] = resolvedSelectionPoints;
        $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);
        $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);
        this._cachedNodes = null;
      }
      clone() {
        const anchor = this.anchor;
        const focus = this.focus;
        const selection = new _RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);
        return selection;
      }
      toggleFormat(format3) {
        this.format = toggleTextFormatType(this.format, format3, null);
        this.dirty = true;
      }
      setStyle(style) {
        this.style = style;
        this.dirty = true;
      }
      hasFormat(type2) {
        const formatFlag = TEXT_TYPE_TO_FORMAT[type2];
        return (this.format & formatFlag) !== 0;
      }
      insertRawText(text) {
        const parts = text.split(/\r?\n/);
        if (parts.length === 1) {
          this.insertText(text);
        } else {
          const nodes = [];
          const length = parts.length;
          for (let i = 0; i < length; i++) {
            const part = parts[i];
            if (part !== "") {
              nodes.push($createTextNode(part));
            }
            if (i !== length - 1) {
              nodes.push($createLineBreakNode());
            }
          }
          this.insertNodes(nodes);
        }
      }
      insertText(text) {
        const anchor = this.anchor;
        const focus = this.focus;
        const isBefore = this.isCollapsed() || anchor.isBefore(focus);
        const format3 = this.format;
        const style = this.style;
        if (isBefore && anchor.type === "element") {
          $transferStartingElementPointToTextPoint(anchor, focus, format3, style);
        } else if (!isBefore && focus.type === "element") {
          $transferStartingElementPointToTextPoint(focus, anchor, format3, style);
        }
        const selectedNodes = this.getNodes();
        const selectedNodesLength = selectedNodes.length;
        const firstPoint = isBefore ? anchor : focus;
        const endPoint = isBefore ? focus : anchor;
        const startOffset = firstPoint.offset;
        const endOffset = endPoint.offset;
        let firstNode = selectedNodes[0];
        if (!$isTextNode(firstNode)) {
          {
            throw Error(`insertText: first node is not a text node`);
          }
        }
        const firstNodeText = firstNode.getTextContent();
        const firstNodeTextLength = firstNodeText.length;
        const firstNodeParent = firstNode.getParentOrThrow();
        const lastIndex = selectedNodesLength - 1;
        let lastNode = selectedNodes[lastIndex];
        if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {
          let nextSibling = firstNode.getNextSibling();
          if (!$isTextNode(nextSibling) || $isTokenOrSegmented(nextSibling)) {
            nextSibling = $createTextNode();
            nextSibling.setFormat(format3);
            if (!firstNodeParent.canInsertTextAfter()) {
              firstNodeParent.insertAfter(nextSibling);
            } else {
              firstNode.insertAfter(nextSibling);
            }
          }
          nextSibling.select(0, 0);
          firstNode = nextSibling;
          if (text !== "") {
            this.insertText(text);
            return;
          }
        } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {
          let prevSibling = firstNode.getPreviousSibling();
          if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {
            prevSibling = $createTextNode();
            prevSibling.setFormat(format3);
            if (!firstNodeParent.canInsertTextBefore()) {
              firstNodeParent.insertBefore(prevSibling);
            } else {
              firstNode.insertBefore(prevSibling);
            }
          }
          prevSibling.select();
          firstNode = prevSibling;
          if (text !== "") {
            this.insertText(text);
            return;
          }
        } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {
          const textNode = $createTextNode(firstNode.getTextContent());
          textNode.setFormat(format3);
          firstNode.replace(textNode);
          firstNode = textNode;
        } else if (!this.isCollapsed() && text !== "") {
          const lastNodeParent = lastNode.getParent();
          if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {
            this.insertText("");
            normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);
            this.insertText(text);
            return;
          }
        }
        if (selectedNodesLength === 1) {
          if (firstNode.isToken()) {
            const textNode = $createTextNode(text);
            textNode.select();
            firstNode.replace(textNode);
            return;
          }
          const firstNodeFormat = firstNode.getFormat();
          const firstNodeStyle = firstNode.getStyle();
          if (startOffset === endOffset && (firstNodeFormat !== format3 || firstNodeStyle !== style)) {
            if (firstNode.getTextContent() === "") {
              firstNode.setFormat(format3);
              firstNode.setStyle(style);
            } else {
              const textNode = $createTextNode(text);
              textNode.setFormat(format3);
              textNode.setStyle(style);
              textNode.select();
              if (startOffset === 0) {
                firstNode.insertBefore(textNode, false);
              } else {
                const [targetNode] = firstNode.splitText(startOffset);
                targetNode.insertAfter(textNode, false);
              }
              if (textNode.isComposing() && this.anchor.type === "text") {
                this.anchor.offset -= text.length;
              }
              return;
            }
          }
          const delCount = endOffset - startOffset;
          firstNode = firstNode.spliceText(startOffset, delCount, text, true);
          if (firstNode.getTextContent() === "") {
            firstNode.remove();
          } else if (this.anchor.type === "text") {
            if (firstNode.isComposing()) {
              this.anchor.offset -= text.length;
            } else {
              this.format = firstNodeFormat;
              this.style = firstNodeStyle;
            }
          }
        } else {
          const markedNodeKeysForKeep = /* @__PURE__ */ new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);
          const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();
          let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();
          let lastElementChild = lastNode;
          if (!firstElement.is(lastElement) && lastElement.isInline()) {
            do {
              lastElementChild = lastElement;
              lastElement = lastElement.getParentOrThrow();
            } while (lastElement.isInline());
          }
          if (endPoint.type === "text" && (endOffset !== 0 || lastNode.getTextContent() === "") || endPoint.type === "element" && lastNode.getIndexWithinParent() < endOffset) {
            if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {
              if (lastNode.isSegmented()) {
                const textNode = $createTextNode(lastNode.getTextContent());
                lastNode.replace(textNode);
                lastNode = textNode;
              }
              lastNode = lastNode.spliceText(0, endOffset, "");
              markedNodeKeysForKeep.add(lastNode.__key);
            } else {
              const lastNodeParent = lastNode.getParentOrThrow();
              if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {
                lastNodeParent.remove();
              } else {
                lastNode.remove();
              }
            }
          } else {
            markedNodeKeysForKeep.add(lastNode.__key);
          }
          const lastNodeChildren = lastElement.getChildren();
          const selectedNodesSet = new Set(selectedNodes);
          const firstAndLastElementsAreEqual = firstElement.is(lastElement);
          const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;
          for (let i = lastNodeChildren.length - 1; i >= 0; i--) {
            const lastNodeChild = lastNodeChildren[i];
            if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {
              break;
            }
            if (lastNodeChild.isAttached()) {
              if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {
                if (!firstAndLastElementsAreEqual) {
                  insertionTarget.insertAfter(lastNodeChild, false);
                }
              } else {
                lastNodeChild.remove();
              }
            }
          }
          if (!firstAndLastElementsAreEqual) {
            let parent = lastElement;
            let lastRemovedParent = null;
            while (parent !== null) {
              const children = parent.getChildren();
              const childrenLength = children.length;
              if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {
                markedNodeKeysForKeep.delete(parent.__key);
                lastRemovedParent = parent;
              }
              parent = parent.getParent();
            }
          }
          if (!firstNode.isToken()) {
            firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);
            if (firstNode.getTextContent() === "") {
              firstNode.remove();
            } else if (firstNode.isComposing() && this.anchor.type === "text") {
              this.anchor.offset -= text.length;
            }
          } else if (startOffset === firstNodeTextLength) {
            firstNode.select();
          } else {
            const textNode = $createTextNode(text);
            textNode.select();
            firstNode.replace(textNode);
          }
          for (let i = 1; i < selectedNodesLength; i++) {
            const selectedNode = selectedNodes[i];
            const key = selectedNode.__key;
            if (!markedNodeKeysForKeep.has(key)) {
              selectedNode.remove();
            }
          }
        }
      }
      removeText() {
        this.insertText("");
      }
      formatText(formatType) {
        if (this.isCollapsed()) {
          this.toggleFormat(formatType);
          $setCompositionKey(null);
          return;
        }
        const selectedNodes = this.getNodes();
        const selectedTextNodes = [];
        for (const selectedNode of selectedNodes) {
          if ($isTextNode(selectedNode)) {
            selectedTextNodes.push(selectedNode);
          }
        }
        const selectedTextNodesLength = selectedTextNodes.length;
        if (selectedTextNodesLength === 0) {
          this.toggleFormat(formatType);
          $setCompositionKey(null);
          return;
        }
        const anchor = this.anchor;
        const focus = this.focus;
        const isBackward = this.isBackward();
        const startPoint = isBackward ? focus : anchor;
        const endPoint = isBackward ? anchor : focus;
        let firstIndex = 0;
        let firstNode = selectedTextNodes[0];
        let startOffset = startPoint.type === "element" ? 0 : startPoint.offset;
        if (startPoint.type === "text" && startOffset === firstNode.getTextContentSize()) {
          firstIndex = 1;
          firstNode = selectedTextNodes[1];
          startOffset = 0;
        }
        if (firstNode == null) {
          return;
        }
        const firstNextFormat = firstNode.getFormatFlags(formatType, null);
        const lastIndex = selectedTextNodesLength - 1;
        let lastNode = selectedTextNodes[lastIndex];
        const endOffset = endPoint.type === "text" ? endPoint.offset : lastNode.getTextContentSize();
        if (firstNode.is(lastNode)) {
          if (startOffset === endOffset) {
            return;
          }
          if (startOffset === 0 && endOffset === firstNode.getTextContentSize()) {
            firstNode.setFormat(firstNextFormat);
          } else {
            const splitNodes = firstNode.splitText(startOffset, endOffset);
            const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];
            replacement.setFormat(firstNextFormat);
            if (startPoint.type === "text") {
              startPoint.set(replacement.__key, 0, "text");
            }
            if (endPoint.type === "text") {
              endPoint.set(replacement.__key, endOffset - startOffset, "text");
            }
          }
          this.format = firstNextFormat;
          return;
        }
        if (startOffset !== 0) {
          [, firstNode] = firstNode.splitText(startOffset);
          startOffset = 0;
        }
        firstNode.setFormat(firstNextFormat);
        const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);
        if (endOffset > 0) {
          if (endOffset !== lastNode.getTextContentSize()) {
            [lastNode] = lastNode.splitText(endOffset);
          }
          lastNode.setFormat(lastNextFormat);
        }
        for (let i = firstIndex + 1; i < lastIndex; i++) {
          const textNode = selectedTextNodes[i];
          if (!textNode.isToken()) {
            const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);
            textNode.setFormat(nextFormat);
          }
        }
        if (startPoint.type === "text") {
          startPoint.set(firstNode.__key, startOffset, "text");
        }
        if (endPoint.type === "text") {
          endPoint.set(lastNode.__key, endOffset, "text");
        }
        this.format = firstNextFormat | lastNextFormat;
      }
      insertNodes(nodes, selectStart) {
        if (!this.isCollapsed()) {
          const selectionEnd = this.isBackward() ? this.anchor : this.focus;
          const nextSibling = selectionEnd.getNode().getNextSibling();
          const nextSiblingKey = nextSibling ? nextSibling.getKey() : null;
          const prevSibling = selectionEnd.getNode().getPreviousSibling();
          const prevSiblingKey = prevSibling ? prevSibling.getKey() : null;
          this.removeText();
          if (this.isCollapsed() && this.focus.type === "element") {
            let textNode;
            if (this.focus.key === nextSiblingKey && this.focus.offset === 0) {
              textNode = $createTextNode();
              this.focus.getNode().insertBefore(textNode);
            } else if (this.focus.key === prevSiblingKey && this.focus.offset === this.focus.getNode().getChildrenSize()) {
              textNode = $createTextNode();
              this.focus.getNode().insertAfter(textNode);
            }
            if (textNode) {
              this.focus.set(textNode.__key, 0, "text");
              this.anchor.set(textNode.__key, 0, "text");
            }
          }
        }
        const anchor = this.anchor;
        const anchorOffset = anchor.offset;
        const anchorNode = anchor.getNode();
        let target = anchorNode;
        if (anchor.type === "element") {
          const element = anchor.getNode();
          const placementNode = element.getChildAtIndex(anchorOffset - 1);
          if (placementNode === null) {
            target = element;
          } else {
            target = placementNode;
          }
        }
        const siblings = [];
        const nextSiblings = anchorNode.getNextSiblings();
        const topLevelElement = $isRootOrShadowRoot(anchorNode) ? null : anchorNode.getTopLevelElementOrThrow();
        if ($isTextNode(anchorNode)) {
          const textContent = anchorNode.getTextContent();
          const textContentLength = textContent.length;
          if (anchorOffset === 0 && textContentLength !== 0) {
            const prevSibling = anchorNode.getPreviousSibling();
            if (prevSibling !== null) {
              target = prevSibling;
            } else {
              target = anchorNode.getParentOrThrow();
            }
            siblings.push(anchorNode);
          } else if (anchorOffset === textContentLength) {
            target = anchorNode;
          } else if (anchorNode.isToken()) {
            return false;
          } else {
            let danglingText;
            [target, danglingText] = anchorNode.splitText(anchorOffset);
            siblings.push(danglingText);
          }
        }
        const startingNode = target;
        siblings.push(...nextSiblings);
        const firstNode = nodes[0];
        let didReplaceOrMerge = false;
        let lastNode = null;
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (!$isRootOrShadowRoot(target) && !$isDecoratorNode(target) && $isElementNode(node) && !node.isInline()) {
            if (node.is(firstNode)) {
              if ($isElementNode(target) && target.isEmpty() && target.canReplaceWith(node)) {
                target.replace(node);
                target = node;
                didReplaceOrMerge = true;
                continue;
              }
              const firstDescendant = node.getFirstDescendant();
              if ($isLeafNode(firstDescendant)) {
                let element = firstDescendant.getParentOrThrow();
                while (element.isInline()) {
                  element = element.getParentOrThrow();
                }
                const children = element.getChildren();
                const childrenLength = children.length;
                if ($isElementNode(target)) {
                  let firstChild = target.getFirstChild();
                  for (let s2 = 0; s2 < childrenLength; s2++) {
                    const child = children[s2];
                    if (firstChild === null) {
                      target.append(child);
                    } else {
                      firstChild.insertAfter(child);
                    }
                    firstChild = child;
                  }
                } else {
                  for (let s2 = childrenLength - 1; s2 >= 0; s2--) {
                    target.insertAfter(children[s2]);
                  }
                  target = target.getParentOrThrow();
                }
                lastNode = children[childrenLength - 1];
                element.remove();
                didReplaceOrMerge = true;
                if (element.is(node)) {
                  continue;
                }
              }
            }
            if ($isTextNode(target)) {
              if (topLevelElement === null) {
                {
                  throw Error(`insertNode: topLevelElement is root node`);
                }
              }
              target = topLevelElement;
            }
          } else if (didReplaceOrMerge && !$isDecoratorNode(node) && $isRootOrShadowRoot(target.getParent())) {
            {
              throw Error(`insertNodes: cannot insert a non-element into a root node`);
            }
          }
          didReplaceOrMerge = false;
          if ($isElementNode(target) && !target.isInline()) {
            lastNode = node;
            if ($isDecoratorNode(node) && !node.isInline()) {
              target = target.insertAfter(node, false);
            } else if (!$isElementNode(node)) {
              const firstChild = target.getFirstChild();
              if (firstChild !== null) {
                firstChild.insertBefore(node);
              } else {
                target.append(node);
              }
              target = node;
            } else {
              if (!node.canBeEmpty() && node.isEmpty()) {
                continue;
              }
              if ($isRootNode(target)) {
                const placementNode = target.getChildAtIndex(anchorOffset);
                if (placementNode !== null) {
                  placementNode.insertBefore(node);
                } else {
                  target.append(node);
                }
                target = node;
              } else {
                target = target.insertAfter(node, false);
              }
            }
          } else if (!$isElementNode(node) || $isElementNode(node) && node.isInline() || $isDecoratorNode(target) && !target.isInline()) {
            lastNode = node;
            if ($isRangeSelection2(this) && $isDecoratorNode(node) && ($isElementNode(target) || $isTextNode(target)) && !node.isInline()) {
              let splitNode;
              let splitOffset;
              if ($isTextNode(target)) {
                splitNode = target.getParentOrThrow();
                const [textNode] = target.splitText(anchorOffset);
                splitOffset = textNode.getIndexWithinParent() + 1;
              } else {
                splitNode = target;
                splitOffset = anchorOffset;
              }
              const [, rightTree] = $splitNode(splitNode, splitOffset);
              target = rightTree.insertBefore(node);
            } else {
              target = target.insertAfter(node, false);
            }
          } else {
            const nextTarget = target.getParentOrThrow();
            if ($isLineBreakNode(target)) {
              target.remove();
            }
            target = nextTarget;
            i--;
            continue;
          }
        }
        if (selectStart) {
          if ($isTextNode(startingNode)) {
            startingNode.select();
          } else {
            const prevSibling = target.getPreviousSibling();
            if ($isTextNode(prevSibling)) {
              prevSibling.select();
            } else {
              const index2 = target.getIndexWithinParent();
              target.getParentOrThrow().select(index2, index2);
            }
          }
        }
        if ($isElementNode(target)) {
          const lastChild = $isTextNode(lastNode) ? lastNode : $isElementNode(lastNode) && lastNode.isInline() ? lastNode.getLastDescendant() : target.getLastDescendant();
          if (!selectStart) {
            if (lastChild === null) {
              target.select();
            } else if ($isTextNode(lastChild)) {
              if (lastChild.getTextContent() === "") {
                lastChild.selectPrevious();
              } else {
                lastChild.select();
              }
            } else {
              lastChild.selectNext();
            }
          }
          if (siblings.length !== 0) {
            const originalTarget = target;
            for (let i = siblings.length - 1; i >= 0; i--) {
              const sibling = siblings[i];
              const prevParent = sibling.getParentOrThrow();
              if ($isElementNode(target) && !$isBlockElementNode(sibling) && !($isDecoratorNode(sibling) && // Note: We are only looking for decorators that are inline and not isolated.
              (!sibling.isInline() || sibling.isIsolated()))) {
                if (originalTarget === target) {
                  target.append(sibling);
                } else {
                  target.insertBefore(sibling);
                }
                target = sibling;
              } else if (!$isElementNode(target) && !$isBlockElementNode(sibling)) {
                target.insertBefore(sibling);
                target = sibling;
              } else {
                if ($isElementNode(sibling) && !sibling.canInsertAfter(target)) {
                  const prevParentClone = prevParent.constructor.clone(prevParent);
                  if (!$isElementNode(prevParentClone)) {
                    {
                      throw Error(`insertNodes: cloned parent clone is not an element`);
                    }
                  }
                  prevParentClone.append(sibling);
                  target.insertAfter(prevParentClone);
                } else {
                  target.insertAfter(sibling);
                }
              }
              if (prevParent.isEmpty() && !prevParent.canBeEmpty()) {
                prevParent.remove();
              }
            }
          }
        } else if (!selectStart) {
          if ($isTextNode(target)) {
            target.select();
          } else {
            const element = target.getParentOrThrow();
            const index2 = target.getIndexWithinParent() + 1;
            element.select(index2, index2);
          }
        }
        return true;
      }
      insertParagraph() {
        if (!this.isCollapsed()) {
          this.removeText();
        }
        const anchor = this.anchor;
        const anchorOffset = anchor.offset;
        let currentElement;
        let nodesToMove = [];
        let siblingsToMove = [];
        if (anchor.type === "text") {
          const anchorNode = anchor.getNode();
          nodesToMove = anchorNode.getNextSiblings().reverse();
          currentElement = anchorNode.getParentOrThrow();
          const isInline = currentElement.isInline();
          const textContentLength = isInline ? currentElement.getTextContentSize() : anchorNode.getTextContentSize();
          if (anchorOffset === 0) {
            nodesToMove.push(anchorNode);
          } else {
            if (isInline) {
              siblingsToMove = currentElement.getNextSiblings();
            }
            if (anchorOffset !== textContentLength) {
              if (!isInline || anchorOffset !== anchorNode.getTextContentSize()) {
                const [, splitNode] = anchorNode.splitText(anchorOffset);
                nodesToMove.push(splitNode);
              }
            }
          }
        } else {
          currentElement = anchor.getNode();
          if ($isRootOrShadowRoot(currentElement)) {
            const paragraph = $createParagraphNode2();
            const child = currentElement.getChildAtIndex(anchorOffset);
            paragraph.select();
            if (child !== null) {
              child.insertBefore(paragraph, false);
            } else {
              currentElement.append(paragraph);
            }
            return;
          }
          nodesToMove = currentElement.getChildren().slice(anchorOffset).reverse();
        }
        const nodesToMoveLength = nodesToMove.length;
        if (anchorOffset === 0 && nodesToMoveLength > 0 && currentElement.isInline()) {
          const parent = currentElement.getParentOrThrow();
          const newElement2 = parent.insertNewAfter(this, false);
          if ($isElementNode(newElement2)) {
            const children = parent.getChildren();
            for (let i = 0; i < children.length; i++) {
              newElement2.append(children[i]);
            }
          }
          return;
        }
        const newElement = currentElement.insertNewAfter(this, false);
        if (newElement === null) {
          this.insertLineBreak();
        } else if ($isElementNode(newElement)) {
          const currentElementFirstChild = currentElement.getFirstChild();
          const isBeginning = anchorOffset === 0 && (currentElement.is(anchor.getNode()) || currentElementFirstChild && currentElementFirstChild.is(anchor.getNode()));
          if (isBeginning && nodesToMoveLength > 0) {
            currentElement.insertBefore(newElement);
            return;
          }
          let firstChild = null;
          const siblingsToMoveLength = siblingsToMove.length;
          const parent = newElement.getParentOrThrow();
          if (siblingsToMoveLength > 0) {
            for (let i = 0; i < siblingsToMoveLength; i++) {
              const siblingToMove = siblingsToMove[i];
              parent.append(siblingToMove);
            }
          }
          if (nodesToMoveLength !== 0) {
            for (let i = 0; i < nodesToMoveLength; i++) {
              const nodeToMove = nodesToMove[i];
              if (firstChild === null) {
                newElement.append(nodeToMove);
              } else {
                firstChild.insertBefore(nodeToMove);
              }
              firstChild = nodeToMove;
            }
          }
          if (!newElement.canBeEmpty() && newElement.getChildrenSize() === 0) {
            newElement.selectPrevious();
            newElement.remove();
          } else {
            newElement.selectStart();
          }
        }
      }
      insertLineBreak(selectStart) {
        const lineBreakNode = $createLineBreakNode();
        const anchor = this.anchor;
        if (anchor.type === "element") {
          const element = anchor.getNode();
          if ($isRootNode(element)) {
            this.insertParagraph();
          }
        }
        if (selectStart) {
          this.insertNodes([lineBreakNode], true);
        } else {
          if (this.insertNodes([lineBreakNode])) {
            lineBreakNode.selectNext(0, 0);
          }
        }
      }
      getCharacterOffsets() {
        return getCharacterOffsets(this);
      }
      extract() {
        const selectedNodes = this.getNodes();
        const selectedNodesLength = selectedNodes.length;
        const lastIndex = selectedNodesLength - 1;
        const anchor = this.anchor;
        const focus = this.focus;
        let firstNode = selectedNodes[0];
        let lastNode = selectedNodes[lastIndex];
        const [anchorOffset, focusOffset] = getCharacterOffsets(this);
        if (selectedNodesLength === 0) {
          return [];
        } else if (selectedNodesLength === 1) {
          if ($isTextNode(firstNode) && !this.isCollapsed()) {
            const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;
            const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;
            const splitNodes = firstNode.splitText(startOffset, endOffset);
            const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];
            return node != null ? [node] : [];
          }
          return [firstNode];
        }
        const isBefore = anchor.isBefore(focus);
        if ($isTextNode(firstNode)) {
          const startOffset = isBefore ? anchorOffset : focusOffset;
          if (startOffset === firstNode.getTextContentSize()) {
            selectedNodes.shift();
          } else if (startOffset !== 0) {
            [, firstNode] = firstNode.splitText(startOffset);
            selectedNodes[0] = firstNode;
          }
        }
        if ($isTextNode(lastNode)) {
          const lastNodeText = lastNode.getTextContent();
          const lastNodeTextLength = lastNodeText.length;
          const endOffset = isBefore ? focusOffset : anchorOffset;
          if (endOffset === 0) {
            selectedNodes.pop();
          } else if (endOffset !== lastNodeTextLength) {
            [lastNode] = lastNode.splitText(endOffset);
            selectedNodes[lastIndex] = lastNode;
          }
        }
        return selectedNodes;
      }
      modify(alter, isBackward, granularity) {
        const focus = this.focus;
        const anchor = this.anchor;
        const collapse = alter === "move";
        const possibleNode = $getAdjacentNode(focus, isBackward);
        if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {
          if (collapse && possibleNode.isKeyboardSelectable()) {
            const nodeSelection = $createNodeSelection();
            nodeSelection.add(possibleNode.__key);
            $setSelection2(nodeSelection);
            return;
          }
          const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();
          if (!$isTextNode(sibling)) {
            const parent = possibleNode.getParentOrThrow();
            let offset;
            let elementKey;
            if ($isElementNode(sibling)) {
              elementKey = sibling.__key;
              offset = isBackward ? sibling.getChildrenSize() : 0;
            } else {
              offset = possibleNode.getIndexWithinParent();
              elementKey = parent.__key;
              if (!isBackward) {
                offset++;
              }
            }
            focus.set(elementKey, offset, "element");
            if (collapse) {
              anchor.set(elementKey, offset, "element");
            }
            return;
          } else {
            const siblingKey = sibling.__key;
            const offset = isBackward ? sibling.getTextContent().length : 0;
            focus.set(siblingKey, offset, "text");
            if (collapse) {
              anchor.set(siblingKey, offset, "text");
            }
            return;
          }
        }
        const editor = getActiveEditor();
        const domSelection = getDOMSelection(editor._window);
        if (!domSelection) {
          return;
        }
        const blockCursorElement = editor._blockCursorElement;
        const rootElement = editor._rootElement;
        if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {
          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
        }
        moveNativeSelection(domSelection, alter, isBackward ? "backward" : "forward", granularity);
        if (domSelection.rangeCount > 0) {
          const range2 = domSelection.getRangeAt(0);
          const anchorNode = this.anchor.getNode();
          const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);
          this.applyDOMRange(range2);
          this.dirty = true;
          if (!collapse) {
            const nodes = this.getNodes();
            const validNodes = [];
            let shrinkSelection = false;
            for (let i = 0; i < nodes.length; i++) {
              const nextNode = nodes[i];
              if ($hasAncestor(nextNode, root)) {
                validNodes.push(nextNode);
              } else {
                shrinkSelection = true;
              }
            }
            if (shrinkSelection && validNodes.length > 0) {
              if (isBackward) {
                const firstValidNode = validNodes[0];
                if ($isElementNode(firstValidNode)) {
                  firstValidNode.selectStart();
                } else {
                  firstValidNode.getParentOrThrow().selectStart();
                }
              } else {
                const lastValidNode = validNodes[validNodes.length - 1];
                if ($isElementNode(lastValidNode)) {
                  lastValidNode.selectEnd();
                } else {
                  lastValidNode.getParentOrThrow().selectEnd();
                }
              }
            }
            if (domSelection.anchorNode !== range2.startContainer || domSelection.anchorOffset !== range2.startOffset) {
              $swapPoints(this);
            }
          }
        }
      }
      deleteCharacter(isBackward) {
        if (this.isCollapsed()) {
          const anchor = this.anchor;
          const focus = this.focus;
          let anchorNode = anchor.getNode();
          if (!isBackward && // Delete forward handle case
          (anchor.type === "element" && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === "text" && anchor.offset === anchorNode.getTextContentSize())) {
            const parent = anchorNode.getParent();
            const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());
            if ($isElementNode(nextSibling) && !nextSibling.canExtractContents()) {
              return;
            }
          }
          const possibleNode = $getAdjacentNode(focus, isBackward);
          if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {
            if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {
              anchorNode.remove();
              const nodeSelection = $createNodeSelection();
              nodeSelection.add(possibleNode.__key);
              $setSelection2(nodeSelection);
            } else {
              possibleNode.remove();
            }
            return;
          }
          this.modify("extend", isBackward, "character");
          if (!this.isCollapsed()) {
            const focusNode = focus.type === "text" ? focus.getNode() : null;
            anchorNode = anchor.type === "text" ? anchor.getNode() : null;
            if (focusNode !== null && focusNode.isSegmented()) {
              const offset = focus.offset;
              const textContentSize = focusNode.getTextContentSize();
              if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {
                $removeSegment(focusNode, isBackward, offset);
                return;
              }
            } else if (anchorNode !== null && anchorNode.isSegmented()) {
              const offset = anchor.offset;
              const textContentSize = anchorNode.getTextContentSize();
              if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {
                $removeSegment(anchorNode, isBackward, offset);
                return;
              }
            }
            $updateCaretSelectionForUnicodeCharacter(this, isBackward);
          } else if (isBackward && anchor.offset === 0) {
            const element = anchor.type === "element" ? anchor.getNode() : anchor.getNode().getParentOrThrow();
            if (element.collapseAtStart(this)) {
              return;
            }
          }
        }
        const wasCollapsed = this.isCollapsed();
        this.removeText();
        if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0) {
          const anchorNode = this.anchor.getNode();
          if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {
            anchorNode.collapseAtStart(this);
          }
        }
      }
      deleteLine(isBackward) {
        if (this.isCollapsed()) {
          if (this.anchor.type === "text") {
            this.modify("extend", isBackward, "lineboundary");
          }
          const endPoint = isBackward ? this.focus : this.anchor;
          if (endPoint.offset === 0) {
            this.modify("extend", isBackward, "character");
          }
        }
        this.removeText();
      }
      deleteWord(isBackward) {
        if (this.isCollapsed()) {
          this.modify("extend", isBackward, "word");
        }
        this.removeText();
      }
    };
    function $isNodeSelection(x4) {
      return x4 instanceof NodeSelection;
    }
    function getCharacterOffset(point6) {
      const offset = point6.offset;
      if (point6.type === "text") {
        return offset;
      }
      const parent = point6.getNode();
      return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;
    }
    function getCharacterOffsets(selection) {
      const anchor = selection.anchor;
      const focus = selection.focus;
      if (anchor.type === "element" && focus.type === "element" && anchor.key === focus.key && anchor.offset === focus.offset) {
        return [0, 0];
      }
      return [getCharacterOffset(anchor), getCharacterOffset(focus)];
    }
    function $swapPoints(selection) {
      const focus = selection.focus;
      const anchor = selection.anchor;
      const anchorKey = anchor.key;
      const anchorOffset = anchor.offset;
      const anchorType = anchor.type;
      $setPointValues(anchor, focus.key, focus.offset, focus.type);
      $setPointValues(focus, anchorKey, anchorOffset, anchorType);
      selection._cachedNodes = null;
    }
    function moveNativeSelection(domSelection, alter, direction, granularity) {
      domSelection.modify(alter, direction, granularity);
    }
    function $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {
      const anchor = selection.anchor;
      const focus = selection.focus;
      const anchorNode = anchor.getNode();
      const focusNode = focus.getNode();
      if (anchorNode === focusNode && anchor.type === "text" && focus.type === "text") {
        const anchorOffset = anchor.offset;
        const focusOffset = focus.offset;
        const isBefore = anchorOffset < focusOffset;
        const startOffset = isBefore ? anchorOffset : focusOffset;
        const endOffset = isBefore ? focusOffset : anchorOffset;
        const characterOffset = endOffset - 1;
        if (startOffset !== characterOffset) {
          const text = anchorNode.getTextContent().slice(startOffset, endOffset);
          if (!doesContainGrapheme(text)) {
            if (isBackward) {
              focus.offset = characterOffset;
            } else {
              anchor.offset = characterOffset;
            }
          }
        }
      }
    }
    function $removeSegment(node, isBackward, offset) {
      const textNode = node;
      const textContent = textNode.getTextContent();
      const split = textContent.split(/(?=\s)/g);
      const splitLength = split.length;
      let segmentOffset = 0;
      let restoreOffset = 0;
      for (let i = 0; i < splitLength; i++) {
        const text = split[i];
        const isLast = i === splitLength - 1;
        restoreOffset = segmentOffset;
        segmentOffset += text.length;
        if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {
          split.splice(i, 1);
          if (isLast) {
            restoreOffset = void 0;
          }
          break;
        }
      }
      const nextTextContent = split.join("").trim();
      if (nextTextContent === "") {
        textNode.remove();
      } else {
        textNode.setTextContent(nextTextContent);
        textNode.select(restoreOffset, restoreOffset);
      }
    }
    function shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {
      const parent = resolvedElement.getParent();
      return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();
    }
    function internalResolveSelectionPoint(dom, offset, lastPoint, editor) {
      let resolvedOffset = offset;
      let resolvedNode;
      if (dom.nodeType === DOM_ELEMENT_TYPE) {
        let moveSelectionToEnd = false;
        const childNodes = dom.childNodes;
        const childNodesLength = childNodes.length;
        if (resolvedOffset === childNodesLength) {
          moveSelectionToEnd = true;
          resolvedOffset = childNodesLength - 1;
        }
        let childDOM = childNodes[resolvedOffset];
        let hasBlockCursor = false;
        if (childDOM === editor._blockCursorElement) {
          childDOM = childNodes[resolvedOffset + 1];
          hasBlockCursor = true;
        } else if (editor._blockCursorElement !== null) {
          resolvedOffset--;
        }
        resolvedNode = getNodeFromDOM(childDOM);
        if ($isTextNode(resolvedNode)) {
          resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);
        } else {
          let resolvedElement = getNodeFromDOM(dom);
          if (resolvedElement === null) {
            return null;
          }
          if ($isElementNode(resolvedElement)) {
            let child = resolvedElement.getChildAtIndex(resolvedOffset);
            if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {
              const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();
              if (descendant === null) {
                resolvedElement = child;
                resolvedOffset = 0;
              } else {
                child = descendant;
                resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();
              }
            }
            if ($isTextNode(child)) {
              resolvedNode = child;
              resolvedElement = null;
              resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);
            } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {
              resolvedOffset++;
            }
          } else {
            const index2 = resolvedElement.getIndexWithinParent();
            if (offset === 0 && $isDecoratorNode(resolvedElement) && getNodeFromDOM(dom) === resolvedElement) {
              resolvedOffset = index2;
            } else {
              resolvedOffset = index2 + 1;
            }
            resolvedElement = resolvedElement.getParentOrThrow();
          }
          if ($isElementNode(resolvedElement)) {
            return $createPoint(resolvedElement.__key, resolvedOffset, "element");
          }
        }
      } else {
        resolvedNode = getNodeFromDOM(dom);
      }
      if (!$isTextNode(resolvedNode)) {
        return null;
      }
      return $createPoint(resolvedNode.__key, resolvedOffset, "text");
    }
    function resolveSelectionPointOnBoundary(point6, isBackward, isCollapsed) {
      const offset = point6.offset;
      const node = point6.getNode();
      if (offset === 0) {
        const prevSibling = node.getPreviousSibling();
        const parent = node.getParent();
        if (!isBackward) {
          if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {
            point6.key = prevSibling.__key;
            point6.offset = prevSibling.getChildrenSize();
            point6.type = "element";
          } else if ($isTextNode(prevSibling)) {
            point6.key = prevSibling.__key;
            point6.offset = prevSibling.getTextContent().length;
          }
        } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {
          const parentSibling = parent.getPreviousSibling();
          if ($isTextNode(parentSibling)) {
            point6.key = parentSibling.__key;
            point6.offset = parentSibling.getTextContent().length;
          }
        }
      } else if (offset === node.getTextContent().length) {
        const nextSibling = node.getNextSibling();
        const parent = node.getParent();
        if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {
          point6.key = nextSibling.__key;
          point6.offset = 0;
          point6.type = "element";
        } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {
          const parentSibling = parent.getNextSibling();
          if ($isTextNode(parentSibling)) {
            point6.key = parentSibling.__key;
            point6.offset = 0;
          }
        }
      }
    }
    function normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {
      if (anchor.type === "text" && focus.type === "text") {
        const isBackward = anchor.isBefore(focus);
        const isCollapsed = anchor.is(focus);
        resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);
        resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);
        if (isCollapsed) {
          focus.key = anchor.key;
          focus.offset = anchor.offset;
          focus.type = anchor.type;
        }
        const editor = getActiveEditor();
        if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection2(lastSelection)) {
          const lastAnchor = lastSelection.anchor;
          const lastFocus = lastSelection.focus;
          $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);
          $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);
        }
      }
    }
    function internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {
      if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
        return null;
      }
      const resolvedAnchorPoint = internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection2(lastSelection) ? lastSelection.anchor : null, editor);
      if (resolvedAnchorPoint === null) {
        return null;
      }
      const resolvedFocusPoint = internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection2(lastSelection) ? lastSelection.focus : null, editor);
      if (resolvedFocusPoint === null) {
        return null;
      }
      if (resolvedAnchorPoint.type === "element" && resolvedFocusPoint.type === "element") {
        const anchorNode = getNodeFromDOM(anchorDOM);
        const focusNode = getNodeFromDOM(focusDOM);
        if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {
          return null;
        }
      }
      normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);
      return [resolvedAnchorPoint, resolvedFocusPoint];
    }
    function $isBlockElementNode(node) {
      return $isElementNode(node) && !node.isInline();
    }
    function internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {
      const editorState = getActiveEditorState();
      const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, "");
      selection.dirty = true;
      editorState._selection = selection;
      return selection;
    }
    function $createRangeSelection() {
      const anchor = $createPoint("root", 0, "element");
      const focus = $createPoint("root", 0, "element");
      return new RangeSelection(anchor, focus, 0, "");
    }
    function $createNodeSelection() {
      return new NodeSelection(/* @__PURE__ */ new Set());
    }
    function DEPRECATED_$createGridSelection() {
      const anchor = $createPoint("root", 0, "element");
      const focus = $createPoint("root", 0, "element");
      return new GridSelection("root", anchor, focus);
    }
    function internalCreateSelection(editor) {
      const currentEditorState = editor.getEditorState();
      const lastSelection = currentEditorState._selection;
      const domSelection = getDOMSelection(editor._window);
      if ($isNodeSelection(lastSelection) || DEPRECATED_$isGridSelection(lastSelection)) {
        return lastSelection.clone();
      }
      return internalCreateRangeSelection(lastSelection, domSelection, editor);
    }
    function internalCreateRangeSelection(lastSelection, domSelection, editor) {
      const windowObj = editor._window;
      if (windowObj === null) {
        return null;
      }
      const windowEvent = windowObj.event;
      const eventType = windowEvent ? windowEvent.type : void 0;
      const isSelectionChange = eventType === "selectionchange";
      const useDOMSelection = !getIsProcesssingMutations() && (isSelectionChange || eventType === "beforeinput" || eventType === "compositionstart" || eventType === "compositionend" || eventType === "click" && windowEvent && windowEvent.detail === 3 || eventType === "drop" || eventType === void 0);
      let anchorDOM, focusDOM, anchorOffset, focusOffset;
      if (!$isRangeSelection2(lastSelection) || useDOMSelection) {
        if (domSelection === null) {
          return null;
        }
        anchorDOM = domSelection.anchorNode;
        focusDOM = domSelection.focusNode;
        anchorOffset = domSelection.anchorOffset;
        focusOffset = domSelection.focusOffset;
        if (isSelectionChange && $isRangeSelection2(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
          return lastSelection.clone();
        }
      } else {
        return lastSelection.clone();
      }
      const resolvedSelectionPoints = internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);
      if (resolvedSelectionPoints === null) {
        return null;
      }
      const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;
      return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection2(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection2(lastSelection) ? "" : lastSelection.style);
    }
    function $getSelection2() {
      const editorState = getActiveEditorState();
      return editorState._selection;
    }
    function $getPreviousSelection() {
      const editor = getActiveEditor();
      return editor._editorState._selection;
    }
    function $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {
      const anchor = selection.anchor;
      const focus = selection.focus;
      const anchorNode = anchor.getNode();
      const focusNode = focus.getNode();
      if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {
        return;
      }
      const parentKey = parentNode.__key;
      if (selection.isCollapsed()) {
        const selectionOffset = anchor.offset;
        if (nodeOffset <= selectionOffset) {
          const newSelectionOffset = Math.max(0, selectionOffset + times);
          anchor.set(parentKey, newSelectionOffset, "element");
          focus.set(parentKey, newSelectionOffset, "element");
          $updateSelectionResolveTextNodes(selection);
        }
        return;
      }
      const isBackward = selection.isBackward();
      const firstPoint = isBackward ? focus : anchor;
      const firstPointNode = firstPoint.getNode();
      const lastPoint = isBackward ? anchor : focus;
      const lastPointNode = lastPoint.getNode();
      if (parentNode.is(firstPointNode)) {
        const firstPointOffset = firstPoint.offset;
        if (nodeOffset <= firstPointOffset) {
          firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), "element");
        }
      }
      if (parentNode.is(lastPointNode)) {
        const lastPointOffset = lastPoint.offset;
        if (nodeOffset <= lastPointOffset) {
          lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), "element");
        }
      }
      $updateSelectionResolveTextNodes(selection);
    }
    function $updateSelectionResolveTextNodes(selection) {
      const anchor = selection.anchor;
      const anchorOffset = anchor.offset;
      const focus = selection.focus;
      const focusOffset = focus.offset;
      const anchorNode = anchor.getNode();
      const focusNode = focus.getNode();
      if (selection.isCollapsed()) {
        if (!$isElementNode(anchorNode)) {
          return;
        }
        const childSize = anchorNode.getChildrenSize();
        const anchorOffsetAtEnd = anchorOffset >= childSize;
        const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);
        if ($isTextNode(child)) {
          let newOffset = 0;
          if (anchorOffsetAtEnd) {
            newOffset = child.getTextContentSize();
          }
          anchor.set(child.__key, newOffset, "text");
          focus.set(child.__key, newOffset, "text");
        }
        return;
      }
      if ($isElementNode(anchorNode)) {
        const childSize = anchorNode.getChildrenSize();
        const anchorOffsetAtEnd = anchorOffset >= childSize;
        const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);
        if ($isTextNode(child)) {
          let newOffset = 0;
          if (anchorOffsetAtEnd) {
            newOffset = child.getTextContentSize();
          }
          anchor.set(child.__key, newOffset, "text");
        }
      }
      if ($isElementNode(focusNode)) {
        const childSize = focusNode.getChildrenSize();
        const focusOffsetAtEnd = focusOffset >= childSize;
        const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);
        if ($isTextNode(child)) {
          let newOffset = 0;
          if (focusOffsetAtEnd) {
            newOffset = child.getTextContentSize();
          }
          focus.set(child.__key, newOffset, "text");
        }
      }
    }
    function applySelectionTransforms(nextEditorState, editor) {
      const prevEditorState = editor.getEditorState();
      const prevSelection = prevEditorState._selection;
      const nextSelection = nextEditorState._selection;
      if ($isRangeSelection2(nextSelection)) {
        const anchor = nextSelection.anchor;
        const focus = nextSelection.focus;
        let anchorNode;
        if (anchor.type === "text") {
          anchorNode = anchor.getNode();
          anchorNode.selectionTransform(prevSelection, nextSelection);
        }
        if (focus.type === "text") {
          const focusNode = focus.getNode();
          if (anchorNode !== focusNode) {
            focusNode.selectionTransform(prevSelection, nextSelection);
          }
        }
      }
    }
    function moveSelectionPointToSibling(point6, node, parent, prevSibling, nextSibling) {
      let siblingKey = null;
      let offset = 0;
      let type2 = null;
      if (prevSibling !== null) {
        siblingKey = prevSibling.__key;
        if ($isTextNode(prevSibling)) {
          offset = prevSibling.getTextContentSize();
          type2 = "text";
        } else if ($isElementNode(prevSibling)) {
          offset = prevSibling.getChildrenSize();
          type2 = "element";
        }
      } else {
        if (nextSibling !== null) {
          siblingKey = nextSibling.__key;
          if ($isTextNode(nextSibling)) {
            type2 = "text";
          } else if ($isElementNode(nextSibling)) {
            type2 = "element";
          }
        }
      }
      if (siblingKey !== null && type2 !== null) {
        point6.set(siblingKey, offset, type2);
      } else {
        offset = node.getIndexWithinParent();
        if (offset === -1) {
          offset = parent.getChildrenSize();
        }
        point6.set(parent.__key, offset, "element");
      }
    }
    function adjustPointOffsetForMergedSibling(point6, isBefore, key, target, textLength) {
      if (point6.type === "text") {
        point6.key = key;
        if (!isBefore) {
          point6.offset += textLength;
        }
      } else if (point6.offset > target.getIndexWithinParent()) {
        point6.offset -= 1;
      }
    }
    function updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {
      const anchorDOMNode = domSelection.anchorNode;
      const focusDOMNode = domSelection.focusNode;
      const anchorOffset = domSelection.anchorOffset;
      const focusOffset = domSelection.focusOffset;
      const activeElement = document.activeElement;
      if (tags.has("collaboration") && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {
        return;
      }
      if (!$isRangeSelection2(nextSelection)) {
        if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {
          domSelection.removeAllRanges();
        }
        return;
      }
      const anchor = nextSelection.anchor;
      const focus = nextSelection.focus;
      const anchorKey = anchor.key;
      const focusKey = focus.key;
      const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);
      const focusDOM = getElementByKeyOrThrow(editor, focusKey);
      const nextAnchorOffset = anchor.offset;
      const nextFocusOffset = focus.offset;
      const nextFormat = nextSelection.format;
      const nextStyle = nextSelection.style;
      const isCollapsed = nextSelection.isCollapsed();
      let nextAnchorNode = anchorDOM;
      let nextFocusNode = focusDOM;
      let anchorFormatOrStyleChanged = false;
      if (anchor.type === "text") {
        nextAnchorNode = getDOMTextNode(anchorDOM);
        const anchorNode = anchor.getNode();
        anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;
      } else if ($isRangeSelection2(prevSelection) && prevSelection.anchor.type === "text") {
        anchorFormatOrStyleChanged = true;
      }
      if (focus.type === "text") {
        nextFocusNode = getDOMTextNode(focusDOM);
      }
      if (nextAnchorNode === null || nextFocusNode === null) {
        return;
      }
      if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection2(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {
        markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());
      }
      if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode && // Badly interpreted range selection when collapsed - #1482
      !(domSelection.type === "Range" && isCollapsed)) {
        if (activeElement === null || !rootElement.contains(activeElement)) {
          rootElement.focus({
            preventScroll: true
          });
        }
        if (anchor.type !== "element") {
          return;
        }
      }
      try {
        if (IS_CHROME && nodeCount > 1e3) {
          window.requestAnimationFrame(() => domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset));
        } else {
          domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);
        }
      } catch (error) {
      }
      if (!tags.has("skip-scroll-into-view") && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {
        const selectionTarget = nextSelection instanceof RangeSelection && nextSelection.anchor.type === "element" ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;
        if (selectionTarget !== null) {
          const selectionRect = selectionTarget.getBoundingClientRect();
          scrollIntoViewIfNeeded(editor, selectionRect, rootElement);
        }
      }
      markSelectionChangeFromDOMUpdate();
    }
    function $insertNodes(nodes, selectStart) {
      let selection = $getSelection2();
      if (selection === null) {
        selection = $getRoot().selectEnd();
      }
      return selection.insertNodes(nodes, selectStart);
    }
    function $getTextContent() {
      const selection = $getSelection2();
      if (selection === null) {
        return "";
      }
      return selection.getTextContent();
    }
    var activeEditorState = null;
    var activeEditor = null;
    var isReadOnlyMode = false;
    var isAttemptingToRecoverFromReconcilerError = false;
    var infiniteTransformCount = 0;
    var observerOptions = {
      characterData: true,
      childList: true,
      subtree: true
    };
    function isCurrentlyReadOnlyMode() {
      return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;
    }
    function errorOnReadOnly() {
      if (isReadOnlyMode) {
        {
          throw Error(`Cannot use method in read-only mode.`);
        }
      }
    }
    function errorOnInfiniteTransforms() {
      if (infiniteTransformCount > 99) {
        {
          throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);
        }
      }
    }
    function getActiveEditorState() {
      if (activeEditorState === null) {
        {
          throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().`);
        }
      }
      return activeEditorState;
    }
    function getActiveEditor() {
      if (activeEditor === null) {
        {
          throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().`);
        }
      }
      return activeEditor;
    }
    function internalGetActiveEditor() {
      return activeEditor;
    }
    function $applyTransforms(editor, node, transformsCache) {
      const type2 = node.__type;
      const registeredNode = getRegisteredNodeOrThrow(editor, type2);
      let transformsArr = transformsCache.get(type2);
      if (transformsArr === void 0) {
        transformsArr = Array.from(registeredNode.transforms);
        transformsCache.set(type2, transformsArr);
      }
      const transformsArrLength = transformsArr.length;
      for (let i = 0; i < transformsArrLength; i++) {
        transformsArr[i](node);
        if (!node.isAttached()) {
          break;
        }
      }
    }
    function $isNodeValidForTransform(node, compositionKey) {
      return node !== void 0 && // We don't want to transform nodes being composed
      node.__key !== compositionKey && node.isAttached();
    }
    function $normalizeAllDirtyTextNodes(editorState, editor) {
      const dirtyLeaves = editor._dirtyLeaves;
      const nodeMap = editorState._nodeMap;
      for (const nodeKey of dirtyLeaves) {
        const node = nodeMap.get(nodeKey);
        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {
          $normalizeTextNode(node);
        }
      }
    }
    function $applyAllTransforms(editorState, editor) {
      const dirtyLeaves = editor._dirtyLeaves;
      const dirtyElements = editor._dirtyElements;
      const nodeMap = editorState._nodeMap;
      const compositionKey = $getCompositionKey();
      const transformsCache = /* @__PURE__ */ new Map();
      let untransformedDirtyLeaves = dirtyLeaves;
      let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
      let untransformedDirtyElements = dirtyElements;
      let untransformedDirtyElementsLength = untransformedDirtyElements.size;
      while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {
        if (untransformedDirtyLeavesLength > 0) {
          editor._dirtyLeaves = /* @__PURE__ */ new Set();
          for (const nodeKey of untransformedDirtyLeaves) {
            const node = nodeMap.get(nodeKey);
            if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {
              $normalizeTextNode(node);
            }
            if (node !== void 0 && $isNodeValidForTransform(node, compositionKey)) {
              $applyTransforms(editor, node, transformsCache);
            }
            dirtyLeaves.add(nodeKey);
          }
          untransformedDirtyLeaves = editor._dirtyLeaves;
          untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
          if (untransformedDirtyLeavesLength > 0) {
            infiniteTransformCount++;
            continue;
          }
        }
        editor._dirtyLeaves = /* @__PURE__ */ new Set();
        editor._dirtyElements = /* @__PURE__ */ new Map();
        for (const currentUntransformedDirtyElement of untransformedDirtyElements) {
          const nodeKey = currentUntransformedDirtyElement[0];
          const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];
          if (nodeKey !== "root" && !intentionallyMarkedAsDirty) {
            continue;
          }
          const node = nodeMap.get(nodeKey);
          if (node !== void 0 && $isNodeValidForTransform(node, compositionKey)) {
            $applyTransforms(editor, node, transformsCache);
          }
          dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);
        }
        untransformedDirtyLeaves = editor._dirtyLeaves;
        untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
        untransformedDirtyElements = editor._dirtyElements;
        untransformedDirtyElementsLength = untransformedDirtyElements.size;
        infiniteTransformCount++;
      }
      editor._dirtyLeaves = dirtyLeaves;
      editor._dirtyElements = dirtyElements;
    }
    function $parseSerializedNode(serializedNode) {
      const internalSerializedNode = serializedNode;
      return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);
    }
    function $parseSerializedNodeImpl(serializedNode, registeredNodes) {
      const type2 = serializedNode.type;
      const registeredNode = registeredNodes.get(type2);
      if (registeredNode === void 0) {
        {
          throw Error(`parseEditorState: type "${type2}" + not found`);
        }
      }
      const nodeClass = registeredNode.klass;
      if (serializedNode.type !== nodeClass.getType()) {
        {
          throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);
        }
      }
      const node = nodeClass.importJSON(serializedNode);
      const children = serializedNode.children;
      if ($isElementNode(node) && Array.isArray(children)) {
        for (let i = 0; i < children.length; i++) {
          const serializedJSONChildNode = children[i];
          const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);
          node.append(childNode);
        }
      }
      return node;
    }
    function parseEditorState(serializedEditorState, editor, updateFn) {
      const editorState = createEmptyEditorState();
      const previousActiveEditorState = activeEditorState;
      const previousReadOnlyMode = isReadOnlyMode;
      const previousActiveEditor = activeEditor;
      const previousDirtyElements = editor._dirtyElements;
      const previousDirtyLeaves = editor._dirtyLeaves;
      const previousCloneNotNeeded = editor._cloneNotNeeded;
      const previousDirtyType = editor._dirtyType;
      editor._dirtyElements = /* @__PURE__ */ new Map();
      editor._dirtyLeaves = /* @__PURE__ */ new Set();
      editor._cloneNotNeeded = /* @__PURE__ */ new Set();
      editor._dirtyType = 0;
      activeEditorState = editorState;
      isReadOnlyMode = false;
      activeEditor = editor;
      try {
        const registeredNodes = editor._nodes;
        const serializedNode = serializedEditorState.root;
        $parseSerializedNodeImpl(serializedNode, registeredNodes);
        if (updateFn) {
          updateFn();
        }
        editorState._readOnly = true;
        {
          handleDEVOnlyPendingUpdateGuarantees(editorState);
        }
      } finally {
        editor._dirtyElements = previousDirtyElements;
        editor._dirtyLeaves = previousDirtyLeaves;
        editor._cloneNotNeeded = previousCloneNotNeeded;
        editor._dirtyType = previousDirtyType;
        activeEditorState = previousActiveEditorState;
        isReadOnlyMode = previousReadOnlyMode;
        activeEditor = previousActiveEditor;
      }
      return editorState;
    }
    function readEditorState(editorState, callbackFn) {
      const previousActiveEditorState = activeEditorState;
      const previousReadOnlyMode = isReadOnlyMode;
      const previousActiveEditor = activeEditor;
      activeEditorState = editorState;
      isReadOnlyMode = true;
      activeEditor = null;
      try {
        return callbackFn();
      } finally {
        activeEditorState = previousActiveEditorState;
        isReadOnlyMode = previousReadOnlyMode;
        activeEditor = previousActiveEditor;
      }
    }
    function handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {
      const nodeMap = pendingEditorState._nodeMap;
      nodeMap.set = () => {
        throw new Error("Cannot call set() on a frozen Lexical node map");
      };
      nodeMap.clear = () => {
        throw new Error("Cannot call clear() on a frozen Lexical node map");
      };
      nodeMap.delete = () => {
        throw new Error("Cannot call delete() on a frozen Lexical node map");
      };
    }
    function commitPendingUpdates(editor) {
      const pendingEditorState = editor._pendingEditorState;
      const rootElement = editor._rootElement;
      const shouldSkipDOM = editor._headless || rootElement === null;
      if (pendingEditorState === null) {
        return;
      }
      const currentEditorState = editor._editorState;
      const currentSelection = currentEditorState._selection;
      const pendingSelection = pendingEditorState._selection;
      const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;
      const previousActiveEditorState = activeEditorState;
      const previousReadOnlyMode = isReadOnlyMode;
      const previousActiveEditor = activeEditor;
      const previouslyUpdating = editor._updating;
      const observer = editor._observer;
      let mutatedNodes2 = null;
      editor._pendingEditorState = null;
      editor._editorState = pendingEditorState;
      if (!shouldSkipDOM && needsUpdate && observer !== null) {
        activeEditor = editor;
        activeEditorState = pendingEditorState;
        isReadOnlyMode = false;
        editor._updating = true;
        try {
          const dirtyType = editor._dirtyType;
          const dirtyElements2 = editor._dirtyElements;
          const dirtyLeaves2 = editor._dirtyLeaves;
          observer.disconnect();
          mutatedNodes2 = reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements2, dirtyLeaves2);
        } catch (error) {
          if (error instanceof Error) {
            editor._onError(error);
          }
          if (!isAttemptingToRecoverFromReconcilerError) {
            resetEditor(editor, null, rootElement, pendingEditorState);
            initMutationObserver(editor);
            editor._dirtyType = FULL_RECONCILE;
            isAttemptingToRecoverFromReconcilerError = true;
            commitPendingUpdates(editor);
            isAttemptingToRecoverFromReconcilerError = false;
          } else {
            throw error;
          }
          return;
        } finally {
          observer.observe(rootElement, observerOptions);
          editor._updating = previouslyUpdating;
          activeEditorState = previousActiveEditorState;
          isReadOnlyMode = previousReadOnlyMode;
          activeEditor = previousActiveEditor;
        }
      }
      if (!pendingEditorState._readOnly) {
        pendingEditorState._readOnly = true;
        {
          handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);
          if ($isRangeSelection2(pendingSelection)) {
            Object.freeze(pendingSelection.anchor);
            Object.freeze(pendingSelection.focus);
          }
          Object.freeze(pendingSelection);
        }
      }
      const dirtyLeaves = editor._dirtyLeaves;
      const dirtyElements = editor._dirtyElements;
      const normalizedNodes = editor._normalizedNodes;
      const tags = editor._updateTags;
      const deferred = editor._deferred;
      const nodeCount = pendingEditorState._nodeMap.size;
      if (needsUpdate) {
        editor._dirtyType = NO_DIRTY_NODES;
        editor._cloneNotNeeded.clear();
        editor._dirtyLeaves = /* @__PURE__ */ new Set();
        editor._dirtyElements = /* @__PURE__ */ new Map();
        editor._normalizedNodes = /* @__PURE__ */ new Set();
        editor._updateTags = /* @__PURE__ */ new Set();
      }
      $garbageCollectDetachedDecorators(editor, pendingEditorState);
      const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window);
      if (editor._editable && // domSelection will be null in headless
      domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {
        activeEditor = editor;
        activeEditorState = pendingEditorState;
        try {
          if (observer !== null) {
            observer.disconnect();
          }
          if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {
            const blockCursorElement = editor._blockCursorElement;
            if (blockCursorElement !== null) {
              removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
            }
            updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement, nodeCount);
          }
          updateDOMBlockCursorElement(editor, rootElement, pendingSelection);
          if (observer !== null) {
            observer.observe(rootElement, observerOptions);
          }
        } finally {
          activeEditor = previousActiveEditor;
          activeEditorState = previousActiveEditorState;
        }
      }
      if (mutatedNodes2 !== null) {
        triggerMutationListeners(editor, currentEditorState, pendingEditorState, mutatedNodes2, tags, dirtyLeaves);
      }
      if (!$isRangeSelection2(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {
        editor.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0);
      }
      const pendingDecorators = editor._pendingDecorators;
      if (pendingDecorators !== null) {
        editor._decorators = pendingDecorators;
        editor._pendingDecorators = null;
        triggerListeners("decorator", editor, true, pendingDecorators);
      }
      triggerTextContentListeners(editor, currentEditorState, pendingEditorState);
      triggerListeners("update", editor, true, {
        dirtyElements,
        dirtyLeaves,
        editorState: pendingEditorState,
        normalizedNodes,
        prevEditorState: currentEditorState,
        tags
      });
      triggerDeferredUpdateCallbacks(editor, deferred);
      triggerEnqueuedUpdates(editor);
    }
    function triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {
      const currentTextContent = getEditorStateTextContent(currentEditorState);
      const latestTextContent = getEditorStateTextContent(pendingEditorState);
      if (currentTextContent !== latestTextContent) {
        triggerListeners("textcontent", editor, true, latestTextContent);
      }
    }
    function triggerMutationListeners(editor, currentEditorState, pendingEditorState, mutatedNodes2, updateTags, dirtyLeaves) {
      const listeners = Array.from(editor._listeners.mutation);
      const listenersLength = listeners.length;
      for (let i = 0; i < listenersLength; i++) {
        const [listener, klass] = listeners[i];
        const mutatedNodesByType = mutatedNodes2.get(klass);
        if (mutatedNodesByType !== void 0) {
          listener(mutatedNodesByType, {
            dirtyLeaves,
            updateTags
          });
        }
      }
    }
    function triggerListeners(type2, editor, isCurrentlyEnqueuingUpdates, ...payload) {
      const previouslyUpdating = editor._updating;
      editor._updating = isCurrentlyEnqueuingUpdates;
      try {
        const listeners = Array.from(editor._listeners[type2]);
        for (let i = 0; i < listeners.length; i++) {
          listeners[i].apply(null, payload);
        }
      } finally {
        editor._updating = previouslyUpdating;
      }
    }
    function triggerCommandListeners(editor, type2, payload) {
      if (editor._updating === false || activeEditor !== editor) {
        let returnVal = false;
        editor.update(() => {
          returnVal = triggerCommandListeners(editor, type2, payload);
        });
        return returnVal;
      }
      const editors = getEditorsToPropagate(editor);
      for (let i = 4; i >= 0; i--) {
        for (let e = 0; e < editors.length; e++) {
          const currentEditor = editors[e];
          const commandListeners = currentEditor._commands;
          const listenerInPriorityOrder = commandListeners.get(type2);
          if (listenerInPriorityOrder !== void 0) {
            const listenersSet = listenerInPriorityOrder[i];
            if (listenersSet !== void 0) {
              const listeners = Array.from(listenersSet);
              const listenersLength = listeners.length;
              for (let j = 0; j < listenersLength; j++) {
                if (listeners[j](payload, editor) === true) {
                  return true;
                }
              }
            }
          }
        }
      }
      return false;
    }
    function triggerEnqueuedUpdates(editor) {
      const queuedUpdates = editor._updates;
      if (queuedUpdates.length !== 0) {
        const queuedUpdate = queuedUpdates.shift();
        if (queuedUpdate) {
          const [updateFn, options] = queuedUpdate;
          beginUpdate(editor, updateFn, options);
        }
      }
    }
    function triggerDeferredUpdateCallbacks(editor, deferred) {
      editor._deferred = [];
      if (deferred.length !== 0) {
        const previouslyUpdating = editor._updating;
        editor._updating = true;
        try {
          for (let i = 0; i < deferred.length; i++) {
            deferred[i]();
          }
        } finally {
          editor._updating = previouslyUpdating;
        }
      }
    }
    function processNestedUpdates(editor, initialSkipTransforms) {
      const queuedUpdates = editor._updates;
      let skipTransforms = initialSkipTransforms || false;
      while (queuedUpdates.length !== 0) {
        const queuedUpdate = queuedUpdates.shift();
        if (queuedUpdate) {
          const [nextUpdateFn, options] = queuedUpdate;
          let onUpdate;
          let tag;
          if (options !== void 0) {
            onUpdate = options.onUpdate;
            tag = options.tag;
            if (options.skipTransforms) {
              skipTransforms = true;
            }
            if (onUpdate) {
              editor._deferred.push(onUpdate);
            }
            if (tag) {
              editor._updateTags.add(tag);
            }
          }
          nextUpdateFn();
        }
      }
      return skipTransforms;
    }
    function beginUpdate(editor, updateFn, options) {
      const updateTags = editor._updateTags;
      let onUpdate;
      let tag;
      let skipTransforms = false;
      let discrete = false;
      if (options !== void 0) {
        onUpdate = options.onUpdate;
        tag = options.tag;
        if (tag != null) {
          updateTags.add(tag);
        }
        skipTransforms = options.skipTransforms || false;
        discrete = options.discrete || false;
      }
      if (onUpdate) {
        editor._deferred.push(onUpdate);
      }
      const currentEditorState = editor._editorState;
      let pendingEditorState = editor._pendingEditorState;
      let editorStateWasCloned = false;
      if (pendingEditorState === null || pendingEditorState._readOnly) {
        pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);
        editorStateWasCloned = true;
      }
      pendingEditorState._flushSync = discrete;
      const previousActiveEditorState = activeEditorState;
      const previousReadOnlyMode = isReadOnlyMode;
      const previousActiveEditor = activeEditor;
      const previouslyUpdating = editor._updating;
      activeEditorState = pendingEditorState;
      isReadOnlyMode = false;
      editor._updating = true;
      activeEditor = editor;
      try {
        if (editorStateWasCloned) {
          if (editor._headless) {
            if (currentEditorState._selection != null) {
              pendingEditorState._selection = currentEditorState._selection.clone();
            }
          } else {
            pendingEditorState._selection = internalCreateSelection(editor);
          }
        }
        const startingCompositionKey = editor._compositionKey;
        updateFn();
        skipTransforms = processNestedUpdates(editor, skipTransforms);
        applySelectionTransforms(pendingEditorState, editor);
        if (editor._dirtyType !== NO_DIRTY_NODES) {
          if (skipTransforms) {
            $normalizeAllDirtyTextNodes(pendingEditorState, editor);
          } else {
            $applyAllTransforms(pendingEditorState, editor);
          }
          processNestedUpdates(editor);
          $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);
        }
        const endingCompositionKey = editor._compositionKey;
        if (startingCompositionKey !== endingCompositionKey) {
          pendingEditorState._flushSync = true;
        }
        const pendingSelection = pendingEditorState._selection;
        if ($isRangeSelection2(pendingSelection)) {
          const pendingNodeMap = pendingEditorState._nodeMap;
          const anchorKey = pendingSelection.anchor.key;
          const focusKey = pendingSelection.focus.key;
          if (pendingNodeMap.get(anchorKey) === void 0 || pendingNodeMap.get(focusKey) === void 0) {
            {
              throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);
            }
          }
        } else if ($isNodeSelection(pendingSelection)) {
          if (pendingSelection._nodes.size === 0) {
            pendingEditorState._selection = null;
          }
        }
      } catch (error) {
        if (error instanceof Error) {
          editor._onError(error);
        }
        editor._pendingEditorState = currentEditorState;
        editor._dirtyType = FULL_RECONCILE;
        editor._cloneNotNeeded.clear();
        editor._dirtyLeaves = /* @__PURE__ */ new Set();
        editor._dirtyElements.clear();
        commitPendingUpdates(editor);
        return;
      } finally {
        activeEditorState = previousActiveEditorState;
        isReadOnlyMode = previousReadOnlyMode;
        activeEditor = previousActiveEditor;
        editor._updating = previouslyUpdating;
        infiniteTransformCount = 0;
      }
      const windowObj = editor._window;
      const windowEvent = windowObj !== null ? window.event : null;
      const eventType = windowEvent != null ? windowEvent.type : null;
      const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor) || editor._blockCursorElement !== null && eventType === "blur";
      if (shouldUpdate) {
        if (pendingEditorState._flushSync) {
          pendingEditorState._flushSync = false;
          commitPendingUpdates(editor);
        } else if (editorStateWasCloned) {
          scheduleMicroTask(() => {
            commitPendingUpdates(editor);
          });
        }
      } else {
        pendingEditorState._flushSync = false;
        if (editorStateWasCloned) {
          updateTags.clear();
          editor._deferred = [];
          editor._pendingEditorState = null;
        }
      }
    }
    function updateEditor(editor, updateFn, options) {
      if (editor._updating) {
        editor._updates.push([updateFn, options]);
      } else {
        beginUpdate(editor, updateFn, options);
      }
    }
    function removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {
      errorOnReadOnly();
      const key = nodeToRemove.__key;
      const parent = nodeToRemove.getParent();
      if (parent === null) {
        return;
      }
      const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);
      let selectionMoved = false;
      if ($isRangeSelection2(selection) && restoreSelection) {
        const anchor = selection.anchor;
        const focus = selection.focus;
        if (anchor.key === key) {
          moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());
          selectionMoved = true;
        }
        if (focus.key === key) {
          moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());
          selectionMoved = true;
        }
      }
      if ($isRangeSelection2(selection) && restoreSelection && !selectionMoved) {
        const index2 = nodeToRemove.getIndexWithinParent();
        removeFromParent(nodeToRemove);
        $updateElementSelectionOnCreateDeleteNode(selection, parent, index2, -1);
      } else {
        removeFromParent(nodeToRemove);
      }
      if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {
        removeNode(parent, restoreSelection);
      }
      if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {
        parent.selectEnd();
      }
    }
    var LexicalNode = class {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      // Flow doesn't support abstract classes unfortunately, so we can't _force_
      // subclasses of Node to implement statics. All subclasses of Node should have
      // a static getType and clone method though. We define getType and clone here so we can call it
      // on any  Node, and we throw this error by default since the subclass should provide
      // their own implementation.
      static getType() {
        {
          throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);
        }
      }
      static clone(_data) {
        {
          throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);
        }
      }
      constructor(key) {
        this.__type = this.constructor.getType();
        this.__parent = null;
        this.__prev = null;
        this.__next = null;
        $setNodeKey(this, key);
        {
          if (this.__type !== "root") {
            errorOnReadOnly();
            errorOnTypeKlassMismatch(
              this.__type,
              // @ts-expect-error
              this.constructor
            );
          }
        }
      }
      // Getters and Traversers
      getType() {
        return this.__type;
      }
      isAttached() {
        let nodeKey = this.__key;
        while (nodeKey !== null) {
          if (nodeKey === "root") {
            return true;
          }
          const node = $getNodeByKey(nodeKey);
          if (node === null) {
            break;
          }
          nodeKey = node.__parent;
        }
        return false;
      }
      isSelected(selection) {
        const targetSelection = selection || $getSelection2();
        if (targetSelection == null) {
          return false;
        }
        const isSelected = targetSelection.getNodes().some((n) => n.__key === this.__key);
        if ($isTextNode(this)) {
          return isSelected;
        }
        if ($isRangeSelection2(targetSelection) && targetSelection.anchor.type === "element" && targetSelection.focus.type === "element" && targetSelection.anchor.key === targetSelection.focus.key && targetSelection.anchor.offset === targetSelection.focus.offset) {
          return false;
        }
        return isSelected;
      }
      getKey() {
        return this.__key;
      }
      getIndexWithinParent() {
        const parent = this.getParent();
        if (parent === null) {
          return -1;
        }
        let node = parent.getFirstChild();
        let index2 = 0;
        while (node !== null) {
          if (this.is(node)) {
            return index2;
          }
          index2++;
          node = node.getNextSibling();
        }
        return -1;
      }
      getParent() {
        const parent = this.getLatest().__parent;
        if (parent === null) {
          return null;
        }
        return $getNodeByKey(parent);
      }
      getParentOrThrow() {
        const parent = this.getParent();
        if (parent === null) {
          {
            throw Error(`Expected node ${this.__key} to have a parent.`);
          }
        }
        return parent;
      }
      getTopLevelElement() {
        let node = this;
        while (node !== null) {
          const parent = node.getParent();
          if ($isRootOrShadowRoot(parent)) {
            return node;
          }
          node = parent;
        }
        return null;
      }
      getTopLevelElementOrThrow() {
        const parent = this.getTopLevelElement();
        if (parent === null) {
          {
            throw Error(`Expected node ${this.__key} to have a top parent element.`);
          }
        }
        return parent;
      }
      getParents() {
        const parents = [];
        let node = this.getParent();
        while (node !== null) {
          parents.push(node);
          node = node.getParent();
        }
        return parents;
      }
      getParentKeys() {
        const parents = [];
        let node = this.getParent();
        while (node !== null) {
          parents.push(node.__key);
          node = node.getParent();
        }
        return parents;
      }
      getPreviousSibling() {
        const self2 = this.getLatest();
        const prevKey = self2.__prev;
        return prevKey === null ? null : $getNodeByKey(prevKey);
      }
      getPreviousSiblings() {
        const siblings = [];
        const parent = this.getParent();
        if (parent === null) {
          return siblings;
        }
        let node = parent.getFirstChild();
        while (node !== null) {
          if (node.is(this)) {
            break;
          }
          siblings.push(node);
          node = node.getNextSibling();
        }
        return siblings;
      }
      getNextSibling() {
        const self2 = this.getLatest();
        const nextKey = self2.__next;
        return nextKey === null ? null : $getNodeByKey(nextKey);
      }
      getNextSiblings() {
        const siblings = [];
        let node = this.getNextSibling();
        while (node !== null) {
          siblings.push(node);
          node = node.getNextSibling();
        }
        return siblings;
      }
      getCommonAncestor(node) {
        const a2 = this.getParents();
        const b = node.getParents();
        if ($isElementNode(this)) {
          a2.unshift(this);
        }
        if ($isElementNode(node)) {
          b.unshift(node);
        }
        const aLength = a2.length;
        const bLength = b.length;
        if (aLength === 0 || bLength === 0 || a2[aLength - 1] !== b[bLength - 1]) {
          return null;
        }
        const bSet = new Set(b);
        for (let i = 0; i < aLength; i++) {
          const ancestor = a2[i];
          if (bSet.has(ancestor)) {
            return ancestor;
          }
        }
        return null;
      }
      is(object) {
        if (object == null) {
          return false;
        }
        return this.__key === object.__key;
      }
      isBefore(targetNode) {
        if (targetNode.isParentOf(this)) {
          return true;
        }
        if (this.isParentOf(targetNode)) {
          return false;
        }
        const commonAncestor = this.getCommonAncestor(targetNode);
        let indexA = 0;
        let indexB = 0;
        let node = this;
        while (true) {
          const parent = node.getParentOrThrow();
          if (parent === commonAncestor) {
            indexA = node.getIndexWithinParent();
            break;
          }
          node = parent;
        }
        node = targetNode;
        while (true) {
          const parent = node.getParentOrThrow();
          if (parent === commonAncestor) {
            indexB = node.getIndexWithinParent();
            break;
          }
          node = parent;
        }
        return indexA < indexB;
      }
      isParentOf(targetNode) {
        const key = this.__key;
        if (key === targetNode.__key) {
          return false;
        }
        let node = targetNode;
        while (node !== null) {
          if (node.__key === key) {
            return true;
          }
          node = node.getParent();
        }
        return false;
      }
      // TO-DO: this function can be simplified a lot
      getNodesBetween(targetNode) {
        const isBefore = this.isBefore(targetNode);
        const nodes = [];
        const visited = /* @__PURE__ */ new Set();
        let node = this;
        while (true) {
          const key = node.__key;
          if (!visited.has(key)) {
            visited.add(key);
            nodes.push(node);
          }
          if (node === targetNode) {
            break;
          }
          const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;
          if (child !== null) {
            node = child;
            continue;
          }
          const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();
          if (nextSibling !== null) {
            node = nextSibling;
            continue;
          }
          const parent = node.getParentOrThrow();
          if (!visited.has(parent.__key)) {
            nodes.push(parent);
          }
          if (parent === targetNode) {
            break;
          }
          let parentSibling = null;
          let ancestor = parent;
          do {
            if (ancestor === null) {
              {
                throw Error(`getNodesBetween: ancestor is null`);
              }
            }
            parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();
            ancestor = ancestor.getParent();
            if (ancestor !== null) {
              if (parentSibling === null && !visited.has(ancestor.__key)) {
                nodes.push(ancestor);
              }
            }
          } while (parentSibling === null);
          node = parentSibling;
        }
        if (!isBefore) {
          nodes.reverse();
        }
        return nodes;
      }
      isDirty() {
        const editor = getActiveEditor();
        const dirtyLeaves = editor._dirtyLeaves;
        return dirtyLeaves !== null && dirtyLeaves.has(this.__key);
      }
      getLatest() {
        const latest = $getNodeByKey(this.__key);
        if (latest === null) {
          {
            throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);
          }
        }
        return latest;
      }
      getWritable() {
        errorOnReadOnly();
        const editorState = getActiveEditorState();
        const editor = getActiveEditor();
        const nodeMap = editorState._nodeMap;
        const key = this.__key;
        const latestNode = this.getLatest();
        const parent = latestNode.__parent;
        const cloneNotNeeded = editor._cloneNotNeeded;
        const selection = $getSelection2();
        if (selection !== null) {
          selection._cachedNodes = null;
        }
        if (cloneNotNeeded.has(key)) {
          internalMarkNodeAsDirty(latestNode);
          return latestNode;
        }
        const constructor = latestNode.constructor;
        const mutableNode = constructor.clone(latestNode);
        mutableNode.__parent = parent;
        mutableNode.__next = latestNode.__next;
        mutableNode.__prev = latestNode.__prev;
        if ($isElementNode(latestNode) && $isElementNode(mutableNode)) {
          mutableNode.__first = latestNode.__first;
          mutableNode.__last = latestNode.__last;
          mutableNode.__size = latestNode.__size;
          mutableNode.__indent = latestNode.__indent;
          mutableNode.__format = latestNode.__format;
          mutableNode.__dir = latestNode.__dir;
        } else if ($isTextNode(latestNode) && $isTextNode(mutableNode)) {
          mutableNode.__format = latestNode.__format;
          mutableNode.__style = latestNode.__style;
          mutableNode.__mode = latestNode.__mode;
          mutableNode.__detail = latestNode.__detail;
        }
        cloneNotNeeded.add(key);
        mutableNode.__key = key;
        internalMarkNodeAsDirty(mutableNode);
        nodeMap.set(key, mutableNode);
        return mutableNode;
      }
      getTextContent() {
        return "";
      }
      getTextContentSize() {
        return this.getTextContent().length;
      }
      // View
      createDOM(_config, _editor) {
        {
          throw Error(`createDOM: base method not extended`);
        }
      }
      /*
       * This method is called when a node changes and should update the DOM
       * in whatever way is necessary to make it align with any changes that might
       * have happened during the update.
       *
       * Returning "true" here will cause lexical to unmount and recreate the DOM node
       * (by calling createDOM). You would need to do this if the element tag changes,
       * for instance.
       *
       * */
      updateDOM(_prevNode, _dom, _config) {
        {
          throw Error(`updateDOM: base method not extended`);
        }
      }
      exportDOM(editor) {
        const element = this.createDOM(editor._config, editor);
        return {
          element
        };
      }
      exportJSON() {
        {
          throw Error(`exportJSON: base method not extended`);
        }
      }
      static importJSON(_serializedNode) {
        {
          throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);
        }
      }
      // Setters and mutators
      remove(preserveEmptyParent) {
        removeNode(this, true, preserveEmptyParent);
      }
      replace(replaceWith, includeChildren) {
        errorOnReadOnly();
        let selection = $getSelection2();
        if (selection !== null)
          selection = selection.clone();
        errorOnInsertTextNodeOnRoot(this, replaceWith);
        const self2 = this.getLatest();
        const toReplaceKey = this.__key;
        const key = replaceWith.__key;
        const writableReplaceWith = replaceWith.getWritable();
        const writableParent = this.getParentOrThrow().getWritable();
        const size = writableParent.__size;
        removeFromParent(writableReplaceWith);
        const prevSibling = self2.getPreviousSibling();
        const nextSibling = self2.getNextSibling();
        const prevKey = self2.__prev;
        const nextKey = self2.__next;
        const parentKey = self2.__parent;
        removeNode(self2, false, true);
        if (prevSibling === null) {
          writableParent.__first = key;
        } else {
          const writablePrevSibling = prevSibling.getWritable();
          writablePrevSibling.__next = key;
        }
        writableReplaceWith.__prev = prevKey;
        if (nextSibling === null) {
          writableParent.__last = key;
        } else {
          const writableNextSibling = nextSibling.getWritable();
          writableNextSibling.__prev = key;
        }
        writableReplaceWith.__next = nextKey;
        writableReplaceWith.__parent = parentKey;
        writableParent.__size = size;
        if (includeChildren) {
          this.getChildren().forEach((child) => {
            writableReplaceWith.append(child);
          });
        }
        if ($isRangeSelection2(selection)) {
          $setSelection2(selection);
          const anchor = selection.anchor;
          const focus = selection.focus;
          if (anchor.key === toReplaceKey) {
            $moveSelectionPointToEnd(anchor, writableReplaceWith);
          }
          if (focus.key === toReplaceKey) {
            $moveSelectionPointToEnd(focus, writableReplaceWith);
          }
        }
        if ($getCompositionKey() === toReplaceKey) {
          $setCompositionKey(key);
        }
        return writableReplaceWith;
      }
      insertAfter(nodeToInsert, restoreSelection = true) {
        errorOnReadOnly();
        errorOnInsertTextNodeOnRoot(this, nodeToInsert);
        const writableSelf = this.getWritable();
        const writableNodeToInsert = nodeToInsert.getWritable();
        const oldParent = writableNodeToInsert.getParent();
        const selection = $getSelection2();
        let elementAnchorSelectionOnNode = false;
        let elementFocusSelectionOnNode = false;
        if (oldParent !== null) {
          const oldIndex = nodeToInsert.getIndexWithinParent();
          removeFromParent(writableNodeToInsert);
          if ($isRangeSelection2(selection)) {
            const oldParentKey = oldParent.__key;
            const anchor = selection.anchor;
            const focus = selection.focus;
            elementAnchorSelectionOnNode = anchor.type === "element" && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;
            elementFocusSelectionOnNode = focus.type === "element" && focus.key === oldParentKey && focus.offset === oldIndex + 1;
          }
        }
        const nextSibling = this.getNextSibling();
        const writableParent = this.getParentOrThrow().getWritable();
        const insertKey = writableNodeToInsert.__key;
        const nextKey = writableSelf.__next;
        if (nextSibling === null) {
          writableParent.__last = insertKey;
        } else {
          const writableNextSibling = nextSibling.getWritable();
          writableNextSibling.__prev = insertKey;
        }
        writableParent.__size++;
        writableSelf.__next = insertKey;
        writableNodeToInsert.__next = nextKey;
        writableNodeToInsert.__prev = writableSelf.__key;
        writableNodeToInsert.__parent = writableSelf.__parent;
        if (restoreSelection && $isRangeSelection2(selection)) {
          const index2 = this.getIndexWithinParent();
          $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index2 + 1);
          const writableParentKey = writableParent.__key;
          if (elementAnchorSelectionOnNode) {
            selection.anchor.set(writableParentKey, index2 + 2, "element");
          }
          if (elementFocusSelectionOnNode) {
            selection.focus.set(writableParentKey, index2 + 2, "element");
          }
        }
        return nodeToInsert;
      }
      insertBefore(nodeToInsert, restoreSelection = true) {
        errorOnReadOnly();
        errorOnInsertTextNodeOnRoot(this, nodeToInsert);
        const writableSelf = this.getWritable();
        const writableNodeToInsert = nodeToInsert.getWritable();
        const insertKey = writableNodeToInsert.__key;
        removeFromParent(writableNodeToInsert);
        const prevSibling = this.getPreviousSibling();
        const writableParent = this.getParentOrThrow().getWritable();
        const prevKey = writableSelf.__prev;
        const index2 = this.getIndexWithinParent();
        if (prevSibling === null) {
          writableParent.__first = insertKey;
        } else {
          const writablePrevSibling = prevSibling.getWritable();
          writablePrevSibling.__next = insertKey;
        }
        writableParent.__size++;
        writableSelf.__prev = insertKey;
        writableNodeToInsert.__prev = prevKey;
        writableNodeToInsert.__next = writableSelf.__key;
        writableNodeToInsert.__parent = writableSelf.__parent;
        const selection = $getSelection2();
        if (restoreSelection && $isRangeSelection2(selection)) {
          const parent = this.getParentOrThrow();
          $updateElementSelectionOnCreateDeleteNode(selection, parent, index2);
        }
        return nodeToInsert;
      }
      isParentRequired() {
        return false;
      }
      createParentElementNode() {
        return $createParagraphNode2();
      }
      selectPrevious(anchorOffset, focusOffset) {
        errorOnReadOnly();
        const prevSibling = this.getPreviousSibling();
        const parent = this.getParentOrThrow();
        if (prevSibling === null) {
          return parent.select(0, 0);
        }
        if ($isElementNode(prevSibling)) {
          return prevSibling.select();
        } else if (!$isTextNode(prevSibling)) {
          const index2 = prevSibling.getIndexWithinParent() + 1;
          return parent.select(index2, index2);
        }
        return prevSibling.select(anchorOffset, focusOffset);
      }
      selectNext(anchorOffset, focusOffset) {
        errorOnReadOnly();
        const nextSibling = this.getNextSibling();
        const parent = this.getParentOrThrow();
        if (nextSibling === null) {
          return parent.select();
        }
        if ($isElementNode(nextSibling)) {
          return nextSibling.select(0, 0);
        } else if (!$isTextNode(nextSibling)) {
          const index2 = nextSibling.getIndexWithinParent();
          return parent.select(index2, index2);
        }
        return nextSibling.select(anchorOffset, focusOffset);
      }
      // Proxy to mark something as dirty
      markDirty() {
        this.getWritable();
      }
    };
    function errorOnTypeKlassMismatch(type2, klass) {
      const registeredNode = getActiveEditor()._nodes.get(type2);
      if (registeredNode === void 0) {
        {
          throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);
        }
      }
      const editorKlass = registeredNode.klass;
      if (editorKlass !== klass) {
        {
          throw Error(`Create node: Type ${type2} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);
        }
      }
    }
    var DecoratorNode = class extends LexicalNode {
      constructor(key) {
        super(key);
      }
      decorate(editor, config) {
        {
          throw Error(`decorate: base method not extended`);
        }
      }
      isIsolated() {
        return false;
      }
      isInline() {
        return true;
      }
      isKeyboardSelectable() {
        return true;
      }
    };
    function $isDecoratorNode(node) {
      return node instanceof DecoratorNode;
    }
    var ElementNode = class extends LexicalNode {
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      constructor(key) {
        super(key);
        this.__first = null;
        this.__last = null;
        this.__size = 0;
        this.__format = 0;
        this.__indent = 0;
        this.__dir = null;
      }
      getFormat() {
        const self2 = this.getLatest();
        return self2.__format;
      }
      getFormatType() {
        const format3 = this.getFormat();
        return ELEMENT_FORMAT_TO_TYPE[format3] || "";
      }
      getIndent() {
        const self2 = this.getLatest();
        return self2.__indent;
      }
      getChildren() {
        const children = [];
        let child = this.getFirstChild();
        while (child !== null) {
          children.push(child);
          child = child.getNextSibling();
        }
        return children;
      }
      getChildrenKeys() {
        const children = [];
        let child = this.getFirstChild();
        while (child !== null) {
          children.push(child.__key);
          child = child.getNextSibling();
        }
        return children;
      }
      getChildrenSize() {
        const self2 = this.getLatest();
        return self2.__size;
      }
      isEmpty() {
        return this.getChildrenSize() === 0;
      }
      isDirty() {
        const editor = getActiveEditor();
        const dirtyElements = editor._dirtyElements;
        return dirtyElements !== null && dirtyElements.has(this.__key);
      }
      isLastChild() {
        const self2 = this.getLatest();
        const parentLastChild = this.getParentOrThrow().getLastChild();
        return parentLastChild !== null && parentLastChild.is(self2);
      }
      getAllTextNodes() {
        const textNodes = [];
        let child = this.getFirstChild();
        while (child !== null) {
          if ($isTextNode(child)) {
            textNodes.push(child);
          }
          if ($isElementNode(child)) {
            const subChildrenNodes = child.getAllTextNodes();
            textNodes.push(...subChildrenNodes);
          }
          child = child.getNextSibling();
        }
        return textNodes;
      }
      getFirstDescendant() {
        let node = this.getFirstChild();
        while (node !== null) {
          if ($isElementNode(node)) {
            const child = node.getFirstChild();
            if (child !== null) {
              node = child;
              continue;
            }
          }
          break;
        }
        return node;
      }
      getLastDescendant() {
        let node = this.getLastChild();
        while (node !== null) {
          if ($isElementNode(node)) {
            const child = node.getLastChild();
            if (child !== null) {
              node = child;
              continue;
            }
          }
          break;
        }
        return node;
      }
      getDescendantByIndex(index2) {
        const children = this.getChildren();
        const childrenLength = children.length;
        if (index2 >= childrenLength) {
          const resolvedNode2 = children[childrenLength - 1];
          return $isElementNode(resolvedNode2) && resolvedNode2.getLastDescendant() || resolvedNode2 || null;
        }
        const resolvedNode = children[index2];
        return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;
      }
      getFirstChild() {
        const self2 = this.getLatest();
        const firstKey = self2.__first;
        return firstKey === null ? null : $getNodeByKey(firstKey);
      }
      getFirstChildOrThrow() {
        const firstChild = this.getFirstChild();
        if (firstChild === null) {
          {
            throw Error(`Expected node ${this.__key} to have a first child.`);
          }
        }
        return firstChild;
      }
      getLastChild() {
        const self2 = this.getLatest();
        const lastKey = self2.__last;
        return lastKey === null ? null : $getNodeByKey(lastKey);
      }
      getLastChildOrThrow() {
        const lastChild = this.getLastChild();
        if (lastChild === null) {
          {
            throw Error(`Expected node ${this.__key} to have a last child.`);
          }
        }
        return lastChild;
      }
      getChildAtIndex(index2) {
        const size = this.getChildrenSize();
        let node;
        let i;
        if (index2 < size / 2) {
          node = this.getFirstChild();
          i = 0;
          while (node !== null && i <= index2) {
            if (i === index2) {
              return node;
            }
            node = node.getNextSibling();
            i++;
          }
          return null;
        }
        node = this.getLastChild();
        i = size - 1;
        while (node !== null && i >= index2) {
          if (i === index2) {
            return node;
          }
          node = node.getPreviousSibling();
          i--;
        }
        return null;
      }
      getTextContent() {
        let textContent = "";
        const children = this.getChildren();
        const childrenLength = children.length;
        for (let i = 0; i < childrenLength; i++) {
          const child = children[i];
          textContent += child.getTextContent();
          if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {
            textContent += DOUBLE_LINE_BREAK;
          }
        }
        return textContent;
      }
      getDirection() {
        const self2 = this.getLatest();
        return self2.__dir;
      }
      hasFormat(type2) {
        if (type2 !== "") {
          const formatFlag = ELEMENT_TYPE_TO_FORMAT[type2];
          return (this.getFormat() & formatFlag) !== 0;
        }
        return false;
      }
      // Mutators
      select(_anchorOffset, _focusOffset) {
        errorOnReadOnly();
        const selection = $getSelection2();
        let anchorOffset = _anchorOffset;
        let focusOffset = _focusOffset;
        const childrenCount = this.getChildrenSize();
        if (!this.canBeEmpty()) {
          if (_anchorOffset === 0 && _focusOffset === 0) {
            const firstChild = this.getFirstChild();
            if ($isTextNode(firstChild) || $isElementNode(firstChild)) {
              return firstChild.select(0, 0);
            }
          } else if ((_anchorOffset === void 0 || _anchorOffset === childrenCount) && (_focusOffset === void 0 || _focusOffset === childrenCount)) {
            const lastChild = this.getLastChild();
            if ($isTextNode(lastChild) || $isElementNode(lastChild)) {
              return lastChild.select();
            }
          }
        }
        if (anchorOffset === void 0) {
          anchorOffset = childrenCount;
        }
        if (focusOffset === void 0) {
          focusOffset = childrenCount;
        }
        const key = this.__key;
        if (!$isRangeSelection2(selection)) {
          return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, "element", "element");
        } else {
          selection.anchor.set(key, anchorOffset, "element");
          selection.focus.set(key, focusOffset, "element");
          selection.dirty = true;
        }
        return selection;
      }
      selectStart() {
        const firstNode = this.getFirstDescendant();
        if ($isElementNode(firstNode) || $isTextNode(firstNode)) {
          return firstNode.select(0, 0);
        }
        if (firstNode !== null) {
          return firstNode.selectPrevious();
        }
        return this.select(0, 0);
      }
      selectEnd() {
        const lastNode = this.getLastDescendant();
        if ($isElementNode(lastNode) || $isTextNode(lastNode)) {
          return lastNode.select();
        }
        if (lastNode !== null) {
          return lastNode.selectNext();
        }
        return this.select();
      }
      clear() {
        const writableSelf = this.getWritable();
        const children = this.getChildren();
        children.forEach((child) => child.remove());
        return writableSelf;
      }
      append(...nodesToAppend) {
        return this.splice(this.getChildrenSize(), 0, nodesToAppend);
      }
      setDirection(direction) {
        const self2 = this.getWritable();
        self2.__dir = direction;
        return self2;
      }
      setFormat(type2) {
        const self2 = this.getWritable();
        self2.__format = type2 !== "" ? ELEMENT_TYPE_TO_FORMAT[type2] : 0;
        return this;
      }
      setIndent(indentLevel) {
        const self2 = this.getWritable();
        self2.__indent = indentLevel;
        return this;
      }
      splice(start, deleteCount, nodesToInsert) {
        const nodesToInsertLength = nodesToInsert.length;
        const oldSize = this.getChildrenSize();
        const writableSelf = this.getWritable();
        const writableSelfKey = writableSelf.__key;
        const nodesToInsertKeys = [];
        const nodesToRemoveKeys = [];
        const nodeAfterRange = this.getChildAtIndex(start + deleteCount);
        let nodeBeforeRange = null;
        let newSize = oldSize - deleteCount + nodesToInsertLength;
        if (start !== 0) {
          if (start === oldSize) {
            nodeBeforeRange = this.getLastChild();
          } else {
            const node = this.getChildAtIndex(start);
            if (node !== null) {
              nodeBeforeRange = node.getPreviousSibling();
            }
          }
        }
        if (deleteCount > 0) {
          let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();
          for (let i = 0; i < deleteCount; i++) {
            if (nodeToDelete === null) {
              {
                throw Error(`splice: sibling not found`);
              }
            }
            const nextSibling = nodeToDelete.getNextSibling();
            const nodeKeyToDelete = nodeToDelete.__key;
            const writableNodeToDelete = nodeToDelete.getWritable();
            removeFromParent(writableNodeToDelete);
            nodesToRemoveKeys.push(nodeKeyToDelete);
            nodeToDelete = nextSibling;
          }
        }
        let prevNode = nodeBeforeRange;
        for (let i = 0; i < nodesToInsertLength; i++) {
          const nodeToInsert = nodesToInsert[i];
          if (prevNode !== null && nodeToInsert.is(prevNode)) {
            nodeBeforeRange = prevNode = prevNode.getPreviousSibling();
          }
          const writableNodeToInsert = nodeToInsert.getWritable();
          if (writableNodeToInsert.__parent === writableSelfKey) {
            newSize--;
          }
          removeFromParent(writableNodeToInsert);
          const nodeKeyToInsert = nodeToInsert.__key;
          if (prevNode === null) {
            writableSelf.__first = nodeKeyToInsert;
            writableNodeToInsert.__prev = null;
          } else {
            const writablePrevNode = prevNode.getWritable();
            writablePrevNode.__next = nodeKeyToInsert;
            writableNodeToInsert.__prev = writablePrevNode.__key;
          }
          if (nodeToInsert.__key === writableSelfKey) {
            {
              throw Error(`append: attempting to append self`);
            }
          }
          writableNodeToInsert.__parent = writableSelfKey;
          nodesToInsertKeys.push(nodeKeyToInsert);
          prevNode = nodeToInsert;
        }
        if (start + deleteCount === oldSize) {
          if (prevNode !== null) {
            const writablePrevNode = prevNode.getWritable();
            writablePrevNode.__next = null;
            writableSelf.__last = prevNode.__key;
          }
        } else if (nodeAfterRange !== null) {
          const writableNodeAfterRange = nodeAfterRange.getWritable();
          if (prevNode !== null) {
            const writablePrevNode = prevNode.getWritable();
            writableNodeAfterRange.__prev = prevNode.__key;
            writablePrevNode.__next = nodeAfterRange.__key;
          } else {
            writableNodeAfterRange.__prev = null;
          }
        }
        writableSelf.__size = newSize;
        if (nodesToRemoveKeys.length) {
          const selection = $getSelection2();
          if ($isRangeSelection2(selection)) {
            const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);
            const nodesToInsertKeySet = new Set(nodesToInsertKeys);
            const {
              anchor,
              focus
            } = selection;
            if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {
              moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);
            }
            if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {
              moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);
            }
            if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {
              this.remove();
            }
          }
        }
        return writableSelf;
      }
      // JSON serialization
      exportJSON() {
        return {
          children: [],
          direction: this.getDirection(),
          format: this.getFormatType(),
          indent: this.getIndent(),
          type: "element",
          version: 1
        };
      }
      // These are intended to be extends for specific element heuristics.
      insertNewAfter(selection, restoreSelection) {
        return null;
      }
      canInsertTab() {
        return false;
      }
      canIndent() {
        return true;
      }
      /*
       * This method controls the behavior of a the node during backwards
       * deletion (i.e., backspace) when selection is at the beginning of
       * the node (offset 0)
       */
      collapseAtStart(selection) {
        return false;
      }
      excludeFromCopy(destination) {
        return false;
      }
      canExtractContents() {
        return true;
      }
      canReplaceWith(replacement) {
        return true;
      }
      canInsertAfter(node) {
        return true;
      }
      canBeEmpty() {
        return true;
      }
      canInsertTextBefore() {
        return true;
      }
      canInsertTextAfter() {
        return true;
      }
      isInline() {
        return false;
      }
      // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the
      // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)
      // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode
      // will return the immediate first child underneath TableCellNode instead of RootNode.
      isShadowRoot() {
        return false;
      }
      canMergeWith(node) {
        return false;
      }
      extractWithChild(child, selection, destination) {
        return false;
      }
    };
    function $isElementNode(node) {
      return node instanceof ElementNode;
    }
    function isPointRemoved(point6, nodesToRemoveKeySet, nodesToInsertKeySet) {
      let node = point6.getNode();
      while (node) {
        const nodeKey = node.__key;
        if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {
          return true;
        }
        node = node.getParent();
      }
      return false;
    }
    var RootNode = class _RootNode extends ElementNode {
      /** @internal */
      static getType() {
        return "root";
      }
      static clone() {
        return new _RootNode();
      }
      constructor() {
        super("root");
        this.__cachedText = null;
      }
      getTopLevelElementOrThrow() {
        {
          throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);
        }
      }
      getTextContent() {
        const cachedText = this.__cachedText;
        if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {
          if (cachedText !== null) {
            return cachedText;
          }
        }
        return super.getTextContent();
      }
      remove() {
        {
          throw Error(`remove: cannot be called on root nodes`);
        }
      }
      replace(node) {
        {
          throw Error(`replace: cannot be called on root nodes`);
        }
      }
      insertBefore(nodeToInsert) {
        {
          throw Error(`insertBefore: cannot be called on root nodes`);
        }
      }
      insertAfter(nodeToInsert) {
        {
          throw Error(`insertAfter: cannot be called on root nodes`);
        }
      }
      // View
      updateDOM(prevNode, dom) {
        return false;
      }
      // Mutate
      append(...nodesToAppend) {
        for (let i = 0; i < nodesToAppend.length; i++) {
          const node = nodesToAppend[i];
          if (!$isElementNode(node) && !$isDecoratorNode(node)) {
            {
              throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);
            }
          }
        }
        return super.append(...nodesToAppend);
      }
      static importJSON(serializedNode) {
        const node = $getRoot();
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        return node;
      }
      exportJSON() {
        return {
          children: [],
          direction: this.getDirection(),
          format: this.getFormatType(),
          indent: this.getIndent(),
          type: "root",
          version: 1
        };
      }
      collapseAtStart() {
        return true;
      }
    };
    function $createRootNode() {
      return new RootNode();
    }
    function $isRootNode(node) {
      return node instanceof RootNode;
    }
    function editorStateHasDirtySelection(editorState, editor) {
      const currentSelection = editor.getEditorState()._selection;
      const pendingSelection = editorState._selection;
      if (pendingSelection !== null) {
        if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {
          return true;
        }
      } else if (currentSelection !== null) {
        return true;
      }
      return false;
    }
    function cloneEditorState(current) {
      return new EditorState(new Map(current._nodeMap));
    }
    function createEmptyEditorState() {
      return new EditorState(/* @__PURE__ */ new Map([["root", $createRootNode()]]));
    }
    function exportNodeToJSON(node) {
      const serializedNode = node.exportJSON();
      const nodeClass = node.constructor;
      if (serializedNode.type !== nodeClass.getType()) {
        {
          throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);
        }
      }
      const serializedChildren = serializedNode.children;
      if ($isElementNode(node)) {
        if (!Array.isArray(serializedChildren)) {
          {
            throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
          }
        }
        const children = node.getChildren();
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          const serializedChildNode = exportNodeToJSON(child);
          serializedChildren.push(serializedChildNode);
        }
      }
      return serializedNode;
    }
    var EditorState = class _EditorState {
      constructor(nodeMap, selection) {
        this._nodeMap = nodeMap;
        this._selection = selection || null;
        this._flushSync = false;
        this._readOnly = false;
      }
      isEmpty() {
        return this._nodeMap.size === 1 && this._selection === null;
      }
      read(callbackFn) {
        return readEditorState(this, callbackFn);
      }
      clone(selection) {
        const editorState = new _EditorState(this._nodeMap, selection === void 0 ? this._selection : selection);
        editorState._readOnly = true;
        return editorState;
      }
      toJSON() {
        return readEditorState(this, () => ({
          root: exportNodeToJSON($getRoot())
        }));
      }
    };
    var LineBreakNode = class _LineBreakNode extends LexicalNode {
      static getType() {
        return "linebreak";
      }
      static clone(node) {
        return new _LineBreakNode(node.__key);
      }
      constructor(key) {
        super(key);
      }
      getTextContent() {
        return "\n";
      }
      createDOM() {
        return document.createElement("br");
      }
      updateDOM() {
        return false;
      }
      static importDOM() {
        return {
          br: (node) => {
            const parentElement = node.parentElement;
            if (parentElement != null && parentElement.firstChild === node && parentElement.lastChild === node) {
              return null;
            }
            return {
              conversion: convertLineBreakElement,
              priority: 0
            };
          }
        };
      }
      static importJSON(serializedLineBreakNode) {
        return $createLineBreakNode();
      }
      exportJSON() {
        return {
          type: "linebreak",
          version: 1
        };
      }
    };
    function convertLineBreakElement(node) {
      return {
        node: $createLineBreakNode()
      };
    }
    function $createLineBreakNode() {
      return $applyNodeReplacement(new LineBreakNode());
    }
    function $isLineBreakNode(node) {
      return node instanceof LineBreakNode;
    }
    function getElementOuterTag(node, format3) {
      if (format3 & IS_CODE) {
        return "code";
      }
      if (format3 & IS_HIGHLIGHT) {
        return "mark";
      }
      if (format3 & IS_SUBSCRIPT) {
        return "sub";
      }
      if (format3 & IS_SUPERSCRIPT) {
        return "sup";
      }
      return null;
    }
    function getElementInnerTag(node, format3) {
      if (format3 & IS_BOLD) {
        return "strong";
      }
      if (format3 & IS_ITALIC) {
        return "em";
      }
      return "span";
    }
    function setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {
      const domClassList = dom.classList;
      let classNames = getCachedClassNameArray(textClassNames, "base");
      if (classNames !== void 0) {
        domClassList.add(...classNames);
      }
      classNames = getCachedClassNameArray(textClassNames, "underlineStrikethrough");
      let hasUnderlineStrikethrough = false;
      const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;
      const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;
      if (classNames !== void 0) {
        if (nextUnderlineStrikethrough) {
          hasUnderlineStrikethrough = true;
          if (!prevUnderlineStrikethrough) {
            domClassList.add(...classNames);
          }
        } else if (prevUnderlineStrikethrough) {
          domClassList.remove(...classNames);
        }
      }
      for (const key in TEXT_TYPE_TO_FORMAT) {
        const format3 = key;
        const flag = TEXT_TYPE_TO_FORMAT[format3];
        classNames = getCachedClassNameArray(textClassNames, key);
        if (classNames !== void 0) {
          if (nextFormat & flag) {
            if (hasUnderlineStrikethrough && (key === "underline" || key === "strikethrough")) {
              if (prevFormat & flag) {
                domClassList.remove(...classNames);
              }
              continue;
            }
            if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === "underline" || key === "strikethrough") {
              domClassList.add(...classNames);
            }
          } else if (prevFormat & flag) {
            domClassList.remove(...classNames);
          }
        }
      }
    }
    function diffComposedText(a2, b) {
      const aLength = a2.length;
      const bLength = b.length;
      let left2 = 0;
      let right2 = 0;
      while (left2 < aLength && left2 < bLength && a2[left2] === b[left2]) {
        left2++;
      }
      while (right2 + left2 < aLength && right2 + left2 < bLength && a2[aLength - right2 - 1] === b[bLength - right2 - 1]) {
        right2++;
      }
      return [left2, aLength - left2 - right2, b.slice(left2, bLength - right2)];
    }
    function setTextContent(nextText, dom, node) {
      const firstChild = dom.firstChild;
      const isComposing = node.isComposing();
      const suffix = isComposing ? COMPOSITION_SUFFIX : "";
      const text = nextText + suffix;
      if (firstChild == null) {
        dom.textContent = text;
      } else {
        const nodeValue = firstChild.nodeValue;
        if (nodeValue !== text) {
          if (isComposing || IS_FIREFOX) {
            const [index2, remove, insert] = diffComposedText(nodeValue, text);
            if (remove !== 0) {
              firstChild.deleteData(index2, remove);
            }
            firstChild.insertData(index2, insert);
          } else {
            firstChild.nodeValue = text;
          }
        }
      }
    }
    function createTextInnerDOM(innerDOM, node, innerTag, format3, text, config) {
      setTextContent(text, innerDOM, node);
      const theme = config.theme;
      const textClassNames = theme.text;
      if (textClassNames !== void 0) {
        setTextThemeClassNames(innerTag, 0, format3, innerDOM, textClassNames);
      }
    }
    function wrapElementWith(element, tag) {
      const el = document.createElement(tag);
      el.appendChild(element);
      return el;
    }
    var TextNode2 = class _TextNode extends LexicalNode {
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      static getType() {
        return "text";
      }
      static clone(node) {
        return new _TextNode(node.__text, node.__key);
      }
      constructor(text, key) {
        super(key);
        this.__text = text;
        this.__format = 0;
        this.__style = "";
        this.__mode = 0;
        this.__detail = 0;
      }
      getFormat() {
        const self2 = this.getLatest();
        return self2.__format;
      }
      getDetail() {
        const self2 = this.getLatest();
        return self2.__detail;
      }
      getMode() {
        const self2 = this.getLatest();
        return TEXT_TYPE_TO_MODE[self2.__mode];
      }
      getStyle() {
        const self2 = this.getLatest();
        return self2.__style;
      }
      isToken() {
        const self2 = this.getLatest();
        return self2.__mode === IS_TOKEN;
      }
      isComposing() {
        return this.__key === $getCompositionKey();
      }
      isSegmented() {
        const self2 = this.getLatest();
        return self2.__mode === IS_SEGMENTED;
      }
      isDirectionless() {
        const self2 = this.getLatest();
        return (self2.__detail & IS_DIRECTIONLESS) !== 0;
      }
      isUnmergeable() {
        const self2 = this.getLatest();
        return (self2.__detail & IS_UNMERGEABLE) !== 0;
      }
      hasFormat(type2) {
        const formatFlag = TEXT_TYPE_TO_FORMAT[type2];
        return (this.getFormat() & formatFlag) !== 0;
      }
      isSimpleText() {
        return this.__type === "text" && this.__mode === 0;
      }
      getTextContent() {
        const self2 = this.getLatest();
        return self2.__text;
      }
      getFormatFlags(type2, alignWithFormat) {
        const self2 = this.getLatest();
        const format3 = self2.__format;
        return toggleTextFormatType(format3, type2, alignWithFormat);
      }
      // View
      createDOM(config) {
        const format3 = this.__format;
        const outerTag = getElementOuterTag(this, format3);
        const innerTag = getElementInnerTag(this, format3);
        const tag = outerTag === null ? innerTag : outerTag;
        const dom = document.createElement(tag);
        let innerDOM = dom;
        if (outerTag !== null) {
          innerDOM = document.createElement(innerTag);
          dom.appendChild(innerDOM);
        }
        const text = this.__text;
        createTextInnerDOM(innerDOM, this, innerTag, format3, text, config);
        const style = this.__style;
        if (style !== "") {
          dom.style.cssText = style;
        }
        return dom;
      }
      updateDOM(prevNode, dom, config) {
        const nextText = this.__text;
        const prevFormat = prevNode.__format;
        const nextFormat = this.__format;
        const prevOuterTag = getElementOuterTag(this, prevFormat);
        const nextOuterTag = getElementOuterTag(this, nextFormat);
        const prevInnerTag = getElementInnerTag(this, prevFormat);
        const nextInnerTag = getElementInnerTag(this, nextFormat);
        const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;
        const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;
        if (prevTag !== nextTag) {
          return true;
        }
        if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {
          const prevInnerDOM = dom.firstChild;
          if (prevInnerDOM == null) {
            {
              throw Error(`updateDOM: prevInnerDOM is null or undefined`);
            }
          }
          const nextInnerDOM = document.createElement(nextInnerTag);
          createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);
          dom.replaceChild(nextInnerDOM, prevInnerDOM);
          return false;
        }
        let innerDOM = dom;
        if (nextOuterTag !== null) {
          if (prevOuterTag !== null) {
            innerDOM = dom.firstChild;
            if (innerDOM == null) {
              {
                throw Error(`updateDOM: innerDOM is null or undefined`);
              }
            }
          }
        }
        setTextContent(nextText, innerDOM, this);
        const theme = config.theme;
        const textClassNames = theme.text;
        if (textClassNames !== void 0 && prevFormat !== nextFormat) {
          setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);
        }
        const prevStyle = prevNode.__style;
        const nextStyle = this.__style;
        if (prevStyle !== nextStyle) {
          dom.style.cssText = nextStyle;
        }
        return false;
      }
      static importDOM() {
        return {
          "#text": () => ({
            conversion: convertTextDOMNode,
            priority: 0
          }),
          b: () => ({
            conversion: convertBringAttentionToElement,
            priority: 0
          }),
          br: () => ({
            conversion: convertLineBreakToElement,
            priority: 0
          }),
          code: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          em: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          i: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          s: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          span: () => ({
            conversion: convertSpanElement,
            priority: 0
          }),
          strong: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          sub: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          sup: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          u: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          })
        };
      }
      static importJSON(serializedNode) {
        const node = $createTextNode(serializedNode.text);
        node.setFormat(serializedNode.format);
        node.setDetail(serializedNode.detail);
        node.setMode(serializedNode.mode);
        node.setStyle(serializedNode.style);
        return node;
      }
      // This improves Lexical's basic text output in copy+paste plus
      // for headless mode where people might use Lexical to generate
      // HTML content and not have the ability to use CSS classes.
      exportDOM(editor) {
        let {
          element
        } = super.exportDOM(editor);
        if (element !== null) {
          if (this.hasFormat("bold")) {
            element = wrapElementWith(element, "b");
          }
          if (this.hasFormat("italic")) {
            element = wrapElementWith(element, "i");
          }
          if (this.hasFormat("strikethrough")) {
            element = wrapElementWith(element, "s");
          }
          if (this.hasFormat("underline")) {
            element = wrapElementWith(element, "u");
          }
        }
        return {
          element
        };
      }
      exportJSON() {
        return {
          detail: this.getDetail(),
          format: this.getFormat(),
          mode: this.getMode(),
          style: this.getStyle(),
          text: this.getTextContent(),
          type: "text",
          version: 1
        };
      }
      // Mutators
      selectionTransform(prevSelection, nextSelection) {
        return;
      }
      // TODO 0.5 This should just be a `string`.
      setFormat(format3) {
        const self2 = this.getWritable();
        self2.__format = typeof format3 === "string" ? TEXT_TYPE_TO_FORMAT[format3] : format3;
        return self2;
      }
      // TODO 0.5 This should just be a `string`.
      setDetail(detail) {
        const self2 = this.getWritable();
        self2.__detail = typeof detail === "string" ? DETAIL_TYPE_TO_DETAIL[detail] : detail;
        return self2;
      }
      setStyle(style) {
        const self2 = this.getWritable();
        self2.__style = style;
        return self2;
      }
      toggleFormat(type2) {
        const formatFlag = TEXT_TYPE_TO_FORMAT[type2];
        return this.setFormat(this.getFormat() ^ formatFlag);
      }
      toggleDirectionless() {
        const self2 = this.getWritable();
        self2.__detail ^= IS_DIRECTIONLESS;
        return self2;
      }
      toggleUnmergeable() {
        const self2 = this.getWritable();
        self2.__detail ^= IS_UNMERGEABLE;
        return self2;
      }
      setMode(type2) {
        const mode2 = TEXT_MODE_TO_TYPE[type2];
        if (this.__mode === mode2) {
          return this;
        }
        const self2 = this.getWritable();
        self2.__mode = mode2;
        return self2;
      }
      setTextContent(text) {
        if (this.__text === text) {
          return this;
        }
        const self2 = this.getWritable();
        self2.__text = text;
        return self2;
      }
      select(_anchorOffset, _focusOffset) {
        errorOnReadOnly();
        let anchorOffset = _anchorOffset;
        let focusOffset = _focusOffset;
        const selection = $getSelection2();
        const text = this.getTextContent();
        const key = this.__key;
        if (typeof text === "string") {
          const lastOffset = text.length;
          if (anchorOffset === void 0) {
            anchorOffset = lastOffset;
          }
          if (focusOffset === void 0) {
            focusOffset = lastOffset;
          }
        } else {
          anchorOffset = 0;
          focusOffset = 0;
        }
        if (!$isRangeSelection2(selection)) {
          return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, "text", "text");
        } else {
          const compositionKey = $getCompositionKey();
          if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {
            $setCompositionKey(key);
          }
          selection.setTextNodeRange(this, anchorOffset, this, focusOffset);
        }
        return selection;
      }
      spliceText(offset, delCount, newText, moveSelection) {
        const writableSelf = this.getWritable();
        const text = writableSelf.__text;
        const handledTextLength = newText.length;
        let index2 = offset;
        if (index2 < 0) {
          index2 = handledTextLength + index2;
          if (index2 < 0) {
            index2 = 0;
          }
        }
        const selection = $getSelection2();
        if (moveSelection && $isRangeSelection2(selection)) {
          const newOffset = offset + handledTextLength;
          selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);
        }
        const updatedText = text.slice(0, index2) + newText + text.slice(index2 + delCount);
        writableSelf.__text = updatedText;
        return writableSelf;
      }
      canInsertTextBefore() {
        return true;
      }
      canInsertTextAfter() {
        return true;
      }
      canContainTabs() {
        return false;
      }
      splitText(...splitOffsets) {
        errorOnReadOnly();
        const self2 = this.getLatest();
        const textContent = self2.getTextContent();
        const key = self2.__key;
        const compositionKey = $getCompositionKey();
        const offsetsSet = new Set(splitOffsets);
        const parts = [];
        const textLength = textContent.length;
        let string = "";
        for (let i = 0; i < textLength; i++) {
          if (string !== "" && offsetsSet.has(i)) {
            parts.push(string);
            string = "";
          }
          string += textContent[i];
        }
        if (string !== "") {
          parts.push(string);
        }
        const partsLength = parts.length;
        if (partsLength === 0) {
          return [];
        } else if (parts[0] === textContent) {
          return [self2];
        }
        const firstPart = parts[0];
        const parent = self2.getParentOrThrow();
        let writableNode;
        const format3 = self2.getFormat();
        const style = self2.getStyle();
        const detail = self2.__detail;
        let hasReplacedSelf = false;
        if (self2.isSegmented()) {
          writableNode = $createTextNode(firstPart);
          writableNode.__format = format3;
          writableNode.__style = style;
          writableNode.__detail = detail;
          hasReplacedSelf = true;
        } else {
          writableNode = self2.getWritable();
          writableNode.__text = firstPart;
        }
        const selection = $getSelection2();
        const splitNodes = [writableNode];
        let textSize = firstPart.length;
        for (let i = 1; i < partsLength; i++) {
          const part = parts[i];
          const partSize = part.length;
          const sibling = $createTextNode(part).getWritable();
          sibling.__format = format3;
          sibling.__style = style;
          sibling.__detail = detail;
          const siblingKey = sibling.__key;
          const nextTextSize = textSize + partSize;
          if ($isRangeSelection2(selection)) {
            const anchor = selection.anchor;
            const focus = selection.focus;
            if (anchor.key === key && anchor.type === "text" && anchor.offset > textSize && anchor.offset <= nextTextSize) {
              anchor.key = siblingKey;
              anchor.offset -= textSize;
              selection.dirty = true;
            }
            if (focus.key === key && focus.type === "text" && focus.offset > textSize && focus.offset <= nextTextSize) {
              focus.key = siblingKey;
              focus.offset -= textSize;
              selection.dirty = true;
            }
          }
          if (compositionKey === key) {
            $setCompositionKey(siblingKey);
          }
          textSize = nextTextSize;
          splitNodes.push(sibling);
        }
        internalMarkSiblingsAsDirty(this);
        const writableParent = parent.getWritable();
        const insertionIndex = this.getIndexWithinParent();
        if (hasReplacedSelf) {
          writableParent.splice(insertionIndex, 0, splitNodes);
          this.remove();
        } else {
          writableParent.splice(insertionIndex, 1, splitNodes);
        }
        if ($isRangeSelection2(selection)) {
          $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);
        }
        return splitNodes;
      }
      mergeWithSibling(target) {
        const isBefore = target === this.getPreviousSibling();
        if (!isBefore && target !== this.getNextSibling()) {
          {
            throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);
          }
        }
        const key = this.__key;
        const targetKey = target.__key;
        const text = this.__text;
        const textLength = text.length;
        const compositionKey = $getCompositionKey();
        if (compositionKey === targetKey) {
          $setCompositionKey(key);
        }
        const selection = $getSelection2();
        if ($isRangeSelection2(selection)) {
          const anchor = selection.anchor;
          const focus = selection.focus;
          if (anchor !== null && anchor.key === targetKey) {
            adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);
            selection.dirty = true;
          }
          if (focus !== null && focus.key === targetKey) {
            adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);
            selection.dirty = true;
          }
        }
        const targetText = target.__text;
        const newText = isBefore ? targetText + text : text + targetText;
        this.setTextContent(newText);
        const writableSelf = this.getWritable();
        target.remove();
        return writableSelf;
      }
      isTextEntity() {
        return false;
      }
    };
    function convertSpanElement(domNode) {
      const span = domNode;
      const hasBoldFontWeight = span.style.fontWeight === "700";
      const hasLinethroughTextDecoration = span.style.textDecoration === "line-through";
      const hasItalicFontStyle = span.style.fontStyle === "italic";
      const hasUnderlineTextDecoration = span.style.textDecoration === "underline";
      const verticalAlign = span.style.verticalAlign;
      return {
        forChild: (lexicalNode) => {
          if (!$isTextNode(lexicalNode)) {
            return lexicalNode;
          }
          if (hasBoldFontWeight) {
            lexicalNode.toggleFormat("bold");
          }
          if (hasLinethroughTextDecoration) {
            lexicalNode.toggleFormat("strikethrough");
          }
          if (hasItalicFontStyle) {
            lexicalNode.toggleFormat("italic");
          }
          if (hasUnderlineTextDecoration) {
            lexicalNode.toggleFormat("underline");
          }
          if (verticalAlign === "sub") {
            lexicalNode.toggleFormat("subscript");
          }
          if (verticalAlign === "super") {
            lexicalNode.toggleFormat("superscript");
          }
          return lexicalNode;
        },
        node: null
      };
    }
    function convertLineBreakToElement() {
      return {
        node: $createLineBreakNode()
      };
    }
    function convertBringAttentionToElement(domNode) {
      const b = domNode;
      const hasNormalFontWeight = b.style.fontWeight === "normal";
      return {
        forChild: (lexicalNode) => {
          if ($isTextNode(lexicalNode) && !hasNormalFontWeight) {
            lexicalNode.toggleFormat("bold");
          }
          return lexicalNode;
        },
        node: null
      };
    }
    function convertTextDOMNode(domNode, _parent, preformatted) {
      let textContent = domNode.textContent || "";
      if (!preformatted && /\n/.test(textContent)) {
        textContent = textContent.replace(/\r?\n/gm, " ");
        if (textContent.trim().length === 0) {
          return {
            node: null
          };
        }
      }
      return {
        node: $createTextNode(textContent)
      };
    }
    var nodeNameToTextFormat = {
      code: "code",
      em: "italic",
      i: "italic",
      s: "strikethrough",
      strong: "bold",
      sub: "subscript",
      sup: "superscript",
      u: "underline"
    };
    function convertTextFormatElement(domNode) {
      const format3 = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];
      if (format3 === void 0) {
        return {
          node: null
        };
      }
      return {
        forChild: (lexicalNode) => {
          if ($isTextNode(lexicalNode) && !lexicalNode.hasFormat(format3)) {
            lexicalNode.toggleFormat(format3);
          }
          return lexicalNode;
        },
        node: null
      };
    }
    function $createTextNode(text = "") {
      return $applyNodeReplacement(new TextNode2(text));
    }
    function $isTextNode(node) {
      return node instanceof TextNode2;
    }
    var ParagraphNode = class _ParagraphNode extends ElementNode {
      static getType() {
        return "paragraph";
      }
      static clone(node) {
        return new _ParagraphNode(node.__key);
      }
      // View
      createDOM(config) {
        const dom = document.createElement("p");
        const classNames = getCachedClassNameArray(config.theme, "paragraph");
        if (classNames !== void 0) {
          const domClassList = dom.classList;
          domClassList.add(...classNames);
        }
        return dom;
      }
      updateDOM(prevNode, dom, config) {
        return false;
      }
      static importDOM() {
        return {
          p: (node) => ({
            conversion: convertParagraphElement,
            priority: 0
          })
        };
      }
      exportDOM(editor) {
        const {
          element
        } = super.exportDOM(editor);
        if (element && this.isEmpty()) {
          element.append(document.createElement("br"));
        }
        if (element) {
          const formatType = this.getFormatType();
          element.style.textAlign = formatType;
          const direction = this.getDirection();
          if (direction) {
            element.dir = direction;
          }
          const indent = this.getIndent();
          if (indent > 0) {
            element.style.textIndent = `${indent * 20}px`;
          }
        }
        return {
          element
        };
      }
      static importJSON(serializedNode) {
        const node = $createParagraphNode2();
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        return node;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          type: "paragraph",
          version: 1
        };
      }
      // Mutation
      insertNewAfter(_, restoreSelection) {
        const newElement = $createParagraphNode2();
        const direction = this.getDirection();
        newElement.setDirection(direction);
        this.insertAfter(newElement, restoreSelection);
        return newElement;
      }
      collapseAtStart() {
        const children = this.getChildren();
        if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === "") {
          const nextSibling = this.getNextSibling();
          if (nextSibling !== null) {
            this.selectNext();
            this.remove();
            return true;
          }
          const prevSibling = this.getPreviousSibling();
          if (prevSibling !== null) {
            this.selectPrevious();
            this.remove();
            return true;
          }
        }
        return false;
      }
    };
    function convertParagraphElement(element) {
      const node = $createParagraphNode2();
      if (element.style) {
        node.setFormat(element.style.textAlign);
        const indent = parseInt(element.style.textIndent, 10) / 20;
        if (indent > 0) {
          node.setIndent(indent);
        }
      }
      return {
        node
      };
    }
    function $createParagraphNode2() {
      return $applyNodeReplacement(new ParagraphNode());
    }
    function $isParagraphNode(node) {
      return node instanceof ParagraphNode;
    }
    var COMMAND_PRIORITY_EDITOR = 0;
    var COMMAND_PRIORITY_LOW2 = 1;
    var COMMAND_PRIORITY_NORMAL = 2;
    var COMMAND_PRIORITY_HIGH = 3;
    var COMMAND_PRIORITY_CRITICAL = 4;
    function resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {
      const keyNodeMap = editor._keyToDOMMap;
      keyNodeMap.clear();
      editor._editorState = createEmptyEditorState();
      editor._pendingEditorState = pendingEditorState;
      editor._compositionKey = null;
      editor._dirtyType = NO_DIRTY_NODES;
      editor._cloneNotNeeded.clear();
      editor._dirtyLeaves = /* @__PURE__ */ new Set();
      editor._dirtyElements.clear();
      editor._normalizedNodes = /* @__PURE__ */ new Set();
      editor._updateTags = /* @__PURE__ */ new Set();
      editor._updates = [];
      editor._blockCursorElement = null;
      const observer = editor._observer;
      if (observer !== null) {
        observer.disconnect();
        editor._observer = null;
      }
      if (prevRootElement !== null) {
        prevRootElement.textContent = "";
      }
      if (nextRootElement !== null) {
        nextRootElement.textContent = "";
        keyNodeMap.set("root", nextRootElement);
      }
    }
    function initializeConversionCache(nodes) {
      const conversionCache = /* @__PURE__ */ new Map();
      const handledConversions = /* @__PURE__ */ new Set();
      nodes.forEach((node) => {
        const importDOM = node.klass.importDOM != null ? node.klass.importDOM.bind(node.klass) : null;
        if (importDOM == null || handledConversions.has(importDOM)) {
          return;
        }
        handledConversions.add(importDOM);
        const map4 = importDOM();
        if (map4 !== null) {
          Object.keys(map4).forEach((key) => {
            let currentCache = conversionCache.get(key);
            if (currentCache === void 0) {
              currentCache = [];
              conversionCache.set(key, currentCache);
            }
            currentCache.push(map4[key]);
          });
        }
      });
      return conversionCache;
    }
    function createEditor(editorConfig) {
      const config = editorConfig || {};
      const activeEditor2 = internalGetActiveEditor();
      const theme = config.theme || {};
      const parentEditor = editorConfig === void 0 ? activeEditor2 : config.parentEditor || null;
      const disableEvents = config.disableEvents || false;
      const editorState = createEmptyEditorState();
      const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());
      const initialEditorState = config.editorState;
      const nodes = [RootNode, TextNode2, LineBreakNode, ParagraphNode, ...config.nodes || []];
      const onError = config.onError;
      const isEditable = config.editable !== void 0 ? config.editable : true;
      let registeredNodes;
      if (editorConfig === void 0 && activeEditor2 !== null) {
        registeredNodes = activeEditor2._nodes;
      } else {
        registeredNodes = /* @__PURE__ */ new Map();
        for (let i = 0; i < nodes.length; i++) {
          let klass = nodes[i];
          let replacementClass = null;
          let replacementKlass = null;
          if (typeof klass !== "function") {
            const options = klass;
            klass = options.replace;
            replacementClass = options.with;
            replacementKlass = options.withKlass ? options.withKlass : null;
          }
          {
            const name2 = klass.name;
            if (name2 !== "RootNode") {
              const proto = klass.prototype;
              ["getType", "clone"].forEach((method) => {
                if (!klass.hasOwnProperty(method)) {
                  console.warn(`${name2} must implement static "${method}" method`);
                }
              });
              if (
                // eslint-disable-next-line no-prototype-builtins
                !klass.hasOwnProperty("importDOM") && // eslint-disable-next-line no-prototype-builtins
                klass.hasOwnProperty("exportDOM")
              ) {
                console.warn(`${name2} should implement "importDOM" if using a custom "exportDOM" method to ensure HTML serialization (important for copy & paste) works as expected`);
              }
              if (proto instanceof DecoratorNode) {
                if (!proto.hasOwnProperty("decorate")) {
                  console.warn(`${proto.constructor.name} must implement "decorate" method`);
                }
              }
              if (
                // eslint-disable-next-line no-prototype-builtins
                !klass.hasOwnProperty("importJSON")
              ) {
                console.warn(`${name2} should implement "importJSON" method to ensure JSON and default HTML serialization works as expected`);
              }
              if (
                // eslint-disable-next-line no-prototype-builtins
                !proto.hasOwnProperty("exportJSON")
              ) {
                console.warn(`${name2} should implement "exportJSON" method to ensure JSON and default HTML serialization works as expected`);
              }
            }
          }
          const type2 = klass.getType();
          registeredNodes.set(type2, {
            klass,
            replace: replacementClass,
            replaceWithKlass: replacementKlass,
            transforms: /* @__PURE__ */ new Set()
          });
        }
      }
      const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {
        disableEvents,
        namespace,
        theme
      }, onError ? onError : console.error, initializeConversionCache(registeredNodes), isEditable);
      if (initialEditorState !== void 0) {
        editor._pendingEditorState = initialEditorState;
        editor._dirtyType = FULL_RECONCILE;
      }
      return editor;
    }
    var LexicalEditor = class {
      constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {
        this._parentEditor = parentEditor;
        this._rootElement = null;
        this._editorState = editorState;
        this._pendingEditorState = null;
        this._compositionKey = null;
        this._deferred = [];
        this._keyToDOMMap = /* @__PURE__ */ new Map();
        this._updates = [];
        this._updating = false;
        this._listeners = {
          decorator: /* @__PURE__ */ new Set(),
          editable: /* @__PURE__ */ new Set(),
          mutation: /* @__PURE__ */ new Map(),
          root: /* @__PURE__ */ new Set(),
          textcontent: /* @__PURE__ */ new Set(),
          update: /* @__PURE__ */ new Set()
        };
        this._commands = /* @__PURE__ */ new Map();
        this._config = config;
        this._nodes = nodes;
        this._decorators = {};
        this._pendingDecorators = null;
        this._dirtyType = NO_DIRTY_NODES;
        this._cloneNotNeeded = /* @__PURE__ */ new Set();
        this._dirtyLeaves = /* @__PURE__ */ new Set();
        this._dirtyElements = /* @__PURE__ */ new Map();
        this._normalizedNodes = /* @__PURE__ */ new Set();
        this._updateTags = /* @__PURE__ */ new Set();
        this._observer = null;
        this._key = createUID();
        this._onError = onError;
        this._htmlConversions = htmlConversions;
        this._editable = true;
        this._headless = parentEditor !== null && parentEditor._headless;
        this._window = null;
        this._blockCursorElement = null;
      }
      isComposing() {
        return this._compositionKey != null;
      }
      registerUpdateListener(listener) {
        const listenerSetOrMap = this._listeners.update;
        listenerSetOrMap.add(listener);
        return () => {
          listenerSetOrMap.delete(listener);
        };
      }
      registerEditableListener(listener) {
        const listenerSetOrMap = this._listeners.editable;
        listenerSetOrMap.add(listener);
        return () => {
          listenerSetOrMap.delete(listener);
        };
      }
      registerDecoratorListener(listener) {
        const listenerSetOrMap = this._listeners.decorator;
        listenerSetOrMap.add(listener);
        return () => {
          listenerSetOrMap.delete(listener);
        };
      }
      registerTextContentListener(listener) {
        const listenerSetOrMap = this._listeners.textcontent;
        listenerSetOrMap.add(listener);
        return () => {
          listenerSetOrMap.delete(listener);
        };
      }
      registerRootListener(listener) {
        const listenerSetOrMap = this._listeners.root;
        listener(this._rootElement, null);
        listenerSetOrMap.add(listener);
        return () => {
          listener(null, this._rootElement);
          listenerSetOrMap.delete(listener);
        };
      }
      registerCommand(command, listener, priority) {
        if (priority === void 0) {
          {
            throw Error(`Listener for type "command" requires a "priority".`);
          }
        }
        const commandsMap = this._commands;
        if (!commandsMap.has(command)) {
          commandsMap.set(command, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
        }
        const listenersInPriorityOrder = commandsMap.get(command);
        if (listenersInPriorityOrder === void 0) {
          {
            throw Error(`registerCommand: Command ${String(command)} not found in command map`);
          }
        }
        const listeners = listenersInPriorityOrder[priority];
        listeners.add(listener);
        return () => {
          listeners.delete(listener);
          if (listenersInPriorityOrder.every((listenersSet) => listenersSet.size === 0)) {
            commandsMap.delete(command);
          }
        };
      }
      registerMutationListener(klass, listener) {
        const registeredNode = this._nodes.get(klass.getType());
        if (registeredNode === void 0) {
          {
            throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);
          }
        }
        const mutations = this._listeners.mutation;
        mutations.set(listener, klass);
        return () => {
          mutations.delete(listener);
        };
      }
      registerNodeTransformToKlass(klass, listener) {
        const type2 = klass.getType();
        const registeredNode = this._nodes.get(type2);
        if (registeredNode === void 0) {
          {
            throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);
          }
        }
        const transforms = registeredNode.transforms;
        transforms.add(listener);
        return registeredNode;
      }
      registerNodeTransform(klass, listener) {
        const registeredNode = this.registerNodeTransformToKlass(klass, listener);
        const registeredNodes = [registeredNode];
        const replaceWithKlass = registeredNode.replaceWithKlass;
        if (replaceWithKlass != null) {
          const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);
          registeredNodes.push(registeredReplaceWithNode);
        }
        markAllNodesAsDirty(this, klass.getType());
        return () => {
          registeredNodes.forEach((node) => node.transforms.delete(listener));
        };
      }
      hasNodes(nodes) {
        for (let i = 0; i < nodes.length; i++) {
          const klass = nodes[i];
          const type2 = klass.getType();
          if (!this._nodes.has(type2)) {
            return false;
          }
        }
        return true;
      }
      dispatchCommand(type2, payload) {
        return dispatchCommand(this, type2, payload);
      }
      getDecorators() {
        return this._decorators;
      }
      getRootElement() {
        return this._rootElement;
      }
      getKey() {
        return this._key;
      }
      setRootElement(nextRootElement) {
        const prevRootElement = this._rootElement;
        if (nextRootElement !== prevRootElement) {
          const classNames = getCachedClassNameArray(this._config.theme, "root");
          const pendingEditorState = this._pendingEditorState || this._editorState;
          this._rootElement = nextRootElement;
          resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);
          if (prevRootElement !== null) {
            if (!this._config.disableEvents) {
              removeRootElementEvents(prevRootElement);
            }
            if (classNames != null) {
              prevRootElement.classList.remove(...classNames);
            }
          }
          if (nextRootElement !== null) {
            const windowObj = getDefaultView(nextRootElement);
            const style = nextRootElement.style;
            style.userSelect = "text";
            style.whiteSpace = "pre-wrap";
            style.wordBreak = "break-word";
            nextRootElement.setAttribute("data-lexical-editor", "true");
            this._window = windowObj;
            this._dirtyType = FULL_RECONCILE;
            initMutationObserver(this);
            this._updateTags.add("history-merge");
            commitPendingUpdates(this);
            if (!this._config.disableEvents) {
              addRootElementEvents(nextRootElement, this);
            }
            if (classNames != null) {
              nextRootElement.classList.add(...classNames);
            }
          } else {
            this._window = null;
          }
          triggerListeners("root", this, false, nextRootElement, prevRootElement);
        }
      }
      getElementByKey(key) {
        return this._keyToDOMMap.get(key) || null;
      }
      getEditorState() {
        return this._editorState;
      }
      setEditorState(editorState, options) {
        if (editorState.isEmpty()) {
          {
            throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);
          }
        }
        flushRootMutations(this);
        const pendingEditorState = this._pendingEditorState;
        const tags = this._updateTags;
        const tag = options !== void 0 ? options.tag : null;
        if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {
          if (tag != null) {
            tags.add(tag);
          }
          commitPendingUpdates(this);
        }
        this._pendingEditorState = editorState;
        this._dirtyType = FULL_RECONCILE;
        this._dirtyElements.set("root", false);
        this._compositionKey = null;
        if (tag != null) {
          tags.add(tag);
        }
        commitPendingUpdates(this);
      }
      parseEditorState(maybeStringifiedEditorState, updateFn) {
        const serializedEditorState = typeof maybeStringifiedEditorState === "string" ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;
        return parseEditorState(serializedEditorState, this, updateFn);
      }
      update(updateFn, options) {
        updateEditor(this, updateFn, options);
      }
      focus(callbackFn, options = {}) {
        const rootElement = this._rootElement;
        if (rootElement !== null) {
          rootElement.setAttribute("autocapitalize", "off");
          updateEditor(this, () => {
            const selection = $getSelection2();
            const root = $getRoot();
            if (selection !== null) {
              selection.dirty = true;
            } else if (root.getChildrenSize() !== 0) {
              if (options.defaultSelection === "rootStart") {
                root.selectStart();
              } else {
                root.selectEnd();
              }
            }
          }, {
            onUpdate: () => {
              rootElement.removeAttribute("autocapitalize");
              if (callbackFn) {
                callbackFn();
              }
            }
          });
          if (this._pendingEditorState === null) {
            rootElement.removeAttribute("autocapitalize");
          }
        }
      }
      blur() {
        const rootElement = this._rootElement;
        if (rootElement !== null) {
          rootElement.blur();
        }
        const domSelection = getDOMSelection(this._window);
        if (domSelection !== null) {
          domSelection.removeAllRanges();
        }
      }
      isEditable() {
        return this._editable;
      }
      setEditable(editable) {
        if (this._editable !== editable) {
          this._editable = editable;
          triggerListeners("editable", this, true, editable);
        }
      }
      toJSON() {
        return {
          editorState: this._editorState.toJSON()
        };
      }
    };
    var DEPRECATED_GridCellNode = class extends ElementNode {
      /** @internal */
      constructor(colSpan, key) {
        super(key);
        this.__colSpan = colSpan;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          colSpan: this.__colSpan
        };
      }
    };
    function DEPRECATED_$isGridCellNode(node) {
      return node instanceof DEPRECATED_GridCellNode;
    }
    var DEPRECATED_GridNode = class extends ElementNode {
    };
    function DEPRECATED_$isGridNode(node) {
      return node instanceof DEPRECATED_GridNode;
    }
    var DEPRECATED_GridRowNode = class extends ElementNode {
    };
    function DEPRECATED_$isGridRowNode(node) {
      return node instanceof DEPRECATED_GridRowNode;
    }
    exports.$addUpdateTag = $addUpdateTag;
    exports.$applyNodeReplacement = $applyNodeReplacement;
    exports.$copyNode = $copyNode;
    exports.$createLineBreakNode = $createLineBreakNode;
    exports.$createNodeSelection = $createNodeSelection;
    exports.$createParagraphNode = $createParagraphNode2;
    exports.$createRangeSelection = $createRangeSelection;
    exports.$createTextNode = $createTextNode;
    exports.$getAdjacentNode = $getAdjacentNode;
    exports.$getNearestNodeFromDOMNode = $getNearestNodeFromDOMNode;
    exports.$getNearestRootOrShadowRoot = $getNearestRootOrShadowRoot;
    exports.$getNodeByKey = $getNodeByKey;
    exports.$getPreviousSelection = $getPreviousSelection;
    exports.$getRoot = $getRoot;
    exports.$getSelection = $getSelection2;
    exports.$getTextContent = $getTextContent;
    exports.$hasAncestor = $hasAncestor;
    exports.$insertNodes = $insertNodes;
    exports.$isDecoratorNode = $isDecoratorNode;
    exports.$isElementNode = $isElementNode;
    exports.$isInlineElementOrDecoratorNode = $isInlineElementOrDecoratorNode;
    exports.$isLeafNode = $isLeafNode;
    exports.$isLineBreakNode = $isLineBreakNode;
    exports.$isNodeSelection = $isNodeSelection;
    exports.$isParagraphNode = $isParagraphNode;
    exports.$isRangeSelection = $isRangeSelection2;
    exports.$isRootNode = $isRootNode;
    exports.$isRootOrShadowRoot = $isRootOrShadowRoot;
    exports.$isTextNode = $isTextNode;
    exports.$nodesOfType = $nodesOfType;
    exports.$normalizeSelection__EXPERIMENTAL = $normalizeSelection;
    exports.$parseSerializedNode = $parseSerializedNode;
    exports.$setCompositionKey = $setCompositionKey;
    exports.$setSelection = $setSelection2;
    exports.$splitNode = $splitNode;
    exports.BLUR_COMMAND = BLUR_COMMAND;
    exports.CAN_REDO_COMMAND = CAN_REDO_COMMAND;
    exports.CAN_UNDO_COMMAND = CAN_UNDO_COMMAND;
    exports.CLEAR_EDITOR_COMMAND = CLEAR_EDITOR_COMMAND;
    exports.CLEAR_HISTORY_COMMAND = CLEAR_HISTORY_COMMAND;
    exports.CLICK_COMMAND = CLICK_COMMAND;
    exports.COMMAND_PRIORITY_CRITICAL = COMMAND_PRIORITY_CRITICAL;
    exports.COMMAND_PRIORITY_EDITOR = COMMAND_PRIORITY_EDITOR;
    exports.COMMAND_PRIORITY_HIGH = COMMAND_PRIORITY_HIGH;
    exports.COMMAND_PRIORITY_LOW = COMMAND_PRIORITY_LOW2;
    exports.COMMAND_PRIORITY_NORMAL = COMMAND_PRIORITY_NORMAL;
    exports.CONTROLLED_TEXT_INSERTION_COMMAND = CONTROLLED_TEXT_INSERTION_COMMAND;
    exports.COPY_COMMAND = COPY_COMMAND;
    exports.CUT_COMMAND = CUT_COMMAND;
    exports.DELETE_CHARACTER_COMMAND = DELETE_CHARACTER_COMMAND;
    exports.DELETE_LINE_COMMAND = DELETE_LINE_COMMAND;
    exports.DELETE_WORD_COMMAND = DELETE_WORD_COMMAND;
    exports.DEPRECATED_$createGridSelection = DEPRECATED_$createGridSelection;
    exports.DEPRECATED_$isGridCellNode = DEPRECATED_$isGridCellNode;
    exports.DEPRECATED_$isGridNode = DEPRECATED_$isGridNode;
    exports.DEPRECATED_$isGridRowNode = DEPRECATED_$isGridRowNode;
    exports.DEPRECATED_$isGridSelection = DEPRECATED_$isGridSelection;
    exports.DEPRECATED_GridCellNode = DEPRECATED_GridCellNode;
    exports.DEPRECATED_GridNode = DEPRECATED_GridNode;
    exports.DEPRECATED_GridRowNode = DEPRECATED_GridRowNode;
    exports.DRAGEND_COMMAND = DRAGEND_COMMAND;
    exports.DRAGOVER_COMMAND = DRAGOVER_COMMAND;
    exports.DRAGSTART_COMMAND = DRAGSTART_COMMAND;
    exports.DROP_COMMAND = DROP_COMMAND;
    exports.DecoratorNode = DecoratorNode;
    exports.ElementNode = ElementNode;
    exports.FOCUS_COMMAND = FOCUS_COMMAND;
    exports.FORMAT_ELEMENT_COMMAND = FORMAT_ELEMENT_COMMAND;
    exports.FORMAT_TEXT_COMMAND = FORMAT_TEXT_COMMAND2;
    exports.INDENT_CONTENT_COMMAND = INDENT_CONTENT_COMMAND;
    exports.INSERT_LINE_BREAK_COMMAND = INSERT_LINE_BREAK_COMMAND;
    exports.INSERT_PARAGRAPH_COMMAND = INSERT_PARAGRAPH_COMMAND2;
    exports.KEY_ARROW_DOWN_COMMAND = KEY_ARROW_DOWN_COMMAND;
    exports.KEY_ARROW_LEFT_COMMAND = KEY_ARROW_LEFT_COMMAND;
    exports.KEY_ARROW_RIGHT_COMMAND = KEY_ARROW_RIGHT_COMMAND;
    exports.KEY_ARROW_UP_COMMAND = KEY_ARROW_UP_COMMAND;
    exports.KEY_BACKSPACE_COMMAND = KEY_BACKSPACE_COMMAND;
    exports.KEY_DELETE_COMMAND = KEY_DELETE_COMMAND;
    exports.KEY_DOWN_COMMAND = KEY_DOWN_COMMAND;
    exports.KEY_ENTER_COMMAND = KEY_ENTER_COMMAND;
    exports.KEY_ESCAPE_COMMAND = KEY_ESCAPE_COMMAND;
    exports.KEY_MODIFIER_COMMAND = KEY_MODIFIER_COMMAND;
    exports.KEY_SPACE_COMMAND = KEY_SPACE_COMMAND;
    exports.KEY_TAB_COMMAND = KEY_TAB_COMMAND;
    exports.LineBreakNode = LineBreakNode;
    exports.MOVE_TO_END = MOVE_TO_END;
    exports.MOVE_TO_START = MOVE_TO_START;
    exports.OUTDENT_CONTENT_COMMAND = OUTDENT_CONTENT_COMMAND;
    exports.PASTE_COMMAND = PASTE_COMMAND;
    exports.ParagraphNode = ParagraphNode;
    exports.REDO_COMMAND = REDO_COMMAND;
    exports.REMOVE_TEXT_COMMAND = REMOVE_TEXT_COMMAND;
    exports.RootNode = RootNode;
    exports.SELECTION_CHANGE_COMMAND = SELECTION_CHANGE_COMMAND2;
    exports.TextNode = TextNode2;
    exports.UNDO_COMMAND = UNDO_COMMAND;
    exports.createCommand = createCommand;
    exports.createEditor = createEditor;
    exports.isSelectionWithinEditor = isSelectionWithinEditor;
  }
});

// ../node_modules/lexical/Lexical.js
var require_Lexical = __commonJS({
  "../node_modules/lexical/Lexical.js"(exports, module) {
    "use strict";
    var Lexical = true ? require_Lexical_dev() : null;
    module.exports = Lexical;
  }
});

// ../node_modules/@lexical/react/LexicalComposerContext.dev.js
var require_LexicalComposerContext_dev = __commonJS({
  "../node_modules/@lexical/react/LexicalComposerContext.dev.js"(exports) {
    "use strict";
    var react = require_react();
    var LexicalComposerContext = react.createContext(null);
    function createLexicalComposerContext(parent, theme) {
      let parentContext = null;
      if (parent != null) {
        parentContext = parent[1];
      }
      function getTheme() {
        if (theme != null) {
          return theme;
        }
        return parentContext != null ? parentContext.getTheme() : null;
      }
      return {
        getTheme
      };
    }
    function useLexicalComposerContext2() {
      const composerContext = react.useContext(LexicalComposerContext);
      if (composerContext == null) {
        {
          throw Error(`LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext`);
        }
      }
      return composerContext;
    }
    exports.LexicalComposerContext = LexicalComposerContext;
    exports.createLexicalComposerContext = createLexicalComposerContext;
    exports.useLexicalComposerContext = useLexicalComposerContext2;
  }
});

// ../node_modules/@lexical/react/LexicalComposerContext.js
var require_LexicalComposerContext = __commonJS({
  "../node_modules/@lexical/react/LexicalComposerContext.js"(exports, module) {
    "use strict";
    var LexicalComposerContext = true ? require_LexicalComposerContext_dev() : null;
    module.exports = LexicalComposerContext;
  }
});

// ../node_modules/@lexical/react/LexicalComposer.dev.js
var require_LexicalComposer_dev = __commonJS({
  "../node_modules/@lexical/react/LexicalComposer.dev.js"(exports) {
    "use strict";
    var LexicalComposerContext = require_LexicalComposerContext();
    var lexical = require_Lexical();
    var React2 = require_react();
    var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    var useLayoutEffectImpl = CAN_USE_DOM ? React2.useLayoutEffect : React2.useEffect;
    var useLayoutEffect = useLayoutEffectImpl;
    var HISTORY_MERGE_OPTIONS = {
      tag: "history-merge"
    };
    function LexicalComposer2({
      initialConfig,
      children
    }) {
      const composerContext = React2.useMemo(
        () => {
          const {
            theme,
            namespace,
            editor__DEPRECATED: initialEditor,
            nodes,
            onError,
            editorState: initialEditorState
          } = initialConfig;
          const context = LexicalComposerContext.createLexicalComposerContext(null, theme);
          let editor = initialEditor || null;
          if (editor === null) {
            const newEditor = lexical.createEditor({
              editable: false,
              namespace,
              nodes,
              onError: (error) => onError(error, newEditor),
              theme
            });
            initializeEditor(newEditor, initialEditorState);
            editor = newEditor;
          }
          return [editor, context];
        },
        // We only do this for init
        // eslint-disable-next-line react-hooks/exhaustive-deps
        []
      );
      useLayoutEffect(() => {
        const isEditable = initialConfig.editable;
        const [editor] = composerContext;
        editor.setEditable(isEditable !== void 0 ? isEditable : true);
      }, []);
      return React2.createElement(LexicalComposerContext.LexicalComposerContext.Provider, {
        value: composerContext
      }, children);
    }
    function initializeEditor(editor, initialEditorState) {
      if (initialEditorState === null) {
        return;
      } else if (initialEditorState === void 0) {
        editor.update(() => {
          const root = lexical.$getRoot();
          if (root.isEmpty()) {
            const paragraph = lexical.$createParagraphNode();
            root.append(paragraph);
            const activeElement = CAN_USE_DOM ? document.activeElement : null;
            if (lexical.$getSelection() !== null || activeElement !== null && activeElement === editor.getRootElement()) {
              paragraph.select();
            }
          }
        }, HISTORY_MERGE_OPTIONS);
      } else if (initialEditorState !== null) {
        switch (typeof initialEditorState) {
          case "string": {
            const parsedEditorState = editor.parseEditorState(initialEditorState);
            editor.setEditorState(parsedEditorState, HISTORY_MERGE_OPTIONS);
            break;
          }
          case "object": {
            editor.setEditorState(initialEditorState, HISTORY_MERGE_OPTIONS);
            break;
          }
          case "function": {
            editor.update(() => {
              const root = lexical.$getRoot();
              if (root.isEmpty()) {
                initialEditorState(editor);
              }
            }, HISTORY_MERGE_OPTIONS);
            break;
          }
        }
      }
    }
    exports.LexicalComposer = LexicalComposer2;
  }
});

// ../node_modules/@lexical/react/LexicalComposer.js
var require_LexicalComposer = __commonJS({
  "../node_modules/@lexical/react/LexicalComposer.js"(exports, module) {
    "use strict";
    var LexicalComposer2 = true ? require_LexicalComposer_dev() : null;
    module.exports = LexicalComposer2;
  }
});

// ../node_modules/@lexical/react/LexicalErrorBoundary.dev.js
var require_LexicalErrorBoundary_dev = __commonJS({
  "../node_modules/@lexical/react/LexicalErrorBoundary.dev.js"(exports, module) {
    "use strict";
    var React2 = require_react();
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    var changedArray = function changedArray2(a2, b) {
      if (a2 === void 0) {
        a2 = [];
      }
      if (b === void 0) {
        b = [];
      }
      return a2.length !== b.length || a2.some(function(item, index2) {
        return !Object.is(item, b[index2]);
      });
    };
    var initialState = {
      error: null
    };
    var ErrorBoundary = function(_React$Component) {
      _inheritsLoose(ErrorBoundary2, _React$Component);
      function ErrorBoundary2() {
        var _this;
        for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
          _args[_key] = arguments[_key];
        }
        _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;
        _this.state = initialState;
        _this.resetErrorBoundary = function() {
          var _this$props;
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);
          _this.reset();
        };
        return _this;
      }
      ErrorBoundary2.getDerivedStateFromError = function getDerivedStateFromError(error) {
        return {
          error
        };
      };
      var _proto = ErrorBoundary2.prototype;
      _proto.reset = function reset() {
        this.setState(initialState);
      };
      _proto.componentDidCatch = function componentDidCatch(error, info) {
        var _this$props$onError, _this$props2;
        (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);
      };
      _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
        var error = this.state.error;
        var resetKeys = this.props.resetKeys;
        if (error !== null && prevState.error !== null && changedArray(prevProps.resetKeys, resetKeys)) {
          var _this$props$onResetKe, _this$props3;
          (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);
          this.reset();
        }
      };
      _proto.render = function render() {
        var error = this.state.error;
        var _this$props4 = this.props, fallbackRender = _this$props4.fallbackRender, FallbackComponent = _this$props4.FallbackComponent, fallback = _this$props4.fallback;
        if (error !== null) {
          var _props = {
            error,
            resetErrorBoundary: this.resetErrorBoundary
          };
          if (React2.isValidElement(fallback)) {
            return fallback;
          } else if (typeof fallbackRender === "function") {
            return fallbackRender(_props);
          } else if (FallbackComponent) {
            return React2.createElement(FallbackComponent, _props);
          } else {
            throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
          }
        }
        return this.props.children;
      };
      return ErrorBoundary2;
    }(React2.Component);
    function LexicalErrorBoundary2({
      children,
      onError
    }) {
      return React2.createElement(ErrorBoundary, {
        fallback: React2.createElement("div", {
          style: {
            border: "1px solid #f00",
            color: "#f00",
            padding: "8px"
          }
        }, "An error was thrown."),
        onError
      }, children);
    }
    module.exports = LexicalErrorBoundary2;
  }
});

// ../node_modules/@lexical/react/LexicalErrorBoundary.js
var require_LexicalErrorBoundary = __commonJS({
  "../node_modules/@lexical/react/LexicalErrorBoundary.js"(exports, module) {
    "use strict";
    var LexicalErrorBoundary2 = true ? require_LexicalErrorBoundary_dev() : null;
    module.exports = LexicalErrorBoundary2;
  }
});

// ../node_modules/@lexical/react/useLexicalNodeSelection.dev.js
var require_useLexicalNodeSelection_dev = __commonJS({
  "../node_modules/@lexical/react/useLexicalNodeSelection.dev.js"(exports) {
    "use strict";
    var LexicalComposerContext = require_LexicalComposerContext();
    var lexical = require_Lexical();
    var react = require_react();
    function isNodeSelected(editor, key) {
      return editor.getEditorState().read(() => {
        const node = lexical.$getNodeByKey(key);
        if (node === null) {
          return false;
        }
        return node.isSelected();
      });
    }
    function useLexicalNodeSelection(key) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      const [isSelected, setIsSelected] = react.useState(() => isNodeSelected(editor, key));
      react.useEffect(() => {
        let isMounted = true;
        const unregister = editor.registerUpdateListener(() => {
          if (isMounted) {
            setIsSelected(isNodeSelected(editor, key));
          }
        });
        return () => {
          isMounted = false;
          unregister();
        };
      }, [editor, key]);
      const setSelected = react.useCallback((selected) => {
        editor.update(() => {
          let selection = lexical.$getSelection();
          if (!lexical.$isNodeSelection(selection)) {
            selection = lexical.$createNodeSelection();
            lexical.$setSelection(selection);
          }
          if (selected) {
            selection.add(key);
          } else {
            selection.delete(key);
          }
        });
      }, [editor, key]);
      const clearSelected = react.useCallback(() => {
        editor.update(() => {
          const selection = lexical.$getSelection();
          if (lexical.$isNodeSelection(selection)) {
            selection.clear();
          }
        });
      }, [editor]);
      return [isSelected, setSelected, clearSelected];
    }
    exports.useLexicalNodeSelection = useLexicalNodeSelection;
  }
});

// ../node_modules/@lexical/react/useLexicalNodeSelection.js
var require_useLexicalNodeSelection = __commonJS({
  "../node_modules/@lexical/react/useLexicalNodeSelection.js"(exports, module) {
    "use strict";
    var useLexicalNodeSelection = true ? require_useLexicalNodeSelection_dev() : null;
    module.exports = useLexicalNodeSelection;
  }
});

// ../node_modules/@lexical/selection/LexicalSelection.dev.js
var require_LexicalSelection_dev = __commonJS({
  "../node_modules/@lexical/selection/LexicalSelection.dev.js"(exports) {
    "use strict";
    var lexical = require_Lexical();
    var CSS_TO_STYLES = /* @__PURE__ */ new Map();
    function getDOMTextNode(element) {
      let node = element;
      while (node != null) {
        if (node.nodeType === Node.TEXT_NODE) {
          return node;
        }
        node = node.firstChild;
      }
      return null;
    }
    function getDOMIndexWithinParent(node) {
      const parent = node.parentNode;
      if (parent == null) {
        throw new Error("Should never happen");
      }
      return [parent, Array.from(parent.childNodes).indexOf(node)];
    }
    function createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {
      const anchorKey = anchorNode.getKey();
      const focusKey = focusNode.getKey();
      const range2 = document.createRange();
      let anchorDOM = editor.getElementByKey(anchorKey);
      let focusDOM = editor.getElementByKey(focusKey);
      let anchorOffset = _anchorOffset;
      let focusOffset = _focusOffset;
      if (lexical.$isTextNode(anchorNode)) {
        anchorDOM = getDOMTextNode(anchorDOM);
      }
      if (lexical.$isTextNode(focusNode)) {
        focusDOM = getDOMTextNode(focusDOM);
      }
      if (anchorNode === void 0 || focusNode === void 0 || anchorDOM === null || focusDOM === null) {
        return null;
      }
      if (anchorDOM.nodeName === "BR") {
        [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);
      }
      if (focusDOM.nodeName === "BR") {
        [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);
      }
      const firstChild = anchorDOM.firstChild;
      if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === "BR" && anchorOffset === 0 && focusOffset === 0) {
        focusOffset = 1;
      }
      try {
        range2.setStart(anchorDOM, anchorOffset);
        range2.setEnd(focusDOM, focusOffset);
      } catch (e) {
        return null;
      }
      if (range2.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {
        range2.setStart(focusDOM, focusOffset);
        range2.setEnd(anchorDOM, anchorOffset);
      }
      return range2;
    }
    function createRectsFromDOMRange(editor, range2) {
      const rootElement = editor.getRootElement();
      if (rootElement === null) {
        return [];
      }
      const rootRect = rootElement.getBoundingClientRect();
      const computedStyle = getComputedStyle(rootElement);
      const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
      const selectionRects = Array.from(range2.getClientRects());
      let selectionRectsLength = selectionRects.length;
      let prevRect;
      for (let i = 0; i < selectionRectsLength; i++) {
        const selectionRect = selectionRects[i];
        const isDuplicateRect = prevRect && prevRect.top === selectionRect.top && prevRect.left === selectionRect.left && prevRect.width === selectionRect.width && prevRect.height === selectionRect.height;
        const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;
        if (isDuplicateRect || selectionSpansElement) {
          selectionRects.splice(i--, 1);
          selectionRectsLength--;
          continue;
        }
        prevRect = selectionRect;
      }
      return selectionRects;
    }
    function getStyleObjectFromRawCSS(css) {
      const styleObject = {};
      const styles = css.split(";");
      for (const style of styles) {
        if (style !== "") {
          const [key, value3] = style.split(/:([^]+)/);
          styleObject[key.trim()] = value3.trim();
        }
      }
      return styleObject;
    }
    function getStyleObjectFromCSS(css) {
      let value3 = CSS_TO_STYLES.get(css);
      if (value3 === void 0) {
        value3 = getStyleObjectFromRawCSS(css);
        CSS_TO_STYLES.set(css, value3);
      }
      return value3;
    }
    function getCSSFromStyleObject(styles) {
      let css = "";
      for (const style in styles) {
        if (style) {
          css += `${style}: ${styles[style]};`;
        }
      }
      return css;
    }
    function $updateElementNodeProperties(target, source) {
      target.__first = source.__first;
      target.__last = source.__last;
      target.__size = source.__size;
      target.__format = source.__format;
      target.__indent = source.__indent;
      target.__dir = source.__dir;
      return target;
    }
    function $updateTextNodeProperties(target, source) {
      target.__format = source.__format;
      target.__style = source.__style;
      target.__mode = source.__mode;
      target.__detail = source.__detail;
      return target;
    }
    function $cloneWithProperties(node) {
      const latest = node.getLatest();
      const constructor = latest.constructor;
      const clone = constructor.clone(latest);
      clone.__parent = latest.__parent;
      clone.__next = latest.__next;
      clone.__prev = latest.__prev;
      if (lexical.$isElementNode(latest) && lexical.$isElementNode(clone)) {
        return $updateElementNodeProperties(clone, latest);
      }
      if (lexical.$isTextNode(latest) && lexical.$isTextNode(clone)) {
        return $updateTextNodeProperties(clone, latest);
      }
      return clone;
    }
    function $sliceSelectedTextNodeContent(selection, textNode) {
      if (textNode.isSelected() && !textNode.isSegmented() && !textNode.isToken() && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {
        const anchorNode = selection.anchor.getNode();
        const focusNode = selection.focus.getNode();
        const isAnchor = textNode.is(anchorNode);
        const isFocus = textNode.is(focusNode);
        if (isAnchor || isFocus) {
          const isBackward = selection.isBackward();
          const [anchorOffset, focusOffset] = selection.getCharacterOffsets();
          const isSame = anchorNode.is(focusNode);
          const isFirst = textNode.is(isBackward ? focusNode : anchorNode);
          const isLast = textNode.is(isBackward ? anchorNode : focusNode);
          let startOffset = 0;
          let endOffset = void 0;
          if (isSame) {
            startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;
            endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;
          } else if (isFirst) {
            const offset = isBackward ? focusOffset : anchorOffset;
            startOffset = offset;
            endOffset = void 0;
          } else if (isLast) {
            const offset = isBackward ? anchorOffset : focusOffset;
            startOffset = 0;
            endOffset = offset;
          }
          textNode.__text = textNode.__text.slice(startOffset, endOffset);
          return textNode;
        }
      }
      return textNode;
    }
    function $isAtNodeEnd(point6) {
      if (point6.type === "text") {
        return point6.offset === point6.getNode().getTextContentSize();
      }
      return point6.offset === point6.getNode().getChildrenSize();
    }
    function trimTextContentFromAnchor(editor, anchor, delCount) {
      let currentNode = anchor.getNode();
      let remaining = delCount;
      if (lexical.$isElementNode(currentNode)) {
        const descendantNode = currentNode.getDescendantByIndex(anchor.offset);
        if (descendantNode !== null) {
          currentNode = descendantNode;
        }
      }
      while (remaining > 0 && currentNode !== null) {
        let nextNode = currentNode.getPreviousSibling();
        let additionalElementWhitespace = 0;
        if (nextNode === null) {
          let parent = currentNode.getParentOrThrow();
          let parentSibling = parent.getPreviousSibling();
          while (parentSibling === null) {
            parent = parent.getParent();
            if (parent === null) {
              nextNode = null;
              break;
            }
            parentSibling = parent.getPreviousSibling();
          }
          if (parent !== null) {
            additionalElementWhitespace = parent.isInline() ? 0 : 2;
            if (lexical.$isElementNode(parentSibling)) {
              nextNode = parentSibling.getLastDescendant();
            } else {
              nextNode = parentSibling;
            }
          }
        }
        let text = currentNode.getTextContent();
        if (text === "" && lexical.$isElementNode(currentNode) && !currentNode.isInline()) {
          text = "\n\n";
        }
        const textNodeSize = text.length;
        const offset = textNodeSize - remaining;
        const slicedText = text.slice(0, offset);
        if (!lexical.$isTextNode(currentNode) || remaining >= textNodeSize) {
          const parent = currentNode.getParent();
          currentNode.remove();
          if (parent != null && parent.getChildrenSize() === 0) {
            parent.remove();
          }
          remaining -= textNodeSize + additionalElementWhitespace;
          currentNode = nextNode;
        } else {
          const key = currentNode.getKey();
          const prevTextContent = editor.getEditorState().read(() => {
            const prevNode = lexical.$getNodeByKey(key);
            if (lexical.$isTextNode(prevNode) && prevNode.isSimpleText()) {
              return prevNode.getTextContent();
            }
            return null;
          });
          if (prevTextContent !== null && prevTextContent !== text) {
            const prevSelection = lexical.$getPreviousSelection();
            let target = currentNode;
            if (!currentNode.isSimpleText()) {
              const textNode = lexical.$createTextNode(prevTextContent);
              currentNode.replace(textNode);
              target = textNode;
            } else {
              currentNode.setTextContent(prevTextContent);
            }
            if (lexical.$isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {
              const prevOffset = prevSelection.anchor.offset;
              target.select(prevOffset, prevOffset);
            }
          } else if (currentNode.isSimpleText()) {
            const isSelected = anchor.key === key;
            let anchorOffset = anchor.offset;
            if (anchorOffset < remaining) {
              anchorOffset = textNodeSize;
            }
            const splitStart = isSelected ? anchorOffset - remaining : 0;
            const splitEnd = isSelected ? anchorOffset : offset;
            if (isSelected && splitStart === 0) {
              const [excessNode] = currentNode.splitText(splitStart, splitEnd);
              excessNode.remove();
            } else {
              const [, excessNode] = currentNode.splitText(splitStart, splitEnd);
              excessNode.remove();
            }
          } else {
            const textNode = lexical.$createTextNode(slicedText);
            currentNode.replace(textNode);
          }
          remaining = 0;
        }
      }
    }
    function $addNodeStyle(node) {
      const CSSText = node.getStyle();
      const styles = getStyleObjectFromRawCSS(CSSText);
      CSS_TO_STYLES.set(CSSText, styles);
    }
    function $patchStyle(target, patch) {
      const prevStyles = getStyleObjectFromCSS("getStyle" in target ? target.getStyle() : target.style);
      const newStyles = Object.entries(patch).reduce((styles, [key, value3]) => {
        if (value3 === null) {
          delete styles[key];
        } else {
          styles[key] = value3;
        }
        return styles;
      }, {
        ...prevStyles
      });
      const newCSSText = getCSSFromStyleObject(newStyles);
      target.setStyle(newCSSText);
      CSS_TO_STYLES.set(newCSSText, newStyles);
    }
    function $patchStyleText(selection, patch) {
      const selectedNodes = selection.getNodes();
      const selectedNodesLength = selectedNodes.length;
      const lastIndex = selectedNodesLength - 1;
      let firstNode = selectedNodes[0];
      let lastNode = selectedNodes[lastIndex];
      if (selection.isCollapsed()) {
        $patchStyle(selection, patch);
        return;
      }
      const anchor = selection.anchor;
      const focus = selection.focus;
      const firstNodeText = firstNode.getTextContent();
      const firstNodeTextLength = firstNodeText.length;
      const focusOffset = focus.offset;
      let anchorOffset = anchor.offset;
      const isBefore = anchor.isBefore(focus);
      let startOffset = isBefore ? anchorOffset : focusOffset;
      let endOffset = isBefore ? focusOffset : anchorOffset;
      const startType = isBefore ? anchor.type : focus.type;
      const endType = isBefore ? focus.type : anchor.type;
      const endKey = isBefore ? focus.key : anchor.key;
      if (lexical.$isTextNode(firstNode) && startOffset === firstNodeTextLength) {
        const nextSibling = firstNode.getNextSibling();
        if (lexical.$isTextNode(nextSibling)) {
          anchorOffset = 0;
          startOffset = 0;
          firstNode = nextSibling;
        }
      }
      if (firstNode.is(lastNode)) {
        if (lexical.$isTextNode(firstNode)) {
          startOffset = startType === "element" ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;
          endOffset = endType === "element" ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset;
          if (startOffset === endOffset) {
            return;
          }
          if (startOffset === 0 && endOffset === firstNodeTextLength) {
            $patchStyle(firstNode, patch);
            firstNode.select(startOffset, endOffset);
          } else {
            const splitNodes = firstNode.splitText(startOffset, endOffset);
            const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];
            $patchStyle(replacement, patch);
            replacement.select(0, endOffset - startOffset);
          }
        }
      } else {
        if (lexical.$isTextNode(firstNode) && startOffset < firstNode.getTextContentSize()) {
          if (startOffset !== 0) {
            firstNode = firstNode.splitText(startOffset)[1];
            startOffset = 0;
          }
          $patchStyle(firstNode, patch);
        }
        if (lexical.$isTextNode(lastNode)) {
          const lastNodeText = lastNode.getTextContent();
          const lastNodeTextLength = lastNodeText.length;
          if (lastNode.__key !== endKey && endOffset !== 0) {
            endOffset = lastNodeTextLength;
          }
          if (endOffset !== lastNodeTextLength) {
            [lastNode] = lastNode.splitText(endOffset);
          }
          if (endOffset !== 0) {
            $patchStyle(lastNode, patch);
          }
        }
        for (let i = 1; i < lastIndex; i++) {
          const selectedNode = selectedNodes[i];
          const selectedNodeKey = selectedNode.getKey();
          if (lexical.$isTextNode(selectedNode) && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {
            $patchStyle(selectedNode, patch);
          }
        }
      }
    }
    function $setBlocksType_experimental(selection, createElement2) {
      if (selection.anchor.key === "root") {
        const element = createElement2();
        const root = lexical.$getRoot();
        const firstChild = root.getFirstChild();
        if (firstChild)
          firstChild.replace(element, true);
        else
          root.append(element);
        return;
      }
      const nodes = selection.getNodes();
      if (selection.anchor.type === "text") {
        let firstBlock = selection.anchor.getNode().getParent();
        firstBlock = firstBlock.isInline() ? firstBlock.getParent() : firstBlock;
        if (nodes.indexOf(firstBlock) === -1)
          nodes.push(firstBlock);
      }
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (!isBlock(node))
          continue;
        const targetElement = createElement2();
        targetElement.setFormat(node.getFormatType());
        targetElement.setIndent(node.getIndent());
        node.replace(targetElement, true);
      }
    }
    function isBlock(node) {
      return lexical.$isElementNode(node) && !lexical.$isRootOrShadowRoot(node) && !node.isInline();
    }
    function isPointAttached(point6) {
      return point6.getNode().isAttached();
    }
    function $removeParentEmptyElements(startingNode) {
      let node = startingNode;
      while (node !== null && !lexical.$isRootOrShadowRoot(node)) {
        const latest = node.getLatest();
        const parentNode = node.getParent();
        if (latest.getChildrenSize() === 0) {
          node.remove(true);
        }
        node = parentNode;
      }
    }
    function $wrapNodes(selection, createElement2, wrappingElement = null) {
      const nodes = selection.getNodes();
      const nodesLength = nodes.length;
      const anchor = selection.anchor;
      if (nodesLength === 0 || nodesLength === 1 && anchor.type === "element" && anchor.getNode().getChildrenSize() === 0) {
        const target = anchor.type === "text" ? anchor.getNode().getParentOrThrow() : anchor.getNode();
        const children = target.getChildren();
        let element = createElement2();
        element.setFormat(target.getFormatType());
        element.setIndent(target.getIndent());
        children.forEach((child) => element.append(child));
        if (wrappingElement) {
          element = wrappingElement.append(element);
        }
        target.replace(element);
        return;
      }
      let topLevelNode = null;
      let descendants = [];
      for (let i = 0; i < nodesLength; i++) {
        const node = nodes[i];
        if (lexical.$isRootOrShadowRoot(node)) {
          $wrapNodesImpl(selection, descendants, descendants.length, createElement2, wrappingElement);
          descendants = [];
          topLevelNode = node;
        } else if (topLevelNode === null || topLevelNode !== null && lexical.$hasAncestor(node, topLevelNode)) {
          descendants.push(node);
        } else {
          $wrapNodesImpl(selection, descendants, descendants.length, createElement2, wrappingElement);
          descendants = [node];
        }
      }
      $wrapNodesImpl(selection, descendants, descendants.length, createElement2, wrappingElement);
    }
    function $wrapNodesImpl(selection, nodes, nodesLength, createElement2, wrappingElement = null) {
      if (nodes.length === 0) {
        return;
      }
      const firstNode = nodes[0];
      const elementMapping = /* @__PURE__ */ new Map();
      const elements = [];
      let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();
      if (target.isInline()) {
        target = target.getParentOrThrow();
      }
      let targetIsPrevSibling = false;
      while (target !== null) {
        const prevSibling = target.getPreviousSibling();
        if (prevSibling !== null) {
          target = prevSibling;
          targetIsPrevSibling = true;
          break;
        }
        target = target.getParentOrThrow();
        if (lexical.$isRootOrShadowRoot(target)) {
          break;
        }
      }
      const emptyElements = /* @__PURE__ */ new Set();
      for (let i = 0; i < nodesLength; i++) {
        const node = nodes[i];
        if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {
          emptyElements.add(node.getKey());
        }
      }
      const movedNodes = /* @__PURE__ */ new Set();
      for (let i = 0; i < nodesLength; i++) {
        const node = nodes[i];
        let parent = node.getParent();
        if (parent !== null && parent.isInline()) {
          parent = parent.getParent();
        }
        if (parent !== null && lexical.$isLeafNode(node) && !movedNodes.has(node.getKey())) {
          const parentKey = parent.getKey();
          if (elementMapping.get(parentKey) === void 0) {
            const targetElement = createElement2();
            targetElement.setFormat(parent.getFormatType());
            targetElement.setIndent(parent.getIndent());
            elements.push(targetElement);
            elementMapping.set(parentKey, targetElement);
            parent.getChildren().forEach((child) => {
              targetElement.append(child);
              movedNodes.add(child.getKey());
              if (lexical.$isElementNode(child)) {
                child.getChildrenKeys().forEach((key) => movedNodes.add(key));
              }
            });
            $removeParentEmptyElements(parent);
          }
        } else if (emptyElements.has(node.getKey())) {
          const targetElement = createElement2();
          targetElement.setFormat(node.getFormatType());
          targetElement.setIndent(node.getIndent());
          elements.push(targetElement);
          node.remove(true);
        }
      }
      if (wrappingElement !== null) {
        for (let i = 0; i < elements.length; i++) {
          const element = elements[i];
          wrappingElement.append(element);
        }
      }
      let lastElement = null;
      if (lexical.$isRootOrShadowRoot(target)) {
        if (targetIsPrevSibling) {
          if (wrappingElement !== null) {
            target.insertAfter(wrappingElement);
          } else {
            for (let i = elements.length - 1; i >= 0; i--) {
              const element = elements[i];
              target.insertAfter(element);
            }
          }
        } else {
          const firstChild = target.getFirstChild();
          if (lexical.$isElementNode(firstChild)) {
            target = firstChild;
          }
          if (firstChild === null) {
            if (wrappingElement) {
              target.append(wrappingElement);
            } else {
              for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                target.append(element);
                lastElement = element;
              }
            }
          } else {
            if (wrappingElement !== null) {
              firstChild.insertBefore(wrappingElement);
            } else {
              for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                firstChild.insertBefore(element);
                lastElement = element;
              }
            }
          }
        }
      } else {
        if (wrappingElement) {
          target.insertAfter(wrappingElement);
        } else {
          for (let i = elements.length - 1; i >= 0; i--) {
            const element = elements[i];
            target.insertAfter(element);
            lastElement = element;
          }
        }
      }
      const prevSelection = lexical.$getPreviousSelection();
      if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {
        lexical.$setSelection(prevSelection.clone());
      } else if (lastElement !== null) {
        lastElement.selectEnd();
      } else {
        selection.dirty = true;
      }
    }
    function $shouldOverrideDefaultCharacterSelection(selection, isBackward) {
      const possibleNode = lexical.$getAdjacentNode(selection.focus, isBackward);
      return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();
    }
    function $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {
      selection.modify(isHoldingShift ? "extend" : "move", isBackward, granularity);
    }
    function $isParentElementRTL(selection) {
      const anchorNode = selection.anchor.getNode();
      const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();
      return parent.getDirection() === "rtl";
    }
    function $moveCharacter(selection, isHoldingShift, isBackward) {
      const isRTL = $isParentElementRTL(selection);
      $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, "character");
    }
    function $selectAll(selection) {
      const anchor = selection.anchor;
      const focus = selection.focus;
      const anchorNode = anchor.getNode();
      const topParent = anchorNode.getTopLevelElementOrThrow();
      const root = topParent.getParentOrThrow();
      let firstNode = root.getFirstDescendant();
      let lastNode = root.getLastDescendant();
      let firstType = "element";
      let lastType = "element";
      let lastOffset = 0;
      if (lexical.$isTextNode(firstNode)) {
        firstType = "text";
      } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {
        firstNode = firstNode.getParentOrThrow();
      }
      if (lexical.$isTextNode(lastNode)) {
        lastType = "text";
        lastOffset = lastNode.getTextContentSize();
      } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {
        lastNode = lastNode.getParentOrThrow();
      }
      if (firstNode && lastNode) {
        anchor.set(firstNode.getKey(), 0, firstType);
        focus.set(lastNode.getKey(), lastOffset, lastType);
      }
    }
    function $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {
      const css = node.getStyle();
      const styleObject = getStyleObjectFromCSS(css);
      if (styleObject !== null) {
        return styleObject[styleProperty] || defaultValue;
      }
      return defaultValue;
    }
    function $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = "") {
      let styleValue = null;
      const nodes = selection.getNodes();
      const anchor = selection.anchor;
      const focus = selection.focus;
      const isBackward = selection.isBackward();
      const endOffset = isBackward ? focus.offset : anchor.offset;
      const endNode = isBackward ? focus.getNode() : anchor.getNode();
      if (selection.style !== "") {
        const css = selection.style;
        const styleObject = getStyleObjectFromCSS(css);
        if (styleObject !== null && styleProperty in styleObject) {
          return styleObject[styleProperty];
        }
      }
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (i !== 0 && endOffset === 0 && node.is(endNode)) {
          continue;
        }
        if (lexical.$isTextNode(node)) {
          const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);
          if (styleValue === null) {
            styleValue = nodeStyleValue;
          } else if (styleValue !== nodeStyleValue) {
            styleValue = "";
            break;
          }
        }
      }
      return styleValue === null ? defaultValue : styleValue;
    }
    exports.$addNodeStyle = $addNodeStyle;
    exports.$cloneWithProperties = $cloneWithProperties;
    exports.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;
    exports.$isAtNodeEnd = $isAtNodeEnd;
    exports.$isParentElementRTL = $isParentElementRTL;
    exports.$moveCaretSelection = $moveCaretSelection;
    exports.$moveCharacter = $moveCharacter;
    exports.$patchStyleText = $patchStyleText;
    exports.$selectAll = $selectAll;
    exports.$setBlocksType_experimental = $setBlocksType_experimental;
    exports.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;
    exports.$sliceSelectedTextNodeContent = $sliceSelectedTextNodeContent;
    exports.$wrapNodes = $wrapNodes;
    exports.createDOMRange = createDOMRange;
    exports.createRectsFromDOMRange = createRectsFromDOMRange;
    exports.getStyleObjectFromCSS = getStyleObjectFromCSS;
    exports.trimTextContentFromAnchor = trimTextContentFromAnchor;
  }
});

// ../node_modules/@lexical/selection/LexicalSelection.js
var require_LexicalSelection = __commonJS({
  "../node_modules/@lexical/selection/LexicalSelection.js"(exports, module) {
    "use strict";
    var LexicalSelection = true ? require_LexicalSelection_dev() : null;
    module.exports = LexicalSelection;
  }
});

// ../node_modules/@lexical/utils/LexicalUtils.dev.js
var require_LexicalUtils_dev = __commonJS({
  "../node_modules/@lexical/utils/LexicalUtils.dev.js"(exports) {
    "use strict";
    var selection = require_LexicalSelection();
    var lexical = require_Lexical();
    function addClassNamesToElement(element, ...classNames) {
      classNames.forEach((className) => {
        if (typeof className === "string") {
          const classesToAdd = className.split(" ").filter((n) => n !== "");
          element.classList.add(...classesToAdd);
        }
      });
    }
    function removeClassNamesFromElement(element, ...classNames) {
      classNames.forEach((className) => {
        if (typeof className === "string") {
          element.classList.remove(...className.split(" "));
        }
      });
    }
    function isMimeType(file, acceptableMimeTypes) {
      for (const acceptableType of acceptableMimeTypes) {
        if (file.type.startsWith(acceptableType)) {
          return true;
        }
      }
      return false;
    }
    function mediaFileReader(files, acceptableMimeTypes) {
      const filesIterator = files[Symbol.iterator]();
      return new Promise((resolve, reject) => {
        const processed = [];
        const handleNextFile = () => {
          const {
            done,
            value: file
          } = filesIterator.next();
          if (done) {
            return resolve(processed);
          }
          const fileReader = new FileReader();
          fileReader.addEventListener("error", reject);
          fileReader.addEventListener("load", () => {
            const result = fileReader.result;
            if (typeof result === "string") {
              processed.push({
                file,
                result
              });
            }
            handleNextFile();
          });
          if (isMimeType(file, acceptableMimeTypes)) {
            fileReader.readAsDataURL(file);
          } else {
            handleNextFile();
          }
        };
        handleNextFile();
      });
    }
    function $dfs(startingNode, endingNode) {
      const nodes = [];
      const start = (startingNode || lexical.$getRoot()).getLatest();
      const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);
      let node = start;
      let depth = $getDepth(node);
      while (node !== null && !node.is(end)) {
        nodes.push({
          depth,
          node
        });
        if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {
          node = node.getFirstChild();
          depth++;
        } else {
          let sibling = null;
          while (sibling === null && node !== null) {
            sibling = node.getNextSibling();
            if (sibling === null) {
              node = node.getParent();
              depth--;
            } else {
              node = sibling;
            }
          }
        }
      }
      if (node !== null && node.is(end)) {
        nodes.push({
          depth,
          node
        });
      }
      return nodes;
    }
    function $getDepth(node) {
      let innerNode = node;
      let depth = 0;
      while ((innerNode = innerNode.getParent()) !== null) {
        depth++;
      }
      return depth;
    }
    function $getNearestNodeOfType(node, klass) {
      let parent = node;
      while (parent != null) {
        if (parent instanceof klass) {
          return parent;
        }
        parent = parent.getParent();
      }
      return null;
    }
    function $getNearestBlockElementAncestorOrThrow(startNode) {
      const blockNode = $findMatchingParent(startNode, (node) => lexical.$isElementNode(node) && !node.isInline());
      if (!lexical.$isElementNode(blockNode)) {
        {
          throw Error(`Expected node ${startNode.__key} to have closest block element node.`);
        }
      }
      return blockNode;
    }
    function $findMatchingParent(startingNode, findFn) {
      let curr = startingNode;
      while (curr !== lexical.$getRoot() && curr != null) {
        if (findFn(curr)) {
          return curr;
        }
        curr = curr.getParent();
      }
      return null;
    }
    function mergeRegister(...func) {
      return () => {
        func.forEach((f) => f());
      };
    }
    function registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {
      const $isTargetNode = (node) => {
        return node instanceof targetNode;
      };
      const $findMatch = (node) => {
        const children = node.getChildren();
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if ($isTargetNode(child)) {
            return null;
          }
        }
        let parentNode = node;
        let childNode = node;
        while (parentNode !== null) {
          childNode = parentNode;
          parentNode = parentNode.getParent();
          if ($isTargetNode(parentNode)) {
            return {
              child: childNode,
              parent: parentNode
            };
          }
        }
        return null;
      };
      const elementNodeTransform = (node) => {
        const match = $findMatch(node);
        if (match !== null) {
          const {
            child,
            parent
          } = match;
          if (child.is(node)) {
            handleOverlap(parent, node);
            const nextSiblings = child.getNextSiblings();
            const nextSiblingsLength = nextSiblings.length;
            parent.insertAfter(child);
            if (nextSiblingsLength !== 0) {
              const newParent = cloneNode(parent);
              child.insertAfter(newParent);
              for (let i = 0; i < nextSiblingsLength; i++) {
                newParent.append(nextSiblings[i]);
              }
            }
            if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {
              parent.remove();
            }
          }
        }
      };
      return editor.registerNodeTransform(targetNode, elementNodeTransform);
    }
    function $restoreEditorState(editor, editorState) {
      const FULL_RECONCILE = 2;
      const nodeMap = /* @__PURE__ */ new Map();
      const activeEditorState = editor._pendingEditorState;
      for (const [key, node] of editorState._nodeMap) {
        const clone = selection.$cloneWithProperties(node);
        if (lexical.$isTextNode(clone)) {
          clone.__text = node.__text;
        }
        nodeMap.set(key, clone);
      }
      if (activeEditorState) {
        activeEditorState._nodeMap = nodeMap;
      }
      editor._dirtyType = FULL_RECONCILE;
      const selection$1 = editorState._selection;
      lexical.$setSelection(selection$1 === null ? null : selection$1.clone());
    }
    function $insertNodeToNearestRoot(node) {
      const selection2 = lexical.$getSelection();
      if (lexical.$isRangeSelection(selection2)) {
        const {
          focus
        } = selection2;
        const focusNode = focus.getNode();
        const focusOffset = focus.offset;
        if (lexical.$isRootOrShadowRoot(focusNode)) {
          const focusChild = focusNode.getChildAtIndex(focusOffset);
          if (focusChild == null) {
            focusNode.append(node);
          } else {
            focusChild.insertBefore(node);
          }
          node.selectNext();
        } else {
          let splitNode;
          let splitOffset;
          if (lexical.$isTextNode(focusNode)) {
            splitNode = focusNode.getParentOrThrow();
            splitOffset = focusNode.getIndexWithinParent();
            if (focusOffset > 0) {
              splitOffset += 1;
              focusNode.splitText(focusOffset);
            }
          } else {
            splitNode = focusNode;
            splitOffset = focusOffset;
          }
          const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);
          rightTree.insertBefore(node);
          rightTree.selectStart();
        }
      } else {
        if (lexical.$isNodeSelection(selection2) || lexical.DEPRECATED_$isGridSelection(selection2)) {
          const nodes = selection2.getNodes();
          nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);
        } else {
          const root = lexical.$getRoot();
          root.append(node);
        }
        const paragraphNode = lexical.$createParagraphNode();
        node.insertAfter(paragraphNode);
        paragraphNode.select();
      }
      return node.getLatest();
    }
    function $wrapNodeInElement(node, createElementNode) {
      const elementNode = createElementNode();
      node.replace(elementNode);
      elementNode.append(node);
      return elementNode;
    }
    function isHTMLAnchorElement(x4) {
      return isHTMLElement(x4) && x4.tagName === "A";
    }
    function isHTMLElement(x4) {
      return x4.nodeType === 1;
    }
    exports.$splitNode = lexical.$splitNode;
    exports.$dfs = $dfs;
    exports.$findMatchingParent = $findMatchingParent;
    exports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;
    exports.$getNearestNodeOfType = $getNearestNodeOfType;
    exports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;
    exports.$restoreEditorState = $restoreEditorState;
    exports.$wrapNodeInElement = $wrapNodeInElement;
    exports.addClassNamesToElement = addClassNamesToElement;
    exports.isHTMLAnchorElement = isHTMLAnchorElement;
    exports.isHTMLElement = isHTMLElement;
    exports.isMimeType = isMimeType;
    exports.mediaFileReader = mediaFileReader;
    exports.mergeRegister = mergeRegister;
    exports.registerNestedElementResolver = registerNestedElementResolver;
    exports.removeClassNamesFromElement = removeClassNamesFromElement;
  }
});

// ../node_modules/@lexical/utils/LexicalUtils.js
var require_LexicalUtils = __commonJS({
  "../node_modules/@lexical/utils/LexicalUtils.js"(exports, module) {
    "use strict";
    var LexicalUtils = true ? require_LexicalUtils_dev() : null;
    module.exports = LexicalUtils;
  }
});

// ../node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js
var require_LexicalHorizontalRuleNode_dev = __commonJS({
  "../node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js"(exports) {
    "use strict";
    var LexicalComposerContext = require_LexicalComposerContext();
    var useLexicalNodeSelection = require_useLexicalNodeSelection();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    var React2 = require_react();
    var INSERT_HORIZONTAL_RULE_COMMAND = lexical.createCommand("INSERT_HORIZONTAL_RULE_COMMAND");
    function HorizontalRuleComponent({
      nodeKey
    }) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      const [isSelected, setSelected, clearSelection] = useLexicalNodeSelection.useLexicalNodeSelection(nodeKey);
      const onDelete = React2.useCallback((payload) => {
        if (isSelected && lexical.$isNodeSelection(lexical.$getSelection())) {
          const event = payload;
          event.preventDefault();
          const node = lexical.$getNodeByKey(nodeKey);
          if ($isHorizontalRuleNode(node)) {
            node.remove();
          }
          setSelected(false);
        }
        return false;
      }, [isSelected, nodeKey, setSelected]);
      React2.useEffect(() => {
        return utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, (event) => {
          const hrElem = editor.getElementByKey(nodeKey);
          if (event.target === hrElem) {
            if (!event.shiftKey) {
              clearSelection();
            }
            setSelected(!isSelected);
            return true;
          }
          return false;
        }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_DELETE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW));
      }, [clearSelection, editor, isSelected, nodeKey, onDelete, setSelected]);
      React2.useEffect(() => {
        const hrElem = editor.getElementByKey(nodeKey);
        if (hrElem !== null) {
          hrElem.className = isSelected ? "selected" : "";
        }
      }, [editor, isSelected, nodeKey]);
      return null;
    }
    var HorizontalRuleNode2 = class _HorizontalRuleNode extends lexical.DecoratorNode {
      static getType() {
        return "horizontalrule";
      }
      static clone(node) {
        return new _HorizontalRuleNode(node.__key);
      }
      static importJSON(serializedNode) {
        return $createHorizontalRuleNode();
      }
      static importDOM() {
        return {
          hr: () => ({
            conversion: convertHorizontalRuleElement,
            priority: 0
          })
        };
      }
      exportJSON() {
        return {
          type: "horizontalrule",
          version: 1
        };
      }
      exportDOM() {
        return {
          element: document.createElement("hr")
        };
      }
      createDOM() {
        return document.createElement("hr");
      }
      getTextContent() {
        return "\n";
      }
      isInline() {
        return false;
      }
      updateDOM() {
        return false;
      }
      decorate() {
        return React2.createElement(HorizontalRuleComponent, {
          nodeKey: this.__key
        });
      }
    };
    function convertHorizontalRuleElement() {
      return {
        node: $createHorizontalRuleNode()
      };
    }
    function $createHorizontalRuleNode() {
      return lexical.$applyNodeReplacement(new HorizontalRuleNode2());
    }
    function $isHorizontalRuleNode(node) {
      return node instanceof HorizontalRuleNode2;
    }
    exports.$createHorizontalRuleNode = $createHorizontalRuleNode;
    exports.$isHorizontalRuleNode = $isHorizontalRuleNode;
    exports.HorizontalRuleNode = HorizontalRuleNode2;
    exports.INSERT_HORIZONTAL_RULE_COMMAND = INSERT_HORIZONTAL_RULE_COMMAND;
  }
});

// ../node_modules/@lexical/react/LexicalHorizontalRuleNode.js
var require_LexicalHorizontalRuleNode = __commonJS({
  "../node_modules/@lexical/react/LexicalHorizontalRuleNode.js"(exports, module) {
    "use strict";
    var LexicalHorizontalRuleNode = true ? require_LexicalHorizontalRuleNode_dev() : null;
    module.exports = LexicalHorizontalRuleNode;
  }
});

// ../node_modules/prismjs/prism.js
var require_prism = __commonJS({
  "../node_modules/prismjs/prism.js"(exports, module) {
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    var Prism2 = function(_self2) {
      var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _ = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: _self2.Prism && _self2.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function encode(tokens) {
            if (tokens instanceof Token) {
              return new Token(tokens.type, encode(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(o) {
            return Object.prototype.toString.call(o).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function deepClone(o, visited) {
            visited = visited || {};
            var clone;
            var id;
            switch (_.util.type(o)) {
              case "Object":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone = /** @type {Record<string, any>} */
                {};
                visited[id] = clone;
                for (var key in o) {
                  if (o.hasOwnProperty(key)) {
                    clone[key] = deepClone(o[key], visited);
                  }
                }
                return (
                  /** @type {any} */
                  clone
                );
              case "Array":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone = [];
                visited[id] = clone;
                /** @type {Array} */
                /** @type {any} */
                o.forEach(function(v2, i) {
                  clone[i] = deepClone(v2, visited);
                });
                return (
                  /** @type {any} */
                  clone
                );
              default:
                return o;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(element) {
            while (element) {
              var m = lang.exec(element.className);
              if (m) {
                return m[1].toLowerCase();
              }
              element = element.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(element, language) {
            element.className = element.className.replace(RegExp(lang, "gi"), "");
            element.classList.add("language-" + language);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if ("currentScript" in document && 1 < 2) {
              return (
                /** @type {any} */
                document.currentScript
              );
            }
            try {
              throw new Error();
            } catch (err) {
              var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
              if (src) {
                var scripts = document.getElementsByTagName("script");
                for (var i in scripts) {
                  if (scripts[i].src == src) {
                    return scripts[i];
                  }
                }
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(element, className, defaultActivation) {
            var no = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(id, redef) {
            var lang2 = _.util.clone(_.languages[id]);
            for (var key in redef) {
              lang2[key] = redef[key];
            }
            return lang2;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(inside, before, insert, root) {
            root = root || /** @type {any} */
            _.languages;
            var grammar = root[inside];
            var ret = {};
            for (var token in grammar) {
              if (grammar.hasOwnProperty(token)) {
                if (token == before) {
                  for (var newToken in insert) {
                    if (insert.hasOwnProperty(newToken)) {
                      ret[newToken] = insert[newToken];
                    }
                  }
                }
                if (!insert.hasOwnProperty(token)) {
                  ret[token] = grammar[token];
                }
              }
            }
            var old = root[inside];
            root[inside] = ret;
            _.languages.DFS(_.languages, function(key, value3) {
              if (value3 === old && key != inside) {
                this[key] = ret;
              }
            });
            return ret;
          },
          // Traverse a language definition with Depth First Search
          DFS: function DFS(o, callback, type2, visited) {
            visited = visited || {};
            var objId = _.util.objId;
            for (var i in o) {
              if (o.hasOwnProperty(i)) {
                callback.call(o, i, o[i], type2 || i);
                var property = o[i];
                var propertyType = _.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i, visited);
                }
              }
            }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prism’s API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(async, callback) {
          _.highlightAllUnder(document, async, callback);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(container, async, callback) {
          var env = {
            callback,
            container,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _.hooks.run("before-highlightall", env);
          env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
          _.hooks.run("before-all-elements-highlight", env);
          for (var i = 0, element; element = env.elements[i++]; ) {
            _.highlightElement(element, async === true, env.callback);
          }
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(element, async, callback) {
          var language = _.util.getLanguage(element);
          var grammar = _.languages[language];
          _.util.setLanguage(element, language);
          var parent = element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre") {
            _.util.setLanguage(parent, language);
          }
          var code = element.textContent;
          var env = {
            element,
            language,
            grammar,
            code
          };
          function insertHighlightedCode(highlightedCode) {
            env.highlightedCode = highlightedCode;
            _.hooks.run("before-insert", env);
            env.element.innerHTML = env.highlightedCode;
            _.hooks.run("after-highlight", env);
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
          }
          _.hooks.run("before-sanity-check", env);
          parent = env.element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
            parent.setAttribute("tabindex", "0");
          }
          if (!env.code) {
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
            return;
          }
          _.hooks.run("before-highlight", env);
          if (!env.grammar) {
            insertHighlightedCode(_.util.encode(env.code));
            return;
          }
          if (async && _self2.Worker) {
            var worker = new Worker(_.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env.language,
              code: env.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
          }
        },
        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(text, grammar, language) {
          var env = {
            code: text,
            grammar,
            language
          };
          _.hooks.run("before-tokenize", env);
          if (!env.grammar) {
            throw new Error('The language "' + env.language + '" has no grammar.');
          }
          env.tokens = _.tokenize(env.code, env.grammar);
          _.hooks.run("after-tokenize", env);
          return Token.stringify(_.util.encode(env.tokens), env.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest) {
              grammar[token] = rest[token];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text);
          matchGrammar(text, tokenList, grammar, tokenList.head, 0);
          return toArray(tokenList);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(name2, callback) {
            var hooks = _.hooks.all;
            hooks[name2] = hooks[name2] || [];
            hooks[name2].push(callback);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(name2, env) {
            var callbacks = _.hooks.all[name2];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i = 0, callback; callback = callbacks[i++]; ) {
              callback(env);
            }
          }
        },
        Token
      };
      _self2.Prism = _;
      function Token(type2, content, alias, matchedStr) {
        this.type = type2;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify(o, language) {
        if (typeof o == "string") {
          return o;
        }
        if (Array.isArray(o)) {
          var s2 = "";
          o.forEach(function(e) {
            s2 += stringify(e, language);
          });
          return s2;
        }
        var env = {
          type: o.type,
          content: stringify(o.content, language),
          tag: "span",
          classes: ["token", o.type],
          attributes: {},
          language
        };
        var aliases = o.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env.classes, aliases);
          } else {
            env.classes.push(aliases);
          }
        }
        _.hooks.run("wrap", env);
        var attributes = "";
        for (var name2 in env.attributes) {
          attributes += " " + name2 + '="' + (env.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text);
        if (match && lookbehind && match[1]) {
          var lookbehindLength = match[1].length;
          match.index += lookbehindLength;
          match[0] = match[0].slice(lookbehindLength);
        }
        return match;
      }
      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          var patterns = grammar[token];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j = 0; j < patterns.length; ++j) {
            if (rematch && rematch.cause == token + "," + j) {
              return;
            }
            var patternObj = patterns[j];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match;
              if (greedy) {
                match = matchPattern(pattern, pos, text, lookbehind);
                if (!match || match.index >= text.length) {
                  break;
                }
                var from = match.index;
                var to = match.index + match[0].length;
                var p = pos;
                p += currentNode.value.length;
                while (from >= p) {
                  currentNode = currentNode.next;
                  p += currentNode.value.length;
                }
                p -= currentNode.value.length;
                pos = p;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k2 = currentNode; k2 !== tokenList.tail && (p < to || typeof k2.value === "string"); k2 = k2.next) {
                  removeCount++;
                  p += k2.value.length;
                }
                removeCount--;
                str = text.slice(pos, p);
                match.index -= pos;
              } else {
                match = matchPattern(pattern, 0, str, lookbehind);
                if (!match) {
                  continue;
                }
              }
              var from = match.index;
              var matchStr = match[0];
              var before = str.slice(0, from);
              var after = str.slice(from + matchStr.length);
              var reach = pos + str.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token + "," + j,
                  reach
                };
                matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value3) {
        var next = node.next;
        var newNode = { value: value3, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node, count3) {
        var next = node.next;
        for (var i = 0; i < count3 && next !== list.tail; i++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i;
      }
      function toArray(list) {
        var array3 = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array3.push(node.value);
          node = node.next;
        }
        return array3;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _;
        }
        if (!_.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang2 = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self2.postMessage(_.highlight(code, _.languages[lang2], lang2));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _;
      }
      var script = _.util.currentScript();
      if (script) {
        _.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_.manual) {
          _.highlightAll();
        }
      }
      if (!_.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _;
    }(_self);
    if (typeof module !== "undefined" && module.exports) {
      module.exports = Prism2;
    }
    if (typeof global !== "undefined") {
      global.Prism = Prism2;
    }
    Prism2.languages.markup = {
      "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
      },
      "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
      },
      "doctype": {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
            // see below
          },
          "string": {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          "punctuation": /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          "name": /[^\s<>'"]+/
        }
      },
      "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
      },
      "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          "tag": {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              "punctuation": /^<\/?/,
              "namespace": /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: true
                }
              ]
            }
          },
          "punctuation": /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              "namespace": /^[^\s>\/:]+:/
            }
          }
        }
      },
      "entity": [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    };
    Prism2.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism2.languages.markup["entity"];
    Prism2.languages.markup["doctype"].inside["internal-subset"].inside = Prism2.languages.markup;
    Prism2.hooks.add("wrap", function(env) {
      if (env.type === "entity") {
        env.attributes["title"] = env.content.replace(/&amp;/, "&");
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function addInlined(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: Prism2.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: includedCdataInside
          }
        };
        inside["language-" + lang] = {
          pattern: /[\s\S]+/,
          inside: Prism2.languages[lang]
        };
        var def = {};
        def[tagName] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return tagName;
          }), "i"),
          lookbehind: true,
          greedy: true,
          inside
        };
        Prism2.languages.insertBefore("markup", "cdata", def);
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(attrName, lang) {
        Prism2.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                "value": {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [lang, "language-" + lang],
                  inside: Prism2.languages[lang]
                },
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    });
    Prism2.languages.html = Prism2.languages.markup;
    Prism2.languages.mathml = Prism2.languages.markup;
    Prism2.languages.svg = Prism2.languages.markup;
    Prism2.languages.xml = Prism2.languages.extend("markup", {});
    Prism2.languages.ssml = Prism2.languages.xml;
    Prism2.languages.atom = Prism2.languages.xml;
    Prism2.languages.rss = Prism2.languages.xml;
    (function(Prism3) {
      var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      Prism3.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            "rule": /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            "keyword": {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
            // See rest below
          }
        },
        "url": {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: true,
          inside: {
            "function": /^url/i,
            "punctuation": /^\(|\)$/,
            "string": {
              pattern: RegExp("^" + string.source + "$"),
              alias: "url"
            }
          }
        },
        "selector": {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
          lookbehind: true
        },
        "string": {
          pattern: string,
          greedy: true
        },
        "property": {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        "punctuation": /[(){};:,]/
      };
      Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
      var markup = Prism3.languages.markup;
      if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
      }
    })(Prism2);
    Prism2.languages.clike = {
      "comment": [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      "boolean": /\b(?:false|true)\b/,
      "function": /\b\w+(?=\()/,
      "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      "punctuation": /[{}[\];(),.:]/
    };
    Prism2.languages.javascript = Prism2.languages.extend("clike", {
      "class-name": [
        Prism2.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: true
        }
      ],
      "keyword": [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      "number": {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: true
      },
      "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
    Prism2.languages.insertBefore("javascript", "keyword", {
      "regex": {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism2.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      "parameter": [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        }
      ],
      "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism2.languages.insertBefore("javascript", "string", {
      "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          "interpolation": {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Prism2.languages.javascript
            }
          },
          "string": /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
      }
    });
    Prism2.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
      }
    });
    if (Prism2.languages.markup) {
      Prism2.languages.markup.tag.addInlined("script", "javascript");
      Prism2.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
        "javascript"
      );
    }
    Prism2.languages.js = Prism2.languages.javascript;
    (function() {
      if (typeof Prism2 === "undefined" || typeof document === "undefined") {
        return;
      }
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
      }
      var LOADING_MESSAGE = "Loading…";
      var FAILURE_MESSAGE = function(status, message) {
        return "✖ Error " + status + " while fetching file: " + message;
      };
      var FAILURE_EMPTY_MESSAGE = "✖ Error: File does not exist or is empty";
      var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
      };
      var STATUS_ATTR = "data-src-status";
      var STATUS_LOADING = "loading";
      var STATUS_LOADED = "loaded";
      var STATUS_FAILED = "failed";
      var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
      function loadFile(src, success, error) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", src, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            if (xhr.status < 400 && xhr.responseText) {
              success(xhr.responseText);
            } else {
              if (xhr.status >= 400) {
                error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
              } else {
                error(FAILURE_EMPTY_MESSAGE);
              }
            }
          }
        };
        xhr.send(null);
      }
      function parseRange(range2) {
        var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range2 || "");
        if (m) {
          var start = Number(m[1]);
          var comma = m[2];
          var end = m[3];
          if (!comma) {
            return [start, start];
          }
          if (!end) {
            return [start, void 0];
          }
          return [start, Number(end)];
        }
        return void 0;
      }
      Prism2.hooks.add("before-highlightall", function(env) {
        env.selector += ", " + SELECTOR;
      });
      Prism2.hooks.add("before-sanity-check", function(env) {
        var pre = (
          /** @type {HTMLPreElement} */
          env.element
        );
        if (pre.matches(SELECTOR)) {
          env.code = "";
          pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
          var code = pre.appendChild(document.createElement("CODE"));
          code.textContent = LOADING_MESSAGE;
          var src = pre.getAttribute("data-src");
          var language = env.language;
          if (language === "none") {
            var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
            language = EXTENSIONS[extension] || extension;
          }
          Prism2.util.setLanguage(code, language);
          Prism2.util.setLanguage(pre, language);
          var autoloader = Prism2.plugins.autoloader;
          if (autoloader) {
            autoloader.loadLanguages(language);
          }
          loadFile(
            src,
            function(text) {
              pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
              var range2 = parseRange(pre.getAttribute("data-range"));
              if (range2) {
                var lines = text.split(/\r\n?|\n/g);
                var start = range2[0];
                var end = range2[1] == null ? lines.length : range2[1];
                if (start < 0) {
                  start += lines.length;
                }
                start = Math.max(0, Math.min(start - 1, lines.length));
                if (end < 0) {
                  end += lines.length;
                }
                end = Math.max(0, Math.min(end, lines.length));
                text = lines.slice(start, end).join("\n");
                if (!pre.hasAttribute("data-start")) {
                  pre.setAttribute("data-start", String(start + 1));
                }
              }
              code.textContent = text;
              Prism2.highlightElement(code);
            },
            function(error) {
              pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
              code.textContent = error;
            }
          );
        }
      });
      Prism2.plugins.fileHighlight = {
        /**
         * Executes the File Highlight plugin for all matching `pre` elements under the given container.
         *
         * Note: Elements which are already loaded or currently loading will not be touched by this method.
         *
         * @param {ParentNode} [container=document]
         */
        highlight: function highlight(container) {
          var elements = (container || document).querySelectorAll(SELECTOR);
          for (var i = 0, element; element = elements[i++]; ) {
            Prism2.highlightElement(element);
          }
        }
      };
      var logged = false;
      Prism2.fileHighlight = function() {
        if (!logged) {
          console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
          logged = true;
        }
        Prism2.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
  }
});

// ../node_modules/prismjs/components/prism-clike.js
var require_prism_clike = __commonJS({
  "../node_modules/prismjs/components/prism-clike.js"() {
    Prism.languages.clike = {
      "comment": [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      "boolean": /\b(?:false|true)\b/,
      "function": /\b\w+(?=\()/,
      "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      "punctuation": /[{}[\];(),.:]/
    };
  }
});

// ../node_modules/prismjs/components/prism-javascript.js
var require_prism_javascript = __commonJS({
  "../node_modules/prismjs/components/prism-javascript.js"() {
    Prism.languages.javascript = Prism.languages.extend("clike", {
      "class-name": [
        Prism.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: true
        }
      ],
      "keyword": [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      "number": {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: true
      },
      "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
    Prism.languages.insertBefore("javascript", "keyword", {
      "regex": {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      "parameter": [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: Prism.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism.languages.javascript
        }
      ],
      "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism.languages.insertBefore("javascript", "string", {
      "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          "interpolation": {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Prism.languages.javascript
            }
          },
          "string": /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
      }
    });
    Prism.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
      }
    });
    if (Prism.languages.markup) {
      Prism.languages.markup.tag.addInlined("script", "javascript");
      Prism.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
        "javascript"
      );
    }
    Prism.languages.js = Prism.languages.javascript;
  }
});

// ../node_modules/prismjs/components/prism-markup.js
var require_prism_markup = __commonJS({
  "../node_modules/prismjs/components/prism-markup.js"() {
    Prism.languages.markup = {
      "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
      },
      "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
      },
      "doctype": {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
            // see below
          },
          "string": {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          "punctuation": /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          "name": /[^\s<>'"]+/
        }
      },
      "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
      },
      "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          "tag": {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              "punctuation": /^<\/?/,
              "namespace": /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: true
                }
              ]
            }
          },
          "punctuation": /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              "namespace": /^[^\s>\/:]+:/
            }
          }
        }
      },
      "entity": [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    };
    Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
    Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
    Prism.hooks.add("wrap", function(env) {
      if (env.type === "entity") {
        env.attributes["title"] = env.content.replace(/&amp;/, "&");
      }
    });
    Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function addInlined(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: Prism.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: includedCdataInside
          }
        };
        inside["language-" + lang] = {
          pattern: /[\s\S]+/,
          inside: Prism.languages[lang]
        };
        var def = {};
        def[tagName] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return tagName;
          }), "i"),
          lookbehind: true,
          greedy: true,
          inside
        };
        Prism.languages.insertBefore("markup", "cdata", def);
      }
    });
    Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(attrName, lang) {
        Prism.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                "value": {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [lang, "language-" + lang],
                  inside: Prism.languages[lang]
                },
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    });
    Prism.languages.html = Prism.languages.markup;
    Prism.languages.mathml = Prism.languages.markup;
    Prism.languages.svg = Prism.languages.markup;
    Prism.languages.xml = Prism.languages.extend("markup", {});
    Prism.languages.ssml = Prism.languages.xml;
    Prism.languages.atom = Prism.languages.xml;
    Prism.languages.rss = Prism.languages.xml;
  }
});

// ../node_modules/prismjs/components/prism-markdown.js
var require_prism_markdown = __commonJS({
  "../node_modules/prismjs/components/prism-markdown.js"() {
    (function(Prism2) {
      var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
      function createInline(pattern) {
        pattern = pattern.replace(/<inner>/g, function() {
          return inner;
        });
        return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
      }
      var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
      var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
        return tableCell;
      });
      var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
      Prism2.languages.markdown = Prism2.languages.extend("markup", {});
      Prism2.languages.insertBefore("markdown", "prolog", {
        "front-matter-block": {
          pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
          lookbehind: true,
          greedy: true,
          inside: {
            "punctuation": /^---|---$/,
            "front-matter": {
              pattern: /\S+(?:\s+\S+)*/,
              alias: ["yaml", "language-yaml"],
              inside: Prism2.languages.yaml
            }
          }
        },
        "blockquote": {
          // > ...
          pattern: /^>(?:[\t ]*>)*/m,
          alias: "punctuation"
        },
        "table": {
          pattern: RegExp("^" + tableRow + tableLine + "(?:" + tableRow + ")*", "m"),
          inside: {
            "table-data-rows": {
              pattern: RegExp("^(" + tableRow + tableLine + ")(?:" + tableRow + ")*$"),
              lookbehind: true,
              inside: {
                "table-data": {
                  pattern: RegExp(tableCell),
                  inside: Prism2.languages.markdown
                },
                "punctuation": /\|/
              }
            },
            "table-line": {
              pattern: RegExp("^(" + tableRow + ")" + tableLine + "$"),
              lookbehind: true,
              inside: {
                "punctuation": /\||:?-{3,}:?/
              }
            },
            "table-header-row": {
              pattern: RegExp("^" + tableRow + "$"),
              inside: {
                "table-header": {
                  pattern: RegExp(tableCell),
                  alias: "important",
                  inside: Prism2.languages.markdown
                },
                "punctuation": /\|/
              }
            }
          }
        },
        "code": [
          {
            // Prefixed by 4 spaces or 1 tab and preceded by an empty line
            pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
            lookbehind: true,
            alias: "keyword"
          },
          {
            // ```optional language
            // code block
            // ```
            pattern: /^```[\s\S]*?^```$/m,
            greedy: true,
            inside: {
              "code-block": {
                pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
                lookbehind: true
              },
              "code-language": {
                pattern: /^(```).+/,
                lookbehind: true
              },
              "punctuation": /```/
            }
          }
        ],
        "title": [
          {
            // title 1
            // =======
            // title 2
            // -------
            pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
            alias: "important",
            inside: {
              punctuation: /==+$|--+$/
            }
          },
          {
            // # title 1
            // ###### title 6
            pattern: /(^\s*)#.+/m,
            lookbehind: true,
            alias: "important",
            inside: {
              punctuation: /^#+|#+$/
            }
          }
        ],
        "hr": {
          // ***
          // ---
          // * * *
          // -----------
          pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
          lookbehind: true,
          alias: "punctuation"
        },
        "list": {
          // * item
          // + item
          // - item
          // 1. item
          pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
          lookbehind: true,
          alias: "punctuation"
        },
        "url-reference": {
          // [id]: http://example.com "Optional title"
          // [id]: http://example.com 'Optional title'
          // [id]: http://example.com (Optional title)
          // [id]: <http://example.com> "Optional title"
          pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
          inside: {
            "variable": {
              pattern: /^(!?\[)[^\]]+/,
              lookbehind: true
            },
            "string": /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
            "punctuation": /^[\[\]!:]|[<>]/
          },
          alias: "url"
        },
        "bold": {
          // **strong**
          // __strong__
          // allow one nested instance of italic text using the same delimiter
          pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
          lookbehind: true,
          greedy: true,
          inside: {
            "content": {
              pattern: /(^..)[\s\S]+(?=..$)/,
              lookbehind: true,
              inside: {}
              // see below
            },
            "punctuation": /\*\*|__/
          }
        },
        "italic": {
          // *em*
          // _em_
          // allow one nested instance of bold text using the same delimiter
          pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
          lookbehind: true,
          greedy: true,
          inside: {
            "content": {
              pattern: /(^.)[\s\S]+(?=.$)/,
              lookbehind: true,
              inside: {}
              // see below
            },
            "punctuation": /[*_]/
          }
        },
        "strike": {
          // ~~strike through~~
          // ~strike~
          // eslint-disable-next-line regexp/strict
          pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
          lookbehind: true,
          greedy: true,
          inside: {
            "content": {
              pattern: /(^~~?)[\s\S]+(?=\1$)/,
              lookbehind: true,
              inside: {}
              // see below
            },
            "punctuation": /~~?/
          }
        },
        "code-snippet": {
          // `code`
          // ``code``
          pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
          lookbehind: true,
          greedy: true,
          alias: ["code", "keyword"]
        },
        "url": {
          // [example](http://example.com "Optional title")
          // [example][id]
          // [example] [id]
          pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
          lookbehind: true,
          greedy: true,
          inside: {
            "operator": /^!/,
            "content": {
              pattern: /(^\[)[^\]]+(?=\])/,
              lookbehind: true,
              inside: {}
              // see below
            },
            "variable": {
              pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
              lookbehind: true
            },
            "url": {
              pattern: /(^\]\()[^\s)]+/,
              lookbehind: true
            },
            "string": {
              pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
              lookbehind: true
            }
          }
        }
      });
      ["url", "bold", "italic", "strike"].forEach(function(token) {
        ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside) {
          if (token !== inside) {
            Prism2.languages.markdown[token].inside.content.inside[inside] = Prism2.languages.markdown[inside];
          }
        });
      });
      Prism2.hooks.add("after-tokenize", function(env) {
        if (env.language !== "markdown" && env.language !== "md") {
          return;
        }
        function walkTokens(tokens) {
          if (!tokens || typeof tokens === "string") {
            return;
          }
          for (var i = 0, l = tokens.length; i < l; i++) {
            var token = tokens[i];
            if (token.type !== "code") {
              walkTokens(token.content);
              continue;
            }
            var codeLang = token.content[1];
            var codeBlock = token.content[3];
            if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
              var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
              lang = (/[a-z][\w-]*/i.exec(lang) || [""])[0].toLowerCase();
              var alias = "language-" + lang;
              if (!codeBlock.alias) {
                codeBlock.alias = [alias];
              } else if (typeof codeBlock.alias === "string") {
                codeBlock.alias = [codeBlock.alias, alias];
              } else {
                codeBlock.alias.push(alias);
              }
            }
          }
        }
        walkTokens(env.tokens);
      });
      Prism2.hooks.add("wrap", function(env) {
        if (env.type !== "code-block") {
          return;
        }
        var codeLang = "";
        for (var i = 0, l = env.classes.length; i < l; i++) {
          var cls = env.classes[i];
          var match = /language-(.+)/.exec(cls);
          if (match) {
            codeLang = match[1];
            break;
          }
        }
        var grammar = Prism2.languages[codeLang];
        if (!grammar) {
          if (codeLang && codeLang !== "none" && Prism2.plugins.autoloader) {
            var id = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
            env.attributes["id"] = id;
            Prism2.plugins.autoloader.loadLanguages(codeLang, function() {
              var ele = document.getElementById(id);
              if (ele) {
                ele.innerHTML = Prism2.highlight(ele.textContent, Prism2.languages[codeLang], codeLang);
              }
            });
          }
        } else {
          env.content = Prism2.highlight(textContent(env.content), grammar, codeLang);
        }
      });
      var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, "gi");
      var KNOWN_ENTITY_NAMES = {
        "amp": "&",
        "lt": "<",
        "gt": ">",
        "quot": '"'
      };
      var fromCodePoint = String.fromCodePoint || String.fromCharCode;
      function textContent(html2) {
        var text = html2.replace(tagPattern, "");
        text = text.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m, code) {
          code = code.toLowerCase();
          if (code[0] === "#") {
            var value3;
            if (code[1] === "x") {
              value3 = parseInt(code.slice(2), 16);
            } else {
              value3 = Number(code.slice(1));
            }
            return fromCodePoint(value3);
          } else {
            var known = KNOWN_ENTITY_NAMES[code];
            if (known) {
              return known;
            }
            return m;
          }
        });
        return text;
      }
      Prism2.languages.md = Prism2.languages.markdown;
    })(Prism);
  }
});

// ../node_modules/prismjs/components/prism-c.js
var require_prism_c = __commonJS({
  "../node_modules/prismjs/components/prism-c.js"() {
    Prism.languages.c = Prism.languages.extend("clike", {
      "comment": {
        pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
        greedy: true
      },
      "string": {
        // https://en.cppreference.com/w/c/language/string_literal
        pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
        lookbehind: true
      },
      "keyword": /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
      "function": /\b[a-z_]\w*(?=\s*\()/i,
      "number": /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
      "operator": />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
    });
    Prism.languages.insertBefore("c", "string", {
      "char": {
        // https://en.cppreference.com/w/c/language/character_constant
        pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
        greedy: true
      }
    });
    Prism.languages.insertBefore("c", "string", {
      "macro": {
        // allow for multiline macro definitions
        // spaces after the # character compile fine with gcc
        pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
        lookbehind: true,
        greedy: true,
        alias: "property",
        inside: {
          "string": [
            {
              // highlight the path of the include statement as a string
              pattern: /^(#\s*include\s*)<[^>]+>/,
              lookbehind: true
            },
            Prism.languages.c["string"]
          ],
          "char": Prism.languages.c["char"],
          "comment": Prism.languages.c["comment"],
          "macro-name": [
            {
              pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
              lookbehind: true
            },
            {
              pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
              lookbehind: true,
              alias: "function"
            }
          ],
          // highlight macro directives as keywords
          "directive": {
            pattern: /^(#\s*)[a-z]+/,
            lookbehind: true,
            alias: "keyword"
          },
          "directive-hash": /^#/,
          "punctuation": /##|\\(?=[\r\n])/,
          "expression": {
            pattern: /\S[\s\S]*/,
            inside: Prism.languages.c
          }
        }
      }
    });
    Prism.languages.insertBefore("c", "function", {
      // highlight predefined macros as constants
      "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
    });
    delete Prism.languages.c["boolean"];
  }
});

// ../node_modules/prismjs/components/prism-css.js
var require_prism_css = __commonJS({
  "../node_modules/prismjs/components/prism-css.js"() {
    (function(Prism2) {
      var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      Prism2.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            "rule": /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            "keyword": {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
            // See rest below
          }
        },
        "url": {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: true,
          inside: {
            "function": /^url/i,
            "punctuation": /^\(|\)$/,
            "string": {
              pattern: RegExp("^" + string.source + "$"),
              alias: "url"
            }
          }
        },
        "selector": {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
          lookbehind: true
        },
        "string": {
          pattern: string,
          greedy: true
        },
        "property": {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        "punctuation": /[(){};:,]/
      };
      Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
      var markup = Prism2.languages.markup;
      if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
      }
    })(Prism);
  }
});

// ../node_modules/prismjs/components/prism-objectivec.js
var require_prism_objectivec = __commonJS({
  "../node_modules/prismjs/components/prism-objectivec.js"() {
    Prism.languages.objectivec = Prism.languages.extend("c", {
      "string": {
        pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
        greedy: true
      },
      "keyword": /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
      "operator": /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
    });
    delete Prism.languages.objectivec["class-name"];
    Prism.languages.objc = Prism.languages.objectivec;
  }
});

// ../node_modules/prismjs/components/prism-sql.js
var require_prism_sql = __commonJS({
  "../node_modules/prismjs/components/prism-sql.js"() {
    Prism.languages.sql = {
      "comment": {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
        lookbehind: true
      },
      "variable": [
        {
          pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
          greedy: true
        },
        /@[\w.$]+/
      ],
      "string": {
        pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
        greedy: true,
        lookbehind: true
      },
      "identifier": {
        pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
        greedy: true,
        lookbehind: true,
        inside: {
          "punctuation": /^`|`$/
        }
      },
      "function": /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
      // Should we highlight user defined functions too?
      "keyword": /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
      "boolean": /\b(?:FALSE|NULL|TRUE)\b/i,
      "number": /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
      "operator": /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
      "punctuation": /[;[\]()`,.]/
    };
  }
});

// ../node_modules/prismjs/components/prism-python.js
var require_prism_python = __commonJS({
  "../node_modules/prismjs/components/prism-python.js"() {
    Prism.languages.python = {
      "comment": {
        pattern: /(^|[^\\])#.*/,
        lookbehind: true,
        greedy: true
      },
      "string-interpolation": {
        pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
        greedy: true,
        inside: {
          "interpolation": {
            // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
            pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
            lookbehind: true,
            inside: {
              "format-spec": {
                pattern: /(:)[^:(){}]+(?=\}$)/,
                lookbehind: true
              },
              "conversion-option": {
                pattern: /![sra](?=[:}]$)/,
                alias: "punctuation"
              },
              rest: null
            }
          },
          "string": /[\s\S]+/
        }
      },
      "triple-quoted-string": {
        pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
        greedy: true,
        alias: "string"
      },
      "string": {
        pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
        greedy: true
      },
      "function": {
        pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
        lookbehind: true
      },
      "class-name": {
        pattern: /(\bclass\s+)\w+/i,
        lookbehind: true
      },
      "decorator": {
        pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
        lookbehind: true,
        alias: ["annotation", "punctuation"],
        inside: {
          "punctuation": /\./
        }
      },
      "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
      "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
      "boolean": /\b(?:False|None|True)\b/,
      "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
      "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
      "punctuation": /[{}[\];(),.:]/
    };
    Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;
    Prism.languages.py = Prism.languages.python;
  }
});

// ../node_modules/prismjs/components/prism-rust.js
var require_prism_rust = __commonJS({
  "../node_modules/prismjs/components/prism-rust.js"() {
    (function(Prism2) {
      var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
      for (var i = 0; i < 2; i++) {
        multilineComment = multilineComment.replace(/<self>/g, function() {
          return multilineComment;
        });
      }
      multilineComment = multilineComment.replace(/<self>/g, function() {
        return /[^\s\S]/.source;
      });
      Prism2.languages.rust = {
        "comment": [
          {
            pattern: RegExp(/(^|[^\\])/.source + multilineComment),
            lookbehind: true,
            greedy: true
          },
          {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: true,
            greedy: true
          }
        ],
        "string": {
          pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
          greedy: true
        },
        "char": {
          pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
          greedy: true
        },
        "attribute": {
          pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
          greedy: true,
          alias: "attr-name",
          inside: {
            "string": null
            // see below
          }
        },
        // Closure params should not be confused with bitwise OR |
        "closure-params": {
          pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
          lookbehind: true,
          greedy: true,
          inside: {
            "closure-punctuation": {
              pattern: /^\||\|$/,
              alias: "punctuation"
            },
            rest: null
            // see below
          }
        },
        "lifetime-annotation": {
          pattern: /'\w+/,
          alias: "symbol"
        },
        "fragment-specifier": {
          pattern: /(\$\w+:)[a-z]+/,
          lookbehind: true,
          alias: "punctuation"
        },
        "variable": /\$\w+/,
        "function-definition": {
          pattern: /(\bfn\s+)\w+/,
          lookbehind: true,
          alias: "function"
        },
        "type-definition": {
          pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
          lookbehind: true,
          alias: "class-name"
        },
        "module-declaration": [
          {
            pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
            lookbehind: true,
            alias: "namespace"
          },
          {
            pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
            lookbehind: true,
            alias: "namespace",
            inside: {
              "punctuation": /::/
            }
          }
        ],
        "keyword": [
          // https://github.com/rust-lang/reference/blob/master/src/keywords.md
          /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
          // primitives and str
          // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
          /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
        ],
        // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
        // and Rust's naming conventions recommend snake_case anyway.
        // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
        "function": /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
        "macro": {
          pattern: /\b\w+!/,
          alias: "property"
        },
        "constant": /\b[A-Z_][A-Z_\d]+\b/,
        "class-name": /\b[A-Z]\w*\b/,
        "namespace": {
          pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
          inside: {
            "punctuation": /::/
          }
        },
        // Hex, oct, bin, dec numbers with visual separators and type suffix
        "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
        "boolean": /\b(?:false|true)\b/,
        "punctuation": /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
        "operator": /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
      };
      Prism2.languages.rust["closure-params"].inside.rest = Prism2.languages.rust;
      Prism2.languages.rust["attribute"].inside["string"] = Prism2.languages.rust["string"];
    })(Prism);
  }
});

// ../node_modules/prismjs/components/prism-swift.js
var require_prism_swift = __commonJS({
  "../node_modules/prismjs/components/prism-swift.js"() {
    Prism.languages.swift = {
      "comment": {
        // Nested comments are supported up to 2 levels
        pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
        lookbehind: true,
        greedy: true
      },
      "string-literal": [
        // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
        {
          pattern: RegExp(
            /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
          ),
          lookbehind: true,
          greedy: true,
          inside: {
            "interpolation": {
              pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
              lookbehind: true,
              inside: null
              // see below
            },
            "interpolation-punctuation": {
              pattern: /^\)|\\\($/,
              alias: "punctuation"
            },
            "punctuation": /\\(?=[\r\n])/,
            "string": /[\s\S]+/
          }
        },
        {
          pattern: RegExp(
            /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
          ),
          lookbehind: true,
          greedy: true,
          inside: {
            "interpolation": {
              pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
              lookbehind: true,
              inside: null
              // see below
            },
            "interpolation-punctuation": {
              pattern: /^\)|\\#+\($/,
              alias: "punctuation"
            },
            "string": /[\s\S]+/
          }
        }
      ],
      "directive": {
        // directives with conditions
        pattern: RegExp(
          /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
        ),
        alias: "property",
        inside: {
          "directive-name": /^#\w+/,
          "boolean": /\b(?:false|true)\b/,
          "number": /\b\d+(?:\.\d+)*\b/,
          "operator": /!|&&|\|\||[<>]=?/,
          "punctuation": /[(),]/
        }
      },
      "literal": {
        pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
        alias: "constant"
      },
      "other-directive": {
        pattern: /#\w+\b/,
        alias: "property"
      },
      "attribute": {
        pattern: /@\w+/,
        alias: "atrule"
      },
      "function-definition": {
        pattern: /(\bfunc\s+)\w+/,
        lookbehind: true,
        alias: "function"
      },
      "label": {
        // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
        pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
        lookbehind: true,
        alias: "important"
      },
      "keyword": /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
      "boolean": /\b(?:false|true)\b/,
      "nil": {
        pattern: /\bnil\b/,
        alias: "constant"
      },
      "short-argument": /\$\d+\b/,
      "omit": {
        pattern: /\b_\b/,
        alias: "keyword"
      },
      "number": /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
      // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
      "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
      "function": /\b[a-z_]\w*(?=\s*\()/i,
      "constant": /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
      // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
      // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
      // This regex only supports ASCII operators.
      "operator": /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
      "punctuation": /[{}[\]();,.:\\]/
    };
    Prism.languages.swift["string-literal"].forEach(function(rule) {
      rule.inside["interpolation"].inside = Prism.languages.swift;
    });
  }
});

// ../node_modules/prismjs/components/prism-typescript.js
var require_prism_typescript = __commonJS({
  "../node_modules/prismjs/components/prism-typescript.js"() {
    (function(Prism2) {
      Prism2.languages.typescript = Prism2.languages.extend("javascript", {
        "class-name": {
          pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
          lookbehind: true,
          greedy: true,
          inside: null
          // see below
        },
        "builtin": /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
      });
      Prism2.languages.typescript.keyword.push(
        /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
        // keywords that have to be followed by an identifier
        /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
        // This is for `import type *, {}`
        /\btype\b(?=\s*(?:[\{*]|$))/
      );
      delete Prism2.languages.typescript["parameter"];
      delete Prism2.languages.typescript["literal-property"];
      var typeInside = Prism2.languages.extend("typescript", {});
      delete typeInside["class-name"];
      Prism2.languages.typescript["class-name"].inside = typeInside;
      Prism2.languages.insertBefore("typescript", "function", {
        "decorator": {
          pattern: /@[$\w\xA0-\uFFFF]+/,
          inside: {
            "at": {
              pattern: /^@/,
              alias: "operator"
            },
            "function": /^[\s\S]+/
          }
        },
        "generic-function": {
          // e.g. foo<T extends "bar" | "baz">( ...
          pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
          greedy: true,
          inside: {
            "function": /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
            "generic": {
              pattern: /<[\s\S]+/,
              // everything after the first <
              alias: "class-name",
              inside: typeInside
            }
          }
        }
      });
      Prism2.languages.ts = Prism2.languages.typescript;
    })(Prism);
  }
});

// ../node_modules/prismjs/components/prism-java.js
var require_prism_java = __commonJS({
  "../node_modules/prismjs/components/prism-java.js"() {
    (function(Prism2) {
      var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
      var classNamePrefix = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
      var className = {
        pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
        lookbehind: true,
        inside: {
          "namespace": {
            pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
            inside: {
              "punctuation": /\./
            }
          },
          "punctuation": /\./
        }
      };
      Prism2.languages.java = Prism2.languages.extend("clike", {
        "string": {
          pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
          lookbehind: true,
          greedy: true
        },
        "class-name": [
          className,
          {
            // variables, parameters, and constructor references
            // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
            pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
            lookbehind: true,
            inside: className.inside
          },
          {
            // class names based on keyword
            // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
            pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix + /[A-Z]\w*\b/.source),
            lookbehind: true,
            inside: className.inside
          }
        ],
        "keyword": keywords,
        "function": [
          Prism2.languages.clike.function,
          {
            pattern: /(::\s*)[a-z_]\w*/,
            lookbehind: true
          }
        ],
        "number": /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
        "operator": {
          pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
          lookbehind: true
        },
        "constant": /\b[A-Z][A-Z_\d]+\b/
      });
      Prism2.languages.insertBefore("java", "string", {
        "triple-quoted-string": {
          // http://openjdk.java.net/jeps/355#Description
          pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
          greedy: true,
          alias: "string"
        },
        "char": {
          pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
          greedy: true
        }
      });
      Prism2.languages.insertBefore("java", "class-name", {
        "annotation": {
          pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
          lookbehind: true,
          alias: "punctuation"
        },
        "generics": {
          pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
          inside: {
            "class-name": className,
            "keyword": keywords,
            "punctuation": /[<>(),.:]/,
            "operator": /[?&|]/
          }
        },
        "import": [
          {
            pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
            lookbehind: true,
            inside: {
              "namespace": className.inside.namespace,
              "punctuation": /\./,
              "operator": /\*/,
              "class-name": /\w+/
            }
          },
          {
            pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix + /(?:\w+|\*)(?=\s*;)/.source),
            lookbehind: true,
            alias: "static",
            inside: {
              "namespace": className.inside.namespace,
              "static": /\b\w+$/,
              "punctuation": /\./,
              "operator": /\*/,
              "class-name": /\w+/
            }
          }
        ],
        "namespace": {
          pattern: RegExp(
            /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
              return keywords.source;
            })
          ),
          lookbehind: true,
          inside: {
            "punctuation": /\./
          }
        }
      });
    })(Prism);
  }
});

// ../node_modules/prismjs/components/prism-cpp.js
var require_prism_cpp = __commonJS({
  "../node_modules/prismjs/components/prism-cpp.js"() {
    (function(Prism2) {
      var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
      var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
        return keyword.source;
      });
      Prism2.languages.cpp = Prism2.languages.extend("c", {
        "class-name": [
          {
            pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
              return keyword.source;
            })),
            lookbehind: true
          },
          // This is intended to capture the class name of method implementations like:
          //   void foo::bar() const {}
          // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
          // it starts with an uppercase letter. This approximation should give decent results.
          /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
          // This will capture the class name before destructors like:
          //   Foo::~Foo() {}
          /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
          // This also intends to capture the class name of method implementations but here the class has template
          // parameters, so it can't be a namespace (until C++ adds generic namespaces).
          /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
        ],
        "keyword": keyword,
        "number": {
          pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
          greedy: true
        },
        "operator": />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
        "boolean": /\b(?:false|true)\b/
      });
      Prism2.languages.insertBefore("cpp", "string", {
        "module": {
          // https://en.cppreference.com/w/cpp/language/modules
          pattern: RegExp(
            /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
            /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
            /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
              return modName;
            }) + ")"
          ),
          lookbehind: true,
          greedy: true,
          inside: {
            "string": /^[<"][\s\S]+/,
            "operator": /:/,
            "punctuation": /\./
          }
        },
        "raw-string": {
          pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
          alias: "string",
          greedy: true
        }
      });
      Prism2.languages.insertBefore("cpp", "keyword", {
        "generic-function": {
          pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
          inside: {
            "function": /^\w+/,
            "generic": {
              pattern: /<[\s\S]+/,
              alias: "class-name",
              inside: Prism2.languages.cpp
            }
          }
        }
      });
      Prism2.languages.insertBefore("cpp", "operator", {
        "double-colon": {
          pattern: /::/,
          alias: "punctuation"
        }
      });
      Prism2.languages.insertBefore("cpp", "class-name", {
        // the base clause is an optional list of parent classes
        // https://en.cppreference.com/w/cpp/language/class
        "base-clause": {
          pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
          lookbehind: true,
          greedy: true,
          inside: Prism2.languages.extend("cpp", {})
        }
      });
      Prism2.languages.insertBefore("inside", "double-colon", {
        // All untokenized words that are not namespaces should be class names
        "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
      }, Prism2.languages.cpp["base-clause"]);
    })(Prism);
  }
});

// ../node_modules/@lexical/code/LexicalCode.dev.js
var require_LexicalCode_dev = __commonJS({
  "../node_modules/@lexical/code/LexicalCode.dev.js"(exports) {
    "use strict";
    var Prism2 = require_prism();
    require_prism_clike();
    require_prism_javascript();
    require_prism_markup();
    require_prism_markdown();
    require_prism_c();
    require_prism_css();
    require_prism_objectivec();
    require_prism_sql();
    require_prism_python();
    require_prism_rust();
    require_prism_swift();
    require_prism_typescript();
    require_prism_java();
    require_prism_cpp();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    var mapToPrismLanguage = (language) => {
      return language != null && Prism2.languages.hasOwnProperty(language) ? language : void 0;
    };
    function hasChildDOMNodeTag(node, tagName) {
      for (const child of node.childNodes) {
        if (utils.isHTMLElement(child) && child.tagName === tagName) {
          return true;
        }
        hasChildDOMNodeTag(child, tagName);
      }
      return false;
    }
    var LANGUAGE_DATA_ATTRIBUTE = "data-highlight-language";
    var CodeNode = class _CodeNode extends lexical.ElementNode {
      /** @internal */
      static getType() {
        return "code";
      }
      static clone(node) {
        return new _CodeNode(node.__language, node.__key);
      }
      constructor(language, key) {
        super(key);
        this.__language = mapToPrismLanguage(language);
      }
      // View
      createDOM(config) {
        const element = document.createElement("code");
        utils.addClassNamesToElement(element, config.theme.code);
        element.setAttribute("spellcheck", "false");
        const language = this.getLanguage();
        if (language) {
          element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);
        }
        return element;
      }
      updateDOM(prevNode, dom, config) {
        const language = this.__language;
        const prevLanguage = prevNode.__language;
        if (language) {
          if (language !== prevLanguage) {
            dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);
          }
        } else if (prevLanguage) {
          dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);
        }
        return false;
      }
      static importDOM() {
        return {
          // Typically <pre> is used for code blocks, and <code> for inline code styles
          // but if it's a multi line <code> we'll create a block. Pass through to
          // inline format handled by TextNode otherwise.
          code: (node) => {
            const isMultiLine = node.textContent != null && (/\r?\n/.test(node.textContent) || hasChildDOMNodeTag(node, "BR"));
            return isMultiLine ? {
              conversion: convertPreElement,
              priority: 1
            } : null;
          },
          div: (node) => ({
            conversion: convertDivElement,
            priority: 1
          }),
          pre: (node) => ({
            conversion: convertPreElement,
            priority: 0
          }),
          table: (node) => {
            const table = node;
            if (isGitHubCodeTable(table)) {
              return {
                conversion: convertTableElement,
                priority: 3
              };
            }
            return null;
          },
          td: (node) => {
            const td = node;
            const table = td.closest("table");
            if (isGitHubCodeCell(td)) {
              return {
                conversion: convertTableCellElement,
                priority: 3
              };
            }
            if (table && isGitHubCodeTable(table)) {
              return {
                conversion: convertCodeNoop,
                priority: 3
              };
            }
            return null;
          },
          tr: (node) => {
            const tr = node;
            const table = tr.closest("table");
            if (table && isGitHubCodeTable(table)) {
              return {
                conversion: convertCodeNoop,
                priority: 3
              };
            }
            return null;
          }
        };
      }
      static importJSON(serializedNode) {
        const node = $createCodeNode(serializedNode.language);
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        return node;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          language: this.getLanguage(),
          type: "code",
          version: 1
        };
      }
      // Mutation
      insertNewAfter(selection, restoreSelection = true) {
        const children = this.getChildren();
        const childrenLength = children.length;
        if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === "\n" && children[childrenLength - 2].getTextContent() === "\n" && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {
          children[childrenLength - 1].remove();
          children[childrenLength - 2].remove();
          const newElement = lexical.$createParagraphNode();
          this.insertAfter(newElement, restoreSelection);
          return newElement;
        }
        const anchor = selection.anchor.getNode();
        const firstNode = getFirstCodeHighlightNodeOfLine(anchor);
        if (firstNode != null) {
          let leadingWhitespace = 0;
          const firstNodeText = firstNode.getTextContent();
          while (leadingWhitespace < firstNodeText.length && /[\t ]/.test(firstNodeText[leadingWhitespace])) {
            leadingWhitespace += 1;
          }
          if (leadingWhitespace > 0) {
            const whitespace = firstNodeText.substring(0, leadingWhitespace);
            const indentedChild = $createCodeHighlightNode(whitespace);
            anchor.insertAfter(indentedChild);
            selection.insertNodes([lexical.$createLineBreakNode()]);
            indentedChild.select();
            return indentedChild;
          }
        }
        return null;
      }
      canInsertTab() {
        const selection = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {
          return false;
        }
        return true;
      }
      canIndent() {
        return false;
      }
      collapseAtStart() {
        const paragraph = lexical.$createParagraphNode();
        const children = this.getChildren();
        children.forEach((child) => paragraph.append(child));
        this.replace(paragraph);
        return true;
      }
      setLanguage(language) {
        const writable = this.getWritable();
        writable.__language = mapToPrismLanguage(language);
      }
      getLanguage() {
        return this.getLatest().__language;
      }
    };
    function $createCodeNode(language) {
      return lexical.$applyNodeReplacement(new CodeNode(language));
    }
    function $isCodeNode(node) {
      return node instanceof CodeNode;
    }
    function convertPreElement(domNode) {
      return {
        node: $createCodeNode(),
        preformatted: true
      };
    }
    function convertDivElement(domNode) {
      const div = domNode;
      const isCode = isCodeElement(div);
      if (!isCode && !isCodeChildElement(div)) {
        return {
          node: null
        };
      }
      return {
        after: (childLexicalNodes) => {
          const domParent = domNode.parentNode;
          if (domParent != null && domNode !== domParent.lastChild) {
            childLexicalNodes.push(lexical.$createLineBreakNode());
          }
          return childLexicalNodes;
        },
        node: isCode ? $createCodeNode() : null,
        preformatted: isCode
      };
    }
    function convertTableElement() {
      return {
        node: $createCodeNode(),
        preformatted: true
      };
    }
    function convertCodeNoop() {
      return {
        node: null
      };
    }
    function convertTableCellElement(domNode) {
      const cell = domNode;
      return {
        after: (childLexicalNodes) => {
          if (cell.parentNode && cell.parentNode.nextSibling) {
            childLexicalNodes.push(lexical.$createLineBreakNode());
          }
          return childLexicalNodes;
        },
        node: null
      };
    }
    function isCodeElement(div) {
      return div.style.fontFamily.match("monospace") !== null;
    }
    function isCodeChildElement(node) {
      let parent = node.parentElement;
      while (parent !== null) {
        if (isCodeElement(parent)) {
          return true;
        }
        parent = parent.parentElement;
      }
      return false;
    }
    function isGitHubCodeCell(cell) {
      return cell.classList.contains("js-file-line");
    }
    function isGitHubCodeTable(table) {
      return table.classList.contains("js-file-line-container");
    }
    var DEFAULT_CODE_LANGUAGE = "javascript";
    var CODE_LANGUAGE_FRIENDLY_NAME_MAP = {
      c: "C",
      clike: "C-like",
      cpp: "C++",
      css: "CSS",
      html: "HTML",
      java: "Java",
      js: "JavaScript",
      markdown: "Markdown",
      objc: "Objective-C",
      plain: "Plain Text",
      py: "Python",
      rust: "Rust",
      sql: "SQL",
      swift: "Swift",
      typescript: "TypeScript",
      xml: "XML"
    };
    var CODE_LANGUAGE_MAP = {
      cpp: "cpp",
      java: "java",
      javascript: "js",
      md: "markdown",
      plaintext: "plain",
      python: "py",
      text: "plain",
      ts: "typescript"
    };
    function normalizeCodeLang(lang) {
      return CODE_LANGUAGE_MAP[lang] || lang;
    }
    function getLanguageFriendlyName(lang) {
      const _lang = normalizeCodeLang(lang);
      return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;
    }
    var getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;
    var getCodeLanguages = () => Object.keys(Prism2.languages).filter(
      // Prism has several language helpers mixed into languages object
      // so filtering them out here to get langs list
      (language) => typeof Prism2.languages[language] !== "function"
    ).sort();
    var CodeHighlightNode = class _CodeHighlightNode extends lexical.TextNode {
      /** @internal */
      constructor(text, highlightType, key) {
        super(text, key);
        this.__highlightType = highlightType;
      }
      static getType() {
        return "code-highlight";
      }
      static clone(node) {
        return new _CodeHighlightNode(node.__text, node.__highlightType || void 0, node.__key);
      }
      getHighlightType() {
        const self2 = this.getLatest();
        return self2.__highlightType;
      }
      createDOM(config) {
        const element = super.createDOM(config);
        const className = getHighlightThemeClass(config.theme, this.__highlightType);
        utils.addClassNamesToElement(element, className);
        return element;
      }
      updateDOM(prevNode, dom, config) {
        const update = super.updateDOM(prevNode, dom, config);
        const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);
        const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);
        if (prevClassName !== nextClassName) {
          if (prevClassName) {
            utils.removeClassNamesFromElement(dom, prevClassName);
          }
          if (nextClassName) {
            utils.addClassNamesToElement(dom, nextClassName);
          }
        }
        return update;
      }
      static importJSON(serializedNode) {
        const node = $createCodeHighlightNode(serializedNode.text, serializedNode.highlightType);
        node.setFormat(serializedNode.format);
        node.setDetail(serializedNode.detail);
        node.setMode(serializedNode.mode);
        node.setStyle(serializedNode.style);
        return node;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          highlightType: this.getHighlightType(),
          type: "code-highlight",
          version: 1
        };
      }
      // Prevent formatting (bold, underline, etc)
      setFormat(format3) {
        return this;
      }
      isParentRequired() {
        return true;
      }
      createParentElementNode() {
        return $createCodeNode();
      }
    };
    function getHighlightThemeClass(theme, highlightType) {
      return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];
    }
    function $createCodeHighlightNode(text, highlightType) {
      return lexical.$applyNodeReplacement(new CodeHighlightNode(text, highlightType));
    }
    function $isCodeHighlightNode(node) {
      return node instanceof CodeHighlightNode;
    }
    function getFirstCodeHighlightNodeOfLine(anchor) {
      let currentNode = null;
      const previousSiblings = anchor.getPreviousSiblings();
      previousSiblings.push(anchor);
      while (previousSiblings.length > 0) {
        const node = previousSiblings.pop();
        if ($isCodeHighlightNode(node)) {
          currentNode = node;
        }
        if (lexical.$isLineBreakNode(node)) {
          break;
        }
      }
      return currentNode;
    }
    function getLastCodeHighlightNodeOfLine(anchor) {
      let currentNode = null;
      const nextSiblings = anchor.getNextSiblings();
      nextSiblings.unshift(anchor);
      while (nextSiblings.length > 0) {
        const node = nextSiblings.shift();
        if ($isCodeHighlightNode(node)) {
          currentNode = node;
        }
        if (lexical.$isLineBreakNode(node)) {
          break;
        }
      }
      return currentNode;
    }
    var PrismTokenizer = {
      defaultLanguage: DEFAULT_CODE_LANGUAGE,
      tokenize(code, language) {
        return Prism2.tokenize(code, Prism2.languages[language || ""] || Prism2.languages[this.defaultLanguage]);
      }
    };
    function isSpaceOrTabChar(char) {
      return char === " " || char === "	";
    }
    function findFirstNotSpaceOrTabCharAtText(text, isForward) {
      const length = text.length;
      let offset = -1;
      if (isForward) {
        for (let i = 0; i < length; i++) {
          const char = text[i];
          if (!isSpaceOrTabChar(char)) {
            offset = i;
            break;
          }
        }
      } else {
        for (let i = length - 1; i > -1; i--) {
          const char = text[i];
          if (!isSpaceOrTabChar(char)) {
            offset = i;
            break;
          }
        }
      }
      return offset;
    }
    function getStartOfCodeInLine(anchor) {
      let currentNode = null;
      let currentNodeOffset = -1;
      const previousSiblings = anchor.getPreviousSiblings();
      previousSiblings.push(anchor);
      while (previousSiblings.length > 0) {
        const node = previousSiblings.pop();
        if ($isCodeHighlightNode(node)) {
          const text = node.getTextContent();
          const offset = findFirstNotSpaceOrTabCharAtText(text, true);
          if (offset !== -1) {
            currentNode = node;
            currentNodeOffset = offset;
          }
        }
        if (lexical.$isLineBreakNode(node)) {
          break;
        }
      }
      if (currentNode === null) {
        const nextSiblings = anchor.getNextSiblings();
        while (nextSiblings.length > 0) {
          const node = nextSiblings.shift();
          if ($isCodeHighlightNode(node)) {
            const text = node.getTextContent();
            const offset = findFirstNotSpaceOrTabCharAtText(text, true);
            if (offset !== -1) {
              currentNode = node;
              currentNodeOffset = offset;
              break;
            }
          }
          if (lexical.$isLineBreakNode(node)) {
            break;
          }
        }
      }
      return {
        node: currentNode,
        offset: currentNodeOffset
      };
    }
    function getEndOfCodeInLine(anchor) {
      let currentNode = null;
      let currentNodeOffset = -1;
      const nextSiblings = anchor.getNextSiblings();
      nextSiblings.unshift(anchor);
      while (nextSiblings.length > 0) {
        const node = nextSiblings.shift();
        if ($isCodeHighlightNode(node)) {
          const text = node.getTextContent();
          const offset = findFirstNotSpaceOrTabCharAtText(text, false);
          if (offset !== -1) {
            currentNode = node;
            currentNodeOffset = offset + 1;
          }
        }
        if (lexical.$isLineBreakNode(node)) {
          break;
        }
      }
      if (currentNode === null) {
        const previousSiblings = anchor.getPreviousSiblings();
        while (previousSiblings.length > 0) {
          const node = previousSiblings.pop();
          if ($isCodeHighlightNode(node)) {
            const text = node.getTextContent();
            const offset = findFirstNotSpaceOrTabCharAtText(text, false);
            if (offset !== -1) {
              currentNode = node;
              currentNodeOffset = offset + 1;
              break;
            }
          }
          if (lexical.$isLineBreakNode(node)) {
            break;
          }
        }
      }
      return {
        node: currentNode,
        offset: currentNodeOffset
      };
    }
    function textNodeTransform(node, editor, tokenizer) {
      const parentNode = node.getParent();
      if ($isCodeNode(parentNode)) {
        codeNodeTransform(parentNode, editor, tokenizer);
      } else if ($isCodeHighlightNode(node)) {
        node.replace(lexical.$createTextNode(node.__text));
      }
    }
    function updateCodeGutter(node, editor) {
      const codeElement = editor.getElementByKey(node.getKey());
      if (codeElement === null) {
        return;
      }
      const children = node.getChildren();
      const childrenLength = children.length;
      if (childrenLength === codeElement.__cachedChildrenLength) {
        return;
      }
      codeElement.__cachedChildrenLength = childrenLength;
      let gutter = "1";
      let count3 = 1;
      for (let i = 0; i < childrenLength; i++) {
        if (lexical.$isLineBreakNode(children[i])) {
          gutter += "\n" + ++count3;
        }
      }
      codeElement.setAttribute("data-gutter", gutter);
    }
    var nodesCurrentlyHighlighting = /* @__PURE__ */ new Set();
    function codeNodeTransform(node, editor, tokenizer) {
      const nodeKey = node.getKey();
      if (nodesCurrentlyHighlighting.has(nodeKey)) {
        return;
      }
      nodesCurrentlyHighlighting.add(nodeKey);
      if (node.getLanguage() === void 0) {
        node.setLanguage(tokenizer.defaultLanguage);
      }
      editor.update(() => {
        updateAndRetainSelection(nodeKey, () => {
          const currentNode = lexical.$getNodeByKey(nodeKey);
          if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {
            return false;
          }
          const code = currentNode.getTextContent();
          const tokens = tokenizer.tokenize(code, currentNode.getLanguage() || tokenizer.defaultLanguage);
          const highlightNodes = getHighlightNodes(tokens);
          const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);
          const {
            from,
            to,
            nodesForReplacement
          } = diffRange;
          if (from !== to || nodesForReplacement.length) {
            node.splice(from, to - from, nodesForReplacement);
            return true;
          }
          return false;
        });
      }, {
        onUpdate: () => {
          nodesCurrentlyHighlighting.delete(nodeKey);
        },
        skipTransforms: true
      });
    }
    function getHighlightNodes(tokens) {
      const nodes = [];
      tokens.forEach((token) => {
        if (typeof token === "string") {
          const partials = token.split("\n");
          for (let i = 0; i < partials.length; i++) {
            const text = partials[i];
            if (text.length) {
              nodes.push($createCodeHighlightNode(text));
            }
            if (i < partials.length - 1) {
              nodes.push(lexical.$createLineBreakNode());
            }
          }
        } else {
          const {
            content
          } = token;
          if (typeof content === "string") {
            nodes.push($createCodeHighlightNode(content, token.type));
          } else if (Array.isArray(content) && content.length === 1 && typeof content[0] === "string") {
            nodes.push($createCodeHighlightNode(content[0], token.type));
          } else if (Array.isArray(content)) {
            nodes.push(...getHighlightNodes(content));
          }
        }
      });
      return nodes;
    }
    function updateAndRetainSelection(nodeKey, updateFn) {
      const node = lexical.$getNodeByKey(nodeKey);
      if (!$isCodeNode(node) || !node.isAttached()) {
        return;
      }
      const selection = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection)) {
        updateFn();
        return;
      }
      const anchor = selection.anchor;
      const anchorOffset = anchor.offset;
      const isNewLineAnchor = anchor.type === "element" && lexical.$isLineBreakNode(node.getChildAtIndex(anchor.offset - 1));
      let textOffset = 0;
      if (!isNewLineAnchor) {
        const anchorNode = anchor.getNode();
        textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {
          return offset + _node.getTextContentSize();
        }, 0);
      }
      const hasChanges = updateFn();
      if (!hasChanges) {
        return;
      }
      if (isNewLineAnchor) {
        anchor.getNode().select(anchorOffset, anchorOffset);
        return;
      }
      node.getChildren().some((_node) => {
        const isText = lexical.$isTextNode(_node);
        if (isText || lexical.$isLineBreakNode(_node)) {
          const textContentSize = _node.getTextContentSize();
          if (isText && textContentSize >= textOffset) {
            _node.select(textOffset, textOffset);
            return true;
          }
          textOffset -= textContentSize;
        }
        return false;
      });
    }
    function getDiffRange(prevNodes, nextNodes) {
      let leadingMatch = 0;
      while (leadingMatch < prevNodes.length) {
        if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {
          break;
        }
        leadingMatch++;
      }
      const prevNodesLength = prevNodes.length;
      const nextNodesLength = nextNodes.length;
      const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;
      let trailingMatch = 0;
      while (trailingMatch < maxTrailingMatch) {
        trailingMatch++;
        if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {
          trailingMatch--;
          break;
        }
      }
      const from = leadingMatch;
      const to = prevNodesLength - trailingMatch;
      const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);
      return {
        from,
        nodesForReplacement,
        to
      };
    }
    function isEqual(nodeA, nodeB) {
      if ($isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB)) {
        return nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType;
      }
      if (lexical.$isLineBreakNode(nodeA) && lexical.$isLineBreakNode(nodeB)) {
        return true;
      }
      return false;
    }
    function handleMultilineIndent(type2) {
      const selection = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection) || selection.isCollapsed()) {
        return false;
      }
      const nodes = selection.getNodes();
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (!$isCodeHighlightNode(node) && !lexical.$isLineBreakNode(node)) {
          return false;
        }
      }
      const startOfLine = getFirstCodeHighlightNodeOfLine(nodes[0]);
      if (startOfLine != null) {
        doIndent(startOfLine, type2);
      }
      for (let i = 1; i < nodes.length; i++) {
        const node = nodes[i];
        if (lexical.$isLineBreakNode(nodes[i - 1]) && $isCodeHighlightNode(node)) {
          doIndent(node, type2);
        }
      }
      return true;
    }
    function doIndent(node, type2) {
      const text = node.getTextContent();
      if (type2 === lexical.INDENT_CONTENT_COMMAND) {
        if (text.length > 0 && /\s/.test(text[0])) {
          node.setTextContent("	" + text);
        } else {
          const indentNode = $createCodeHighlightNode("	");
          node.insertBefore(indentNode);
        }
      } else {
        if (text.indexOf("	") === 0) {
          if (text.length === 1) {
            node.remove();
          } else {
            node.setTextContent(text.substring(1));
          }
        }
      }
    }
    function handleShiftLines(type2, event) {
      const selection = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection)) {
        return false;
      }
      const {
        anchor,
        focus
      } = selection;
      const anchorOffset = anchor.offset;
      const focusOffset = focus.offset;
      const anchorNode = anchor.getNode();
      const focusNode = focus.getNode();
      const arrowIsUp = type2 === lexical.KEY_ARROW_UP_COMMAND;
      if (!$isCodeHighlightNode(anchorNode) || !$isCodeHighlightNode(focusNode)) {
        return false;
      }
      if (!event.altKey) {
        if (selection.isCollapsed()) {
          const codeNode = anchorNode.getParentOrThrow();
          if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {
            const codeNodeSibling = codeNode.getPreviousSibling();
            if (codeNodeSibling === null) {
              codeNode.selectPrevious();
              event.preventDefault();
              return true;
            }
          } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {
            const codeNodeSibling = codeNode.getNextSibling();
            if (codeNodeSibling === null) {
              codeNode.selectNext();
              event.preventDefault();
              return true;
            }
          }
        }
        return false;
      }
      const start = getFirstCodeHighlightNodeOfLine(anchorNode);
      const end = getLastCodeHighlightNodeOfLine(focusNode);
      if (start == null || end == null) {
        return false;
      }
      const range2 = start.getNodesBetween(end);
      for (let i = 0; i < range2.length; i++) {
        const node = range2[i];
        if (!$isCodeHighlightNode(node) && !lexical.$isLineBreakNode(node)) {
          return false;
        }
      }
      event.preventDefault();
      event.stopPropagation();
      const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();
      if (!lexical.$isLineBreakNode(linebreak)) {
        return true;
      }
      const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();
      if (sibling == null) {
        return true;
      }
      const maybeInsertionPoint = arrowIsUp ? getFirstCodeHighlightNodeOfLine(sibling) : getLastCodeHighlightNodeOfLine(sibling);
      let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;
      linebreak.remove();
      range2.forEach((node) => node.remove());
      if (type2 === lexical.KEY_ARROW_UP_COMMAND) {
        range2.forEach((node) => insertionPoint.insertBefore(node));
        insertionPoint.insertBefore(linebreak);
      } else {
        insertionPoint.insertAfter(linebreak);
        insertionPoint = linebreak;
        range2.forEach((node) => {
          insertionPoint.insertAfter(node);
          insertionPoint = node;
        });
      }
      selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);
      return true;
    }
    function handleMoveTo(type2, event) {
      const selection = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection)) {
        return false;
      }
      const {
        anchor,
        focus
      } = selection;
      const anchorNode = anchor.getNode();
      const focusNode = focus.getNode();
      const isMoveToStart = type2 === lexical.MOVE_TO_START;
      if (!$isCodeHighlightNode(anchorNode) || !$isCodeHighlightNode(focusNode)) {
        return false;
      }
      let node;
      let offset;
      if (isMoveToStart) {
        ({
          node,
          offset
        } = getStartOfCodeInLine(focusNode));
      } else {
        ({
          node,
          offset
        } = getEndOfCodeInLine(focusNode));
      }
      if (node !== null && offset !== -1) {
        selection.setTextNodeRange(node, offset, node, offset);
      }
      event.preventDefault();
      event.stopPropagation();
      return true;
    }
    function registerCodeHighlighting(editor, tokenizer) {
      if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {
        throw new Error("CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor");
      }
      if (tokenizer == null) {
        tokenizer = PrismTokenizer;
      }
      return utils.mergeRegister(editor.registerMutationListener(CodeNode, (mutations) => {
        editor.update(() => {
          for (const [key, type2] of mutations) {
            if (type2 !== "destroyed") {
              const node = lexical.$getNodeByKey(key);
              if (node !== null) {
                updateCodeGutter(node, editor);
              }
            }
          }
        });
      }), editor.registerNodeTransform(CodeNode, (node) => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(lexical.TextNode, (node) => textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, (node) => textNodeTransform(node, editor, tokenizer)), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, (payload) => handleMultilineIndent(lexical.INDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, (payload) => handleMultilineIndent(lexical.OUTDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, (payload) => handleShiftLines(lexical.KEY_ARROW_UP_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, (payload) => handleShiftLines(lexical.KEY_ARROW_DOWN_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_END, (payload) => handleMoveTo(lexical.MOVE_TO_END, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_START, (payload) => handleMoveTo(lexical.MOVE_TO_START, payload), lexical.COMMAND_PRIORITY_LOW));
    }
    exports.$createCodeHighlightNode = $createCodeHighlightNode;
    exports.$createCodeNode = $createCodeNode;
    exports.$isCodeHighlightNode = $isCodeHighlightNode;
    exports.$isCodeNode = $isCodeNode;
    exports.CODE_LANGUAGE_FRIENDLY_NAME_MAP = CODE_LANGUAGE_FRIENDLY_NAME_MAP;
    exports.CODE_LANGUAGE_MAP = CODE_LANGUAGE_MAP;
    exports.CodeHighlightNode = CodeHighlightNode;
    exports.CodeNode = CodeNode;
    exports.DEFAULT_CODE_LANGUAGE = DEFAULT_CODE_LANGUAGE;
    exports.PrismTokenizer = PrismTokenizer;
    exports.getCodeLanguages = getCodeLanguages;
    exports.getDefaultCodeLanguage = getDefaultCodeLanguage;
    exports.getEndOfCodeInLine = getEndOfCodeInLine;
    exports.getFirstCodeHighlightNodeOfLine = getFirstCodeHighlightNodeOfLine;
    exports.getLanguageFriendlyName = getLanguageFriendlyName;
    exports.getLastCodeHighlightNodeOfLine = getLastCodeHighlightNodeOfLine;
    exports.getStartOfCodeInLine = getStartOfCodeInLine;
    exports.normalizeCodeLang = normalizeCodeLang;
    exports.registerCodeHighlighting = registerCodeHighlighting;
  }
});

// ../node_modules/@lexical/code/LexicalCode.js
var require_LexicalCode = __commonJS({
  "../node_modules/@lexical/code/LexicalCode.js"(exports, module) {
    "use strict";
    var LexicalCode2 = true ? require_LexicalCode_dev() : null;
    module.exports = LexicalCode2;
  }
});

// ../node_modules/@lexical/list/LexicalList.dev.js
var require_LexicalList_dev = __commonJS({
  "../node_modules/@lexical/list/LexicalList.dev.js"(exports) {
    "use strict";
    var lexical = require_Lexical();
    var utils = require_LexicalUtils();
    function $getListDepth(listNode) {
      let depth = 1;
      let parent = listNode.getParent();
      while (parent != null) {
        if ($isListItemNode(parent)) {
          const parentList = parent.getParent();
          if ($isListNode(parentList)) {
            depth++;
            parent = parentList.getParent();
            continue;
          }
          {
            throw Error(`A ListItemNode must have a ListNode for a parent.`);
          }
        }
        return depth;
      }
      return depth;
    }
    function $getTopListNode(listItem) {
      let list = listItem.getParent();
      if (!$isListNode(list)) {
        {
          throw Error(`A ListItemNode must have a ListNode for a parent.`);
        }
      }
      let parent = list;
      while (parent !== null) {
        parent = parent.getParent();
        if ($isListNode(parent)) {
          list = parent;
        }
      }
      return list;
    }
    function $getAllListItems(node) {
      let listItemNodes = [];
      const listChildren = node.getChildren().filter($isListItemNode);
      for (let i = 0; i < listChildren.length; i++) {
        const listItemNode = listChildren[i];
        const firstChild = listItemNode.getFirstChild();
        if ($isListNode(firstChild)) {
          listItemNodes = listItemNodes.concat($getAllListItems(firstChild));
        } else {
          listItemNodes.push(listItemNode);
        }
      }
      return listItemNodes;
    }
    function isNestedListNode(node) {
      return $isListItemNode(node) && $isListNode(node.getFirstChild());
    }
    function $removeHighestEmptyListParent(sublist) {
      let emptyListPtr = sublist;
      while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {
        const parent = emptyListPtr.getParent();
        if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {
          break;
        }
        emptyListPtr = parent;
      }
      emptyListPtr.remove();
    }
    function wrapInListItem(node) {
      const listItemWrapper = $createListItemNode();
      return listItemWrapper.append(node);
    }
    function $isSelectingEmptyListItem(anchorNode, nodes) {
      return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);
    }
    function $getListItemValue(listItem) {
      const list = listItem.getParent();
      let value3 = 1;
      if (list != null) {
        if (!$isListNode(list)) {
          {
            throw Error(`$getListItemValue: list node is not parent of list item node`);
          }
        } else {
          value3 = list.getStart();
        }
      }
      const siblings = listItem.getPreviousSiblings();
      for (let i = 0; i < siblings.length; i++) {
        const sibling = siblings[i];
        if ($isListItemNode(sibling) && !$isListNode(sibling.getFirstChild())) {
          value3++;
        }
      }
      return value3;
    }
    function insertList(editor, listType) {
      editor.update(() => {
        const selection = lexical.$getSelection();
        if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {
          const nodes = selection.getNodes();
          const anchor = selection.anchor;
          const anchorNode = anchor.getNode();
          const anchorNodeParent = anchorNode.getParent();
          if ($isSelectingEmptyListItem(anchorNode, nodes)) {
            const list = $createListNode(listType);
            if (lexical.$isRootOrShadowRoot(anchorNodeParent)) {
              anchorNode.replace(list);
              const listItem = $createListItemNode();
              if (lexical.$isElementNode(anchorNode)) {
                listItem.setFormat(anchorNode.getFormatType());
                listItem.setIndent(anchorNode.getIndent());
              }
              list.append(listItem);
            } else if ($isListItemNode(anchorNode)) {
              const parent = anchorNode.getParentOrThrow();
              append2(list, parent.getChildren());
              parent.replace(list);
            }
            return;
          } else {
            const handled = /* @__PURE__ */ new Set();
            for (let i = 0; i < nodes.length; i++) {
              const node = nodes[i];
              if (lexical.$isElementNode(node) && node.isEmpty() && !handled.has(node.getKey())) {
                createListOrMerge(node, listType);
                continue;
              }
              if (lexical.$isLeafNode(node)) {
                let parent = node.getParent();
                while (parent != null) {
                  const parentKey = parent.getKey();
                  if ($isListNode(parent)) {
                    if (!handled.has(parentKey)) {
                      const newListNode = $createListNode(listType);
                      append2(newListNode, parent.getChildren());
                      parent.replace(newListNode);
                      updateChildrenListItemValue(newListNode);
                      handled.add(parentKey);
                    }
                    break;
                  } else {
                    const nextParent = parent.getParent();
                    if (lexical.$isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {
                      handled.add(parentKey);
                      createListOrMerge(parent, listType);
                      break;
                    }
                    parent = nextParent;
                  }
                }
              }
            }
          }
        }
      });
    }
    function append2(node, nodesToAppend) {
      node.splice(node.getChildrenSize(), 0, nodesToAppend);
    }
    function createListOrMerge(node, listType) {
      if ($isListNode(node)) {
        return node;
      }
      const previousSibling = node.getPreviousSibling();
      const nextSibling = node.getNextSibling();
      const listItem = $createListItemNode();
      listItem.setFormat(node.getFormatType());
      listItem.setIndent(node.getIndent());
      append2(listItem, node.getChildren());
      if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {
        previousSibling.append(listItem);
        node.remove();
        if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {
          append2(previousSibling, nextSibling.getChildren());
          nextSibling.remove();
        }
        return previousSibling;
      } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {
        nextSibling.getFirstChildOrThrow().insertBefore(listItem);
        node.remove();
        return nextSibling;
      } else {
        const list = $createListNode(listType);
        list.append(listItem);
        node.replace(list);
        updateChildrenListItemValue(list);
        return list;
      }
    }
    function removeList(editor) {
      editor.update(() => {
        const selection = lexical.$getSelection();
        if (lexical.$isRangeSelection(selection)) {
          const listNodes = /* @__PURE__ */ new Set();
          const nodes = selection.getNodes();
          const anchorNode = selection.anchor.getNode();
          if ($isSelectingEmptyListItem(anchorNode, nodes)) {
            listNodes.add($getTopListNode(anchorNode));
          } else {
            for (let i = 0; i < nodes.length; i++) {
              const node = nodes[i];
              if (lexical.$isLeafNode(node)) {
                const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode);
                if (listItemNode != null) {
                  listNodes.add($getTopListNode(listItemNode));
                }
              }
            }
          }
          for (const listNode of listNodes) {
            let insertionPoint = listNode;
            const listItems = $getAllListItems(listNode);
            for (const listItemNode of listItems) {
              const paragraph = lexical.$createParagraphNode();
              append2(paragraph, listItemNode.getChildren());
              insertionPoint.insertAfter(paragraph);
              insertionPoint = paragraph;
              if (listItemNode.__key === selection.anchor.key) {
                selection.anchor.set(paragraph.getKey(), 0, "element");
              }
              if (listItemNode.__key === selection.focus.key) {
                selection.focus.set(paragraph.getKey(), 0, "element");
              }
              listItemNode.remove();
            }
            listNode.remove();
          }
        }
      });
    }
    function updateChildrenListItemValue(list, children) {
      const childrenOrExisting = children || list.getChildren();
      if (childrenOrExisting !== void 0) {
        for (let i = 0; i < childrenOrExisting.length; i++) {
          const child = childrenOrExisting[i];
          if ($isListItemNode(child)) {
            const prevValue = child.getValue();
            const nextValue = $getListItemValue(child);
            if (prevValue !== nextValue) {
              child.setValue(nextValue);
            }
          }
        }
      }
    }
    function $handleIndent(listItemNode) {
      const removed = /* @__PURE__ */ new Set();
      if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {
        return;
      }
      const parent = listItemNode.getParent();
      const nextSibling = listItemNode.getNextSibling();
      const previousSibling = listItemNode.getPreviousSibling();
      if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {
        const innerList = previousSibling.getFirstChild();
        if ($isListNode(innerList)) {
          innerList.append(listItemNode);
          const nextInnerList = nextSibling.getFirstChild();
          if ($isListNode(nextInnerList)) {
            const children = nextInnerList.getChildren();
            append2(innerList, children);
            nextSibling.remove();
            removed.add(nextSibling.getKey());
          }
          updateChildrenListItemValue(innerList);
        }
      } else if (isNestedListNode(nextSibling)) {
        const innerList = nextSibling.getFirstChild();
        if ($isListNode(innerList)) {
          const firstChild = innerList.getFirstChild();
          if (firstChild !== null) {
            firstChild.insertBefore(listItemNode);
          }
          updateChildrenListItemValue(innerList);
        }
      } else if (isNestedListNode(previousSibling)) {
        const innerList = previousSibling.getFirstChild();
        if ($isListNode(innerList)) {
          innerList.append(listItemNode);
          updateChildrenListItemValue(innerList);
        }
      } else {
        if ($isListNode(parent)) {
          const newListItem = $createListItemNode();
          const newList = $createListNode(parent.getListType());
          newListItem.append(newList);
          newList.append(listItemNode);
          if (previousSibling) {
            previousSibling.insertAfter(newListItem);
          } else if (nextSibling) {
            nextSibling.insertBefore(newListItem);
          } else {
            parent.append(newListItem);
          }
        }
      }
      if ($isListNode(parent)) {
        updateChildrenListItemValue(parent);
      }
    }
    function $handleOutdent(listItemNode) {
      if (isNestedListNode(listItemNode)) {
        return;
      }
      const parentList = listItemNode.getParent();
      const grandparentListItem = parentList ? parentList.getParent() : void 0;
      const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : void 0;
      if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {
        const firstChild = parentList ? parentList.getFirstChild() : void 0;
        const lastChild = parentList ? parentList.getLastChild() : void 0;
        if (listItemNode.is(firstChild)) {
          grandparentListItem.insertBefore(listItemNode);
          if (parentList.isEmpty()) {
            grandparentListItem.remove();
          }
        } else if (listItemNode.is(lastChild)) {
          grandparentListItem.insertAfter(listItemNode);
          if (parentList.isEmpty()) {
            grandparentListItem.remove();
          }
        } else {
          const listType = parentList.getListType();
          const previousSiblingsListItem = $createListItemNode();
          const previousSiblingsList = $createListNode(listType);
          previousSiblingsListItem.append(previousSiblingsList);
          listItemNode.getPreviousSiblings().forEach((sibling) => previousSiblingsList.append(sibling));
          const nextSiblingsListItem = $createListItemNode();
          const nextSiblingsList = $createListNode(listType);
          nextSiblingsListItem.append(nextSiblingsList);
          append2(nextSiblingsList, listItemNode.getNextSiblings());
          grandparentListItem.insertBefore(previousSiblingsListItem);
          grandparentListItem.insertAfter(nextSiblingsListItem);
          grandparentListItem.replace(listItemNode);
        }
        updateChildrenListItemValue(parentList);
        updateChildrenListItemValue(greatGrandparentList);
      }
    }
    function $handleListInsertParagraph() {
      const selection = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {
        return false;
      }
      const anchor = selection.anchor.getNode();
      if (!$isListItemNode(anchor) || anchor.getTextContent() !== "") {
        return false;
      }
      const topListNode = $getTopListNode(anchor);
      const parent = anchor.getParent();
      if (!$isListNode(parent)) {
        throw Error(`A ListItemNode must have a ListNode for a parent.`);
      }
      const grandparent = parent.getParent();
      let replacementNode;
      if (lexical.$isRootOrShadowRoot(grandparent)) {
        replacementNode = lexical.$createParagraphNode();
        topListNode.insertAfter(replacementNode);
      } else if ($isListItemNode(grandparent)) {
        replacementNode = $createListItemNode();
        grandparent.insertAfter(replacementNode);
      } else {
        return false;
      }
      replacementNode.select();
      const nextSiblings = anchor.getNextSiblings();
      if (nextSiblings.length > 0) {
        const newList = $createListNode(parent.getListType());
        if (lexical.$isParagraphNode(replacementNode)) {
          replacementNode.insertAfter(newList);
        } else {
          const newListItem = $createListItemNode();
          newListItem.append(newList);
          replacementNode.insertAfter(newListItem);
        }
        nextSiblings.forEach((sibling) => {
          sibling.remove();
          newList.append(sibling);
        });
      }
      $removeHighestEmptyListParent(anchor);
      return true;
    }
    var ListItemNode = class _ListItemNode extends lexical.ElementNode {
      /** @internal */
      /** @internal */
      static getType() {
        return "listitem";
      }
      static clone(node) {
        return new _ListItemNode(node.__value, node.__checked, node.__key);
      }
      constructor(value3, checked, key) {
        super(key);
        this.__value = value3 === void 0 ? 1 : value3;
        this.__checked = checked;
      }
      createDOM(config) {
        const element = document.createElement("li");
        const parent = this.getParent();
        if ($isListNode(parent)) {
          updateChildrenListItemValue(parent);
          updateListItemChecked(element, this, null, parent);
        }
        element.value = this.__value;
        $setListItemThemeClassNames(element, config.theme, this);
        return element;
      }
      updateDOM(prevNode, dom, config) {
        const parent = this.getParent();
        if ($isListNode(parent)) {
          updateChildrenListItemValue(parent);
          updateListItemChecked(dom, this, prevNode, parent);
        }
        dom.value = this.__value;
        $setListItemThemeClassNames(dom, config.theme, this);
        return false;
      }
      static importDOM() {
        return {
          li: (node) => ({
            conversion: convertListItemElement,
            priority: 0
          })
        };
      }
      static importJSON(serializedNode) {
        const node = new _ListItemNode(serializedNode.value, serializedNode.checked);
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        return node;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          checked: this.getChecked(),
          type: "listitem",
          value: this.getValue(),
          version: 1
        };
      }
      append(...nodes) {
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (lexical.$isElementNode(node) && this.canMergeWith(node)) {
            const children = node.getChildren();
            this.append(...children);
            node.remove();
          } else {
            super.append(node);
          }
        }
        return this;
      }
      replace(replaceWithNode, includeChildren) {
        if ($isListItemNode(replaceWithNode)) {
          return super.replace(replaceWithNode);
        }
        const list = this.getParentOrThrow();
        if ($isListNode(list)) {
          const childrenKeys = list.getChildrenKeys();
          const childrenLength = childrenKeys.length;
          const index2 = childrenKeys.indexOf(this.__key);
          if (index2 === 0) {
            list.insertBefore(replaceWithNode);
          } else if (index2 === childrenLength - 1) {
            list.insertAfter(replaceWithNode);
          } else {
            const newList = $createListNode(list.getListType());
            const children = list.getChildren();
            for (let i = index2 + 1; i < childrenLength; i++) {
              const child = children[i];
              newList.append(child);
            }
            list.insertAfter(replaceWithNode);
            replaceWithNode.insertAfter(newList);
          }
          if (includeChildren) {
            this.getChildren().forEach((child) => {
              replaceWithNode.append(child);
            });
          }
          this.remove();
          if (childrenLength === 1) {
            list.remove();
          }
        }
        return replaceWithNode;
      }
      insertAfter(node, restoreSelection = true) {
        const listNode = this.getParentOrThrow();
        if (!$isListNode(listNode)) {
          {
            throw Error(`insertAfter: list node is not parent of list item node`);
          }
        }
        const siblings = this.getNextSiblings();
        if ($isListItemNode(node)) {
          const after = super.insertAfter(node, restoreSelection);
          const afterListNode = node.getParentOrThrow();
          if ($isListNode(afterListNode)) {
            updateChildrenListItemValue(afterListNode);
          }
          return after;
        }
        if ($isListNode(node) && node.getListType() === listNode.getListType()) {
          let child = node;
          const children = node.getChildren();
          for (let i = children.length - 1; i >= 0; i--) {
            child = children[i];
            this.insertAfter(child, restoreSelection);
          }
          return child;
        }
        listNode.insertAfter(node, restoreSelection);
        if (siblings.length !== 0) {
          const newListNode = $createListNode(listNode.getListType());
          siblings.forEach((sibling) => newListNode.append(sibling));
          node.insertAfter(newListNode, restoreSelection);
        }
        return node;
      }
      remove(preserveEmptyParent) {
        const nextSibling = this.getNextSibling();
        super.remove(preserveEmptyParent);
        if (nextSibling !== null) {
          const parent = nextSibling.getParent();
          if ($isListNode(parent)) {
            updateChildrenListItemValue(parent);
          }
        }
      }
      insertNewAfter(_, restoreSelection = true) {
        const newElement = $createListItemNode(this.__checked == null ? void 0 : false);
        this.insertAfter(newElement, restoreSelection);
        return newElement;
      }
      collapseAtStart(selection) {
        const paragraph = lexical.$createParagraphNode();
        const children = this.getChildren();
        children.forEach((child) => paragraph.append(child));
        const listNode = this.getParentOrThrow();
        const listNodeParent = listNode.getParentOrThrow();
        const isIndented = $isListItemNode(listNodeParent);
        if (listNode.getChildrenSize() === 1) {
          if (isIndented) {
            listNode.remove();
            listNodeParent.select();
          } else {
            listNode.insertBefore(paragraph);
            listNode.remove();
            const anchor = selection.anchor;
            const focus = selection.focus;
            const key = paragraph.getKey();
            if (anchor.type === "element" && anchor.getNode().is(this)) {
              anchor.set(key, anchor.offset, "element");
            }
            if (focus.type === "element" && focus.getNode().is(this)) {
              focus.set(key, focus.offset, "element");
            }
          }
        } else {
          listNode.insertBefore(paragraph);
          this.remove();
        }
        return true;
      }
      getValue() {
        const self2 = this.getLatest();
        return self2.__value;
      }
      setValue(value3) {
        const self2 = this.getWritable();
        self2.__value = value3;
      }
      getChecked() {
        const self2 = this.getLatest();
        return self2.__checked;
      }
      setChecked(checked) {
        const self2 = this.getWritable();
        self2.__checked = checked;
      }
      toggleChecked() {
        this.setChecked(!this.__checked);
      }
      getIndent() {
        const parent = this.getParent();
        if (parent === null) {
          return this.getLatest().__indent;
        }
        let listNodeParent = parent.getParentOrThrow();
        let indentLevel = 0;
        while ($isListItemNode(listNodeParent)) {
          listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();
          indentLevel++;
        }
        return indentLevel;
      }
      setIndent(indent) {
        let currentIndent = this.getIndent();
        while (currentIndent !== indent) {
          if (currentIndent < indent) {
            $handleIndent(this);
            currentIndent++;
          } else {
            $handleOutdent(this);
            currentIndent--;
          }
        }
        return this;
      }
      insertBefore(nodeToInsert) {
        if ($isListItemNode(nodeToInsert)) {
          const parent = this.getParentOrThrow();
          if ($isListNode(parent)) {
            const siblings = this.getNextSiblings();
            updateChildrenListItemValue(parent, siblings);
          }
        }
        return super.insertBefore(nodeToInsert);
      }
      canInsertAfter(node) {
        return $isListItemNode(node);
      }
      canReplaceWith(replacement) {
        return $isListItemNode(replacement);
      }
      canMergeWith(node) {
        return lexical.$isParagraphNode(node) || $isListItemNode(node);
      }
      extractWithChild(child, selection) {
        if (!lexical.$isRangeSelection(selection)) {
          return false;
        }
        const anchorNode = selection.anchor.getNode();
        const focusNode = selection.focus.getNode();
        return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;
      }
      isParentRequired() {
        return true;
      }
      createParentElementNode() {
        return $createListNode("bullet");
      }
    };
    function $setListItemThemeClassNames(dom, editorThemeClasses, node) {
      const classesToAdd = [];
      const classesToRemove = [];
      const listTheme = editorThemeClasses.list;
      const listItemClassName = listTheme ? listTheme.listitem : void 0;
      let nestedListItemClassName;
      if (listTheme && listTheme.nested) {
        nestedListItemClassName = listTheme.nested.listitem;
      }
      if (listItemClassName !== void 0) {
        const listItemClasses = listItemClassName.split(" ");
        classesToAdd.push(...listItemClasses);
      }
      if (listTheme) {
        const parentNode = node.getParent();
        const isCheckList = $isListNode(parentNode) && parentNode.getListType() === "check";
        const checked = node.getChecked();
        if (!isCheckList || checked) {
          classesToRemove.push(listTheme.listitemUnchecked);
        }
        if (!isCheckList || !checked) {
          classesToRemove.push(listTheme.listitemChecked);
        }
        if (isCheckList) {
          classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);
        }
      }
      if (nestedListItemClassName !== void 0) {
        const nestedListItemClasses = nestedListItemClassName.split(" ");
        if (node.getChildren().some((child) => $isListNode(child))) {
          classesToAdd.push(...nestedListItemClasses);
        } else {
          classesToRemove.push(...nestedListItemClasses);
        }
      }
      if (classesToRemove.length > 0) {
        utils.removeClassNamesFromElement(dom, ...classesToRemove);
      }
      if (classesToAdd.length > 0) {
        utils.addClassNamesToElement(dom, ...classesToAdd);
      }
    }
    function updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {
      const isCheckList = listNode.getListType() === "check";
      if (isCheckList) {
        if ($isListNode(listItemNode.getFirstChild())) {
          dom.removeAttribute("role");
          dom.removeAttribute("tabIndex");
          dom.removeAttribute("aria-checked");
        } else {
          dom.setAttribute("role", "checkbox");
          dom.setAttribute("tabIndex", "-1");
          if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {
            dom.setAttribute("aria-checked", listItemNode.getChecked() ? "true" : "false");
          }
        }
      } else {
        if (listItemNode.getChecked() != null) {
          listItemNode.setChecked(void 0);
        }
      }
    }
    function convertListItemElement(domNode) {
      const checked = utils.isHTMLElement(domNode) && domNode.getAttribute("aria-checked") === "true";
      return {
        node: $createListItemNode(checked)
      };
    }
    function $createListItemNode(checked) {
      return lexical.$applyNodeReplacement(new ListItemNode(void 0, checked));
    }
    function $isListItemNode(node) {
      return node instanceof ListItemNode;
    }
    var ListNode = class _ListNode extends lexical.ElementNode {
      /** @internal */
      /** @internal */
      /** @internal */
      static getType() {
        return "list";
      }
      static clone(node) {
        const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];
        return new _ListNode(listType, node.__start, node.__key);
      }
      constructor(listType, start, key) {
        super(key);
        const _listType = TAG_TO_LIST_TYPE[listType] || listType;
        this.__listType = _listType;
        this.__tag = _listType === "number" ? "ol" : "ul";
        this.__start = start;
      }
      getTag() {
        return this.__tag;
      }
      getListType() {
        return this.__listType;
      }
      getStart() {
        return this.__start;
      }
      // View
      createDOM(config, _editor) {
        const tag = this.__tag;
        const dom = document.createElement(tag);
        if (this.__start !== 1) {
          dom.setAttribute("start", String(this.__start));
        }
        dom.__lexicalListType = this.__listType;
        setListThemeClassNames(dom, config.theme, this);
        return dom;
      }
      updateDOM(prevNode, dom, config) {
        if (prevNode.__tag !== this.__tag) {
          return true;
        }
        setListThemeClassNames(dom, config.theme, this);
        return false;
      }
      static importDOM() {
        return {
          ol: (node) => ({
            conversion: convertListNode,
            priority: 0
          }),
          ul: (node) => ({
            conversion: convertListNode,
            priority: 0
          })
        };
      }
      static importJSON(serializedNode) {
        const node = $createListNode(serializedNode.listType, serializedNode.start);
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        return node;
      }
      exportDOM(editor) {
        const {
          element
        } = super.exportDOM(editor);
        if (element) {
          if (this.__start !== 1) {
            element.setAttribute("start", String(this.__start));
          }
          if (this.__listType === "check") {
            element.setAttribute("__lexicalListType", "check");
          }
        }
        return {
          element
        };
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          listType: this.getListType(),
          start: this.getStart(),
          tag: this.getTag(),
          type: "list",
          version: 1
        };
      }
      canBeEmpty() {
        return false;
      }
      canIndent() {
        return false;
      }
      append(...nodesToAppend) {
        for (let i = 0; i < nodesToAppend.length; i++) {
          const currentNode = nodesToAppend[i];
          if ($isListItemNode(currentNode)) {
            super.append(currentNode);
          } else {
            const listItemNode = $createListItemNode();
            if ($isListNode(currentNode)) {
              listItemNode.append(currentNode);
            } else if (lexical.$isElementNode(currentNode)) {
              const textNode = lexical.$createTextNode(currentNode.getTextContent());
              listItemNode.append(textNode);
            } else {
              listItemNode.append(currentNode);
            }
            super.append(listItemNode);
          }
        }
        return this;
      }
      extractWithChild(child) {
        return $isListItemNode(child);
      }
    };
    function setListThemeClassNames(dom, editorThemeClasses, node) {
      const classesToAdd = [];
      const classesToRemove = [];
      const listTheme = editorThemeClasses.list;
      if (listTheme !== void 0) {
        const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];
        const listDepth = $getListDepth(node) - 1;
        const normalizedListDepth = listDepth % listLevelsClassNames.length;
        const listLevelClassName = listLevelsClassNames[normalizedListDepth];
        const listClassName = listTheme[node.__tag];
        let nestedListClassName;
        const nestedListTheme = listTheme.nested;
        if (nestedListTheme !== void 0 && nestedListTheme.list) {
          nestedListClassName = nestedListTheme.list;
        }
        if (listClassName !== void 0) {
          classesToAdd.push(listClassName);
        }
        if (listLevelClassName !== void 0) {
          const listItemClasses = listLevelClassName.split(" ");
          classesToAdd.push(...listItemClasses);
          for (let i = 0; i < listLevelsClassNames.length; i++) {
            if (i !== normalizedListDepth) {
              classesToRemove.push(node.__tag + i);
            }
          }
        }
        if (nestedListClassName !== void 0) {
          const nestedListItemClasses = nestedListClassName.split(" ");
          if (listDepth > 1) {
            classesToAdd.push(...nestedListItemClasses);
          } else {
            classesToRemove.push(...nestedListItemClasses);
          }
        }
      }
      if (classesToRemove.length > 0) {
        utils.removeClassNamesFromElement(dom, ...classesToRemove);
      }
      if (classesToAdd.length > 0) {
        utils.addClassNamesToElement(dom, ...classesToAdd);
      }
    }
    function normalizeChildren(nodes) {
      const normalizedListItems = [];
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if ($isListItemNode(node)) {
          normalizedListItems.push(node);
          const children = node.getChildren();
          if (children.length > 1) {
            children.forEach((child) => {
              if ($isListNode(child)) {
                normalizedListItems.push(wrapInListItem(child));
              }
            });
          }
        } else {
          normalizedListItems.push(wrapInListItem(node));
        }
      }
      return normalizedListItems;
    }
    function convertListNode(domNode) {
      const nodeName = domNode.nodeName.toLowerCase();
      let node = null;
      if (nodeName === "ol") {
        node = $createListNode("number");
      } else if (nodeName === "ul") {
        if (utils.isHTMLElement(domNode) && domNode.getAttribute("__lexicallisttype") === "check") {
          node = $createListNode("check");
        } else {
          node = $createListNode("bullet");
        }
      }
      return {
        after: normalizeChildren,
        node
      };
    }
    var TAG_TO_LIST_TYPE = {
      ol: "number",
      ul: "bullet"
    };
    function $createListNode(listType, start = 1) {
      return lexical.$applyNodeReplacement(new ListNode(listType, start));
    }
    function $isListNode(node) {
      return node instanceof ListNode;
    }
    var INSERT_UNORDERED_LIST_COMMAND = lexical.createCommand("INSERT_UNORDERED_LIST_COMMAND");
    var INSERT_ORDERED_LIST_COMMAND = lexical.createCommand("INSERT_ORDERED_LIST_COMMAND");
    var INSERT_CHECK_LIST_COMMAND = lexical.createCommand("INSERT_CHECK_LIST_COMMAND");
    var REMOVE_LIST_COMMAND = lexical.createCommand("REMOVE_LIST_COMMAND");
    exports.$createListItemNode = $createListItemNode;
    exports.$createListNode = $createListNode;
    exports.$getListDepth = $getListDepth;
    exports.$handleListInsertParagraph = $handleListInsertParagraph;
    exports.$isListItemNode = $isListItemNode;
    exports.$isListNode = $isListNode;
    exports.INSERT_CHECK_LIST_COMMAND = INSERT_CHECK_LIST_COMMAND;
    exports.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND;
    exports.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND;
    exports.ListItemNode = ListItemNode;
    exports.ListNode = ListNode;
    exports.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND;
    exports.insertList = insertList;
    exports.removeList = removeList;
  }
});

// ../node_modules/@lexical/list/LexicalList.js
var require_LexicalList = __commonJS({
  "../node_modules/@lexical/list/LexicalList.js"(exports, module) {
    "use strict";
    var LexicalList2 = true ? require_LexicalList_dev() : null;
    module.exports = LexicalList2;
  }
});

// ../node_modules/@lexical/html/LexicalHtml.dev.js
var require_LexicalHtml_dev = __commonJS({
  "../node_modules/@lexical/html/LexicalHtml.dev.js"(exports) {
    "use strict";
    var selection = require_LexicalSelection();
    var lexical = require_Lexical();
    function $generateNodesFromDOM(editor, dom) {
      let lexicalNodes = [];
      const elements = dom.body ? Array.from(dom.body.childNodes) : [];
      const elementsLength = elements.length;
      for (let i = 0; i < elementsLength; i++) {
        const element = elements[i];
        if (!IGNORE_TAGS.has(element.nodeName)) {
          const lexicalNode = $createNodesFromDOM(element, editor);
          if (lexicalNode !== null) {
            lexicalNodes = lexicalNodes.concat(lexicalNode);
          }
        }
      }
      return lexicalNodes;
    }
    function $generateHtmlFromNodes(editor, selection2) {
      if (typeof document === "undefined" || typeof window === "undefined") {
        throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
      }
      const container = document.createElement("div");
      const root = lexical.$getRoot();
      const topLevelChildren = root.getChildren();
      for (let i = 0; i < topLevelChildren.length; i++) {
        const topLevelNode = topLevelChildren[i];
        $appendNodesToHTML(editor, topLevelNode, container, selection2);
      }
      return container.innerHTML;
    }
    function $appendNodesToHTML(editor, currentNode, parentElement, selection$1 = null) {
      let shouldInclude = selection$1 != null ? currentNode.isSelected() : true;
      const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy("html");
      let target = currentNode;
      if (selection$1 !== null) {
        let clone = selection.$cloneWithProperties(currentNode);
        clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;
        target = clone;
      }
      const children = lexical.$isElementNode(target) ? target.getChildren() : [];
      const {
        element,
        after
      } = target.exportDOM(editor);
      if (!element) {
        return false;
      }
      const fragment = new DocumentFragment();
      for (let i = 0; i < children.length; i++) {
        const childNode = children[i];
        const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);
        if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, "html")) {
          shouldInclude = true;
        }
      }
      if (shouldInclude && !shouldExclude) {
        element.append(fragment);
        parentElement.append(element);
        if (after) {
          const newElement = after.call(target, element);
          if (newElement)
            element.replaceWith(newElement);
        }
      } else {
        parentElement.append(fragment);
      }
      return shouldInclude;
    }
    function getConversionFunction(domNode, editor) {
      const {
        nodeName
      } = domNode;
      const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());
      let currentConversion = null;
      if (cachedConversions !== void 0) {
        for (const cachedConversion of cachedConversions) {
          const domConversion = cachedConversion(domNode);
          if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {
            currentConversion = domConversion;
          }
        }
      }
      return currentConversion !== null ? currentConversion.conversion : null;
    }
    var IGNORE_TAGS = /* @__PURE__ */ new Set(["STYLE"]);
    function $createNodesFromDOM(node, editor, forChildMap = /* @__PURE__ */ new Map(), parentLexicalNode, preformatted = false) {
      let lexicalNodes = [];
      if (IGNORE_TAGS.has(node.nodeName)) {
        return lexicalNodes;
      }
      let currentLexicalNode = null;
      const transformFunction = getConversionFunction(node, editor);
      const transformOutput = transformFunction ? transformFunction(node, void 0, preformatted) : null;
      let postTransform = null;
      if (transformOutput !== null) {
        postTransform = transformOutput.after;
        currentLexicalNode = transformOutput.node;
        if (currentLexicalNode !== null) {
          for (const [, forChildFunction] of forChildMap) {
            currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);
            if (!currentLexicalNode) {
              break;
            }
          }
          if (currentLexicalNode) {
            lexicalNodes.push(currentLexicalNode);
          }
        }
        if (transformOutput.forChild != null) {
          forChildMap.set(node.nodeName, transformOutput.forChild);
        }
      }
      const children = node.childNodes;
      let childLexicalNodes = [];
      for (let i = 0; i < children.length; i++) {
        childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode, preformatted || (transformOutput && transformOutput.preformatted) === true));
      }
      if (postTransform != null) {
        childLexicalNodes = postTransform(childLexicalNodes);
      }
      if (currentLexicalNode == null) {
        lexicalNodes = lexicalNodes.concat(childLexicalNodes);
      } else {
        if (lexical.$isElementNode(currentLexicalNode)) {
          currentLexicalNode.append(...childLexicalNodes);
        }
      }
      return lexicalNodes;
    }
    exports.$generateHtmlFromNodes = $generateHtmlFromNodes;
    exports.$generateNodesFromDOM = $generateNodesFromDOM;
  }
});

// ../node_modules/@lexical/html/LexicalHtml.js
var require_LexicalHtml = __commonJS({
  "../node_modules/@lexical/html/LexicalHtml.js"(exports, module) {
    "use strict";
    var LexicalHtml = true ? require_LexicalHtml_dev() : null;
    module.exports = LexicalHtml;
  }
});

// ../node_modules/@lexical/clipboard/LexicalClipboard.dev.js
var require_LexicalClipboard_dev = __commonJS({
  "../node_modules/@lexical/clipboard/LexicalClipboard.dev.js"(exports) {
    "use strict";
    var html2 = require_LexicalHtml();
    var selection = require_LexicalSelection();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    function $getHtmlContent(editor) {
      const selection2 = lexical.$getSelection();
      if (selection2 == null) {
        {
          throw Error(`Expected valid LexicalSelection`);
        }
      }
      if (lexical.$isRangeSelection(selection2) && selection2.isCollapsed() || selection2.getNodes().length === 0) {
        return "";
      }
      return html2.$generateHtmlFromNodes(editor, selection2);
    }
    function $getLexicalContent(editor) {
      const selection2 = lexical.$getSelection();
      if (selection2 == null) {
        {
          throw Error(`Expected valid LexicalSelection`);
        }
      }
      if (lexical.$isRangeSelection(selection2) && selection2.isCollapsed() || selection2.getNodes().length === 0) {
        return null;
      }
      return JSON.stringify($generateJSONFromSelectedNodes(editor, selection2));
    }
    function $insertDataTransferForPlainText(dataTransfer, selection2) {
      const text = dataTransfer.getData("text/plain");
      if (text != null) {
        selection2.insertRawText(text);
      }
    }
    function $insertDataTransferForRichText(dataTransfer, selection2, editor) {
      const lexicalString = dataTransfer.getData("application/x-lexical-editor");
      if (lexicalString) {
        try {
          const payload = JSON.parse(lexicalString);
          if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {
            const nodes = $generateNodesFromSerializedNodes(payload.nodes);
            return $insertGeneratedNodes(editor, nodes, selection2);
          }
        } catch {
        }
      }
      const htmlString = dataTransfer.getData("text/html");
      if (htmlString) {
        try {
          const parser2 = new DOMParser();
          const dom = parser2.parseFromString(htmlString, "text/html");
          const nodes = html2.$generateNodesFromDOM(editor, dom);
          return $insertGeneratedNodes(editor, nodes, selection2);
        } catch {
        }
      }
      const text = dataTransfer.getData("text/plain");
      if (text != null) {
        if (lexical.$isRangeSelection(selection2)) {
          const lines = text.split(/\r?\n/);
          const linesLength = lines.length;
          for (let i = 0; i < linesLength; i++) {
            selection2.insertText(lines[i]);
            if (i < linesLength - 1) {
              selection2.insertParagraph();
            }
          }
        } else {
          selection2.insertRawText(text);
        }
      }
    }
    function $insertGeneratedNodes(editor, nodes, selection2) {
      const isSelectionInsideOfGrid = lexical.DEPRECATED_$isGridSelection(selection2) || utils.$findMatchingParent(selection2.anchor.getNode(), (n) => lexical.DEPRECATED_$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection2.focus.getNode(), (n) => lexical.DEPRECATED_$isGridCellNode(n)) !== null;
      if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.DEPRECATED_$isGridNode(nodes[0])) {
        $mergeGridNodesStrategy(nodes, selection2, false, editor);
        return;
      }
      $basicInsertStrategy(nodes, selection2);
      return;
    }
    function $basicInsertStrategy(nodes, selection2) {
      const topLevelBlocks = [];
      let currentBlock = null;
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        const isLineBreakNode = lexical.$isLineBreakNode(node);
        if (isLineBreakNode || lexical.$isDecoratorNode(node) && node.isInline() || lexical.$isElementNode(node) && node.isInline() || lexical.$isTextNode(node) || node.isParentRequired()) {
          if (currentBlock === null) {
            currentBlock = node.createParentElementNode();
            topLevelBlocks.push(currentBlock);
            if (isLineBreakNode) {
              continue;
            }
          }
          if (currentBlock !== null) {
            currentBlock.append(node);
          }
        } else {
          topLevelBlocks.push(node);
          currentBlock = null;
        }
      }
      if (lexical.$isRangeSelection(selection2)) {
        selection2.insertNodes(topLevelBlocks);
      } else if (lexical.DEPRECATED_$isGridSelection(selection2)) {
        const anchorCell = selection2.anchor.getNode();
        if (!lexical.DEPRECATED_$isGridCellNode(anchorCell)) {
          {
            throw Error(`Expected Grid Cell in Grid Selection`);
          }
        }
        anchorCell.append(...topLevelBlocks);
      }
    }
    function $mergeGridNodesStrategy(nodes, selection2, isFromLexical, editor) {
      if (nodes.length !== 1 || !lexical.DEPRECATED_$isGridNode(nodes[0])) {
        {
          throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);
        }
      }
      const newGrid = nodes[0];
      const newGridRows = newGrid.getChildren();
      const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();
      const newRowCount = newGrid.getChildrenSize();
      const gridCellNode = utils.$findMatchingParent(selection2.anchor.getNode(), (n) => lexical.DEPRECATED_$isGridCellNode(n));
      const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, (n) => lexical.DEPRECATED_$isGridRowNode(n));
      const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, (n) => lexical.DEPRECATED_$isGridNode(n));
      if (!lexical.DEPRECATED_$isGridCellNode(gridCellNode) || !lexical.DEPRECATED_$isGridRowNode(gridRowNode) || !lexical.DEPRECATED_$isGridNode(gridNode)) {
        {
          throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);
        }
      }
      const startY = gridRowNode.getIndexWithinParent();
      const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);
      const startX = gridCellNode.getIndexWithinParent();
      const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);
      const fromX = Math.min(startX, stopX);
      const fromY = Math.min(startY, stopY);
      const toX = Math.max(startX, stopX);
      const toY = Math.max(startY, stopY);
      const gridRowNodes = gridNode.getChildren();
      let newRowIdx = 0;
      let newAnchorCellKey;
      let newFocusCellKey;
      for (let r = fromY; r <= toY; r++) {
        const currentGridRowNode = gridRowNodes[r];
        if (!lexical.DEPRECATED_$isGridRowNode(currentGridRowNode)) {
          {
            throw Error(`getNodes: expected to find GridRowNode`);
          }
        }
        const newGridRowNode = newGridRows[newRowIdx];
        if (!lexical.DEPRECATED_$isGridRowNode(newGridRowNode)) {
          {
            throw Error(`getNodes: expected to find GridRowNode`);
          }
        }
        const gridCellNodes = currentGridRowNode.getChildren();
        const newGridCellNodes = newGridRowNode.getChildren();
        let newColumnIdx = 0;
        for (let c3 = fromX; c3 <= toX; c3++) {
          const currentGridCellNode = gridCellNodes[c3];
          if (!lexical.DEPRECATED_$isGridCellNode(currentGridCellNode)) {
            {
              throw Error(`getNodes: expected to find GridCellNode`);
            }
          }
          const newGridCellNode = newGridCellNodes[newColumnIdx];
          if (!lexical.DEPRECATED_$isGridCellNode(newGridCellNode)) {
            {
              throw Error(`getNodes: expected to find GridCellNode`);
            }
          }
          if (r === fromY && c3 === fromX) {
            newAnchorCellKey = currentGridCellNode.getKey();
          } else if (r === toY && c3 === toX) {
            newFocusCellKey = currentGridCellNode.getKey();
          }
          const originalChildren = currentGridCellNode.getChildren();
          newGridCellNode.getChildren().forEach((child) => {
            if (lexical.$isTextNode(child)) {
              const paragraphNode = lexical.$createParagraphNode();
              paragraphNode.append(child);
              currentGridCellNode.append(child);
            } else {
              currentGridCellNode.append(child);
            }
          });
          originalChildren.forEach((n) => n.remove());
          newColumnIdx++;
        }
        newRowIdx++;
      }
      if (newAnchorCellKey && newFocusCellKey) {
        const newGridSelection = lexical.DEPRECATED_$createGridSelection();
        newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);
        lexical.$setSelection(newGridSelection);
        editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, void 0);
      }
    }
    function exportNodeToJSON(node) {
      const serializedNode = node.exportJSON();
      const nodeClass = node.constructor;
      if (serializedNode.type !== nodeClass.getType()) {
        {
          throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);
        }
      }
      const serializedChildren = serializedNode.children;
      if (lexical.$isElementNode(node)) {
        if (!Array.isArray(serializedChildren)) {
          {
            throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
          }
        }
      }
      return serializedNode;
    }
    function $appendNodesToJSON(editor, selection$1, currentNode, targetArray = []) {
      let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;
      const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy("html");
      let target = currentNode;
      if (selection$1 !== null) {
        let clone = selection.$cloneWithProperties(currentNode);
        clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;
        target = clone;
      }
      const children = lexical.$isElementNode(target) ? target.getChildren() : [];
      const serializedNode = exportNodeToJSON(target);
      if (lexical.$isTextNode(target)) {
        const text = target.__text;
        if (text.length > 0) {
          serializedNode.text = text;
        } else {
          shouldInclude = false;
        }
      }
      for (let i = 0; i < children.length; i++) {
        const childNode = children[i];
        const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);
        if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, "clone")) {
          shouldInclude = true;
        }
      }
      if (shouldInclude && !shouldExclude) {
        targetArray.push(serializedNode);
      } else if (Array.isArray(serializedNode.children)) {
        for (let i = 0; i < serializedNode.children.length; i++) {
          const serializedChildNode = serializedNode.children[i];
          targetArray.push(serializedChildNode);
        }
      }
      return shouldInclude;
    }
    function $generateJSONFromSelectedNodes(editor, selection2) {
      const nodes = [];
      const root = lexical.$getRoot();
      const topLevelChildren = root.getChildren();
      for (let i = 0; i < topLevelChildren.length; i++) {
        const topLevelNode = topLevelChildren[i];
        $appendNodesToJSON(editor, selection2, topLevelNode, nodes);
      }
      return {
        namespace: editor._config.namespace,
        nodes
      };
    }
    function $generateNodesFromSerializedNodes(serializedNodes) {
      const nodes = [];
      for (let i = 0; i < serializedNodes.length; i++) {
        const serializedNode = serializedNodes[i];
        const node = lexical.$parseSerializedNode(serializedNode);
        if (lexical.$isTextNode(node)) {
          selection.$addNodeStyle(node);
        }
        nodes.push(node);
      }
      return nodes;
    }
    var EVENT_LATENCY = 50;
    var clipboardEventTimeout = null;
    async function copyToClipboard__EXPERIMENTAL(editor, event) {
      if (clipboardEventTimeout !== null) {
        return false;
      }
      if (event !== null) {
        return new Promise((resolve, reject) => {
          editor.update(() => {
            resolve($copyToClipboardEvent(editor, event));
          });
        });
      }
      const rootElement = editor.getRootElement();
      const domSelection = document.getSelection();
      if (rootElement === null || domSelection === null) {
        return false;
      }
      const element = document.createElement("span");
      element.style.cssText = "position: fixed; top: -1000px;";
      element.append(document.createTextNode("#"));
      rootElement.append(element);
      const range2 = new Range();
      range2.setStart(element, 0);
      range2.setEnd(element, 1);
      domSelection.removeAllRanges();
      domSelection.addRange(range2);
      return new Promise((resolve, reject) => {
        const removeListener = editor.registerCommand(lexical.COPY_COMMAND, (secondEvent) => {
          if (secondEvent instanceof ClipboardEvent) {
            removeListener();
            if (clipboardEventTimeout !== null) {
              window.clearTimeout(clipboardEventTimeout);
              clipboardEventTimeout = null;
            }
            resolve($copyToClipboardEvent(editor, secondEvent));
          }
          return true;
        }, lexical.COMMAND_PRIORITY_CRITICAL);
        clipboardEventTimeout = window.setTimeout(() => {
          removeListener();
          clipboardEventTimeout = null;
          resolve(false);
        }, EVENT_LATENCY);
        document.execCommand("copy");
        element.remove();
      });
    }
    function $copyToClipboardEvent(editor, event) {
      const domSelection = window.getSelection();
      if (!domSelection) {
        return false;
      }
      const anchorDOM = domSelection.anchorNode;
      const focusDOM = domSelection.focusNode;
      if (anchorDOM !== null && focusDOM !== null && !lexical.isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
        return false;
      }
      event.preventDefault();
      const clipboardData = event.clipboardData;
      const selection2 = lexical.$getSelection();
      if (clipboardData === null || selection2 === null) {
        return false;
      }
      const htmlString = $getHtmlContent(editor);
      const lexicalString = $getLexicalContent(editor);
      let plainString = "";
      if (selection2 !== null) {
        plainString = selection2.getTextContent();
      }
      if (htmlString !== null) {
        clipboardData.setData("text/html", htmlString);
      }
      if (lexicalString !== null) {
        clipboardData.setData("application/x-lexical-editor", lexicalString);
      }
      clipboardData.setData("text/plain", plainString);
      return true;
    }
    exports.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;
    exports.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;
    exports.$getHtmlContent = $getHtmlContent;
    exports.$getLexicalContent = $getLexicalContent;
    exports.$insertDataTransferForPlainText = $insertDataTransferForPlainText;
    exports.$insertDataTransferForRichText = $insertDataTransferForRichText;
    exports.$insertGeneratedNodes = $insertGeneratedNodes;
    exports.copyToClipboard__EXPERIMENTAL = copyToClipboard__EXPERIMENTAL;
  }
});

// ../node_modules/@lexical/clipboard/LexicalClipboard.js
var require_LexicalClipboard = __commonJS({
  "../node_modules/@lexical/clipboard/LexicalClipboard.js"(exports, module) {
    "use strict";
    var LexicalClipboard = true ? require_LexicalClipboard_dev() : null;
    module.exports = LexicalClipboard;
  }
});

// ../node_modules/@lexical/rich-text/LexicalRichText.dev.js
var require_LexicalRichText_dev = __commonJS({
  "../node_modules/@lexical/rich-text/LexicalRichText.dev.js"(exports) {
    "use strict";
    var clipboard = require_LexicalClipboard();
    var selection = require_LexicalSelection();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    function caretFromPoint(x4, y4) {
      if (typeof document.caretRangeFromPoint !== "undefined") {
        const range2 = document.caretRangeFromPoint(x4, y4);
        if (range2 === null) {
          return null;
        }
        return {
          node: range2.startContainer,
          offset: range2.startOffset
        };
      } else if (document.caretPositionFromPoint !== "undefined") {
        const range2 = document.caretPositionFromPoint(x4, y4);
        if (range2 === null) {
          return null;
        }
        return {
          node: range2.offsetNode,
          offset: range2.offset
        };
      } else {
        return null;
      }
    }
    var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    var documentMode = CAN_USE_DOM && "documentMode" in document ? document.documentMode : null;
    CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
    CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
    var CAN_USE_BEFORE_INPUT = CAN_USE_DOM && "InputEvent" in window && !documentMode ? "getTargetRanges" in new window.InputEvent("input") : false;
    var IS_SAFARI = CAN_USE_DOM && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    var IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    var IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);
    var IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME;
    var DRAG_DROP_PASTE = lexical.createCommand("DRAG_DROP_PASTE_FILE");
    var QuoteNode = class _QuoteNode extends lexical.ElementNode {
      static getType() {
        return "quote";
      }
      static clone(node) {
        return new _QuoteNode(node.__key);
      }
      constructor(key) {
        super(key);
      }
      // View
      createDOM(config) {
        const element = document.createElement("blockquote");
        utils.addClassNamesToElement(element, config.theme.quote);
        return element;
      }
      updateDOM(prevNode, dom) {
        return false;
      }
      static importDOM() {
        return {
          blockquote: (node) => ({
            conversion: convertBlockquoteElement,
            priority: 0
          })
        };
      }
      static importJSON(serializedNode) {
        const node = $createQuoteNode();
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        return node;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          type: "quote"
        };
      }
      // Mutation
      insertNewAfter(_, restoreSelection) {
        const newBlock = lexical.$createParagraphNode();
        const direction = this.getDirection();
        newBlock.setDirection(direction);
        this.insertAfter(newBlock, restoreSelection);
        return newBlock;
      }
      collapseAtStart() {
        const paragraph = lexical.$createParagraphNode();
        const children = this.getChildren();
        children.forEach((child) => paragraph.append(child));
        this.replace(paragraph);
        return true;
      }
    };
    function $createQuoteNode() {
      return lexical.$applyNodeReplacement(new QuoteNode());
    }
    function $isQuoteNode(node) {
      return node instanceof QuoteNode;
    }
    var HeadingNode = class _HeadingNode extends lexical.ElementNode {
      /** @internal */
      static getType() {
        return "heading";
      }
      static clone(node) {
        return new _HeadingNode(node.__tag, node.__key);
      }
      constructor(tag, key) {
        super(key);
        this.__tag = tag;
      }
      getTag() {
        return this.__tag;
      }
      // View
      createDOM(config) {
        const tag = this.__tag;
        const element = document.createElement(tag);
        const theme = config.theme;
        const classNames = theme.heading;
        if (classNames !== void 0) {
          const className = classNames[tag];
          utils.addClassNamesToElement(element, className);
        }
        return element;
      }
      updateDOM(prevNode, dom) {
        return false;
      }
      static importDOM() {
        return {
          h1: (node) => ({
            conversion: convertHeadingElement,
            priority: 0
          }),
          h2: (node) => ({
            conversion: convertHeadingElement,
            priority: 0
          }),
          h3: (node) => ({
            conversion: convertHeadingElement,
            priority: 0
          }),
          h4: (node) => ({
            conversion: convertHeadingElement,
            priority: 0
          }),
          h5: (node) => ({
            conversion: convertHeadingElement,
            priority: 0
          }),
          h6: (node) => ({
            conversion: convertHeadingElement,
            priority: 0
          }),
          p: (node) => {
            const paragraph = node;
            const firstChild = paragraph.firstChild;
            if (firstChild !== null && isGoogleDocsTitle(firstChild)) {
              return {
                conversion: () => ({
                  node: null
                }),
                priority: 3
              };
            }
            return null;
          },
          span: (node) => {
            if (isGoogleDocsTitle(node)) {
              return {
                conversion: (domNode) => {
                  return {
                    node: $createHeadingNode("h1")
                  };
                },
                priority: 3
              };
            }
            return null;
          }
        };
      }
      static importJSON(serializedNode) {
        const node = $createHeadingNode(serializedNode.tag);
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        return node;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          tag: this.getTag(),
          type: "heading",
          version: 1
        };
      }
      // Mutation
      insertNewAfter(selection2, restoreSelection = true) {
        const anchorOffet = selection2 ? selection2.anchor.offset : 0;
        const newElement = anchorOffet > 0 && anchorOffet < this.getTextContentSize() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();
        const direction = this.getDirection();
        newElement.setDirection(direction);
        this.insertAfter(newElement, restoreSelection);
        return newElement;
      }
      collapseAtStart() {
        const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();
        const children = this.getChildren();
        children.forEach((child) => newElement.append(child));
        this.replace(newElement);
        return true;
      }
      extractWithChild() {
        return true;
      }
    };
    function isGoogleDocsTitle(domNode) {
      if (domNode.nodeName.toLowerCase() === "span") {
        return domNode.style.fontSize === "26pt";
      }
      return false;
    }
    function convertHeadingElement(domNode) {
      const nodeName = domNode.nodeName.toLowerCase();
      let node = null;
      if (nodeName === "h1" || nodeName === "h2" || nodeName === "h3" || nodeName === "h4" || nodeName === "h5" || nodeName === "h6") {
        node = $createHeadingNode(nodeName);
      }
      return {
        node
      };
    }
    function convertBlockquoteElement() {
      const node = $createQuoteNode();
      return {
        node
      };
    }
    function $createHeadingNode(headingTag) {
      return lexical.$applyNodeReplacement(new HeadingNode(headingTag));
    }
    function $isHeadingNode(node) {
      return node instanceof HeadingNode;
    }
    function onPasteForRichText(event, editor) {
      event.preventDefault();
      editor.update(() => {
        const selection2 = lexical.$getSelection();
        const clipboardData = event instanceof InputEvent || event instanceof KeyboardEvent ? null : event.clipboardData;
        if (clipboardData != null && (lexical.$isRangeSelection(selection2) || lexical.DEPRECATED_$isGridSelection(selection2))) {
          clipboard.$insertDataTransferForRichText(clipboardData, selection2, editor);
        }
      }, {
        tag: "paste"
      });
    }
    async function onCutForRichText(event, editor) {
      await clipboard.copyToClipboard__EXPERIMENTAL(editor, event instanceof ClipboardEvent ? event : null);
      editor.update(() => {
        const selection2 = lexical.$getSelection();
        if (lexical.$isRangeSelection(selection2)) {
          selection2.removeText();
        } else if (lexical.$isNodeSelection(selection2)) {
          selection2.getNodes().forEach((node) => node.remove());
        }
      });
    }
    function eventFiles(event) {
      let dataTransfer = null;
      if (event instanceof DragEvent) {
        dataTransfer = event.dataTransfer;
      } else if (event instanceof ClipboardEvent) {
        dataTransfer = event.clipboardData;
      }
      if (dataTransfer === null) {
        return [false, [], false];
      }
      const types = dataTransfer.types;
      const hasFiles = types.includes("Files");
      const hasContent = types.includes("text/html") || types.includes("text/plain");
      return [hasFiles, Array.from(dataTransfer.files), hasContent];
    }
    function handleIndentAndOutdent(insertTab, indentOrOutdent) {
      const selection2 = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection2)) {
        return;
      }
      const alreadyHandled = /* @__PURE__ */ new Set();
      const nodes = selection2.getNodes();
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        const key = node.getKey();
        if (alreadyHandled.has(key)) {
          continue;
        }
        const parentBlock = utils.$getNearestBlockElementAncestorOrThrow(node);
        const parentKey = parentBlock.getKey();
        if (parentBlock.canInsertTab()) {
          insertTab(node);
          alreadyHandled.add(key);
        } else if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {
          alreadyHandled.add(parentKey);
          indentOrOutdent(parentBlock);
        }
      }
    }
    function $isTargetWithinDecorator(target) {
      const node = lexical.$getNearestNodeFromDOMNode(target);
      return lexical.$isDecoratorNode(node);
    }
    function $isSelectionAtEndOfRoot(selection2) {
      const focus = selection2.focus;
      return focus.key === "root" && focus.offset === lexical.$getRoot().getChildrenSize();
    }
    function registerRichText(editor) {
      const removeListener = utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, (payload) => {
        const selection2 = lexical.$getSelection();
        if (lexical.$isNodeSelection(selection2)) {
          selection2.clear();
          return true;
        }
        return false;
      }, 0), editor.registerCommand(lexical.DELETE_CHARACTER_COMMAND, (isBackward) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.deleteCharacter(isBackward);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_WORD_COMMAND, (isBackward) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.deleteWord(isBackward);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_LINE_COMMAND, (isBackward) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.deleteLine(isBackward);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, (eventOrText) => {
        const selection2 = lexical.$getSelection();
        if (typeof eventOrText === "string") {
          if (lexical.$isRangeSelection(selection2)) {
            selection2.insertText(eventOrText);
          } else if (lexical.DEPRECATED_$isGridSelection(selection2))
            ;
        } else {
          if (!lexical.$isRangeSelection(selection2) && !lexical.DEPRECATED_$isGridSelection(selection2)) {
            return false;
          }
          const dataTransfer = eventOrText.dataTransfer;
          if (dataTransfer != null) {
            clipboard.$insertDataTransferForRichText(dataTransfer, selection2, editor);
          } else if (lexical.$isRangeSelection(selection2)) {
            const data = eventOrText.data;
            if (data) {
              selection2.insertText(data);
            }
            return true;
          }
        }
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REMOVE_TEXT_COMMAND, () => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.removeText();
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, (format3) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.formatText(format3);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_ELEMENT_COMMAND, (format3) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2) && !lexical.$isNodeSelection(selection2)) {
          return false;
        }
        const nodes = selection2.getNodes();
        for (const node of nodes) {
          const element = utils.$getNearestBlockElementAncestorOrThrow(node);
          element.setFormat(format3);
        }
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_LINE_BREAK_COMMAND, (selectStart) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.insertLineBreak(selectStart);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.insertParagraph();
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, () => {
        handleIndentAndOutdent(() => {
          editor.dispatchCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, "	");
        }, (block) => {
          const indent = block.getIndent();
          if (indent !== 10) {
            block.setIndent(indent + 1);
          }
        });
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, () => {
        handleIndentAndOutdent((node) => {
          if (lexical.$isTextNode(node)) {
            const textContent = node.getTextContent();
            const character = textContent[textContent.length - 1];
            if (character === "	") {
              editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);
            }
          }
        }, (block) => {
          const indent = block.getIndent();
          if (indent !== 0) {
            block.setIndent(indent - 1);
          }
        });
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, (event) => {
        const selection2 = lexical.$getSelection();
        if (lexical.$isNodeSelection(selection2) && !$isTargetWithinDecorator(event.target)) {
          const nodes = selection2.getNodes();
          if (nodes.length > 0) {
            nodes[0].selectPrevious();
            return true;
          }
        } else if (lexical.$isRangeSelection(selection2)) {
          const possibleNode = lexical.$getAdjacentNode(selection2.focus, true);
          if (lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {
            possibleNode.selectPrevious();
            event.preventDefault();
            return true;
          } else if (lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {
            possibleNode.select();
            event.preventDefault();
            return true;
          }
        }
        return false;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, (event) => {
        const selection2 = lexical.$getSelection();
        if (lexical.$isNodeSelection(selection2)) {
          const nodes = selection2.getNodes();
          if (nodes.length > 0) {
            nodes[0].selectNext(0, 0);
            return true;
          }
        } else if (lexical.$isRangeSelection(selection2)) {
          if ($isSelectionAtEndOfRoot(selection2)) {
            event.preventDefault();
            return true;
          }
          const possibleNode = lexical.$getAdjacentNode(selection2.focus, false);
          if (lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {
            possibleNode.selectNext();
            event.preventDefault();
            return true;
          }
        }
        return false;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, (event) => {
        const selection$1 = lexical.$getSelection();
        if (lexical.$isNodeSelection(selection$1)) {
          const nodes = selection$1.getNodes();
          if (nodes.length > 0) {
            event.preventDefault();
            nodes[0].selectPrevious();
            return true;
          }
        }
        if (!lexical.$isRangeSelection(selection$1)) {
          return false;
        }
        if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, true)) {
          const isHoldingShift = event.shiftKey;
          event.preventDefault();
          selection.$moveCharacter(selection$1, isHoldingShift, true);
          return true;
        }
        return false;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, (event) => {
        const selection$1 = lexical.$getSelection();
        if (lexical.$isNodeSelection(selection$1) && !$isTargetWithinDecorator(event.target)) {
          const nodes = selection$1.getNodes();
          if (nodes.length > 0) {
            event.preventDefault();
            nodes[0].selectNext(0, 0);
            return true;
          }
        }
        if (!lexical.$isRangeSelection(selection$1)) {
          return false;
        }
        const isHoldingShift = event.shiftKey;
        if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, false)) {
          event.preventDefault();
          selection.$moveCharacter(selection$1, isHoldingShift, false);
          return true;
        }
        return false;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, (event) => {
        if ($isTargetWithinDecorator(event.target)) {
          return false;
        }
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        event.preventDefault();
        const {
          anchor
        } = selection2;
        const anchorNode = anchor.getNode();
        if (selection2.isCollapsed() && anchor.offset === 0 && !lexical.$isRootNode(anchorNode)) {
          const element = utils.$getNearestBlockElementAncestorOrThrow(anchorNode);
          if (element.getIndent() > 0) {
            return editor.dispatchCommand(lexical.OUTDENT_CONTENT_COMMAND, void 0);
          }
        }
        return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_DELETE_COMMAND, (event) => {
        if ($isTargetWithinDecorator(event.target)) {
          return false;
        }
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        event.preventDefault();
        return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, false);
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ENTER_COMMAND, (event) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        if (event !== null) {
          if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {
            return false;
          }
          event.preventDefault();
          if (event.shiftKey) {
            return editor.dispatchCommand(lexical.INSERT_LINE_BREAK_COMMAND, false);
          }
        }
        return editor.dispatchCommand(lexical.INSERT_PARAGRAPH_COMMAND, void 0);
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, () => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        editor.blur();
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DROP_COMMAND, (event) => {
        const [, files] = eventFiles(event);
        if (files.length > 0) {
          const x4 = event.clientX;
          const y4 = event.clientY;
          const eventRange = caretFromPoint(x4, y4);
          if (eventRange !== null) {
            const {
              offset: domOffset,
              node: domNode
            } = eventRange;
            const node = lexical.$getNearestNodeFromDOMNode(domNode);
            if (node !== null) {
              const selection3 = lexical.$createRangeSelection();
              if (lexical.$isTextNode(node)) {
                selection3.anchor.set(node.getKey(), domOffset, "text");
                selection3.focus.set(node.getKey(), domOffset, "text");
              } else {
                const parentKey = node.getParentOrThrow().getKey();
                const offset = node.getIndexWithinParent() + 1;
                selection3.anchor.set(parentKey, offset, "element");
                selection3.focus.set(parentKey, offset, "element");
              }
              const normalizedSelection = lexical.$normalizeSelection__EXPERIMENTAL(selection3);
              lexical.$setSelection(normalizedSelection);
            }
            editor.dispatchCommand(DRAG_DROP_PASTE, files);
          }
          event.preventDefault();
          return true;
        }
        const selection2 = lexical.$getSelection();
        if (lexical.$isRangeSelection(selection2)) {
          return true;
        }
        return false;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGSTART_COMMAND, (event) => {
        const [isFileTransfer] = eventFiles(event);
        const selection2 = lexical.$getSelection();
        if (isFileTransfer && !lexical.$isRangeSelection(selection2)) {
          return false;
        }
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGOVER_COMMAND, (event) => {
        const [isFileTransfer] = eventFiles(event);
        const selection2 = lexical.$getSelection();
        if (isFileTransfer && !lexical.$isRangeSelection(selection2)) {
          return false;
        }
        const x4 = event.clientX;
        const y4 = event.clientY;
        const eventRange = caretFromPoint(x4, y4);
        if (eventRange !== null) {
          const node = lexical.$getNearestNodeFromDOMNode(eventRange.node);
          if (lexical.$isDecoratorNode(node)) {
            event.preventDefault();
          }
        }
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.COPY_COMMAND, (event) => {
        clipboard.copyToClipboard__EXPERIMENTAL(editor, event instanceof ClipboardEvent ? event : null);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CUT_COMMAND, (event) => {
        onCutForRichText(event, editor);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.PASTE_COMMAND, (event) => {
        const [, files, hasTextContent] = eventFiles(event);
        if (files.length > 0 && !hasTextContent) {
          editor.dispatchCommand(DRAG_DROP_PASTE, files);
          return true;
        }
        const selection2 = lexical.$getSelection();
        if (lexical.$isRangeSelection(selection2) || lexical.DEPRECATED_$isGridSelection(selection2)) {
          onPasteForRichText(event, editor);
          return true;
        }
        return false;
      }, lexical.COMMAND_PRIORITY_EDITOR));
      return removeListener;
    }
    exports.$createHeadingNode = $createHeadingNode;
    exports.$createQuoteNode = $createQuoteNode;
    exports.$isHeadingNode = $isHeadingNode;
    exports.$isQuoteNode = $isQuoteNode;
    exports.DRAG_DROP_PASTE = DRAG_DROP_PASTE;
    exports.HeadingNode = HeadingNode;
    exports.QuoteNode = QuoteNode;
    exports.eventFiles = eventFiles;
    exports.registerRichText = registerRichText;
  }
});

// ../node_modules/@lexical/rich-text/LexicalRichText.js
var require_LexicalRichText = __commonJS({
  "../node_modules/@lexical/rich-text/LexicalRichText.js"(exports, module) {
    "use strict";
    var LexicalRichText2 = true ? require_LexicalRichText_dev() : null;
    module.exports = LexicalRichText2;
  }
});

// ../node_modules/@lexical/link/LexicalLink.dev.js
var require_LexicalLink_dev = __commonJS({
  "../node_modules/@lexical/link/LexicalLink.dev.js"(exports) {
    "use strict";
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    var LinkNode = class _LinkNode extends lexical.ElementNode {
      /** @internal */
      /** @internal */
      /** @internal */
      static getType() {
        return "link";
      }
      static clone(node) {
        return new _LinkNode(node.__url, {
          rel: node.__rel,
          target: node.__target
        }, node.__key);
      }
      constructor(url, attributes = {}, key) {
        super(key);
        const {
          target = null,
          rel = null
        } = attributes;
        this.__url = url;
        this.__target = target;
        this.__rel = rel;
      }
      createDOM(config) {
        const element = document.createElement("a");
        element.href = this.__url;
        if (this.__target !== null) {
          element.target = this.__target;
        }
        if (this.__rel !== null) {
          element.rel = this.__rel;
        }
        utils.addClassNamesToElement(element, config.theme.link);
        return element;
      }
      updateDOM(prevNode, anchor, config) {
        const url = this.__url;
        const target = this.__target;
        const rel = this.__rel;
        if (url !== prevNode.__url) {
          anchor.href = url;
        }
        if (target !== prevNode.__target) {
          if (target) {
            anchor.target = target;
          } else {
            anchor.removeAttribute("target");
          }
        }
        if (rel !== prevNode.__rel) {
          if (rel) {
            anchor.rel = rel;
          } else {
            anchor.removeAttribute("rel");
          }
        }
        return false;
      }
      static importDOM() {
        return {
          a: (node) => ({
            conversion: convertAnchorElement,
            priority: 1
          })
        };
      }
      static importJSON(serializedNode) {
        const node = $createLinkNode(serializedNode.url, {
          rel: serializedNode.rel,
          target: serializedNode.target
        });
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        return node;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          rel: this.getRel(),
          target: this.getTarget(),
          type: "link",
          url: this.getURL(),
          version: 1
        };
      }
      getURL() {
        return this.getLatest().__url;
      }
      setURL(url) {
        const writable = this.getWritable();
        writable.__url = url;
      }
      getTarget() {
        return this.getLatest().__target;
      }
      setTarget(target) {
        const writable = this.getWritable();
        writable.__target = target;
      }
      getRel() {
        return this.getLatest().__rel;
      }
      setRel(rel) {
        const writable = this.getWritable();
        writable.__rel = rel;
      }
      insertNewAfter(selection, restoreSelection = true) {
        const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);
        if (lexical.$isElementNode(element)) {
          const linkNode = $createLinkNode(this.__url, {
            rel: this.__rel,
            target: this.__target
          });
          element.append(linkNode);
          return linkNode;
        }
        return null;
      }
      canInsertTextBefore() {
        return false;
      }
      canInsertTextAfter() {
        return false;
      }
      canBeEmpty() {
        return false;
      }
      isInline() {
        return true;
      }
      extractWithChild(child, selection, destination) {
        if (!lexical.$isRangeSelection(selection)) {
          return false;
        }
        const anchorNode = selection.anchor.getNode();
        const focusNode = selection.focus.getNode();
        return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;
      }
    };
    function convertAnchorElement(domNode) {
      let node = null;
      if (utils.isHTMLAnchorElement(domNode)) {
        const content = domNode.textContent;
        if (content !== null && content !== "") {
          node = $createLinkNode(domNode.getAttribute("href") || "", {
            rel: domNode.getAttribute("rel"),
            target: domNode.getAttribute("target")
          });
        }
      }
      return {
        node
      };
    }
    function $createLinkNode(url, attributes) {
      return lexical.$applyNodeReplacement(new LinkNode(url, attributes));
    }
    function $isLinkNode(node) {
      return node instanceof LinkNode;
    }
    var AutoLinkNode = class _AutoLinkNode extends LinkNode {
      static getType() {
        return "autolink";
      }
      static clone(node) {
        return new _AutoLinkNode(node.__url, {
          rel: node.__rel,
          target: node.__target
        }, node.__key);
      }
      static importJSON(serializedNode) {
        const node = $createAutoLinkNode(serializedNode.url, {
          rel: serializedNode.rel,
          target: serializedNode.target
        });
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        return node;
      }
      static importDOM() {
        return null;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          type: "autolink",
          version: 1
        };
      }
      insertNewAfter(selection, restoreSelection = true) {
        const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);
        if (lexical.$isElementNode(element)) {
          const linkNode = $createAutoLinkNode(this.__url, {
            rel: this._rel,
            target: this.__target
          });
          element.append(linkNode);
          return linkNode;
        }
        return null;
      }
    };
    function $createAutoLinkNode(url, attributes) {
      return lexical.$applyNodeReplacement(new AutoLinkNode(url, attributes));
    }
    function $isAutoLinkNode(node) {
      return node instanceof AutoLinkNode;
    }
    var TOGGLE_LINK_COMMAND = lexical.createCommand("TOGGLE_LINK_COMMAND");
    function toggleLink(url, attributes = {}) {
      const {
        target
      } = attributes;
      const rel = attributes.rel === void 0 ? "noopener" : attributes.rel;
      const selection = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection)) {
        return;
      }
      const nodes = selection.extract();
      if (url === null) {
        nodes.forEach((node) => {
          const parent = node.getParent();
          if ($isLinkNode(parent)) {
            const children = parent.getChildren();
            for (let i = 0; i < children.length; i++) {
              parent.insertBefore(children[i]);
            }
            parent.remove();
          }
        });
      } else {
        if (nodes.length === 1) {
          const firstNode = nodes[0];
          const linkNode2 = $isLinkNode(firstNode) ? firstNode : $getLinkAncestor(firstNode);
          if (linkNode2 !== null) {
            linkNode2.setURL(url);
            if (target !== void 0) {
              linkNode2.setTarget(target);
            }
            if (rel !== null) {
              linkNode2.setRel(rel);
            }
            return;
          }
        }
        let prevParent = null;
        let linkNode = null;
        nodes.forEach((node) => {
          const parent = node.getParent();
          if (parent === linkNode || parent === null || lexical.$isElementNode(node) && !node.isInline()) {
            return;
          }
          if ($isLinkNode(parent)) {
            linkNode = parent;
            parent.setURL(url);
            if (target !== void 0) {
              parent.setTarget(target);
            }
            if (rel !== null) {
              linkNode.setRel(rel);
            }
            return;
          }
          if (!parent.is(prevParent)) {
            prevParent = parent;
            linkNode = $createLinkNode(url, {
              rel,
              target
            });
            if ($isLinkNode(parent)) {
              if (node.getPreviousSibling() === null) {
                parent.insertBefore(linkNode);
              } else {
                parent.insertAfter(linkNode);
              }
            } else {
              node.insertBefore(linkNode);
            }
          }
          if ($isLinkNode(node)) {
            if (node.is(linkNode)) {
              return;
            }
            if (linkNode !== null) {
              const children = node.getChildren();
              for (let i = 0; i < children.length; i++) {
                linkNode.append(children[i]);
              }
            }
            node.remove();
            return;
          }
          if (linkNode !== null) {
            linkNode.append(node);
          }
        });
      }
    }
    function $getLinkAncestor(node) {
      return $getAncestor(node, (ancestor) => $isLinkNode(ancestor));
    }
    function $getAncestor(node, predicate) {
      let parent = node;
      while (parent !== null && (parent = parent.getParent()) !== null && !predicate(parent))
        ;
      return parent;
    }
    exports.$createAutoLinkNode = $createAutoLinkNode;
    exports.$createLinkNode = $createLinkNode;
    exports.$isAutoLinkNode = $isAutoLinkNode;
    exports.$isLinkNode = $isLinkNode;
    exports.AutoLinkNode = AutoLinkNode;
    exports.LinkNode = LinkNode;
    exports.TOGGLE_LINK_COMMAND = TOGGLE_LINK_COMMAND;
    exports.toggleLink = toggleLink;
  }
});

// ../node_modules/@lexical/link/LexicalLink.js
var require_LexicalLink = __commonJS({
  "../node_modules/@lexical/link/LexicalLink.js"(exports, module) {
    "use strict";
    var LexicalLink2 = true ? require_LexicalLink_dev() : null;
    module.exports = LexicalLink2;
  }
});

// ../node_modules/@lexical/markdown/LexicalMarkdown.dev.js
var require_LexicalMarkdown_dev = __commonJS({
  "../node_modules/@lexical/markdown/LexicalMarkdown.dev.js"(exports) {
    "use strict";
    var lexical = require_Lexical();
    var code = require_LexicalCode();
    var list = require_LexicalList();
    var richText = require_LexicalRichText();
    var utils = require_LexicalUtils();
    var link3 = require_LexicalLink();
    function indexBy(list2, callback) {
      const index2 = {};
      for (const item of list2) {
        const key = callback(item);
        if (index2[key]) {
          index2[key].push(item);
        } else {
          index2[key] = [item];
        }
      }
      return index2;
    }
    function transformersByType(transformers) {
      const byType = indexBy(transformers, (t) => t.type);
      return {
        element: byType.element || [],
        textFormat: byType["text-format"] || [],
        textMatch: byType["text-match"] || []
      };
    }
    var PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\s]/;
    function createMarkdownExport(transformers) {
      const byType = transformersByType(transformers);
      const textFormatTransformers = byType.textFormat.filter((transformer3) => transformer3.format.length === 1);
      return () => {
        const output = [];
        const children = lexical.$getRoot().getChildren();
        for (const child of children) {
          const result = exportTopLevelElements(child, byType.element, textFormatTransformers, byType.textMatch);
          if (result != null) {
            output.push(result);
          }
        }
        return output.join("\n\n");
      };
    }
    function exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {
      for (const transformer3 of elementTransformers) {
        const result = transformer3.export(node, (_node) => exportChildren(_node, textTransformersIndex, textMatchTransformers));
        if (result != null) {
          return result;
        }
      }
      if (lexical.$isElementNode(node)) {
        return exportChildren(node, textTransformersIndex, textMatchTransformers);
      } else if (lexical.$isDecoratorNode(node)) {
        return node.getTextContent();
      } else {
        return null;
      }
    }
    function exportChildren(node, textTransformersIndex, textMatchTransformers) {
      const output = [];
      const children = node.getChildren();
      mainLoop:
        for (const child of children) {
          for (const transformer3 of textMatchTransformers) {
            const result = transformer3.export(child, (parentNode) => exportChildren(parentNode, textTransformersIndex, textMatchTransformers), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex));
            if (result != null) {
              output.push(result);
              continue mainLoop;
            }
          }
          if (lexical.$isLineBreakNode(child)) {
            output.push("\n");
          } else if (lexical.$isTextNode(child)) {
            output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex));
          } else if (lexical.$isElementNode(child)) {
            output.push(exportChildren(child, textTransformersIndex, textMatchTransformers));
          } else if (lexical.$isDecoratorNode(child)) {
            output.push(child.getTextContent());
          }
        }
      return output.join("");
    }
    function exportTextFormat(node, textContent, textTransformers) {
      const frozenString = textContent.trim();
      let output = frozenString;
      const applied = /* @__PURE__ */ new Set();
      for (const transformer3 of textTransformers) {
        const format3 = transformer3.format[0];
        const tag = transformer3.tag;
        if (hasFormat(node, format3) && !applied.has(format3)) {
          applied.add(format3);
          const previousNode = getTextSibling(node, true);
          if (!hasFormat(previousNode, format3)) {
            output = tag + output;
          }
          const nextNode = getTextSibling(node, false);
          if (!hasFormat(nextNode, format3)) {
            output += tag;
          }
        }
      }
      return textContent.replace(frozenString, output);
    }
    function getTextSibling(node, backward) {
      let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();
      if (!sibling) {
        const parent = node.getParentOrThrow();
        if (parent.isInline()) {
          sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();
        }
      }
      while (sibling) {
        if (lexical.$isElementNode(sibling)) {
          if (!sibling.isInline()) {
            break;
          }
          const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();
          if (lexical.$isTextNode(descendant)) {
            return descendant;
          } else {
            sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();
          }
        }
        if (lexical.$isTextNode(sibling)) {
          return sibling;
        }
        if (!lexical.$isElementNode(sibling)) {
          return null;
        }
      }
      return null;
    }
    function hasFormat(node, format3) {
      return lexical.$isTextNode(node) && node.hasFormat(format3);
    }
    var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    var documentMode = CAN_USE_DOM && "documentMode" in document ? document.documentMode : null;
    CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
    CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
    CAN_USE_DOM && "InputEvent" in window && !documentMode ? "getTargetRanges" in new window.InputEvent("input") : false;
    var IS_SAFARI = CAN_USE_DOM && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    var IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    var IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);
    var IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME;
    var MARKDOWN_EMPTY_LINE_REG_EXP = /^\s{0,3}$/;
    var CODE_BLOCK_REG_EXP = /^```(\w{1,10})?\s?$/;
    function createMarkdownImport(transformers) {
      const byType = transformersByType(transformers);
      const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);
      return (markdownString) => {
        const lines = markdownString.split("\n");
        const linesLength = lines.length;
        const root = lexical.$getRoot();
        root.clear();
        for (let i = 0; i < linesLength; i++) {
          const lineText = lines[i];
          const [codeBlockNode, shiftedIndex] = importCodeBlock(lines, i, root);
          if (codeBlockNode != null) {
            i = shiftedIndex;
            continue;
          }
          importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch);
        }
        const children = root.getChildren();
        for (const child of children) {
          if (isEmptyParagraph(child)) {
            child.remove();
          }
        }
        root.selectEnd();
      };
    }
    function isEmptyParagraph(node) {
      if (!lexical.$isParagraphNode(node)) {
        return false;
      }
      const firstChild = node.getFirstChild();
      return firstChild == null || node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());
    }
    function importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers) {
      const lineTextTrimmed = lineText.trim();
      const textNode = lexical.$createTextNode(lineTextTrimmed);
      const elementNode = lexical.$createParagraphNode();
      elementNode.append(textNode);
      rootNode.append(elementNode);
      for (const {
        regExp,
        replace
      } of elementTransformers) {
        const match = lineText.match(regExp);
        if (match) {
          textNode.setTextContent(lineText.slice(match[0].length));
          replace(elementNode, [textNode], match, true);
          break;
        }
      }
      importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers);
      if (elementNode.isAttached() && lineTextTrimmed.length > 0) {
        const previousNode = elementNode.getPreviousSibling();
        if (lexical.$isParagraphNode(previousNode) || richText.$isQuoteNode(previousNode) || list.$isListNode(previousNode)) {
          let targetNode = previousNode;
          if (list.$isListNode(previousNode)) {
            const lastDescendant = previousNode.getLastDescendant();
            if (lastDescendant == null) {
              targetNode = null;
            } else {
              targetNode = utils.$findMatchingParent(lastDescendant, list.$isListItemNode);
            }
          }
          if (targetNode != null && targetNode.getTextContentSize() > 0) {
            targetNode.splice(targetNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...elementNode.getChildren()]);
            elementNode.remove();
          }
        }
      }
    }
    function importCodeBlock(lines, startLineIndex, rootNode) {
      const openMatch = lines[startLineIndex].match(CODE_BLOCK_REG_EXP);
      if (openMatch) {
        let endLineIndex = startLineIndex;
        const linesLength = lines.length;
        while (++endLineIndex < linesLength) {
          const closeMatch = lines[endLineIndex].match(CODE_BLOCK_REG_EXP);
          if (closeMatch) {
            const codeBlockNode = code.$createCodeNode(openMatch[1]);
            const textNode = lexical.$createTextNode(lines.slice(startLineIndex + 1, endLineIndex).join("\n"));
            codeBlockNode.append(textNode);
            rootNode.append(codeBlockNode);
            return [codeBlockNode, endLineIndex];
          }
        }
      }
      return [null, startLineIndex];
    }
    function importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {
      const textContent = textNode.getTextContent();
      const match = findOutermostMatch(textContent, textFormatTransformersIndex);
      if (!match) {
        importTextMatchTransformers(textNode, textMatchTransformers);
        return;
      }
      let currentNode, remainderNode, leadingNode;
      if (match[0] === textContent) {
        currentNode = textNode;
      } else {
        const startIndex = match.index || 0;
        const endIndex = startIndex + match[0].length;
        if (startIndex === 0) {
          [currentNode, remainderNode] = textNode.splitText(endIndex);
        } else {
          [leadingNode, currentNode, remainderNode] = textNode.splitText(startIndex, endIndex);
        }
      }
      currentNode.setTextContent(match[2]);
      const transformer3 = textFormatTransformersIndex.transformersByTag[match[1]];
      if (transformer3) {
        for (const format3 of transformer3.format) {
          if (!currentNode.hasFormat(format3)) {
            currentNode.toggleFormat(format3);
          }
        }
      }
      if (!currentNode.hasFormat("code")) {
        importTextFormatTransformers(currentNode, textFormatTransformersIndex, textMatchTransformers);
      }
      if (leadingNode) {
        importTextFormatTransformers(leadingNode, textFormatTransformersIndex, textMatchTransformers);
      }
      if (remainderNode) {
        importTextFormatTransformers(remainderNode, textFormatTransformersIndex, textMatchTransformers);
      }
    }
    function importTextMatchTransformers(textNode_, textMatchTransformers) {
      let textNode = textNode_;
      mainLoop:
        while (textNode) {
          for (const transformer3 of textMatchTransformers) {
            const match = textNode.getTextContent().match(transformer3.importRegExp);
            if (!match) {
              continue;
            }
            const startIndex = match.index || 0;
            const endIndex = startIndex + match[0].length;
            let replaceNode, leftTextNode, rightTextNode;
            if (startIndex === 0) {
              [replaceNode, textNode] = textNode.splitText(endIndex);
            } else {
              [leftTextNode, replaceNode, rightTextNode] = textNode.splitText(startIndex, endIndex);
            }
            if (leftTextNode) {
              importTextMatchTransformers(leftTextNode, textMatchTransformers);
            }
            if (rightTextNode) {
              textNode = rightTextNode;
            }
            transformer3.replace(replaceNode, match);
            continue mainLoop;
          }
          break;
        }
    }
    function findOutermostMatch(textContent, textTransformersIndex) {
      const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);
      if (openTagsMatch == null) {
        return null;
      }
      for (const match of openTagsMatch) {
        const tag = match.replace(/^\s/, "");
        const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];
        if (fullMatchRegExp == null) {
          continue;
        }
        const fullMatch = textContent.match(fullMatchRegExp);
        const transformer3 = textTransformersIndex.transformersByTag[tag];
        if (fullMatch != null && transformer3 != null) {
          if (transformer3.intraword !== false) {
            return fullMatch;
          }
          const {
            index: index2 = 0
          } = fullMatch;
          const beforeChar = textContent[index2 - 1];
          const afterChar = textContent[index2 + fullMatch[0].length];
          if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {
            return fullMatch;
          }
        }
      }
      return null;
    }
    function createTextFormatTransformersIndex(textTransformers) {
      const transformersByTag = {};
      const fullMatchRegExpByTag = {};
      const openTagsRegExp = [];
      const escapeRegExp = `(?<![\\\\])`;
      for (const transformer3 of textTransformers) {
        const {
          tag
        } = transformer3;
        transformersByTag[tag] = transformer3;
        const tagRegExp = tag.replace(/(\*|\^|\+)/g, "\\$1");
        openTagsRegExp.push(tagRegExp);
        if (IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT) {
          fullMatchRegExpByTag[tag] = new RegExp(`(${tagRegExp})(?![${tagRegExp}\\s])(.*?[^${tagRegExp}\\s])${tagRegExp}(?!${tagRegExp})`);
        } else {
          fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\${tagRegExp}])(${tagRegExp})((\\\\${tagRegExp})?.*?[^${tagRegExp}\\s](\\\\${tagRegExp})?)((?<!\\\\)|(?<=\\\\\\\\))(${tagRegExp})(?![\\\\${tagRegExp}])`);
        }
      }
      return {
        // Reg exp to find open tag + content + close tag
        fullMatchRegExpByTag,
        // Reg exp to find opening tags
        openTagsRegExp: new RegExp((IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? "" : `${escapeRegExp}`) + "(" + openTagsRegExp.join("|") + ")", "g"),
        transformersByTag
      };
    }
    function runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {
      const grandParentNode = parentNode.getParent();
      if (!lexical.$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {
        return false;
      }
      const textContent = anchorNode.getTextContent();
      if (textContent[anchorOffset - 1] !== " ") {
        return false;
      }
      for (const {
        regExp,
        replace
      } of elementTransformers) {
        const match = textContent.match(regExp);
        if (match && match[0].length === anchorOffset) {
          const nextSiblings = anchorNode.getNextSiblings();
          const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);
          leadingNode.remove();
          const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;
          replace(parentNode, siblings, match, false);
          return true;
        }
      }
      return false;
    }
    function runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {
      let textContent = anchorNode.getTextContent();
      const lastChar = textContent[anchorOffset - 1];
      const transformers = transformersByTrigger[lastChar];
      if (transformers == null) {
        return false;
      }
      if (anchorOffset < textContent.length) {
        textContent = textContent.slice(0, anchorOffset);
      }
      for (const transformer3 of transformers) {
        const match = textContent.match(transformer3.regExp);
        if (match === null) {
          continue;
        }
        const startIndex = match.index || 0;
        const endIndex = startIndex + match[0].length;
        let replaceNode;
        if (startIndex === 0) {
          [replaceNode] = anchorNode.splitText(endIndex);
        } else {
          [, replaceNode] = anchorNode.splitText(startIndex, endIndex);
        }
        replaceNode.selectNext(0, 0);
        transformer3.replace(replaceNode, match);
        return true;
      }
      return false;
    }
    function runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {
      const textContent = anchorNode.getTextContent();
      const closeTagEndIndex = anchorOffset - 1;
      const closeChar = textContent[closeTagEndIndex];
      const matchers = textFormatTransformers[closeChar];
      if (!matchers) {
        return false;
      }
      for (const matcher of matchers) {
        const {
          tag
        } = matcher;
        const tagLength = tag.length;
        const closeTagStartIndex = closeTagEndIndex - tagLength + 1;
        if (tagLength > 1) {
          if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {
            continue;
          }
        }
        if (textContent[closeTagStartIndex - 1] === " ") {
          continue;
        }
        const afterCloseTagChar = textContent[closeTagEndIndex + 1];
        if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {
          continue;
        }
        const closeNode = anchorNode;
        let openNode = closeNode;
        let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag);
        let sibling = openNode;
        while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {
          if (lexical.$isLineBreakNode(sibling)) {
            break;
          }
          if (lexical.$isTextNode(sibling)) {
            const siblingTextContent = sibling.getTextContent();
            openNode = sibling;
            openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);
          }
        }
        if (openTagStartIndex < 0) {
          continue;
        }
        if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {
          continue;
        }
        const prevOpenNodeText = openNode.getTextContent();
        if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {
          continue;
        }
        const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];
        if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {
          continue;
        }
        const prevCloseNodeText = closeNode.getTextContent();
        const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);
        closeNode.setTextContent(closeNodeText);
        const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;
        openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));
        const selection = lexical.$getSelection();
        const nextSelection = lexical.$createRangeSelection();
        lexical.$setSelection(nextSelection);
        const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;
        nextSelection.anchor.set(openNode.__key, openTagStartIndex, "text");
        nextSelection.focus.set(closeNode.__key, newOffset, "text");
        for (const format3 of matcher.format) {
          if (!nextSelection.hasFormat(format3)) {
            nextSelection.formatText(format3);
          }
        }
        nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type);
        for (const format3 of matcher.format) {
          if (nextSelection.hasFormat(format3)) {
            nextSelection.toggleFormat(format3);
          }
        }
        if (lexical.$isRangeSelection(selection)) {
          nextSelection.format = selection.format;
        }
        return true;
      }
      return false;
    }
    function getOpenTagStartIndex(string, maxIndex2, tag) {
      const tagLength = tag.length;
      for (let i = maxIndex2; i >= tagLength; i--) {
        const startIndex = i - tagLength;
        if (isEqualSubString(string, startIndex, tag, 0, tagLength) && // Space after opening tag cancels transformation
        string[startIndex + tagLength] !== " ") {
          return startIndex;
        }
      }
      return -1;
    }
    function isEqualSubString(stringA, aStart, stringB, bStart, length) {
      for (let i = 0; i < length; i++) {
        if (stringA[aStart + i] !== stringB[bStart + i]) {
          return false;
        }
      }
      return true;
    }
    function registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {
      const byType = transformersByType(transformers);
      const textFormatTransformersIndex = indexBy(byType.textFormat, ({
        tag
      }) => tag[tag.length - 1]);
      const textMatchTransformersIndex = indexBy(byType.textMatch, ({
        trigger
      }) => trigger);
      for (const transformer3 of transformers) {
        const type2 = transformer3.type;
        if (type2 === "element" || type2 === "text-match") {
          const dependencies = transformer3.dependencies;
          if (!editor.hasNodes(dependencies)) {
            {
              throw Error(`MarkdownShortcuts: missing dependency for transformer. Ensure node dependency is included in editor initial config.`);
            }
          }
        }
      }
      const transform = (parentNode, anchorNode, anchorOffset) => {
        if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {
          return;
        }
        if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersIndex)) {
          return;
        }
        runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersIndex);
      };
      return editor.registerUpdateListener(({
        tags,
        dirtyLeaves,
        editorState,
        prevEditorState
      }) => {
        if (tags.has("historic")) {
          return;
        }
        const selection = editorState.read(lexical.$getSelection);
        const prevSelection = prevEditorState.read(lexical.$getSelection);
        if (!lexical.$isRangeSelection(prevSelection) || !lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {
          return;
        }
        const anchorKey = selection.anchor.key;
        const anchorOffset = selection.anchor.offset;
        const anchorNode = editorState._nodeMap.get(anchorKey);
        if (!lexical.$isTextNode(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset !== prevSelection.anchor.offset + 1) {
          return;
        }
        editor.update(() => {
          if (anchorNode.hasFormat("code")) {
            return;
          }
          const parentNode = anchorNode.getParent();
          if (parentNode === null || code.$isCodeNode(parentNode)) {
            return;
          }
          transform(parentNode, anchorNode, selection.anchor.offset);
        });
      });
    }
    var createBlockNode = (createNode) => {
      return (parentNode, children, match) => {
        const node = createNode(match);
        node.append(...children);
        parentNode.replace(node);
        node.select(0, 0);
      };
    };
    var LIST_INDENT_SIZE = 4;
    var listReplace = (listType) => {
      return (parentNode, children, match) => {
        const previousNode = parentNode.getPreviousSibling();
        const listItem = list.$createListItemNode(listType === "check" ? match[3] === "x" : void 0);
        if (list.$isListNode(previousNode) && previousNode.getListType() === listType) {
          previousNode.append(listItem);
          parentNode.remove();
        } else {
          const list$1 = list.$createListNode(listType, listType === "number" ? Number(match[2]) : void 0);
          list$1.append(listItem);
          parentNode.replace(list$1);
        }
        listItem.append(...children);
        listItem.select(0, 0);
        const indent = Math.floor(match[1].length / LIST_INDENT_SIZE);
        if (indent) {
          listItem.setIndent(indent);
        }
      };
    };
    var listExport = (listNode, exportChildren2, depth) => {
      const output = [];
      const children = listNode.getChildren();
      let index2 = 0;
      for (const listItemNode of children) {
        if (list.$isListItemNode(listItemNode)) {
          if (listItemNode.getChildrenSize() === 1) {
            const firstChild = listItemNode.getFirstChild();
            if (list.$isListNode(firstChild)) {
              output.push(listExport(firstChild, exportChildren2, depth + 1));
              continue;
            }
          }
          const indent = " ".repeat(depth * LIST_INDENT_SIZE);
          const listType = listNode.getListType();
          const prefix = listType === "number" ? `${listNode.getStart() + index2}. ` : listType === "check" ? `- [${listItemNode.getChecked() ? "x" : " "}] ` : "- ";
          output.push(indent + prefix + exportChildren2(listItemNode));
          index2++;
        }
      }
      return output.join("\n");
    };
    var HEADING = {
      dependencies: [richText.HeadingNode],
      export: (node, exportChildren2) => {
        if (!richText.$isHeadingNode(node)) {
          return null;
        }
        const level = Number(node.getTag().slice(1));
        return "#".repeat(level) + " " + exportChildren2(node);
      },
      regExp: /^(#{1,6})\s/,
      replace: createBlockNode((match) => {
        const tag = "h" + match[1].length;
        return richText.$createHeadingNode(tag);
      }),
      type: "element"
    };
    var QUOTE2 = {
      dependencies: [richText.QuoteNode],
      export: (node, exportChildren2) => {
        if (!richText.$isQuoteNode(node)) {
          return null;
        }
        const lines = exportChildren2(node).split("\n");
        const output = [];
        for (const line of lines) {
          output.push("> " + line);
        }
        return output.join("\n");
      },
      regExp: /^>\s/,
      replace: (parentNode, children, _match, isImport) => {
        if (isImport) {
          const previousNode = parentNode.getPreviousSibling();
          if (richText.$isQuoteNode(previousNode)) {
            previousNode.splice(previousNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...children]);
            previousNode.select(0, 0);
            parentNode.remove();
            return;
          }
        }
        const node = richText.$createQuoteNode();
        node.append(...children);
        parentNode.replace(node);
        node.select(0, 0);
      },
      type: "element"
    };
    var CODE = {
      dependencies: [code.CodeNode],
      export: (node) => {
        if (!code.$isCodeNode(node)) {
          return null;
        }
        const textContent = node.getTextContent();
        return "```" + (node.getLanguage() || "") + (textContent ? "\n" + textContent : "") + "\n```";
      },
      regExp: /^```(\w{1,10})?\s/,
      replace: createBlockNode((match) => {
        return code.$createCodeNode(match ? match[1] : void 0);
      }),
      type: "element"
    };
    var UNORDERED_LIST = {
      dependencies: [list.ListNode, list.ListItemNode],
      export: (node, exportChildren2) => {
        return list.$isListNode(node) ? listExport(node, exportChildren2, 0) : null;
      },
      regExp: /^(\s*)[-*+]\s/,
      replace: listReplace("bullet"),
      type: "element"
    };
    var CHECK_LIST = {
      dependencies: [list.ListNode, list.ListItemNode],
      export: (node, exportChildren2) => {
        return list.$isListNode(node) ? listExport(node, exportChildren2, 0) : null;
      },
      regExp: /^(\s*)(?:-\s)?\s?(\[(\s|x)?\])\s/i,
      replace: listReplace("check"),
      type: "element"
    };
    var ORDERED_LIST = {
      dependencies: [list.ListNode, list.ListItemNode],
      export: (node, exportChildren2) => {
        return list.$isListNode(node) ? listExport(node, exportChildren2, 0) : null;
      },
      regExp: /^(\s*)(\d{1,})\.\s/,
      replace: listReplace("number"),
      type: "element"
    };
    var INLINE_CODE = {
      format: ["code"],
      tag: "`",
      type: "text-format"
    };
    var HIGHLIGHT = {
      format: ["highlight"],
      tag: "==",
      type: "text-format"
    };
    var BOLD_ITALIC_STAR = {
      format: ["bold", "italic"],
      tag: "***",
      type: "text-format"
    };
    var BOLD_ITALIC_UNDERSCORE = {
      format: ["bold", "italic"],
      intraword: false,
      tag: "___",
      type: "text-format"
    };
    var BOLD_STAR = {
      format: ["bold"],
      tag: "**",
      type: "text-format"
    };
    var BOLD_UNDERSCORE = {
      format: ["bold"],
      intraword: false,
      tag: "__",
      type: "text-format"
    };
    var STRIKETHROUGH = {
      format: ["strikethrough"],
      tag: "~~",
      type: "text-format"
    };
    var ITALIC_STAR = {
      format: ["italic"],
      tag: "*",
      type: "text-format"
    };
    var ITALIC_UNDERSCORE = {
      format: ["italic"],
      intraword: false,
      tag: "_",
      type: "text-format"
    };
    var LINK = {
      dependencies: [link3.LinkNode],
      export: (node, exportChildren2, exportFormat) => {
        if (!link3.$isLinkNode(node)) {
          return null;
        }
        const linkContent = `[${node.getTextContent()}](${node.getURL()})`;
        const firstChild = node.getFirstChild();
        if (node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild)) {
          return exportFormat(firstChild, linkContent);
        } else {
          return linkContent;
        }
      },
      importRegExp: /(?:\[([^[]+)\])(?:\(([^()]+)\))/,
      regExp: /(?:\[([^[]+)\])(?:\(([^()]+)\))$/,
      replace: (textNode, match) => {
        const [, linkText, linkUrl] = match;
        const linkNode = link3.$createLinkNode(linkUrl);
        const linkTextNode = lexical.$createTextNode(linkText);
        linkTextNode.setFormat(textNode.getFormat());
        linkNode.append(linkTextNode);
        textNode.replace(linkNode);
      },
      trigger: ")",
      type: "text-match"
    };
    var ELEMENT_TRANSFORMERS = [HEADING, QUOTE2, CODE, UNORDERED_LIST, ORDERED_LIST];
    var TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];
    var TEXT_MATCH_TRANSFORMERS = [LINK];
    var TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];
    function $convertFromMarkdownString(markdown, transformers = TRANSFORMERS) {
      const importMarkdown = createMarkdownImport(transformers);
      return importMarkdown(markdown);
    }
    function $convertToMarkdownString(transformers = TRANSFORMERS) {
      const exportMarkdown = createMarkdownExport(transformers);
      return exportMarkdown();
    }
    exports.$convertFromMarkdownString = $convertFromMarkdownString;
    exports.$convertToMarkdownString = $convertToMarkdownString;
    exports.BOLD_ITALIC_STAR = BOLD_ITALIC_STAR;
    exports.BOLD_ITALIC_UNDERSCORE = BOLD_ITALIC_UNDERSCORE;
    exports.BOLD_STAR = BOLD_STAR;
    exports.BOLD_UNDERSCORE = BOLD_UNDERSCORE;
    exports.CHECK_LIST = CHECK_LIST;
    exports.CODE = CODE;
    exports.ELEMENT_TRANSFORMERS = ELEMENT_TRANSFORMERS;
    exports.HEADING = HEADING;
    exports.HIGHLIGHT = HIGHLIGHT;
    exports.INLINE_CODE = INLINE_CODE;
    exports.ITALIC_STAR = ITALIC_STAR;
    exports.ITALIC_UNDERSCORE = ITALIC_UNDERSCORE;
    exports.LINK = LINK;
    exports.ORDERED_LIST = ORDERED_LIST;
    exports.QUOTE = QUOTE2;
    exports.STRIKETHROUGH = STRIKETHROUGH;
    exports.TEXT_FORMAT_TRANSFORMERS = TEXT_FORMAT_TRANSFORMERS;
    exports.TEXT_MATCH_TRANSFORMERS = TEXT_MATCH_TRANSFORMERS;
    exports.TRANSFORMERS = TRANSFORMERS;
    exports.UNORDERED_LIST = UNORDERED_LIST;
    exports.registerMarkdownShortcuts = registerMarkdownShortcuts;
  }
});

// ../node_modules/@lexical/markdown/LexicalMarkdown.js
var require_LexicalMarkdown = __commonJS({
  "../node_modules/@lexical/markdown/LexicalMarkdown.js"(exports, module) {
    "use strict";
    var LexicalMarkdown2 = true ? require_LexicalMarkdown_dev() : null;
    module.exports = LexicalMarkdown2;
  }
});

// ../node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js
var require_LexicalMarkdownShortcutPlugin_dev = __commonJS({
  "../node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js"(exports) {
    "use strict";
    var markdown = require_LexicalMarkdown();
    var LexicalComposerContext = require_LexicalComposerContext();
    var LexicalHorizontalRuleNode = require_LexicalHorizontalRuleNode();
    var react = require_react();
    var HR = {
      dependencies: [LexicalHorizontalRuleNode.HorizontalRuleNode],
      export: (node) => {
        return LexicalHorizontalRuleNode.$isHorizontalRuleNode(node) ? "***" : null;
      },
      regExp: /^(---|\*\*\*|___)\s?$/,
      replace: (parentNode, _1, _2, isImport) => {
        const line = LexicalHorizontalRuleNode.$createHorizontalRuleNode();
        if (isImport || parentNode.getNextSibling() != null) {
          parentNode.replace(line);
        } else {
          parentNode.insertBefore(line);
        }
        line.selectNext();
      },
      type: "element"
    };
    var DEFAULT_TRANSFORMERS = [HR, ...markdown.TRANSFORMERS];
    function MarkdownShortcutPlugin2({
      transformers = DEFAULT_TRANSFORMERS
    }) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      react.useEffect(() => {
        return markdown.registerMarkdownShortcuts(editor, transformers);
      }, [editor, transformers]);
      return null;
    }
    exports.DEFAULT_TRANSFORMERS = DEFAULT_TRANSFORMERS;
    exports.MarkdownShortcutPlugin = MarkdownShortcutPlugin2;
  }
});

// ../node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.js
var require_LexicalMarkdownShortcutPlugin = __commonJS({
  "../node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.js"(exports, module) {
    "use strict";
    var LexicalMarkdownShortcutPlugin = true ? require_LexicalMarkdownShortcutPlugin_dev() : null;
    module.exports = LexicalMarkdownShortcutPlugin;
  }
});

// ../node_modules/@lexical/react/useLexicalEditable.dev.js
var require_useLexicalEditable_dev = __commonJS({
  "../node_modules/@lexical/react/useLexicalEditable.dev.js"(exports, module) {
    "use strict";
    var LexicalComposerContext = require_LexicalComposerContext();
    var react = require_react();
    var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    var useLayoutEffectImpl = CAN_USE_DOM ? react.useLayoutEffect : react.useEffect;
    var useLayoutEffect = useLayoutEffectImpl;
    function useLexicalSubscription(subscription2) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      const initializedSubscription = react.useMemo(() => subscription2(editor), [editor, subscription2]);
      const valueRef = react.useRef(initializedSubscription.initialValueFn());
      const [value3, setValue] = react.useState(valueRef.current);
      useLayoutEffect(() => {
        const {
          initialValueFn,
          subscribe
        } = initializedSubscription;
        const currentValue = initialValueFn();
        if (valueRef.current !== currentValue) {
          valueRef.current = currentValue;
          setValue(currentValue);
        }
        return subscribe((newValue) => {
          valueRef.current = newValue;
          setValue(newValue);
        });
      }, [initializedSubscription, subscription2]);
      return value3;
    }
    function subscription(editor) {
      return {
        initialValueFn: () => editor.isEditable(),
        subscribe: (callback) => {
          return editor.registerEditableListener(callback);
        }
      };
    }
    function useLexicalEditable() {
      return useLexicalSubscription(subscription);
    }
    module.exports = useLexicalEditable;
  }
});

// ../node_modules/@lexical/react/useLexicalEditable.js
var require_useLexicalEditable = __commonJS({
  "../node_modules/@lexical/react/useLexicalEditable.js"(exports, module) {
    "use strict";
    var useLexicalEditable = true ? require_useLexicalEditable_dev() : null;
    module.exports = useLexicalEditable;
  }
});

// ../node_modules/@lexical/text/LexicalText.dev.js
var require_LexicalText_dev = __commonJS({
  "../node_modules/@lexical/text/LexicalText.dev.js"(exports) {
    "use strict";
    var lexical = require_Lexical();
    function $findTextIntersectionFromCharacters(root, targetCharacters) {
      let node = root.getFirstChild();
      let currentCharacters = 0;
      mainLoop:
        while (node !== null) {
          if (lexical.$isElementNode(node)) {
            const child = node.getFirstChild();
            if (child !== null) {
              node = child;
              continue;
            }
          } else if (lexical.$isTextNode(node)) {
            const characters = node.getTextContentSize();
            if (currentCharacters + characters > targetCharacters) {
              return {
                node,
                offset: targetCharacters - currentCharacters
              };
            }
            currentCharacters += characters;
          }
          const sibling = node.getNextSibling();
          if (sibling !== null) {
            node = sibling;
            continue;
          }
          let parent = node.getParent();
          while (parent !== null) {
            const parentSibling = parent.getNextSibling();
            if (parentSibling !== null) {
              node = parentSibling;
              continue mainLoop;
            }
            parent = parent.getParent();
          }
          break;
        }
      return null;
    }
    function $isRootTextContentEmpty(isEditorComposing, trim = true) {
      if (isEditorComposing) {
        return false;
      }
      let text = $rootTextContent();
      if (trim) {
        text = text.trim();
      }
      return text === "";
    }
    function $isRootTextContentEmptyCurry(isEditorComposing, trim) {
      return () => $isRootTextContentEmpty(isEditorComposing, trim);
    }
    function $rootTextContent() {
      const root = lexical.$getRoot();
      return root.getTextContent();
    }
    function $canShowPlaceholder(isComposing) {
      if (!$isRootTextContentEmpty(isComposing, false)) {
        return false;
      }
      const root = lexical.$getRoot();
      const children = root.getChildren();
      const childrenLength = children.length;
      if (childrenLength > 1) {
        return false;
      }
      for (let i = 0; i < childrenLength; i++) {
        const topBlock = children[i];
        if (lexical.$isElementNode(topBlock)) {
          if (!lexical.$isParagraphNode(topBlock)) {
            return false;
          }
          if (topBlock.__indent !== 0) {
            return false;
          }
          const topBlockChildren = topBlock.getChildren();
          const topBlockChildrenLength = topBlockChildren.length;
          for (let s2 = 0; s2 < topBlockChildrenLength; s2++) {
            const child = topBlockChildren[i];
            if (!lexical.$isTextNode(child)) {
              return false;
            }
          }
        }
      }
      return true;
    }
    function $canShowPlaceholderCurry(isEditorComposing) {
      return () => $canShowPlaceholder(isEditorComposing);
    }
    function registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {
      const isTargetNode = (node) => {
        return node instanceof targetNode;
      };
      const replaceWithSimpleText = (node) => {
        const textNode = lexical.$createTextNode(node.getTextContent());
        textNode.setFormat(node.getFormat());
        node.replace(textNode);
      };
      const getMode = (node) => {
        return node.getLatest().__mode;
      };
      const textNodeTransform = (node) => {
        if (!node.isSimpleText()) {
          return;
        }
        const prevSibling = node.getPreviousSibling();
        let text = node.getTextContent();
        let currentNode = node;
        let match;
        if (lexical.$isTextNode(prevSibling)) {
          const previousText = prevSibling.getTextContent();
          const combinedText = previousText + text;
          const prevMatch = getMatch(combinedText);
          if (isTargetNode(prevSibling)) {
            if (prevMatch === null || getMode(prevSibling) !== 0) {
              replaceWithSimpleText(prevSibling);
              return;
            } else {
              const diff = prevMatch.end - previousText.length;
              if (diff > 0) {
                const concatText = text.slice(0, diff);
                const newTextContent = previousText + concatText;
                prevSibling.select();
                prevSibling.setTextContent(newTextContent);
                if (diff === text.length) {
                  node.remove();
                } else {
                  const remainingText = text.slice(diff);
                  node.setTextContent(remainingText);
                }
                return;
              }
            }
          } else if (prevMatch === null || prevMatch.start < previousText.length) {
            return;
          }
        }
        while (true) {
          match = getMatch(text);
          let nextText = match === null ? "" : text.slice(match.end);
          text = nextText;
          if (nextText === "") {
            const nextSibling = currentNode.getNextSibling();
            if (lexical.$isTextNode(nextSibling)) {
              nextText = currentNode.getTextContent() + nextSibling.getTextContent();
              const nextMatch = getMatch(nextText);
              if (nextMatch === null) {
                if (isTargetNode(nextSibling)) {
                  replaceWithSimpleText(nextSibling);
                } else {
                  nextSibling.markDirty();
                }
                return;
              } else if (nextMatch.start !== 0) {
                return;
              }
            }
          } else {
            const nextMatch = getMatch(nextText);
            if (nextMatch !== null && nextMatch.start === 0) {
              return;
            }
          }
          if (match === null) {
            return;
          }
          if (match.start === 0 && lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {
            continue;
          }
          let nodeToReplace;
          if (match.start === 0) {
            [nodeToReplace, currentNode] = currentNode.splitText(match.end);
          } else {
            [, nodeToReplace, currentNode] = currentNode.splitText(match.start, match.end);
          }
          const replacementNode = createNode(nodeToReplace);
          nodeToReplace.replace(replacementNode);
          if (currentNode == null) {
            return;
          }
        }
      };
      const reverseNodeTransform = (node) => {
        const text = node.getTextContent();
        const match = getMatch(text);
        if (match === null || match.start !== 0) {
          replaceWithSimpleText(node);
          return;
        }
        if (text.length > match.end) {
          node.splitText(match.end);
          return;
        }
        const prevSibling = node.getPreviousSibling();
        if (lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {
          replaceWithSimpleText(prevSibling);
          replaceWithSimpleText(node);
        }
        const nextSibling = node.getNextSibling();
        if (lexical.$isTextNode(nextSibling) && nextSibling.isTextEntity()) {
          replaceWithSimpleText(nextSibling);
          if (isTargetNode(node)) {
            replaceWithSimpleText(node);
          }
        }
      };
      const removePlainTextTransform = editor.registerNodeTransform(lexical.TextNode, textNodeTransform);
      const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, reverseNodeTransform);
      return [removePlainTextTransform, removeReverseNodeTransform];
    }
    exports.$canShowPlaceholder = $canShowPlaceholder;
    exports.$canShowPlaceholderCurry = $canShowPlaceholderCurry;
    exports.$findTextIntersectionFromCharacters = $findTextIntersectionFromCharacters;
    exports.$isRootTextContentEmpty = $isRootTextContentEmpty;
    exports.$isRootTextContentEmptyCurry = $isRootTextContentEmptyCurry;
    exports.$rootTextContent = $rootTextContent;
    exports.registerLexicalTextEntity = registerLexicalTextEntity;
  }
});

// ../node_modules/@lexical/text/LexicalText.js
var require_LexicalText = __commonJS({
  "../node_modules/@lexical/text/LexicalText.js"(exports, module) {
    "use strict";
    var LexicalText = true ? require_LexicalText_dev() : null;
    module.exports = LexicalText;
  }
});

// ../node_modules/@lexical/dragon/LexicalDragon.dev.js
var require_LexicalDragon_dev = __commonJS({
  "../node_modules/@lexical/dragon/LexicalDragon.dev.js"(exports) {
    "use strict";
    var lexical = require_Lexical();
    function registerDragonSupport(editor) {
      const origin = window.location.origin;
      const handler = (event) => {
        if (event.origin !== origin) {
          return;
        }
        const rootElement = editor.getRootElement();
        if (document.activeElement !== rootElement) {
          return;
        }
        const data = event.data;
        if (typeof data === "string") {
          let parsedData;
          try {
            parsedData = JSON.parse(data);
          } catch (e) {
            return;
          }
          if (parsedData && parsedData.protocol === "nuanria_messaging" && parsedData.type === "request") {
            const payload = parsedData.payload;
            if (payload && payload.functionId === "makeChanges") {
              const args = payload.args;
              if (args) {
                const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args;
                editor.update(() => {
                  const selection = lexical.$getSelection();
                  if (lexical.$isRangeSelection(selection)) {
                    const anchor = selection.anchor;
                    let anchorNode = anchor.getNode();
                    let setSelStart = 0;
                    let setSelEnd = 0;
                    if (lexical.$isTextNode(anchorNode)) {
                      if (elementStart >= 0 && elementLength >= 0) {
                        setSelStart = elementStart;
                        setSelEnd = elementStart + elementLength;
                        selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);
                      }
                    }
                    if (setSelStart !== setSelEnd || text !== "") {
                      selection.insertRawText(text);
                      anchorNode = anchor.getNode();
                    }
                    if (lexical.$isTextNode(anchorNode)) {
                      setSelStart = selStart;
                      setSelEnd = selStart + selLength;
                      const anchorNodeTextLength = anchorNode.getTextContentSize();
                      setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;
                      setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;
                      selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);
                    }
                    event.stopImmediatePropagation();
                  }
                });
              }
            }
          }
        }
      };
      window.addEventListener("message", handler, true);
      return () => {
        window.removeEventListener("message", handler, true);
      };
    }
    exports.registerDragonSupport = registerDragonSupport;
  }
});

// ../node_modules/@lexical/dragon/LexicalDragon.js
var require_LexicalDragon = __commonJS({
  "../node_modules/@lexical/dragon/LexicalDragon.js"(exports, module) {
    "use strict";
    var LexicalDragon = true ? require_LexicalDragon_dev() : null;
    module.exports = LexicalDragon;
  }
});

// ../node_modules/@lexical/react/LexicalRichTextPlugin.dev.js
var require_LexicalRichTextPlugin_dev = __commonJS({
  "../node_modules/@lexical/react/LexicalRichTextPlugin.dev.js"(exports) {
    "use strict";
    var LexicalComposerContext = require_LexicalComposerContext();
    var useLexicalEditable = require_useLexicalEditable();
    var React2 = require_react();
    var text = require_LexicalText();
    var utils = require_LexicalUtils();
    var reactDom = require_react_dom();
    var dragon = require_LexicalDragon();
    var richText = require_LexicalRichText();
    var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    var useLayoutEffectImpl = CAN_USE_DOM ? React2.useLayoutEffect : React2.useEffect;
    var useLayoutEffect = useLayoutEffectImpl;
    function canShowPlaceholderFromCurrentEditorState(editor) {
      const currentCanShowPlaceholder = editor.getEditorState().read(text.$canShowPlaceholderCurry(editor.isComposing()));
      return currentCanShowPlaceholder;
    }
    function useCanShowPlaceholder(editor) {
      const [canShowPlaceholder, setCanShowPlaceholder] = React2.useState(() => canShowPlaceholderFromCurrentEditorState(editor));
      useLayoutEffect(() => {
        function resetCanShowPlaceholder() {
          const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);
          setCanShowPlaceholder(currentCanShowPlaceholder);
        }
        resetCanShowPlaceholder();
        return utils.mergeRegister(editor.registerUpdateListener(() => {
          resetCanShowPlaceholder();
        }), editor.registerEditableListener(() => {
          resetCanShowPlaceholder();
        }));
      }, [editor]);
      return canShowPlaceholder;
    }
    function useDecorators(editor, ErrorBoundary) {
      const [decorators, setDecorators] = React2.useState(() => editor.getDecorators());
      useLayoutEffect(() => {
        return editor.registerDecoratorListener((nextDecorators) => {
          reactDom.flushSync(() => {
            setDecorators(nextDecorators);
          });
        });
      }, [editor]);
      React2.useEffect(() => {
        setDecorators(editor.getDecorators());
      }, [editor]);
      return React2.useMemo(() => {
        const decoratedPortals = [];
        const decoratorKeys = Object.keys(decorators);
        for (let i = 0; i < decoratorKeys.length; i++) {
          const nodeKey = decoratorKeys[i];
          const reactDecorator = React2.createElement(ErrorBoundary, {
            onError: (e) => editor._onError(e)
          }, React2.createElement(React2.Suspense, {
            fallback: null
          }, decorators[nodeKey]));
          const element = editor.getElementByKey(nodeKey);
          if (element !== null) {
            decoratedPortals.push(reactDom.createPortal(reactDecorator, element));
          }
        }
        return decoratedPortals;
      }, [ErrorBoundary, decorators, editor]);
    }
    function useRichTextSetup(editor) {
      useLayoutEffect(() => {
        return utils.mergeRegister(richText.registerRichText(editor), dragon.registerDragonSupport(editor));
      }, [editor]);
    }
    function RichTextPlugin2({
      contentEditable,
      placeholder,
      ErrorBoundary
    }) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      const decorators = useDecorators(editor, ErrorBoundary);
      useRichTextSetup(editor);
      return React2.createElement(React2.Fragment, null, contentEditable, React2.createElement(Placeholder, {
        content: placeholder
      }), decorators);
    }
    function Placeholder({
      content
    }) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      const showPlaceholder = useCanShowPlaceholder(editor);
      const editable = useLexicalEditable();
      if (!showPlaceholder) {
        return null;
      }
      if (typeof content === "function") {
        return content(editable);
      } else {
        return content;
      }
    }
    exports.RichTextPlugin = RichTextPlugin2;
  }
});

// ../node_modules/@lexical/react/LexicalRichTextPlugin.js
var require_LexicalRichTextPlugin = __commonJS({
  "../node_modules/@lexical/react/LexicalRichTextPlugin.js"(exports, module) {
    "use strict";
    var LexicalRichTextPlugin = true ? require_LexicalRichTextPlugin_dev() : null;
    module.exports = LexicalRichTextPlugin;
  }
});

// ../node_modules/@lexical/react/LexicalTabIndentationPlugin.dev.js
var require_LexicalTabIndentationPlugin_dev = __commonJS({
  "../node_modules/@lexical/react/LexicalTabIndentationPlugin.dev.js"(exports) {
    "use strict";
    var LexicalComposerContext = require_LexicalComposerContext();
    var lexical = require_Lexical();
    var react = require_react();
    function TabIndentationPlugin2() {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      react.useEffect(() => {
        return editor.registerCommand(lexical.KEY_TAB_COMMAND, (event) => {
          const selection = lexical.$getSelection();
          if (!lexical.$isRangeSelection(selection)) {
            return false;
          }
          event.preventDefault();
          return editor.dispatchCommand(event.shiftKey ? lexical.OUTDENT_CONTENT_COMMAND : lexical.INDENT_CONTENT_COMMAND, void 0);
        }, lexical.COMMAND_PRIORITY_EDITOR);
      });
      return null;
    }
    exports.TabIndentationPlugin = TabIndentationPlugin2;
  }
});

// ../node_modules/@lexical/react/LexicalTabIndentationPlugin.js
var require_LexicalTabIndentationPlugin = __commonJS({
  "../node_modules/@lexical/react/LexicalTabIndentationPlugin.js"(exports, module) {
    "use strict";
    var LexicalTabIndentationPlugin = true ? require_LexicalTabIndentationPlugin_dev() : null;
    module.exports = LexicalTabIndentationPlugin;
  }
});

// ../node_modules/@material-ui/icons/Code.js
var require_Code = __commonJS({
  "../node_modules/@material-ui/icons/Code.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _interopRequireWildcard = require_interopRequireWildcard();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var React2 = _interopRequireWildcard(require_react());
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _default = (0, _createSvgIcon.default)(React2.createElement("path", {
      d: "M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"
    }), "Code");
    exports.default = _default;
  }
});

// ../node_modules/@material-ui/icons/FormatBold.js
var require_FormatBold = __commonJS({
  "../node_modules/@material-ui/icons/FormatBold.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _interopRequireWildcard = require_interopRequireWildcard();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var React2 = _interopRequireWildcard(require_react());
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _default = (0, _createSvgIcon.default)(React2.createElement("path", {
      d: "M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z"
    }), "FormatBold");
    exports.default = _default;
  }
});

// ../node_modules/@material-ui/icons/FormatItalic.js
var require_FormatItalic = __commonJS({
  "../node_modules/@material-ui/icons/FormatItalic.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _interopRequireWildcard = require_interopRequireWildcard();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var React2 = _interopRequireWildcard(require_react());
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _default = (0, _createSvgIcon.default)(React2.createElement("path", {
      d: "M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z"
    }), "FormatItalic");
    exports.default = _default;
  }
});

// ../node_modules/@material-ui/icons/FormatListNumbered.js
var require_FormatListNumbered = __commonJS({
  "../node_modules/@material-ui/icons/FormatListNumbered.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _interopRequireWildcard = require_interopRequireWildcard();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var React2 = _interopRequireWildcard(require_react());
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _default = (0, _createSvgIcon.default)(React2.createElement("path", {
      d: "M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z"
    }), "FormatListNumbered");
    exports.default = _default;
  }
});

// ../node_modules/@material-ui/icons/StrikethroughS.js
var require_StrikethroughS = __commonJS({
  "../node_modules/@material-ui/icons/StrikethroughS.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _interopRequireWildcard = require_interopRequireWildcard();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var React2 = _interopRequireWildcard(require_react());
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _default = (0, _createSvgIcon.default)(React2.createElement("path", {
      d: "M6.85 7.08C6.85 4.37 9.45 3 12.24 3c1.64 0 3 .49 3.9 1.28.77.65 1.46 1.73 1.46 3.24h-3.01c0-.31-.05-.59-.15-.85-.29-.86-1.2-1.28-2.25-1.28-1.86 0-2.34 1.02-2.34 1.7 0 .48.25.88.74 1.21.38.25.77.48 1.41.7H7.39c-.21-.34-.54-.89-.54-1.92zM21 12v-2H3v2h9.62c1.15.45 1.96.75 1.96 1.97 0 1-.81 1.67-2.28 1.67-1.54 0-2.93-.54-2.93-2.51H6.4c0 .55.08 1.13.24 1.58.81 2.29 3.29 3.3 5.67 3.3 2.27 0 5.3-.89 5.3-4.05 0-.3-.01-1.16-.48-1.94H21V12z"
    }), "StrikethroughS");
    exports.default = _default;
  }
});

// ../node_modules/@material-ui/icons/Subject.js
var require_Subject = __commonJS({
  "../node_modules/@material-ui/icons/Subject.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _interopRequireWildcard = require_interopRequireWildcard();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var React2 = _interopRequireWildcard(require_react());
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _default = (0, _createSvgIcon.default)(React2.createElement("path", {
      d: "M14 17H4v2h10v-2zm6-8H4v2h16V9zM4 15h16v-2H4v2zM4 5v2h16V5H4z"
    }), "Subject");
    exports.default = _default;
  }
});

// ../node_modules/@material-ui/icons/Title.js
var require_Title = __commonJS({
  "../node_modules/@material-ui/icons/Title.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _interopRequireWildcard = require_interopRequireWildcard();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var React2 = _interopRequireWildcard(require_react());
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _default = (0, _createSvgIcon.default)(React2.createElement("path", {
      d: "M5 4v3h5.5v12h3V7H19V4z"
    }), "Title");
    exports.default = _default;
  }
});

// ../node_modules/@eclipse-sirius/sirius-components-forms/dist/sirius-components-forms.es.js
var import_react2 = __toESM(require_react());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_HelpOutlineOutlined = __toESM(require_HelpOutlineOutlined());

// ../node_modules/@eclipse-sirius/sirius-components-charts/dist/sirius-components-charts.es.js
var import_jsx_runtime = __toESM(require_jsx_runtime());

// ../node_modules/d3-array/src/ascending.js
function ascending(a2, b) {
  return a2 == null || b == null ? NaN : a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}

// ../node_modules/d3-array/src/descending.js
function descending(a2, b) {
  return a2 == null || b == null ? NaN : b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
}

// ../node_modules/d3-array/src/bisector.js
function bisector(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending;
    compare2 = (d, x4) => ascending(f(d), x4);
    delta = (d, x4) => f(d) - x4;
  } else {
    compare1 = f === ascending || f === descending ? f : zero;
    compare2 = f;
    delta = f;
  }
  function left2(a2, x4, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x4, x4) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x4) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a2, x4, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x4, x4) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x4) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a2, x4, lo = 0, hi = a2.length) {
    const i = left2(a2, x4, lo, hi - 1);
    return i > lo && delta(a2[i - 1], x4) > -delta(a2[i], x4) ? i - 1 : i;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero() {
  return 0;
}

// ../node_modules/d3-array/src/number.js
function number(x4) {
  return x4 === null ? NaN : +x4;
}

// ../node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// ../node_modules/d3-array/src/blur.js
var blur2 = Blur2(blurf);
var blurImage = Blur2(blurfImage);
function Blur2(blur3) {
  return function(data, rx, ry = rx) {
    if (!((rx = +rx) >= 0))
      throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0))
      throw new RangeError("invalid ry");
    let { data: values, width, height } = data;
    if (!((width = Math.floor(width)) >= 0))
      throw new RangeError("invalid width");
    if (!((height = Math.floor(height !== void 0 ? height : values.length / width)) >= 0))
      throw new RangeError("invalid height");
    if (!width || !height || !rx && !ry)
      return data;
    const blurx = rx && blur3(rx);
    const blury = ry && blur3(ry);
    const temp = values.slice();
    if (blurx && blury) {
      blurh(blurx, temp, values, width, height);
      blurh(blurx, values, temp, width, height);
      blurh(blurx, temp, values, width, height);
      blurv(blury, values, temp, width, height);
      blurv(blury, temp, values, width, height);
      blurv(blury, values, temp, width, height);
    } else if (blurx) {
      blurh(blurx, values, temp, width, height);
      blurh(blurx, temp, values, width, height);
      blurh(blurx, values, temp, width, height);
    } else if (blury) {
      blurv(blury, values, temp, width, height);
      blurv(blury, temp, values, width, height);
      blurv(blury, values, temp, width, height);
    }
    return data;
  };
}
function blurh(blur3, T, S, w, h) {
  for (let y4 = 0, n = w * h; y4 < n; ) {
    blur3(T, S, y4, y4 += w, 1);
  }
}
function blurv(blur3, T, S, w, h) {
  for (let x4 = 0, n = w * h; x4 < w; ++x4) {
    blur3(T, S, x4, x4 + n, w);
  }
}
function blurfImage(radius) {
  const blur3 = blurf(radius);
  return (T, S, start, stop, step) => {
    start <<= 2, stop <<= 2, step <<= 2;
    blur3(T, S, start + 0, stop + 0, step);
    blur3(T, S, start + 1, stop + 1, step);
    blur3(T, S, start + 2, stop + 2, step);
    blur3(T, S, start + 3, stop + 3, step);
  };
}
function blurf(radius) {
  const radius0 = Math.floor(radius);
  if (radius0 === radius)
    return bluri(radius);
  const t = radius - radius0;
  const w = 2 * radius + 1;
  return (T, S, start, stop, step) => {
    if (!((stop -= step) >= start))
      return;
    let sum4 = radius0 * S[start];
    const s0 = step * radius0;
    const s1 = s0 + step;
    for (let i = start, j = start + s0; i < j; i += step) {
      sum4 += S[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step) {
      sum4 += S[Math.min(stop, i + s0)];
      T[i] = (sum4 + t * (S[Math.max(start, i - s1)] + S[Math.min(stop, i + s1)])) / w;
      sum4 -= S[Math.max(start, i - s0)];
    }
  };
}
function bluri(radius) {
  const w = 2 * radius + 1;
  return (T, S, start, stop, step) => {
    if (!((stop -= step) >= start))
      return;
    let sum4 = radius * S[start];
    const s2 = step * radius;
    for (let i = start, j = start + s2; i < j; i += step) {
      sum4 += S[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step) {
      sum4 += S[Math.min(stop, i + s2)];
      T[i] = sum4 / w;
      sum4 -= S[Math.max(start, i - s2)];
    }
  };
}

// ../node_modules/d3-array/src/fsum.js
var Adder = class {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x4) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y4 = p[j], hi = x4 + y4, lo = Math.abs(x4) < Math.abs(y4) ? x4 - (hi - y4) : y4 - (hi - x4);
      if (lo)
        p[i++] = lo;
      x4 = hi;
    }
    p[i] = x4;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x4, y4, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x4 = hi;
        y4 = p[--n];
        hi = x4 + y4;
        lo = y4 - (hi - x4);
        if (lo)
          break;
      }
      if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
        y4 = lo * 2;
        x4 = hi + y4;
        if (y4 == x4 - hi)
          hi = x4;
      }
    }
    return hi;
  }
};

// ../node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null)
      for (const [key2, value3] of entries)
        this.set(key2, value3);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value3) {
    return super.set(intern_set(this, key), value3);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
var InternSet = class extends Set {
  constructor(values, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (values != null)
      for (const value3 of values)
        this.add(value3);
  }
  has(value3) {
    return super.has(intern_get(this, value3));
  }
  add(value3) {
    return super.add(intern_set(this, value3));
  }
  delete(value3) {
    return super.delete(intern_delete(this, value3));
  }
};
function intern_get({ _intern, _key }, value3) {
  const key = _key(value3);
  return _intern.has(key) ? _intern.get(key) : value3;
}
function intern_set({ _intern, _key }, value3) {
  const key = _key(value3);
  if (_intern.has(key))
    return _intern.get(key);
  _intern.set(key, value3);
  return value3;
}
function intern_delete({ _intern, _key }, value3) {
  const key = _key(value3);
  if (_intern.has(key)) {
    value3 = _intern.get(key);
    _intern.delete(key);
  }
  return value3;
}
function keyof(value3) {
  return value3 !== null && typeof value3 === "object" ? value3.valueOf() : value3;
}

// ../node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

// ../node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start, stop, count3) {
  const step = (stop - start) / Math.max(0, count3), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start)
      ++i1;
    if (i2 / inc > stop)
      --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start)
      ++i1;
    if (i2 * inc > stop)
      --i2;
  }
  if (i2 < i1 && 0.5 <= count3 && count3 < 2)
    return tickSpec(start, stop, count3 * 2);
  return [i1, i2, inc];
}
function ticks(start, stop, count3) {
  stop = +stop, start = +start, count3 = +count3;
  if (!(count3 > 0))
    return [];
  if (start === stop)
    return [start];
  const reverse2 = stop < start, [i1, i2, inc] = reverse2 ? tickSpec(stop, start, count3) : tickSpec(start, stop, count3);
  if (!(i2 >= i1))
    return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse2) {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) * inc;
  } else {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start, stop, count3) {
  stop = +stop, start = +start, count3 = +count3;
  return tickSpec(start, stop, count3)[2];
}
function tickStep(start, stop, count3) {
  stop = +stop, start = +start, count3 = +count3;
  const reverse2 = stop < start, inc = reverse2 ? tickIncrement(stop, start, count3) : tickIncrement(start, stop, count3);
  return (reverse2 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}

// ../node_modules/d3-array/src/max.js
function max(values, valueof) {
  let max5;
  if (valueof === void 0) {
    for (const value3 of values) {
      if (value3 != null && (max5 < value3 || max5 === void 0 && value3 >= value3)) {
        max5 = value3;
      }
    }
  } else {
    let index2 = -1;
    for (let value3 of values) {
      if ((value3 = valueof(value3, ++index2, values)) != null && (max5 < value3 || max5 === void 0 && value3 >= value3)) {
        max5 = value3;
      }
    }
  }
  return max5;
}

// ../node_modules/d3-array/src/merge.js
function* flatten(arrays) {
  for (const array3 of arrays) {
    yield* array3;
  }
}
function merge(arrays) {
  return Array.from(flatten(arrays));
}

// ../node_modules/d3-array/src/range.js
function range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range2 = new Array(n);
  while (++i < n) {
    range2[i] = start + i * step;
  }
  return range2;
}

// ../node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random) {
  return function shuffle2(array3, i0 = 0, i1 = array3.length) {
    let m = i1 - (i0 = +i0);
    while (m) {
      const i = random() * m-- | 0, t = array3[m + i0];
      array3[m + i0] = array3[i + i0];
      array3[i + i0] = t;
    }
    return array3;
  };
}

// ../node_modules/d3-array/src/map.js
function map2(values, mapper) {
  if (typeof values[Symbol.iterator] !== "function")
    throw new TypeError("values is not iterable");
  if (typeof mapper !== "function")
    throw new TypeError("mapper is not a function");
  return Array.from(values, (value3, index2) => mapper(value3, index2, values));
}

// ../node_modules/d3-axis/src/identity.js
function identity_default(x4) {
  return x4;
}

// ../node_modules/d3-axis/src/axis.js
var top = 1;
var right = 2;
var bottom = 3;
var left = 4;
var epsilon = 1e-6;
function translateX(x4) {
  return "translate(" + x4 + ",0)";
}
function translateY(y4) {
  return "translate(0," + y4 + ")";
}
function number2(scale2) {
  return (d) => +scale2(d);
}
function center(scale2, offset) {
  offset = Math.max(0, scale2.bandwidth() - offset * 2) / 2;
  if (scale2.round())
    offset = Math.round(offset);
  return (d) => +scale2(d) + offset;
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale2) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k2 = orient === top || orient === left ? -1 : 1, x4 = orient === left || orient === right ? "x" : "y", transform = orient === top || orient === bottom ? translateX : translateY;
  function axis2(context) {
    var values = tickValues == null ? scale2.ticks ? scale2.ticks.apply(scale2, tickArguments) : scale2.domain() : tickValues, format3 = tickFormat2 == null ? scale2.tickFormat ? scale2.tickFormat.apply(scale2, tickArguments) : identity_default : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range2 = scale2.range(), range0 = +range2[0] + offset, range1 = +range2[range2.length - 1] + offset, position = (scale2.bandwidth ? center : number2)(scale2.copy(), offset), selection = context.selection ? context.selection() : context, path2 = selection.selectAll(".domain").data([null]), tick = selection.selectAll(".tick").data(values, scale2).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line = tick.select("line"), text = tick.select("text");
    path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line = line.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x4 + "2", k2 * tickSizeInner));
    text = text.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x4, k2 * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
    if (context !== selection) {
      path2 = path2.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function(d) {
        return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon).attr("transform", function(d) {
        var p = this.parentNode.__axis;
        return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset);
      });
    }
    tickExit.remove();
    path2.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k2 * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k2 * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k2 * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k2 * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
    tick.attr("opacity", 1).attr("transform", function(d) {
      return transform(position(d) + offset);
    });
    line.attr(x4 + "2", k2 * tickSizeInner);
    text.attr(x4, k2 * spacing).text(format3);
    selection.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection.each(function() {
      this.__axis = position;
    });
  }
  axis2.scale = function(_) {
    return arguments.length ? (scale2 = _, axis2) : scale2;
  };
  axis2.ticks = function() {
    return tickArguments = Array.from(arguments), axis2;
  };
  axis2.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis2) : tickArguments.slice();
  };
  axis2.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis2) : tickValues && tickValues.slice();
  };
  axis2.tickFormat = function(_) {
    return arguments.length ? (tickFormat2 = _, axis2) : tickFormat2;
  };
  axis2.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis2) : tickSizeOuter;
  };
  axis2.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis2) : tickPadding;
  };
  axis2.offset = function(_) {
    return arguments.length ? (offset = +_, axis2) : offset;
  };
  return axis2;
}
function axisBottom(scale2) {
  return axis(bottom, scale2);
}
function axisLeft(scale2) {
  return axis(left, scale2);
}

// ../node_modules/d3-brush/src/brush.js
var { abs, max: max2, min: min2 } = Math;
function number1(e) {
  return [+e[0], +e[1]];
}
function number22(e) {
  return [number1(e[0]), number1(e[1])];
}
var X = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x4, e) {
    return x4 == null ? null : [[+x4[0], e[0][1]], [+x4[1], e[1][1]]];
  },
  output: function(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y4, e) {
    return y4 == null ? null : [[e[0][0], +y4[0]], [e[1][0], +y4[1]]];
  },
  output: function(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function(xy) {
    return xy == null ? null : number22(xy);
  },
  output: function(xy) {
    return xy;
  }
};
function type(t) {
  return { type: t };
}

// ../node_modules/d3-chord/src/math.js
var pi = Math.PI;
var halfPi = pi / 2;
var tau = pi * 2;

// ../node_modules/d3-path/src/path.js
var pi2 = Math.PI;
var tau2 = 2 * pi2;
var epsilon2 = 1e-6;
var tauEpsilon = tau2 - epsilon2;
function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0))
    throw new Error(`invalid digits: ${digits}`);
  if (d > 15)
    return append;
  const k2 = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
    }
  };
}
var Path = class {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x4, y4) {
    this._append`M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x4, y4) {
    this._append`L${this._x1 = +x4},${this._y1 = +y4}`;
  }
  quadraticCurveTo(x12, y1, x4, y4) {
    this._append`Q${+x12},${+y1},${this._x1 = +x4},${this._y1 = +y4}`;
  }
  bezierCurveTo(x12, y1, x22, y22, x4, y4) {
    this._append`C${+x12},${+y1},${+x22},${+y22},${this._x1 = +x4},${this._y1 = +y4}`;
  }
  arcTo(x12, y1, x22, y22, r) {
    x12 = +x12, y1 = +y1, x22 = +x22, y22 = +y22, r = +r;
    if (r < 0)
      throw new Error(`negative radius: ${r}`);
    let x02 = this._x1, y0 = this._y1, x21 = x22 - x12, y21 = y22 - y1, x01 = x02 - x12, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x12},${this._y1 = y1}`;
    } else if (!(l01_2 > epsilon2))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r) {
      this._append`L${this._x1 = x12},${this._y1 = y1}`;
    } else {
      let x20 = x22 - x02, y20 = y22 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon2) {
        this._append`L${x12 + t01 * x01},${y1 + t01 * y01}`;
      }
      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x4, y4, r, a0, a1, ccw) {
    x4 = +x4, y4 = +y4, r = +r, ccw = !!ccw;
    if (r < 0)
      throw new Error(`negative radius: ${r}`);
    let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x02 = x4 + dx, y0 = y4 + dy, cw = 1 ^ ccw, da2 = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x02},${y0}`;
    } else if (Math.abs(this._x1 - x02) > epsilon2 || Math.abs(this._y1 - y0) > epsilon2) {
      this._append`L${x02},${y0}`;
    }
    if (!r)
      return;
    if (da2 < 0)
      da2 = da2 % tau2 + tau2;
    if (da2 > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw},${x4 - dx},${y4 - dy}A${r},${r},0,1,${cw},${this._x1 = x02},${this._y1 = y0}`;
    } else if (da2 > epsilon2) {
      this._append`A${r},${r},0,${+(da2 >= pi2)},${cw},${this._x1 = x4 + r * Math.cos(a1)},${this._y1 = y4 + r * Math.sin(a1)}`;
    }
  }
  rect(x4, y4, w, h) {
    this._append`M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path();
}
path.prototype = Path.prototype;

// ../node_modules/d3-chord/src/array.js
var slice2 = Array.prototype.slice;

// ../node_modules/d3-contour/src/array.js
var array2 = Array.prototype;
var slice3 = array2.slice;

// ../node_modules/robust-predicates/esm/util.js
var epsilon4 = 11102230246251565e-32;
var resulterrbound = (3 + 8 * epsilon4) * epsilon4;
function vec(n) {
  return new Float64Array(n);
}

// ../node_modules/robust-predicates/esm/orient2d.js
var ccwerrboundA = (3 + 16 * epsilon4) * epsilon4;
var ccwerrboundB = (2 + 12 * epsilon4) * epsilon4;
var ccwerrboundC = (9 + 64 * epsilon4) * epsilon4 * epsilon4;
var B = vec(4);
var C1 = vec(8);
var C2 = vec(12);
var D = vec(16);
var u = vec(4);

// ../node_modules/robust-predicates/esm/orient3d.js
var o3derrboundA = (7 + 56 * epsilon4) * epsilon4;
var o3derrboundB = (3 + 28 * epsilon4) * epsilon4;
var o3derrboundC = (26 + 288 * epsilon4) * epsilon4 * epsilon4;
var bc = vec(4);
var ca = vec(4);
var ab = vec(4);
var at_b = vec(4);
var at_c = vec(4);
var bt_c = vec(4);
var bt_a = vec(4);
var ct_a = vec(4);
var ct_b = vec(4);
var bct = vec(8);
var cat = vec(8);
var abt = vec(8);
var u2 = vec(4);
var _8 = vec(8);
var _8b = vec(8);
var _16 = vec(8);
var _12 = vec(12);
var fin = vec(192);
var fin2 = vec(192);

// ../node_modules/robust-predicates/esm/incircle.js
var iccerrboundA = (10 + 96 * epsilon4) * epsilon4;
var iccerrboundB = (4 + 48 * epsilon4) * epsilon4;
var iccerrboundC = (44 + 576 * epsilon4) * epsilon4 * epsilon4;
var bc2 = vec(4);
var ca2 = vec(4);
var ab2 = vec(4);
var aa = vec(4);
var bb = vec(4);
var cc = vec(4);
var u3 = vec(4);
var v = vec(4);
var axtbc = vec(8);
var aytbc = vec(8);
var bxtca = vec(8);
var bytca = vec(8);
var cxtab = vec(8);
var cytab = vec(8);
var abt2 = vec(8);
var bct2 = vec(8);
var cat2 = vec(8);
var abtt = vec(4);
var bctt = vec(4);
var catt = vec(4);
var _82 = vec(8);
var _162 = vec(16);
var _16b = vec(16);
var _16c = vec(16);
var _32 = vec(32);
var _32b = vec(32);
var _48 = vec(48);
var _64 = vec(64);
var fin3 = vec(1152);
var fin22 = vec(1152);

// ../node_modules/robust-predicates/esm/insphere.js
var isperrboundA = (16 + 224 * epsilon4) * epsilon4;
var isperrboundB = (5 + 72 * epsilon4) * epsilon4;
var isperrboundC = (71 + 1408 * epsilon4) * epsilon4 * epsilon4;
var ab3 = vec(4);
var bc3 = vec(4);
var cd = vec(4);
var de = vec(4);
var ea = vec(4);
var ac = vec(4);
var bd = vec(4);
var ce = vec(4);
var da = vec(4);
var eb = vec(4);
var abc = vec(24);
var bcd = vec(24);
var cde = vec(24);
var dea = vec(24);
var eab = vec(24);
var abd = vec(24);
var bce = vec(24);
var cda = vec(24);
var deb = vec(24);
var eac = vec(24);
var adet = vec(1152);
var bdet = vec(1152);
var cdet = vec(1152);
var ddet = vec(1152);
var edet = vec(1152);
var abdet = vec(2304);
var cddet = vec(2304);
var cdedet = vec(3456);
var deter = vec(5760);
var _83 = vec(8);
var _8b2 = vec(8);
var _8c = vec(8);
var _163 = vec(16);
var _24 = vec(24);
var _482 = vec(48);
var _48b = vec(48);
var _96 = vec(96);
var _192 = vec(192);
var _384x = vec(384);
var _384y = vec(384);
var _384z = vec(384);
var _768 = vec(768);
var xdet = vec(96);
var ydet = vec(96);
var zdet = vec(96);
var fin4 = vec(1152);

// ../node_modules/delaunator/index.js
var EPSILON = Math.pow(2, -52);
var EDGE_STACK = new Uint32Array(512);

// ../node_modules/d3-delaunay/src/delaunay.js
var tau3 = 2 * Math.PI;

// ../node_modules/d3-dsv/src/dsv.js
var EOL = {};
var EOF = {};
var QUOTE = 34;
var NEWLINE = 10;
var RETURN = 13;
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name2, i) {
    return JSON.stringify(name2) + ": d[" + i + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}
function inferColumns(rows) {
  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });
  return columns;
}
function pad(value3, width) {
  var s2 = value3 + "", length = s2.length;
  return length < width ? new Array(width - length + 1).join(0) + s2 : s2;
}
function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6) : year > 9999 ? "+" + pad(year, 6) : pad(year, 4);
}
function formatDate(date) {
  var hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds2 = date.getUTCSeconds(), milliseconds2 = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date" : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2) + (milliseconds2 ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds2, 2) + "." + pad(milliseconds2, 3) + "Z" : seconds2 ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds2, 2) + "Z" : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z" : "");
}
function dsv_default(delimiter) {
  var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
  function parse2(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert)
        return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text, f) {
    var rows = [], N = text.length, I = 0, n = 0, t, eof = N <= 0, eol = false;
    if (text.charCodeAt(N - 1) === NEWLINE)
      --N;
    if (text.charCodeAt(N - 1) === RETURN)
      --N;
    function token() {
      if (eof)
        return EOF;
      if (eol)
        return eol = false, EOL;
      var i, j = I, c3;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE)
          ;
        if ((i = I) >= N)
          eof = true;
        else if ((c3 = text.charCodeAt(I++)) === NEWLINE)
          eol = true;
        else if (c3 === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE)
            ++I;
        }
        return text.slice(j + 1, i - 1).replace(/""/g, '"');
      }
      while (I < N) {
        if ((c3 = text.charCodeAt(i = I++)) === NEWLINE)
          eol = true;
        else if (c3 === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE)
            ++I;
        } else if (c3 !== DELIMITER)
          continue;
        return text.slice(j, i);
      }
      return eof = true, text.slice(j, N);
    }
    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF)
        row.push(t), t = token();
      if (f && (row = f(row, n++)) == null)
        continue;
      rows.push(row);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }
  function format3(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }
  function formatValue(value3) {
    return value3 == null ? "" : value3 instanceof Date ? formatDate(value3) : reFormat.test(value3 += "") ? '"' + value3.replace(/"/g, '""') + '"' : value3;
  }
  return {
    parse: parse2,
    parseRows,
    format: format3,
    formatBody,
    formatRows,
    formatRow,
    formatValue
  };
}

// ../node_modules/d3-dsv/src/csv.js
var csv = dsv_default(",");
var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;

// ../node_modules/d3-dsv/src/tsv.js
var tsv = dsv_default("	");
var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;

// ../node_modules/d3-dsv/src/autoType.js
var fixtz = (/* @__PURE__ */ new Date("2019-01-01T00:00")).getHours() || (/* @__PURE__ */ new Date("2019-07-01T00:00")).getHours();

// ../node_modules/d3-fetch/src/text.js
function responseText(response) {
  if (!response.ok)
    throw new Error(response.status + " " + response.statusText);
  return response.text();
}
function text_default(input, init) {
  return fetch(input, init).then(responseText);
}

// ../node_modules/d3-fetch/src/dsv.js
function dsvParse(parse2) {
  return function(input, init, row) {
    if (arguments.length === 2 && typeof init === "function")
      row = init, init = void 0;
    return text_default(input, init).then(function(response) {
      return parse2(response, row);
    });
  };
}
var csv2 = dsvParse(csvParse);
var tsv2 = dsvParse(tsvParse);

// ../node_modules/d3-fetch/src/xml.js
function parser(type2) {
  return (input, init) => text_default(input, init).then((text) => new DOMParser().parseFromString(text, type2));
}
var xml_default = parser("application/xml");
var html = parser("text/html");
var svg = parser("image/svg+xml");

// ../node_modules/d3-quadtree/src/add.js
function add_default(d) {
  const x4 = +this._x.call(null, d), y4 = +this._y.call(null, d);
  return add(this.cover(x4, y4), x4, y4, d);
}
function add(tree, x4, y4, d) {
  if (isNaN(x4) || isNaN(y4))
    return tree;
  var parent, node = tree._root, leaf = { data: d }, x02 = tree._x0, y0 = tree._y0, x12 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right2, bottom2, i, j;
  if (!node)
    return tree._root = leaf, tree;
  while (node.length) {
    if (right2 = x4 >= (xm = (x02 + x12) / 2))
      x02 = xm;
    else
      x12 = xm;
    if (bottom2 = y4 >= (ym = (y0 + y1) / 2))
      y0 = ym;
    else
      y1 = ym;
    if (parent = node, !(node = node[i = bottom2 << 1 | right2]))
      return parent[i] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x4 === xp && y4 === yp)
    return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right2 = x4 >= (xm = (x02 + x12) / 2))
      x02 = xm;
    else
      x12 = xm;
    if (bottom2 = y4 >= (ym = (y0 + y1) / 2))
      y0 = ym;
    else
      y1 = ym;
  } while ((i = bottom2 << 1 | right2) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node, parent[i] = leaf, tree;
}
function addAll(data) {
  var d, i, n = data.length, x4, y4, xz = new Array(n), yz = new Array(n), x02 = Infinity, y0 = Infinity, x12 = -Infinity, y1 = -Infinity;
  for (i = 0; i < n; ++i) {
    if (isNaN(x4 = +this._x.call(null, d = data[i])) || isNaN(y4 = +this._y.call(null, d)))
      continue;
    xz[i] = x4;
    yz[i] = y4;
    if (x4 < x02)
      x02 = x4;
    if (x4 > x12)
      x12 = x4;
    if (y4 < y0)
      y0 = y4;
    if (y4 > y1)
      y1 = y4;
  }
  if (x02 > x12 || y0 > y1)
    return this;
  this.cover(x02, y0).cover(x12, y1);
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }
  return this;
}

// ../node_modules/d3-quadtree/src/cover.js
function cover_default(x4, y4) {
  if (isNaN(x4 = +x4) || isNaN(y4 = +y4))
    return this;
  var x02 = this._x0, y0 = this._y0, x12 = this._x1, y1 = this._y1;
  if (isNaN(x02)) {
    x12 = (x02 = Math.floor(x4)) + 1;
    y1 = (y0 = Math.floor(y4)) + 1;
  } else {
    var z = x12 - x02 || 1, node = this._root, parent, i;
    while (x02 > x4 || x4 >= x12 || y0 > y4 || y4 >= y1) {
      i = (y4 < y0) << 1 | x4 < x02;
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0:
          x12 = x02 + z, y1 = y0 + z;
          break;
        case 1:
          x02 = x12 - z, y1 = y0 + z;
          break;
        case 2:
          x12 = x02 + z, y0 = y1 - z;
          break;
        case 3:
          x02 = x12 - z, y0 = y1 - z;
          break;
      }
    }
    if (this._root && this._root.length)
      this._root = node;
  }
  this._x0 = x02;
  this._y0 = y0;
  this._x1 = x12;
  this._y1 = y1;
  return this;
}

// ../node_modules/d3-quadtree/src/data.js
function data_default() {
  var data = [];
  this.visit(function(node) {
    if (!node.length)
      do
        data.push(node.data);
      while (node = node.next);
  });
  return data;
}

// ../node_modules/d3-quadtree/src/extent.js
function extent_default(_) {
  return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

// ../node_modules/d3-quadtree/src/quad.js
function quad_default(node, x02, y0, x12, y1) {
  this.node = node;
  this.x0 = x02;
  this.y0 = y0;
  this.x1 = x12;
  this.y1 = y1;
}

// ../node_modules/d3-quadtree/src/find.js
function find_default(x4, y4, radius) {
  var data, x02 = this._x0, y0 = this._y0, x12, y1, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i;
  if (node)
    quads.push(new quad_default(node, x02, y0, x32, y32));
  if (radius == null)
    radius = Infinity;
  else {
    x02 = x4 - radius, y0 = y4 - radius;
    x32 = x4 + radius, y32 = y4 + radius;
    radius *= radius;
  }
  while (q = quads.pop()) {
    if (!(node = q.node) || (x12 = q.x0) > x32 || (y1 = q.y0) > y32 || (x22 = q.x1) < x02 || (y22 = q.y1) < y0)
      continue;
    if (node.length) {
      var xm = (x12 + x22) / 2, ym = (y1 + y22) / 2;
      quads.push(
        new quad_default(node[3], xm, ym, x22, y22),
        new quad_default(node[2], x12, ym, xm, y22),
        new quad_default(node[1], xm, y1, x22, ym),
        new quad_default(node[0], x12, y1, xm, ym)
      );
      if (i = (y4 >= ym) << 1 | x4 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } else {
      var dx = x4 - +this._x.call(null, node.data), dy = y4 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x02 = x4 - d, y0 = y4 - d;
        x32 = x4 + d, y32 = y4 + d;
        data = node.data;
      }
    }
  }
  return data;
}

// ../node_modules/d3-quadtree/src/remove.js
function remove_default(d) {
  if (isNaN(x4 = +this._x.call(null, d)) || isNaN(y4 = +this._y.call(null, d)))
    return this;
  var parent, node = this._root, retainer, previous, next, x02 = this._x0, y0 = this._y0, x12 = this._x1, y1 = this._y1, x4, y4, xm, ym, right2, bottom2, i, j;
  if (!node)
    return this;
  if (node.length)
    while (true) {
      if (right2 = x4 >= (xm = (x02 + x12) / 2))
        x02 = xm;
      else
        x12 = xm;
      if (bottom2 = y4 >= (ym = (y0 + y1) / 2))
        y0 = ym;
      else
        y1 = ym;
      if (!(parent = node, node = node[i = bottom2 << 1 | right2]))
        return this;
      if (!node.length)
        break;
      if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3])
        retainer = parent, j = i;
    }
  while (node.data !== d)
    if (!(previous = node, node = node.next))
      return this;
  if (next = node.next)
    delete node.next;
  if (previous)
    return next ? previous.next = next : delete previous.next, this;
  if (!parent)
    return this._root = next, this;
  next ? parent[i] = next : delete parent[i];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer)
      retainer[j] = node;
    else
      this._root = node;
  }
  return this;
}
function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i)
    this.remove(data[i]);
  return this;
}

// ../node_modules/d3-quadtree/src/root.js
function root_default() {
  return this._root;
}

// ../node_modules/d3-quadtree/src/size.js
function size_default() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length)
      do
        ++size;
      while (node = node.next);
  });
  return size;
}

// ../node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q, node = this._root, child, x02, y0, x12, y1;
  if (node)
    quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x02 = q.x0, y0 = q.y0, x12 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x02 + x12) / 2, ym = (y0 + y1) / 2;
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x12, y1));
      if (child = node[2])
        quads.push(new quad_default(child, x02, ym, xm, y1));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y0, x12, ym));
      if (child = node[0])
        quads.push(new quad_default(child, x02, y0, xm, ym));
    }
  }
  return this;
}

// ../node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q;
  if (this._root)
    quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x02 = q.x0, y0 = q.y0, x12 = q.x1, y1 = q.y1, xm = (x02 + x12) / 2, ym = (y0 + y1) / 2;
      if (child = node[0])
        quads.push(new quad_default(child, x02, y0, xm, ym));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y0, x12, ym));
      if (child = node[2])
        quads.push(new quad_default(child, x02, ym, xm, y1));
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x12, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

// ../node_modules/d3-quadtree/src/x.js
function defaultX(d) {
  return d[0];
}
function x_default(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

// ../node_modules/d3-quadtree/src/y.js
function defaultY(d) {
  return d[1];
}
function y_default(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

// ../node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x4, y4) {
  var tree = new Quadtree(x4 == null ? defaultX : x4, y4 == null ? defaultY : y4, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x4, y4, x02, y0, x12, y1) {
  this._x = x4;
  this._y = y4;
  this._x0 = x02;
  this._y0 = y0;
  this._x1 = x12;
  this._y1 = y1;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy3 = { data: leaf.data }, next = copy3;
  while (leaf = leaf.next)
    next = next.next = { data: leaf.data };
  return copy3;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy3 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
  if (!node)
    return copy3;
  if (!node.length)
    return copy3._root = leaf_copy(node), copy3;
  nodes = [{ source: node, target: copy3._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length)
          nodes.push({ source: child, target: node.target[i] = new Array(4) });
        else
          node.target[i] = leaf_copy(child);
      }
    }
  }
  return copy3;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default;
treeProto.extent = extent_default;
treeProto.find = find_default;
treeProto.remove = remove_default;
treeProto.removeAll = removeAll;
treeProto.root = root_default;
treeProto.size = size_default;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;
treeProto.y = y_default;

// ../node_modules/d3-force/src/simulation.js
var initialAngle = Math.PI * (3 - Math.sqrt(5));

// ../node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x4) {
  return Math.abs(x4 = Math.round(x4)) >= 1e21 ? x4.toLocaleString("en").replace(/,/g, "") : x4.toString(10);
}
function formatDecimalParts(x4, p) {
  if ((i = (x4 = p ? x4.toExponential(p - 1) : x4.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x4.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x4.slice(i + 1)
  ];
}

// ../node_modules/d3-format/src/exponent.js
function exponent_default(x4) {
  return x4 = formatDecimalParts(Math.abs(x4)), x4 ? x4[1] : NaN;
}

// ../node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value3, width) {
    var i = value3.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width)
        g = Math.max(1, width - length);
      t.push(value3.substring(i -= g, i + g));
      if ((length += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// ../node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value3) {
    return value3.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// ../node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// ../node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s2) {
  out:
    for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s2[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s2[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}

// ../node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x4, p) {
  var d = formatDecimalParts(x4, p);
  if (!d)
    return x4 + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x4, Math.max(0, p + i - 1))[0];
}

// ../node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x4, p) {
  var d = formatDecimalParts(x4, p);
  if (!d)
    return x4 + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// ../node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x4, p) => (x4 * 100).toFixed(p),
  "b": (x4) => Math.round(x4).toString(2),
  "c": (x4) => x4 + "",
  "d": formatDecimal_default,
  "e": (x4, p) => x4.toExponential(p),
  "f": (x4, p) => x4.toFixed(p),
  "g": (x4, p) => x4.toPrecision(p),
  "o": (x4) => Math.round(x4).toString(8),
  "p": (x4, p) => formatRounded_default(x4 * 100, p),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x4) => Math.round(x4).toString(16).toUpperCase(),
  "x": (x4) => Math.round(x4).toString(16)
};

// ../node_modules/d3-format/src/identity.js
function identity_default2(x4) {
  return x4;
}

// ../node_modules/d3-format/src/locale.js
var map3 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale3) {
  var group2 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default2 : formatGroup_default(map3.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default2 : formatNumerals_default(map3.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "−" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes_default[type2])
      precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero2 || fill === "0" && align === "=")
      zero2 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format3(value3) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c3;
      if (type2 === "c") {
        valueSuffix = formatType(value3) + valueSuffix;
        value3 = "";
      } else {
        value3 = +value3;
        var valueNegative = value3 < 0 || 1 / value3 < 0;
        value3 = isNaN(value3) ? nan : formatType(Math.abs(value3), precision);
        if (trim)
          value3 = formatTrim_default(value3);
        if (valueNegative && +value3 === 0 && sign3 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value3.length;
          while (++i < n) {
            if (c3 = value3.charCodeAt(i), 48 > c3 || c3 > 57) {
              valueSuffix = (c3 === 46 ? decimal + value3.slice(i + 1) : value3.slice(i)) + valueSuffix;
              value3 = value3.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero2)
        value3 = group2(value3, Infinity);
      var length = valuePrefix.length + value3.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero2)
        value3 = group2(padding + value3, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value3 = valuePrefix + value3 + valueSuffix + padding;
          break;
        case "=":
          value3 = valuePrefix + padding + value3 + valueSuffix;
          break;
        case "^":
          value3 = padding.slice(0, length = padding.length >> 1) + valuePrefix + value3 + valueSuffix + padding.slice(length);
          break;
        default:
          value3 = padding + valuePrefix + value3 + valueSuffix;
          break;
      }
      return numerals(value3);
    }
    format3.toString = function() {
      return specifier + "";
    };
    return format3;
  }
  function formatPrefix2(specifier, value3) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value3) / 3))) * 3, k2 = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value4) {
      return f(k2 * value4) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// ../node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// ../node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// ../node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value3) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value3) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// ../node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max5) {
  step = Math.abs(step), max5 = Math.abs(max5) - step;
  return Math.max(0, exponent_default(max5) - exponent_default(step)) + 1;
}

// ../node_modules/d3-geo/src/math.js
var epsilon5 = 1e-6;
var epsilon22 = 1e-12;
var pi3 = Math.PI;
var halfPi2 = pi3 / 2;
var quarterPi = pi3 / 4;
var tau4 = pi3 * 2;
var degrees = 180 / pi3;
var radians = pi3 / 180;
var abs3 = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos2 = Math.cos;
var exp = Math.exp;
var log = Math.log;
var sin2 = Math.sin;
var sign = Math.sign || function(x4) {
  return x4 > 0 ? 1 : x4 < 0 ? -1 : 0;
};
var sqrt = Math.sqrt;
var tan = Math.tan;
function acos(x4) {
  return x4 > 1 ? 0 : x4 < -1 ? pi3 : Math.acos(x4);
}
function asin(x4) {
  return x4 > 1 ? halfPi2 : x4 < -1 ? -halfPi2 : Math.asin(x4);
}

// ../node_modules/d3-geo/src/noop.js
function noop() {
}

// ../node_modules/d3-geo/src/area.js
var areaRingSum = new Adder();
var areaSum = new Adder();

// ../node_modules/d3-geo/src/cartesian.js
function cartesian(spherical2) {
  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos2(phi2);
  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];
}
function cartesianCross(a2, b) {
  return [a2[1] * b[2] - a2[2] * b[1], a2[2] * b[0] - a2[0] * b[2], a2[0] * b[1] - a2[1] * b[0]];
}
function cartesianNormalizeInPlace(d) {
  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

// ../node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi2) {
  if (abs3(lambda) > pi3)
    lambda -= Math.round(lambda / tau4) * tau4;
  return [lambda, phi2];
}
rotationIdentity.invert = rotationIdentity;

// ../node_modules/d3-geo/src/clip/buffer.js
function buffer_default2() {
  var lines = [], line;
  return {
    point: function(x4, y4, m) {
      line.push([x4, y4, m]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: noop,
    rejoin: function() {
      if (lines.length > 1)
        lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}

// ../node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a2, b) {
  return abs3(a2[0] - b[0]) < epsilon5 && abs3(a2[1] - b[1]) < epsilon5;
}

// ../node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point6, points, other, entry) {
  this.x = point6;
  this.z = points;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments, compareIntersection2, startInside, interpolate, stream) {
  var subject = [], clip = [], i, n;
  segments.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0)
      return;
    var n2, p0 = segment[0], p1 = segment[n2], x4;
    if (pointEqual_default(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n2; ++i)
          stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon5;
    }
    subject.push(x4 = new Intersection(p0, segment, null, true));
    clip.push(x4.o = new Intersection(p0, null, x4, false));
    subject.push(x4 = new Intersection(p1, segment, null, false));
    clip.push(x4.o = new Intersection(p1, null, x4, true));
  });
  if (!subject.length)
    return;
  clip.sort(compareIntersection2);
  link(subject);
  link(clip);
  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }
  var start = subject[0], points, point6;
  while (1) {
    var current = start, isSubject = true;
    while (current.v)
      if ((current = current.n) === start)
        return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i)
            stream.point((point6 = points[i])[0], point6[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i)
            stream.point((point6 = points[i])[0], point6[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link(array3) {
  if (!(n = array3.length))
    return;
  var n, i = 0, a2 = array3[0], b;
  while (++i < n) {
    a2.n = b = array3[i];
    b.p = a2;
    a2 = b;
  }
  a2.n = b = array3[0];
  b.p = a2;
}

// ../node_modules/d3-geo/src/polygonContains.js
function longitude(point6) {
  return abs3(point6[0]) <= pi3 ? point6[0] : sign(point6[0]) * ((abs3(point6[0]) + pi3) % tau4 - pi3);
}
function polygonContains_default(polygon, point6) {
  var lambda = longitude(point6), phi2 = point6[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle = 0, winding = 0;
  var sum4 = new Adder();
  if (sinPhi === 1)
    phi2 = halfPi2 + epsilon5;
  else if (sinPhi === -1)
    phi2 = -halfPi2 - epsilon5;
  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length))
      continue;
    var ring, m, point0 = ring[m - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin2(phi0), cosPhi0 = cos2(phi0);
    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi1), cosPhi1 = cos2(phi1), delta = lambda1 - lambda0, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi3, k2 = sinPhi0 * sinPhi1;
      sum4.add(atan2(k2 * sign3 * sin2(absDelta), cosPhi0 * cosPhi1 + k2 * cos2(absDelta)));
      angle += antimeridian ? delta + sign3 * tau4 : delta;
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection2 = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection2);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection2[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle < -epsilon5 || angle < epsilon5 && sum4 < -epsilon22) ^ winding & 1;
}

// ../node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink), ringBuffer = buffer_default2(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point6;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains_default(polygon, start);
        if (segments.length) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted)
          sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point6(lambda, phi2) {
      if (pointVisible(lambda, phi2))
        sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line.point(lambda, phi2);
    }
    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }
    function lineEnd() {
      clip.point = point6;
      line.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point7;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n)
        return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i)
            sink.point((point7 = segment[i])[0], point7[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2)
        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a2, b) {
  return ((a2 = a2.x)[0] < 0 ? a2[1] - halfPi2 - epsilon5 : halfPi2 - a2[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi2 - epsilon5 : halfPi2 - b[1]);
}

// ../node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi3, -halfPi2]
);
function clipAntimeridianLine(stream) {
  var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi3 : -pi3, delta = abs3(lambda1 - lambda0);
      if (abs3(delta - pi3) < epsilon5) {
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi2 : -halfPi2);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi3) {
        if (abs3(lambda0 - sign0) < epsilon5)
          lambda0 -= sign0 * epsilon5;
        if (abs3(lambda1 - sign1) < epsilon5)
          lambda1 -= sign1 * epsilon5;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin2(lambda0 - lambda1);
  return abs3(sinLambda0Lambda1) > epsilon5 ? atan((sin2(phi0) * (cosPhi1 = cos2(phi1)) * sin2(lambda1) - sin2(phi1) * (cosPhi0 = cos2(phi0)) * sin2(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi2;
  if (from == null) {
    phi2 = direction * halfPi2;
    stream.point(-pi3, phi2);
    stream.point(0, phi2);
    stream.point(pi3, phi2);
    stream.point(pi3, 0);
    stream.point(pi3, -phi2);
    stream.point(0, -phi2);
    stream.point(-pi3, -phi2);
    stream.point(-pi3, 0);
    stream.point(-pi3, phi2);
  } else if (abs3(from[0] - to[0]) > epsilon5) {
    var lambda = from[0] < to[0] ? pi3 : -pi3;
    phi2 = direction * lambda / 2;
    stream.point(-lambda, phi2);
    stream.point(0, phi2);
    stream.point(lambda, phi2);
  } else {
    stream.point(to[0], to[1]);
  }
}

// ../node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;

// ../node_modules/d3-geo/src/path/area.js
var areaSum2 = new Adder();
var areaRingSum2 = new Adder();

// ../node_modules/d3-geo/src/path/bounds.js
var x0 = Infinity;
var x1 = -x0;

// ../node_modules/d3-geo/src/path/context.js
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0)
      this._context.closePath();
    this._point = NaN;
  },
  point: function(x4, y4) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x4, y4);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x4, y4);
        break;
      }
      default: {
        this._context.moveTo(x4 + this._radius, y4);
        this._context.arc(x4, y4, this._radius, 0, tau4);
        break;
      }
    }
  },
  result: noop
};

// ../node_modules/d3-geo/src/path/measure.js
var lengthSum = new Adder();

// ../node_modules/d3-geo/src/transform.js
function transformer(methods) {
  return function(stream) {
    var s2 = new TransformStream();
    for (var key in methods)
      s2[key] = methods[key];
    s2.stream = stream;
    return s2;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x4, y4) {
    this.stream.point(x4, y4);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// ../node_modules/d3-geo/src/projection/resample.js
var cosMinDistance = cos2(30 * radians);

// ../node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer({
  point: function(x4, y4) {
    this.stream.point(x4 * radians, y4 * radians);
  }
});

// ../node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale2) {
  return function(x4, y4) {
    var cx = cos2(x4), cy = cos2(y4), k2 = scale2(cx * cy);
    if (k2 === Infinity)
      return [2, 0];
    return [
      k2 * cy * sin2(x4),
      k2 * sin2(y4)
    ];
  };
}
function azimuthalInvert(angle) {
  return function(x4, y4) {
    var z = sqrt(x4 * x4 + y4 * y4), c3 = angle(z), sc = sin2(c3), cc2 = cos2(c3);
    return [
      atan2(x4 * sc, z * cc2),
      asin(z && y4 * sc / z)
    ];
  };
}

// ../node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin(z / 2);
});

// ../node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c3) {
  return (c3 = acos(c3)) && c3 / sin2(c3);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});

// ../node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi2) {
  return [lambda, log(tan((halfPi2 + phi2) / 2))];
}
mercatorRaw.invert = function(x4, y4) {
  return [x4, 2 * atan(exp(y4)) - halfPi2];
};

// ../node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
equirectangularRaw.invert = equirectangularRaw;

// ../node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A2 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M = sqrt(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi2) {
  var l = asin(M * sin2(phi2)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * cos2(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
  ];
}
equalEarthRaw.invert = function(x4, y4) {
  var l = y4, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y4;
    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if (abs3(delta) < epsilon22)
      break;
  }
  return [
    M * x4 * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos2(l),
    asin(sin2(l) / M)
  ];
};

// ../node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x4, y4) {
  var cy = cos2(y4), k2 = cos2(x4) * cy;
  return [cy * sin2(x4) / k2, sin2(y4) / k2];
}
gnomonicRaw.invert = azimuthalInvert(atan);

// ../node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x4, y4) {
  var phi2 = y4, i = 25, delta;
  do {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y4) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
  } while (abs3(delta) > epsilon5 && --i > 0);
  return [
    x4 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
    phi2
  ];
};

// ../node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x4, y4) {
  return [cos2(y4) * sin2(x4), sin2(y4)];
}
orthographicRaw.invert = azimuthalInvert(asin);

// ../node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x4, y4) {
  var cy = cos2(y4), k2 = 1 + cos2(x4) * cy;
  return [cy * sin2(x4) / k2, sin2(y4) / k2];
}
stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});

// ../node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi2) {
  return [log(tan((halfPi2 + phi2) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x4, y4) {
  return [-y4, 2 * atan(exp(x4)) - halfPi2];
};

// ../node_modules/d3-hierarchy/src/hierarchy/count.js
function count2(node) {
  var sum4 = 0, children = node.children, i = children && children.length;
  if (!i)
    sum4 = 1;
  else
    while (--i >= 0)
      sum4 += children[i].value;
  node.value = sum4;
}
function count_default() {
  return this.eachAfter(count2);
}

// ../node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default(callback, that) {
  let index2 = -1;
  for (const node of this) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}

// ../node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children, i, index2 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index2, this);
    if (children = node.children) {
      for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
    }
  }
  return this;
}

// ../node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children, i, n, index2 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children = node.children) {
      for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}

// ../node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default2(callback, that) {
  let index2 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index2, this)) {
      return node;
    }
  }
}

// ../node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value3) {
  return this.eachAfter(function(node) {
    var sum4 = +value3(node.data) || 0, children = node.children, i = children && children.length;
    while (--i >= 0)
      sum4 += children[i].value;
    node.value = sum4;
  });
}

// ../node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

// ../node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default2(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k2 = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k2, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a2, b) {
  if (a2 === b)
    return a2;
  var aNodes = a2.ancestors(), bNodes = b.ancestors(), c3 = null;
  a2 = aNodes.pop();
  b = bNodes.pop();
  while (a2 === b) {
    c3 = a2;
    a2 = aNodes.pop();
    b = bNodes.pop();
  }
  return c3;
}

// ../node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// ../node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// ../node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// ../node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}

// ../node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default() {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children = node.children) {
        for (i = 0, n = children.length; i < n; ++i) {
          next.push(children[i]);
        }
      }
    }
  } while (next.length);
}

// ../node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data, children) {
  if (data instanceof Map) {
    data = [void 0, data];
    if (children === void 0)
      children = mapChildren;
  } else if (children === void 0) {
    children = objectChildren;
  }
  var root = new Node2(data), node, nodes = [root], child, childs, i, n;
  while (node = nodes.pop()) {
    if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node2(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0)
    node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node2(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node2.prototype = hierarchy.prototype = {
  constructor: Node2,
  count: count_default,
  each: each_default,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default2,
  sum: sum_default,
  sort: sort_default,
  path: path_default2,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default
};

// ../node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent, x02, y0, x12, y1) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k2 = parent.value && (x12 - x02) / parent.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x02, node.x1 = x02 += node.value * k2;
  }
}

// ../node_modules/d3-hierarchy/src/tree.js
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node2.prototype);

// ../node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent, x02, y0, x12, y1) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k2 = parent.value && (y1 - y0) / parent.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x02, node.x1 = x12;
    node.y0 = y0, node.y1 = y0 += node.value * k2;
  }
}

// ../node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x02, y0, x12, y1) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value3 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x12 - x02, dy = y1 - y0;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value3 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice)
      dice_default(row, x02, y0, x12, value3 ? y0 += dy * sumValue / value3 : y1);
    else
      slice_default(row, x02, y0, value3 ? x02 += dx * sumValue / value3 : x12, y1);
    value3 -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify_default = function custom(ratio) {
  function squarify(parent, x02, y0, x12, y1) {
    squarifyRatio(ratio, parent, x02, y0, x12, y1);
  }
  squarify.ratio = function(x4) {
    return custom((x4 = +x4) > 1 ? x4 : 1);
  };
  return squarify;
}(phi);

// ../node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default = function custom2(ratio) {
  function resquarify(parent, x02, y0, x12, y1) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows, row, nodes, i, j = -1, n, m = rows.length, value3 = parent.value;
      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i)
          row.value += nodes[i].value;
        if (row.dice)
          dice_default(row, x02, y0, x12, value3 ? y0 += (y1 - y0) * row.value / value3 : y1);
        else
          slice_default(row, x02, y0, value3 ? x02 += (x12 - x02) * row.value / value3 : x12, y1);
        value3 -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x02, y0, x12, y1);
      rows.ratio = ratio;
    }
  }
  resquarify.ratio = function(x4) {
    return custom2((x4 = +x4) > 1 ? x4 : 1);
  };
  return resquarify;
}(phi);

// ../node_modules/d3-random/src/defaultSource.js
var defaultSource_default = Math.random;

// ../node_modules/d3-random/src/uniform.js
var uniform_default = function sourceRandomUniform(source) {
  function randomUniform(min4, max5) {
    min4 = min4 == null ? 0 : +min4;
    max5 = max5 == null ? 1 : +max5;
    if (arguments.length === 1)
      max5 = min4, min4 = 0;
    else
      max5 -= min4;
    return function() {
      return source() * max5 + min4;
    };
  }
  randomUniform.source = sourceRandomUniform;
  return randomUniform;
}(defaultSource_default);

// ../node_modules/d3-random/src/int.js
var int_default = function sourceRandomInt(source) {
  function randomInt(min4, max5) {
    if (arguments.length < 2)
      max5 = min4, min4 = 0;
    min4 = Math.floor(min4);
    max5 = Math.floor(max5) - min4;
    return function() {
      return Math.floor(source() * max5 + min4);
    };
  }
  randomInt.source = sourceRandomInt;
  return randomInt;
}(defaultSource_default);

// ../node_modules/d3-random/src/normal.js
var normal_default = function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x4, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function() {
      var y4;
      if (x4 != null)
        y4 = x4, x4 = null;
      else
        do {
          x4 = source() * 2 - 1;
          y4 = source() * 2 - 1;
          r = x4 * x4 + y4 * y4;
        } while (!r || r > 1);
      return mu + sigma * y4 * Math.sqrt(-2 * Math.log(r) / r);
    };
  }
  randomNormal.source = sourceRandomNormal;
  return randomNormal;
}(defaultSource_default);

// ../node_modules/d3-random/src/logNormal.js
var logNormal_default = function sourceRandomLogNormal(source) {
  var N = normal_default.source(source);
  function randomLogNormal() {
    var randomNormal = N.apply(this, arguments);
    return function() {
      return Math.exp(randomNormal());
    };
  }
  randomLogNormal.source = sourceRandomLogNormal;
  return randomLogNormal;
}(defaultSource_default);

// ../node_modules/d3-random/src/irwinHall.js
var irwinHall_default = function sourceRandomIrwinHall(source) {
  function randomIrwinHall(n) {
    if ((n = +n) <= 0)
      return () => 0;
    return function() {
      for (var sum4 = 0, i = n; i > 1; --i)
        sum4 += source();
      return sum4 + i * source();
    };
  }
  randomIrwinHall.source = sourceRandomIrwinHall;
  return randomIrwinHall;
}(defaultSource_default);

// ../node_modules/d3-random/src/bates.js
var bates_default = function sourceRandomBates(source) {
  var I = irwinHall_default.source(source);
  function randomBates(n) {
    if ((n = +n) === 0)
      return source;
    var randomIrwinHall = I(n);
    return function() {
      return randomIrwinHall() / n;
    };
  }
  randomBates.source = sourceRandomBates;
  return randomBates;
}(defaultSource_default);

// ../node_modules/d3-random/src/exponential.js
var exponential_default = function sourceRandomExponential(source) {
  function randomExponential(lambda) {
    return function() {
      return -Math.log1p(-source()) / lambda;
    };
  }
  randomExponential.source = sourceRandomExponential;
  return randomExponential;
}(defaultSource_default);

// ../node_modules/d3-random/src/pareto.js
var pareto_default = function sourceRandomPareto(source) {
  function randomPareto(alpha) {
    if ((alpha = +alpha) < 0)
      throw new RangeError("invalid alpha");
    alpha = 1 / -alpha;
    return function() {
      return Math.pow(1 - source(), alpha);
    };
  }
  randomPareto.source = sourceRandomPareto;
  return randomPareto;
}(defaultSource_default);

// ../node_modules/d3-random/src/bernoulli.js
var bernoulli_default = function sourceRandomBernoulli(source) {
  function randomBernoulli(p) {
    if ((p = +p) < 0 || p > 1)
      throw new RangeError("invalid p");
    return function() {
      return Math.floor(source() + p);
    };
  }
  randomBernoulli.source = sourceRandomBernoulli;
  return randomBernoulli;
}(defaultSource_default);

// ../node_modules/d3-random/src/geometric.js
var geometric_default = function sourceRandomGeometric(source) {
  function randomGeometric(p) {
    if ((p = +p) < 0 || p > 1)
      throw new RangeError("invalid p");
    if (p === 0)
      return () => Infinity;
    if (p === 1)
      return () => 1;
    p = Math.log1p(-p);
    return function() {
      return 1 + Math.floor(Math.log1p(-source()) / p);
    };
  }
  randomGeometric.source = sourceRandomGeometric;
  return randomGeometric;
}(defaultSource_default);

// ../node_modules/d3-random/src/gamma.js
var gamma_default = function sourceRandomGamma(source) {
  var randomNormal = normal_default.source(source)();
  function randomGamma(k2, theta) {
    if ((k2 = +k2) < 0)
      throw new RangeError("invalid k");
    if (k2 === 0)
      return () => 0;
    theta = theta == null ? 1 : +theta;
    if (k2 === 1)
      return () => -Math.log1p(-source()) * theta;
    var d = (k2 < 1 ? k2 + 1 : k2) - 1 / 3, c3 = 1 / (3 * Math.sqrt(d)), multiplier = k2 < 1 ? () => Math.pow(source(), 1 / k2) : () => 1;
    return function() {
      do {
        do {
          var x4 = randomNormal(), v2 = 1 + c3 * x4;
        } while (v2 <= 0);
        v2 *= v2 * v2;
        var u4 = 1 - source();
      } while (u4 >= 1 - 0.0331 * x4 * x4 * x4 * x4 && Math.log(u4) >= 0.5 * x4 * x4 + d * (1 - v2 + Math.log(v2)));
      return d * v2 * multiplier() * theta;
    };
  }
  randomGamma.source = sourceRandomGamma;
  return randomGamma;
}(defaultSource_default);

// ../node_modules/d3-random/src/beta.js
var beta_default = function sourceRandomBeta(source) {
  var G = gamma_default.source(source);
  function randomBeta(alpha, beta) {
    var X2 = G(alpha), Y2 = G(beta);
    return function() {
      var x4 = X2();
      return x4 === 0 ? 0 : x4 / (x4 + Y2());
    };
  }
  randomBeta.source = sourceRandomBeta;
  return randomBeta;
}(defaultSource_default);

// ../node_modules/d3-random/src/binomial.js
var binomial_default = function sourceRandomBinomial(source) {
  var G = geometric_default.source(source), B2 = beta_default.source(source);
  function randomBinomial(n, p) {
    n = +n;
    if ((p = +p) >= 1)
      return () => n;
    if (p <= 0)
      return () => 0;
    return function() {
      var acc = 0, nn = n, pp = p;
      while (nn * pp > 16 && nn * (1 - pp) > 16) {
        var i = Math.floor((nn + 1) * pp), y4 = B2(i, nn - i + 1)();
        if (y4 <= pp) {
          acc += i;
          nn -= i;
          pp = (pp - y4) / (1 - y4);
        } else {
          nn = i - 1;
          pp /= y4;
        }
      }
      var sign3 = pp < 0.5, pFinal = sign3 ? pp : 1 - pp, g = G(pFinal);
      for (var s2 = g(), k2 = 0; s2 <= nn; ++k2)
        s2 += g();
      return acc + (sign3 ? k2 : nn - k2);
    };
  }
  randomBinomial.source = sourceRandomBinomial;
  return randomBinomial;
}(defaultSource_default);

// ../node_modules/d3-random/src/weibull.js
var weibull_default = function sourceRandomWeibull(source) {
  function randomWeibull(k2, a2, b) {
    var outerFunc;
    if ((k2 = +k2) === 0) {
      outerFunc = (x4) => -Math.log(x4);
    } else {
      k2 = 1 / k2;
      outerFunc = (x4) => Math.pow(x4, k2);
    }
    a2 = a2 == null ? 0 : +a2;
    b = b == null ? 1 : +b;
    return function() {
      return a2 + b * outerFunc(-Math.log1p(-source()));
    };
  }
  randomWeibull.source = sourceRandomWeibull;
  return randomWeibull;
}(defaultSource_default);

// ../node_modules/d3-random/src/cauchy.js
var cauchy_default = function sourceRandomCauchy(source) {
  function randomCauchy(a2, b) {
    a2 = a2 == null ? 0 : +a2;
    b = b == null ? 1 : +b;
    return function() {
      return a2 + b * Math.tan(Math.PI * source());
    };
  }
  randomCauchy.source = sourceRandomCauchy;
  return randomCauchy;
}(defaultSource_default);

// ../node_modules/d3-random/src/logistic.js
var logistic_default = function sourceRandomLogistic(source) {
  function randomLogistic(a2, b) {
    a2 = a2 == null ? 0 : +a2;
    b = b == null ? 1 : +b;
    return function() {
      var u4 = source();
      return a2 + b * Math.log(u4 / (1 - u4));
    };
  }
  randomLogistic.source = sourceRandomLogistic;
  return randomLogistic;
}(defaultSource_default);

// ../node_modules/d3-random/src/poisson.js
var poisson_default = function sourceRandomPoisson(source) {
  var G = gamma_default.source(source), B2 = binomial_default.source(source);
  function randomPoisson(lambda) {
    return function() {
      var acc = 0, l = lambda;
      while (l > 16) {
        var n = Math.floor(0.875 * l), t = G(n)();
        if (t > l)
          return acc + B2(n - 1, l / t)();
        acc += n;
        l -= t;
      }
      for (var s2 = -Math.log1p(-source()), k2 = 0; s2 <= l; ++k2)
        s2 -= Math.log1p(-source());
      return acc + k2;
    };
  }
  randomPoisson.source = sourceRandomPoisson;
  return randomPoisson;
}(defaultSource_default);

// ../node_modules/d3-random/src/lcg.js
var eps = 1 / 4294967296;

// ../node_modules/d3-scale/src/init.js
function initRange(domain, range2) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range2).domain(domain);
      break;
  }
  return this;
}

// ../node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");
function ordinal() {
  var index2 = new InternMap(), domain = [], range2 = [], unknown = implicit;
  function scale2(d) {
    let i = index2.get(d);
    if (i === void 0) {
      if (unknown !== implicit)
        return unknown;
      index2.set(d, i = domain.push(d) - 1);
    }
    return range2[i % range2.length];
  }
  scale2.domain = function(_) {
    if (!arguments.length)
      return domain.slice();
    domain = [], index2 = new InternMap();
    for (const value3 of _) {
      if (index2.has(value3))
        continue;
      index2.set(value3, domain.push(value3) - 1);
    }
    return scale2;
  };
  scale2.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), scale2) : range2.slice();
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.copy = function() {
    return ordinal(domain, range2).unknown(unknown);
  };
  initRange.apply(scale2, arguments);
  return scale2;
}

// ../node_modules/d3-scale/src/band.js
function band() {
  var scale2 = ordinal().unknown(void 0), domain = scale2.domain, ordinalRange = scale2.range, r0 = 0, r1 = 1, step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale2.unknown;
  function rescale() {
    var n = domain().length, reverse2 = r1 < r0, start = reverse2 ? r1 : r0, stop = reverse2 ? r0 : r1;
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round)
      step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round)
      start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = range(n).map(function(i) {
      return start + step * i;
    });
    return ordinalRange(reverse2 ? values.reverse() : values);
  }
  scale2.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale2.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale2.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
  };
  scale2.bandwidth = function() {
    return bandwidth;
  };
  scale2.step = function() {
    return step;
  };
  scale2.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };
  scale2.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };
  scale2.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };
  scale2.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };
  scale2.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };
  scale2.copy = function() {
    return band(domain(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}

// ../node_modules/d3-scale/src/constant.js
function constants(x4) {
  return function() {
    return x4;
  };
}

// ../node_modules/d3-scale/src/number.js
function number3(x4) {
  return +x4;
}

// ../node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity2(x4) {
  return x4;
}
function normalize(a2, b) {
  return (b -= a2 = +a2) ? function(x4) {
    return (x4 - a2) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a2, b) {
  var t;
  if (a2 > b)
    t = a2, a2 = b, b = t;
  return function(x4) {
    return Math.max(a2, Math.min(b, x4));
  };
}
function bimap(domain, range2, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
  if (d1 < d0)
    d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else
    d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x4) {
    return r0(d0(x4));
  };
}
function polymap(domain, range2, interpolate) {
  var j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range2 = range2.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range2[i], range2[i + 1]);
  }
  return function(x4) {
    var i2 = bisect_default(domain, x4, 1, j) - 1;
    return r[i2](d[i2](x4));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer2() {
  var domain = unit, range2 = unit, interpolate = value_default, transform, untransform, unknown, clamp = identity2, piecewise2, output, input;
  function rescale() {
    var n = Math.min(domain.length, range2.length);
    if (clamp !== identity2)
      clamp = clamper(domain[0], domain[n - 1]);
    piecewise2 = n > 2 ? polymap : bimap;
    output = input = null;
    return scale2;
  }
  function scale2(x4) {
    return x4 == null || isNaN(x4 = +x4) ? unknown : (output || (output = piecewise2(domain.map(transform), range2, interpolate)))(transform(clamp(x4)));
  }
  scale2.invert = function(y4) {
    return clamp(untransform((input || (input = piecewise2(range2, domain.map(transform), number_default)))(y4)));
  };
  scale2.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number3), rescale()) : domain.slice();
  };
  scale2.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
  };
  scale2.rangeRound = function(_) {
    return range2 = Array.from(_), interpolate = round_default, rescale();
  };
  scale2.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity2, rescale()) : clamp !== identity2;
  };
  scale2.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  return function(t, u4) {
    transform = t, untransform = u4;
    return rescale();
  };
}
function continuous() {
  return transformer2()(identity2, identity2);
}

// ../node_modules/d3-scale/src/tickFormat.js
function tickFormat(start, stop, count3, specifier) {
  var step = tickStep(start, stop, count3), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value3 = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value3)))
        specifier.precision = precision;
      return formatPrefix(specifier, value3);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// ../node_modules/d3-scale/src/linear.js
function linearish(scale2) {
  var domain = scale2.domain;
  scale2.ticks = function(count3) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count3 == null ? 10 : count3);
  };
  scale2.tickFormat = function(count3, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count3 == null ? 10 : count3, specifier);
  };
  scale2.nice = function(count3) {
    if (count3 == null)
      count3 = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop, count3);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale2;
  };
  return scale2;
}
function linear() {
  var scale2 = continuous();
  scale2.copy = function() {
    return copy(scale2, linear());
  };
  initRange.apply(scale2, arguments);
  return linearish(scale2);
}

// ../node_modules/d3-time/src/interval.js
var t0 = /* @__PURE__ */ new Date();
var t1 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count3, field) {
  function interval(date) {
    return floori(date = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date)), date;
  }
  interval.floor = (date) => {
    return floori(date = /* @__PURE__ */ new Date(+date)), date;
  };
  interval.ceil = (date) => {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };
  interval.round = (date) => {
    const d0 = interval(date), d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };
  interval.offset = (date, step) => {
    return offseti(date = /* @__PURE__ */ new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };
  interval.range = (start, stop, step) => {
    const range2 = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0))
      return range2;
    let previous;
    do
      range2.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range2;
  };
  interval.filter = (test) => {
    return timeInterval((date) => {
      if (date >= date)
        while (floori(date), !test(date))
          date.setTime(date - 1);
    }, (date, step) => {
      if (date >= date) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date, -1), !test(date)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date, 1), !test(date)) {
            }
          }
      }
    });
  };
  if (count3) {
    interval.count = (start, end) => {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count3(t0, t1));
    };
    interval.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? (d) => field(d) % step === 0 : (d) => interval.count(0, d) % step === 0);
    };
  }
  return interval;
}

// ../node_modules/d3-time/src/millisecond.js
var millisecond = timeInterval(() => {
}, (date, step) => {
  date.setTime(+date + step);
}, (start, end) => {
  return end - start;
});
millisecond.every = (k2) => {
  k2 = Math.floor(k2);
  if (!isFinite(k2) || !(k2 > 0))
    return null;
  if (!(k2 > 1))
    return millisecond;
  return timeInterval((date) => {
    date.setTime(Math.floor(date / k2) * k2);
  }, (date, step) => {
    date.setTime(+date + step * k2);
  }, (start, end) => {
    return (end - start) / k2;
  });
};
var milliseconds = millisecond.range;

// ../node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// ../node_modules/d3-time/src/second.js
var second = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds());
}, (date, step) => {
  date.setTime(+date + step * durationSecond);
}, (start, end) => {
  return (end - start) / durationSecond;
}, (date) => {
  return date.getUTCSeconds();
});
var seconds = second.range;

// ../node_modules/d3-time/src/minute.js
var timeMinute = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, (date, step) => {
  date.setTime(+date + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date) => {
  return date.getMinutes();
});
var timeMinutes = timeMinute.range;
var utcMinute = timeInterval((date) => {
  date.setUTCSeconds(0, 0);
}, (date, step) => {
  date.setTime(+date + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date) => {
  return date.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

// ../node_modules/d3-time/src/hour.js
var timeHour = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, (date, step) => {
  date.setTime(+date + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date) => {
  return date.getHours();
});
var timeHours = timeHour.range;
var utcHour = timeInterval((date) => {
  date.setUTCMinutes(0, 0, 0);
}, (date, step) => {
  date.setTime(+date + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date) => {
  return date.getUTCHours();
});
var utcHours = utcHour.range;

// ../node_modules/d3-time/src/day.js
var timeDay = timeInterval(
  (date) => date.setHours(0, 0, 0, 0),
  (date, step) => date.setDate(date.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
  (date) => date.getDate() - 1
);
var timeDays = timeDay.range;
var utcDay = timeInterval((date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCDate(date.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date) => {
  return date.getUTCDate() - 1;
});
var utcDays = utcDay.range;
var unixDay = timeInterval((date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCDate(date.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date) => {
  return Math.floor(date / durationDay);
});
var unixDays = unixDay.range;

// ../node_modules/d3-time/src/week.js
function timeWeekday(i) {
  return timeInterval((date) => {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setDate(date.getDate() + step * 7);
  }, (start, end) => {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var timeSunday = timeWeekday(0);
var timeMonday = timeWeekday(1);
var timeTuesday = timeWeekday(2);
var timeWednesday = timeWeekday(3);
var timeThursday = timeWeekday(4);
var timeFriday = timeWeekday(5);
var timeSaturday = timeWeekday(6);
var timeSundays = timeSunday.range;
var timeMondays = timeMonday.range;
var timeTuesdays = timeTuesday.range;
var timeWednesdays = timeWednesday.range;
var timeThursdays = timeThursday.range;
var timeFridays = timeFriday.range;
var timeSaturdays = timeSaturday.range;
function utcWeekday(i) {
  return timeInterval((date) => {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, (start, end) => {
    return (end - start) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// ../node_modules/d3-time/src/month.js
var timeMonth = timeInterval((date) => {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, (date, step) => {
  date.setMonth(date.getMonth() + step);
}, (start, end) => {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, (date) => {
  return date.getMonth();
});
var timeMonths = timeMonth.range;
var utcMonth = timeInterval((date) => {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCMonth(date.getUTCMonth() + step);
}, (start, end) => {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, (date) => {
  return date.getUTCMonth();
});
var utcMonths = utcMonth.range;

// ../node_modules/d3-time/src/year.js
var timeYear = timeInterval((date) => {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, (date, step) => {
  date.setFullYear(date.getFullYear() + step);
}, (start, end) => {
  return end.getFullYear() - start.getFullYear();
}, (date) => {
  return date.getFullYear();
});
timeYear.every = (k2) => {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date) => {
    date.setFullYear(Math.floor(date.getFullYear() / k2) * k2);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setFullYear(date.getFullYear() + step * k2);
  });
};
var timeYears = timeYear.range;
var utcYear = timeInterval((date) => {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, (start, end) => {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, (date) => {
  return date.getUTCFullYear();
});
utcYear.every = (k2) => {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date) => {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k2) * k2);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setUTCFullYear(date.getUTCFullYear() + step * k2);
  });
};
var utcYears = utcYear.range;

// ../node_modules/d3-time/src/ticks.js
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start, stop, count3) {
    const reverse2 = stop < start;
    if (reverse2)
      [start, stop] = [stop, start];
    const interval = count3 && typeof count3.range === "function" ? count3 : tickInterval(start, stop, count3);
    const ticks3 = interval ? interval.range(start, +stop + 1) : [];
    return reverse2 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start, stop, count3) {
    const target = Math.abs(stop - start) / count3;
    const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
    if (i === tickIntervals.length)
      return year.every(tickStep(start / durationYear, stop / durationYear, count3));
    if (i === 0)
      return millisecond.every(Math.max(tickStep(start, stop, count3), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step);
  }
  return [ticks2, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

// ../node_modules/d3-time-format/src/locale.js
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y4, m, d) {
  return { y: y4, m, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale3) {
  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear2,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date) {
      var string = [], i = -1, j = 0, n = specifier.length, c3, pad3, format3;
      if (!(date instanceof Date))
        date = /* @__PURE__ */ new Date(+date);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad3 = pads[c3 = specifier.charAt(++i)]) != null)
            c3 = specifier.charAt(++i);
          else
            pad3 = c3 === "e" ? " " : "0";
          if (format3 = formats2[c3])
            c3 = format3(date, pad3);
          string.push(c3);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
      if (i != string.length)
        return null;
      if ("Q" in d)
        return new Date(d.Q);
      if ("s" in d)
        return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d))
        d.Z = 0;
      if ("p" in d)
        d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0)
        d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53)
          return null;
        if (!("w" in d))
          d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d))
          d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0, n = specifier.length, m = string.length, c3, parse2;
    while (i < n) {
      if (j >= m)
        return -1;
      c3 = specifier.charCodeAt(i++);
      if (c3 === 37) {
        c3 = specifier.charAt(i++);
        parse2 = parses[c3 in pads ? specifier.charAt(i++) : c3];
        if (!parse2 || (j = parse2(d, string, j)) < 0)
          return -1;
      } else if (c3 != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad2(value3, fill, width) {
  var sign3 = value3 < 0 ? "-" : "", string = (sign3 ? -value3 : value3) + "", length = string.length;
  return sign3 + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}
function requote(s2) {
  return s2.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name2, i) => [name2.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad2(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad2(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad2(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad2(1 + timeDay.count(timeYear(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad2(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad2(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad2(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad2(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d, p) {
  return pad2(timeSunday.count(timeYear(d) - 1, d), p, 2);
}
function dISO(d) {
  var day = d.getDay();
  return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad2(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad2(timeMonday.count(timeYear(d) - 1, d), p, 2);
}
function formatYear2(d, p) {
  return pad2(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad2(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad2(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
  return pad2(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad2(z / 60 | 0, "0", 2) + pad2(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad2(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad2(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad2(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad2(1 + utcDay.count(utcYear(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad2(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad2(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad2(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad2(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad2(utcSunday.count(utcYear(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day = d.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad2(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad2(utcMonday.count(utcYear(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad2(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad2(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad2(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad2(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}

// ../node_modules/d3-time-format/src/defaultLocale.js
var locale2;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition) {
  locale2 = formatLocale(definition);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// ../node_modules/d3-time-format/src/isoFormat.js
var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
function formatIsoNative(date) {
  return date.toISOString();
}
var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);

// ../node_modules/d3-time-format/src/isoParse.js
function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}
var parseIso = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);

// ../node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n)
    colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
}

// ../node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// ../node_modules/d3-scale-chromatic/src/categorical/Accent.js
var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

// ../node_modules/d3-scale-chromatic/src/categorical/Dark2.js
var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

// ../node_modules/d3-scale-chromatic/src/categorical/Paired.js
var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

// ../node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

// ../node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

// ../node_modules/d3-scale-chromatic/src/categorical/Set1.js
var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

// ../node_modules/d3-scale-chromatic/src/categorical/Set2.js
var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

// ../node_modules/d3-scale-chromatic/src/categorical/Set3.js
var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

// ../node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

// ../node_modules/d3-scale-chromatic/src/ramp.js
var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);

// ../node_modules/d3-scale-chromatic/src/diverging/BrBG.js
var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors_default);
var BrBG_default = ramp_default(scheme);

// ../node_modules/d3-scale-chromatic/src/diverging/PRGn.js
var scheme2 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors_default);
var PRGn_default = ramp_default(scheme2);

// ../node_modules/d3-scale-chromatic/src/diverging/PiYG.js
var scheme3 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors_default);
var PiYG_default = ramp_default(scheme3);

// ../node_modules/d3-scale-chromatic/src/diverging/PuOr.js
var scheme4 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors_default);
var PuOr_default = ramp_default(scheme4);

// ../node_modules/d3-scale-chromatic/src/diverging/RdBu.js
var scheme5 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors_default);
var RdBu_default = ramp_default(scheme5);

// ../node_modules/d3-scale-chromatic/src/diverging/RdGy.js
var scheme6 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors_default);
var RdGy_default = ramp_default(scheme6);

// ../node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
var scheme7 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors_default);
var RdYlBu_default = ramp_default(scheme7);

// ../node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
var scheme8 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors_default);
var RdYlGn_default = ramp_default(scheme8);

// ../node_modules/d3-scale-chromatic/src/diverging/Spectral.js
var scheme9 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors_default);
var Spectral_default = ramp_default(scheme9);

// ../node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
var scheme10 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors_default);
var BuGn_default = ramp_default(scheme10);

// ../node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
var scheme11 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors_default);
var BuPu_default = ramp_default(scheme11);

// ../node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
var scheme12 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors_default);
var GnBu_default = ramp_default(scheme12);

// ../node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
var scheme13 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors_default);
var OrRd_default = ramp_default(scheme13);

// ../node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
var scheme14 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors_default);
var PuBuGn_default = ramp_default(scheme14);

// ../node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
var scheme15 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors_default);
var PuBu_default = ramp_default(scheme15);

// ../node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
var scheme16 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors_default);
var PuRd_default = ramp_default(scheme16);

// ../node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
var scheme17 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors_default);
var RdPu_default = ramp_default(scheme17);

// ../node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
var scheme18 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors_default);
var YlGnBu_default = ramp_default(scheme18);

// ../node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
var scheme19 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors_default);
var YlGn_default = ramp_default(scheme19);

// ../node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
var scheme20 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors_default);
var YlOrBr_default = ramp_default(scheme20);

// ../node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
var scheme21 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors_default);
var YlOrRd_default = ramp_default(scheme21);

// ../node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
var scheme22 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors_default);
var Blues_default = ramp_default(scheme22);

// ../node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
var scheme23 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors_default);
var Greens_default = ramp_default(scheme23);

// ../node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
var scheme24 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors_default);
var Greys_default = ramp_default(scheme24);

// ../node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
var scheme25 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors_default);
var Purples_default = ramp_default(scheme25);

// ../node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
var scheme26 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors_default);
var Reds_default = ramp_default(scheme26);

// ../node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
var scheme27 = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors_default);
var Oranges_default = ramp_default(scheme27);

// ../node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
var cubehelix_default = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

// ../node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var c = cubehelix();

// ../node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
var c2 = rgb();
var pi_1_3 = Math.PI / 3;
var pi_2_3 = Math.PI * 2 / 3;

// ../node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
function ramp(range2) {
  var n = range2.length;
  return function(t) {
    return range2[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}
var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// ../node_modules/d3-shape/src/constant.js
function constant_default7(x4) {
  return function constant2() {
    return x4;
  };
}

// ../node_modules/d3-shape/src/math.js
var abs4 = Math.abs;
var atan22 = Math.atan2;
var cos3 = Math.cos;
var max4 = Math.max;
var min3 = Math.min;
var sin3 = Math.sin;
var sqrt3 = Math.sqrt;
var epsilon6 = 1e-12;
var pi4 = Math.PI;
var halfPi3 = pi4 / 2;
var tau5 = 2 * pi4;
function acos2(x4) {
  return x4 > 1 ? 0 : x4 < -1 ? pi4 : Math.acos(x4);
}
function asin2(x4) {
  return x4 >= 1 ? halfPi3 : x4 <= -1 ? -halfPi3 : Math.asin(x4);
}

// ../node_modules/d3-shape/src/path.js
function withPath(shape) {
  let digits = 3;
  shape.digits = function(_) {
    if (!arguments.length)
      return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0))
        throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    return shape;
  };
  return () => new Path(digits);
}

// ../node_modules/d3-shape/src/arc.js
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect(x02, y0, x12, y1, x22, y22, x32, y32) {
  var x10 = x12 - x02, y10 = y1 - y0, x322 = x32 - x22, y322 = y32 - y22, t = y322 * x10 - x322 * y10;
  if (t * t < epsilon6)
    return;
  t = (x322 * (y0 - y22) - y322 * (x02 - x22)) / t;
  return [x02 + t * x10, y0 + t * y10];
}
function cornerTangents(x02, y0, x12, y1, r1, rc, cw) {
  var x01 = x02 - x12, y01 = y0 - y1, lo = (cw ? rc : -rc) / sqrt3(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x02 + ox, y11 = y0 + oy, x10 = x12 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D2 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt3(max4(0, r * r * d2 - D2 * D2)), cx0 = (D2 * dy - dx * d) / d2, cy0 = (-D2 * dx - dy * d) / d2, cx1 = (D2 * dy + dx * d) / d2, cy1 = (-D2 * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
    cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function arc_default() {
  var innerRadius2 = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default7(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path2 = withPath(arc);
  function arc() {
    var buffer, r, r0 = +innerRadius2.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi3, a1 = endAngle.apply(this, arguments) - halfPi3, da2 = abs4(a1 - a0), cw = a1 > a0;
    if (!context)
      context = buffer = path2();
    if (r1 < r0)
      r = r1, r1 = r0, r0 = r;
    if (!(r1 > epsilon6))
      context.moveTo(0, 0);
    else if (da2 > tau5 - epsilon6) {
      context.moveTo(r1 * cos3(a0), r1 * sin3(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon6) {
        context.moveTo(r0 * cos3(a1), r0 * sin3(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da2, da1 = da2, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon6 && (padRadius ? +padRadius.apply(this, arguments) : sqrt3(r0 * r0 + r1 * r1)), rc = min3(abs4(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t02, t12;
      if (rp > epsilon6) {
        var p0 = asin2(rp / r0 * sin3(ap)), p1 = asin2(rp / r1 * sin3(ap));
        if ((da0 -= p0 * 2) > epsilon6)
          p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
        else
          da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon6)
          p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
        else
          da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos3(a01), y01 = r1 * sin3(a01), x10 = r0 * cos3(a10), y10 = r0 * sin3(a10);
      if (rc > epsilon6) {
        var x11 = r1 * cos3(a11), y11 = r1 * sin3(a11), x00 = r0 * cos3(a00), y00 = r0 * sin3(a00), oc;
        if (da2 < pi4) {
          if (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin3(acos2((ax * bx + ay * by) / (sqrt3(ax * ax + ay * ay) * sqrt3(bx * bx + by * by))) / 2), lc = sqrt3(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min3(rc, (r0 - lc) / (kc - 1));
            rc1 = min3(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }
      if (!(da1 > epsilon6))
        context.moveTo(x01, y01);
      else if (rc1 > epsilon6) {
        t02 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t12 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
        context.moveTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc1 < rc)
          context.arc(t02.cx, t02.cy, rc1, atan22(t02.y01, t02.x01), atan22(t12.y01, t12.x01), !cw);
        else {
          context.arc(t02.cx, t02.cy, rc1, atan22(t02.y01, t02.x01), atan22(t02.y11, t02.x11), !cw);
          context.arc(0, 0, r1, atan22(t02.cy + t02.y11, t02.cx + t02.x11), atan22(t12.cy + t12.y11, t12.cx + t12.x11), !cw);
          context.arc(t12.cx, t12.cy, rc1, atan22(t12.y11, t12.x11), atan22(t12.y01, t12.x01), !cw);
        }
      } else
        context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
      if (!(r0 > epsilon6) || !(da0 > epsilon6))
        context.lineTo(x10, y10);
      else if (rc0 > epsilon6) {
        t02 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t12 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
        context.lineTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc0 < rc)
          context.arc(t02.cx, t02.cy, rc0, atan22(t02.y01, t02.x01), atan22(t12.y01, t12.x01), !cw);
        else {
          context.arc(t02.cx, t02.cy, rc0, atan22(t02.y01, t02.x01), atan22(t02.y11, t02.x11), !cw);
          context.arc(0, 0, r0, atan22(t02.cy + t02.y11, t02.cx + t02.x11), atan22(t12.cy + t12.y11, t12.cx + t12.x11), cw);
          context.arc(t12.cx, t12.cy, rc0, atan22(t12.y11, t12.x11), atan22(t12.y01, t12.x01), !cw);
        }
      } else
        context.arc(0, 0, r0, a10, a00, cw);
    }
    context.closePath();
    if (buffer)
      return context = null, buffer + "" || null;
  }
  arc.centroid = function() {
    var r = (+innerRadius2.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi4 / 2;
    return [cos3(a2) * r, sin3(a2) * r];
  };
  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius2 = typeof _ === "function" ? _ : constant_default7(+_), arc) : innerRadius2;
  };
  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant_default7(+_), arc) : outerRadius;
  };
  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant_default7(+_), arc) : cornerRadius;
  };
  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant_default7(+_), arc) : padRadius;
  };
  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default7(+_), arc) : startAngle;
  };
  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default7(+_), arc) : endAngle;
  };
  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default7(+_), arc) : padAngle;
  };
  arc.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, arc) : context;
  };
  return arc;
}

// ../node_modules/d3-shape/src/array.js
var slice4 = Array.prototype.slice;
function array_default2(x4) {
  return typeof x4 === "object" && "length" in x4 ? x4 : Array.from(x4);
}

// ../node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x4, y4);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear(context);
}

// ../node_modules/d3-shape/src/descending.js
function descending_default(a2, b) {
  return b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
}

// ../node_modules/d3-shape/src/identity.js
function identity_default5(d) {
  return d;
}

// ../node_modules/d3-shape/src/pie.js
function pie_default() {
  var value3 = identity_default5, sortValues = descending_default, sort2 = null, startAngle = constant_default7(0), endAngle = constant_default7(tau5), padAngle = constant_default7(0);
  function pie(data) {
    var i, n = (data = array_default2(data)).length, j, k2, sum4 = 0, index2 = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da2 = Math.min(tau5, Math.max(-tau5, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da2) / n, padAngle.apply(this, arguments)), pa = p * (da2 < 0 ? -1 : 1), v2;
    for (i = 0; i < n; ++i) {
      if ((v2 = arcs[index2[i] = i] = +value3(data[i], i, data)) > 0) {
        sum4 += v2;
      }
    }
    if (sortValues != null)
      index2.sort(function(i2, j2) {
        return sortValues(arcs[i2], arcs[j2]);
      });
    else if (sort2 != null)
      index2.sort(function(i2, j2) {
        return sort2(data[i2], data[j2]);
      });
    for (i = 0, k2 = sum4 ? (da2 - n * pa) / sum4 : 0; i < n; ++i, a0 = a1) {
      j = index2[i], v2 = arcs[j], a1 = a0 + (v2 > 0 ? v2 * k2 : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v2,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }
    return arcs;
  }
  pie.value = function(_) {
    return arguments.length ? (value3 = typeof _ === "function" ? _ : constant_default7(+_), pie) : value3;
  };
  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort2 = null, pie) : sortValues;
  };
  pie.sort = function(_) {
    return arguments.length ? (sort2 = _, sortValues = null, pie) : sort2;
  };
  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default7(+_), pie) : startAngle;
  };
  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default7(+_), pie) : endAngle;
  };
  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default7(+_), pie) : padAngle;
  };
  return pie;
}

// ../node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial(curve) {
  this._curve = curve;
}
Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a2, r) {
    this._curve.point(r * Math.sin(a2), r * -Math.cos(a2));
  }
};
function curveRadial(curve) {
  function radial2(context) {
    return new Radial(curve(context));
  }
  radial2._curve = curve;
  return radial2;
}

// ../node_modules/d3-shape/src/symbol/asterisk.js
var sqrt32 = sqrt3(3);

// ../node_modules/d3-shape/src/symbol/diamond.js
var tan30 = sqrt3(1 / 3);
var tan30_2 = tan30 * 2;

// ../node_modules/d3-shape/src/symbol/star.js
var kr = sin3(pi4 / 10) / sin3(7 * pi4 / 10);
var kx = sin3(tau5 / 10) * kr;
var ky = -cos3(tau5 / 10) * kr;

// ../node_modules/d3-shape/src/symbol/triangle.js
var sqrt33 = sqrt3(3);

// ../node_modules/d3-shape/src/symbol/triangle2.js
var sqrt34 = sqrt3(3);

// ../node_modules/d3-shape/src/symbol/wye.js
var s = sqrt3(3) / 2;
var k = 1 / sqrt3(12);
var a = (k / 2 + 1) * 3;

// ../node_modules/d3-shape/src/noop.js
function noop_default2() {
}

// ../node_modules/d3-shape/src/curve/basis.js
function point2(that, x4, y4) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x4) / 6,
    (that._y0 + 4 * that._y1 + y4) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point2(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point2(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
  }
};

// ../node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x4, this._y2 = y4;
        break;
      case 1:
        this._point = 2;
        this._x3 = x4, this._y3 = y4;
        break;
      case 2:
        this._point = 3;
        this._x4 = x4, this._y4 = y4;
        this._context.moveTo((this._x0 + 4 * this._x1 + x4) / 6, (this._y0 + 4 * this._y1 + y4) / 6);
        break;
      default:
        point2(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
  }
};

// ../node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x02 = (this._x0 + 4 * this._x1 + x4) / 6, y0 = (this._y0 + 4 * this._y1 + y4) / 6;
        this._line ? this._context.lineTo(x02, y0) : this._context.moveTo(x02, y0);
        break;
      case 3:
        this._point = 4;
      default:
        point2(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
  }
};

// ../node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x4 = this._x, y4 = this._y, j = x4.length - 1;
    if (j > 0) {
      var x02 = x4[0], y0 = y4[0], dx = x4[j] - x02, dy = y4[j] - y0, i = -1, t;
      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x4[i] + (1 - this._beta) * (x02 + t * dx),
          this._beta * y4[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x4, y4) {
    this._x.push(+x4);
    this._y.push(+y4);
  }
};
var bundle_default = function custom3(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom3(+beta2);
  };
  return bundle;
}(0.85);

// ../node_modules/d3-shape/src/curve/cardinal.js
function point3(that, x4, y4) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x4),
    that._y2 + that._k * (that._y1 - y4),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point3(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        this._x1 = x4, this._y1 = y4;
        break;
      case 2:
        this._point = 3;
      default:
        point3(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinal_default = function custom4(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// ../node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x4, this._y3 = y4;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x4, this._y4 = y4);
        break;
      case 2:
        this._point = 3;
        this._x5 = x4, this._y5 = y4;
        break;
      default:
        point3(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinalClosed_default = function custom5(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom5(+tension2);
  };
  return cardinal;
}(0);

// ../node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point3(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinalOpen_default = function custom6(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom6(+tension2);
  };
  return cardinal;
}(0);

// ../node_modules/d3-shape/src/curve/catmullRom.js
function point4(that, x4, y4) {
  var x12 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon6) {
    var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x12 = (x12 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon6) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x4 * that._l12_2a) / m;
    y22 = (y22 * b + that._y1 * that._l23_2a - y4 * that._l12_2a) / m;
  }
  that._context.bezierCurveTo(x12, y1, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x4, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point4(this, x4, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRom_default = function custom7(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
}(0.5);

// ../node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x4, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x4, this._y3 = y4;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x4, this._y4 = y4);
        break;
      case 2:
        this._point = 3;
        this._x5 = x4, this._y5 = y4;
        break;
      default:
        point4(this, x4, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRomClosed_default = function custom8(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom8(+alpha2);
  };
  return catmullRom;
}(0.5);

// ../node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x4, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point4(this, x4, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRomOpen_default = function custom9(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom9(+alpha2);
  };
  return catmullRom;
}(0.5);

// ../node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point)
      this._context.closePath();
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point)
      this._context.lineTo(x4, y4);
    else
      this._point = 1, this._context.moveTo(x4, y4);
  }
};

// ../node_modules/d3-shape/src/curve/monotone.js
function sign2(x4) {
  return x4 < 0 ? -1 : 1;
}
function slope3(that, x22, y22) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign2(s0) + sign2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point5(that, t02, t12) {
  var x02 = that._x0, y0 = that._y0, x12 = that._x1, y1 = that._y1, dx = (x12 - x02) / 3;
  that._context.bezierCurveTo(x02 + dx, y0 + dx * t02, x12 - dx, y1 - dx * t12, x12, y1);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point5(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    var t12 = NaN;
    x4 = +x4, y4 = +y4;
    if (x4 === this._x1 && y4 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point5(this, slope2(this, t12 = slope3(this, x4, y4)), t12);
        break;
      default:
        point5(this, this._t0, t12 = slope3(this, x4, y4));
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
    this._t0 = t12;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x4, y4) {
  MonotoneX.prototype.point.call(this, y4, x4);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x4, y4) {
    this._context.moveTo(y4, x4);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x4, y4) {
    this._context.lineTo(y4, x4);
  },
  bezierCurveTo: function(x12, y1, x22, y22, x4, y4) {
    this._context.bezierCurveTo(y1, x12, y22, x22, y4, x4);
  }
};

// ../node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x4 = this._x, y4 = this._y, n = x4.length;
    if (n) {
      this._line ? this._context.lineTo(x4[0], y4[0]) : this._context.moveTo(x4[0], y4[0]);
      if (n === 2) {
        this._context.lineTo(x4[1], y4[1]);
      } else {
        var px = controlPoints(x4), py = controlPoints(y4);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x4[i1], y4[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x4, y4) {
    this._x.push(+x4);
    this._y.push(+y4);
  }
};
function controlPoints(x4) {
  var i, n = x4.length - 1, m, a2 = new Array(n), b = new Array(n), r = new Array(n);
  a2[0] = 0, b[0] = 2, r[0] = x4[0] + 2 * x4[1];
  for (i = 1; i < n - 1; ++i)
    a2[i] = 1, b[i] = 4, r[i] = 4 * x4[i] + 2 * x4[i + 1];
  a2[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x4[n - 1] + x4[n];
  for (i = 1; i < n; ++i)
    m = a2[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a2[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i)
    a2[i] = (r[i] - a2[i + 1]) / b[i];
  b[n - 1] = (x4[n] + a2[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i)
    b[i] = 2 * x4[i + 1] - a2[i + 1];
  return [a2, b];
}

// ../node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
  this._context = context;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y4);
          this._context.lineTo(x4, y4);
        } else {
          var x12 = this._x * (1 - this._t) + x4 * this._t;
          this._context.lineTo(x12, this._y);
          this._context.lineTo(x12, y4);
        }
        break;
      }
    }
    this._x = x4, this._y = y4;
  }
};

// ../node_modules/@eclipse-sirius/sirius-components-charts/dist/sirius-components-charts.es.js
var import_react = __toESM(require_react());
var getFontWeight = (style) => {
  if (style == null ? void 0 : style.bold) {
    return "bold";
  }
  return "normal";
};
var getFontSize = (style) => {
  return (style == null ? void 0 : style.fontSize) ?? 14;
};
var getFontStyle = (style) => {
  if (style == null ? void 0 : style.italic) {
    return "italic";
  }
  return "normal";
};
var getTextDecoration = (style) => {
  let decoration = "";
  if (style == null ? void 0 : style.strikeThrough) {
    decoration = decoration + "line-through";
  }
  if (style == null ? void 0 : style.underline) {
    let separator = decoration.length > 0 ? " " : "";
    decoration = decoration + separator + "underline";
  }
  return decoration.length > 0 ? decoration : "none";
};
var marginTop = 30;
var marginBottom = 30;
var marginRight = 0;
var marginLeft = 50;
var xPadding = 0.1;
var yType = linear;
var yFormat = "f";
var x3 = (d) => d.key;
var y3 = (d) => d.value;
var BarChart = ({ chart }) => {
  const d3Container = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(() => {
    const width = chart.width;
    const height = chart.height;
    const xRange = [marginLeft, width - marginRight];
    const yRange = [height - marginBottom, marginTop];
    if (d3Container.current && chart) {
      const { entries: data, label: yLabel, style } = chart;
      const fontSize = getFontSize(style);
      const fontStyle = getFontStyle(style);
      const fontWeight = getFontWeight(style);
      const textDecoration = getTextDecoration(style);
      let color;
      if ((style == null ? void 0 : style.barsColor) != null && (style == null ? void 0 : style.barsColor.length) > 0) {
        color = style == null ? void 0 : style.barsColor;
      } else {
        color = "steelblue";
      }
      const X2 = map2(data, x3);
      const Y2 = map2(data, y3);
      const xDomain = new InternSet(X2);
      const yDomain = [0, max(Y2)];
      const I = range(X2.length).filter((i) => xDomain.has(X2[i]));
      const xScale = band(xDomain, xRange).padding(xPadding);
      const yScale = yType(yDomain, yRange);
      const xAxis = axisBottom(xScale).tickSizeOuter(0);
      const yAxis = axisLeft(yScale).ticks(height / 40, yFormat);
      const formatValue = yScale.tickFormat(100, yFormat);
      const title = (i) => `${X2[i]}
${formatValue(Y2[i])}`;
      const selection = select_default(d3Container.current);
      selection.selectAll("*").remove();
      const svg2 = selection.attr("viewBox", [0, 0, width, height]).attr("text-decoration", textDecoration).attr("pointer-events", "none");
      svg2.append("g").attr("transform", `translate(${marginLeft},0)`).attr("style", `font-size:${fontSize}; font-style: ${fontStyle}; font-weight: ${fontWeight}`).call(yAxis).call((g) => g.select(".domain").remove()).call(
        (g) => g.selectAll(".tick line").clone().attr("x2", width - marginLeft - marginRight).attr("stroke-opacity", 0.1)
      ).call(
        (g) => g.append("text").attr("x", -marginLeft).attr("y", 10).attr("fill", "currentColor").attr("text-anchor", "start").text(yLabel)
      );
      const bar = svg2.append("g").attr("fill", color).selectAll("rect").data(I).join("rect").attr("x", (i) => xScale(X2[i])).attr("y", (i) => yScale(Y2[i])).attr("height", (i) => yScale(0) - yScale(Y2[i])).attr("width", xScale.bandwidth());
      if (title) {
        bar.append("title").text(title);
      }
      svg2.append("g").attr("transform", `translate(0,${height - marginBottom})`).attr("style", `font-size:${fontSize}; font-style: ${fontStyle}; font-weight: ${fontWeight}`).call(xAxis);
    }
  }, [chart, d3Container]);
  return (0, import_jsx_runtime.jsx)("svg", { ref: d3Container, width: chart.width, height: chart.height });
};
var name = (d) => d.key;
var value = (d) => d.value;
var innerRadius = 0;
var format2 = ",";
var strokeLinejoin = "round";
var PieChart = ({ width, height, chart }) => {
  const d3Container = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(() => {
    const { entries: data, style } = chart;
    const outerRadius = Math.min(width, height) / 2;
    const labelRadius = innerRadius * 0.2 + outerRadius * 0.8;
    const stroke = getStrokeColorValue(style);
    const padAngle = stroke === "none" ? 1 / outerRadius : 0;
    const strokeWidth = getStrokeWidth(style);
    const fontWeight = getFontWeight(style);
    const fontStyle = getFontStyle(style);
    const textDecoration = getTextDecoration(style);
    const fontSize = getFontSize(style);
    const N = map2(data, name);
    const V = map2(data, value);
    const I = range(N.length).filter((i) => !isNaN(V[i]));
    const names = new InternSet(N);
    let colors = style == null ? void 0 : style.colors;
    if (colors === void 0 || colors.length === 0) {
      colors = quantize_default((t) => Spectral_default(t * 0.8 + 0.1), names.size);
    }
    const color = ordinal(names, colors);
    const formatValue = format(format2);
    const title = (i) => `${N[i]}
${formatValue(V[i])}`;
    const label = (d) => {
      const lines = `${title(d.data)}`.split(/\n/);
      let value22 = d.endAngle - d.startAngle > 0.25 ? lines : lines.slice(0, 1);
      return value22.map((v2) => {
        if (v2.length > 13) {
          return v2.substring(0, 10).concat("...");
        }
        return v2;
      });
    };
    const arcs = pie_default().padAngle(padAngle).sort(null).value((i) => V[i])(I);
    const arc = arc_default().innerRadius(innerRadius).outerRadius(outerRadius);
    const arcLabel = arc_default().innerRadius(labelRadius).outerRadius(labelRadius);
    const selection = select_default(d3Container.current);
    selection.selectAll("*").remove();
    const svg2 = selection.attr("width", width).attr("height", height).attr("viewBox", [-width / 2, -height / 2, width, height]).attr("style", "max-width: 100%; height: auto; height: intrinsic;").attr("pointer-events", "none");
    svg2.append("g").attr("stroke", stroke).attr("stroke-width", strokeWidth).attr("stroke-linejoin", strokeLinejoin).selectAll("path").data(arcs).join("path").attr("fill", (d) => color(N[d.data])).attr("d", arc).append("title").text((d) => title(d.data));
    svg2.append("g").attr("font-family", "sans-serif").attr("font-size", fontSize).attr("font-style", fontStyle).attr("text-decoration", textDecoration).attr("font-weight", fontWeight).attr("text-anchor", "middle").selectAll("text").data(arcs).join("text").attr("transform", (d) => `translate(${arcLabel.centroid(d)})`).selectAll("tspan").data(label).join("tspan").attr("x", 0).attr("y", (_, i) => `${i * 1.1}em`).attr("font-weight", (_, i) => i ? null : "bold").text((d) => d);
    Object.assign(svg2.node(), { scales: { color } });
  }, [width, height, chart, d3Container]);
  const getStrokeColorValue = (style) => {
    return (style == null ? void 0 : style.strokeColor) ?? "white";
  };
  const getStrokeWidth = (style) => {
    return (style == null ? void 0 : style.strokeWidth) ?? 1;
  };
  return (0, import_jsx_runtime.jsx)("svg", { ref: d3Container });
};

// ../node_modules/@eclipse-sirius/sirius-components-forms/dist/sirius-components-forms.es.js
var import_Delete = __toESM(require_Delete());
var import_lexical = __toESM(require_Lexical());
var import_LexicalComposer = __toESM(require_LexicalComposer());
var import_LexicalComposerContext = __toESM(require_LexicalComposerContext());
var import_LexicalErrorBoundary = __toESM(require_LexicalErrorBoundary());
var import_LexicalHorizontalRuleNode = __toESM(require_LexicalHorizontalRuleNode());
var import_LexicalMarkdownShortcutPlugin = __toESM(require_LexicalMarkdownShortcutPlugin());
var import_LexicalRichTextPlugin = __toESM(require_LexicalRichTextPlugin());
var import_LexicalTabIndentationPlugin = __toESM(require_LexicalTabIndentationPlugin());
var import_Code = __toESM(require_Code());
var import_FormatBold = __toESM(require_FormatBold());
var import_FormatItalic = __toESM(require_FormatItalic());
var import_FormatListBulleted = __toESM(require_FormatListBulleted());
var import_FormatListNumbered = __toESM(require_FormatListNumbered());
var import_StrikethroughS = __toESM(require_StrikethroughS());
var import_Subject = __toESM(require_Subject());
var import_Title = __toESM(require_Title());
var import_ChevronRight = __toESM(require_ChevronRight());
var import_ExpandMore = __toESM(require_ExpandMore());
var propertySectionsRegistry = {
  getComponent: (_widget) => {
    return null;
  },
  getPreviewComponent: (_widget) => {
    return null;
  },
  getWidgetContributions: () => []
};
var value2 = {
  propertySectionsRegistry
};
var PropertySectionContext = import_react2.default.createContext(value2);
var subscribersUpdatedEventPayloadFragment = `
  fragment subscribersUpdatedEventPayloadFragment on SubscribersUpdatedEventPayload {
    id
    subscribers {
      username
    }
  }
`;
var widgetSubscriptionsUpdatedEventPayloadFragment = `
  fragment widgetSubscriptionsUpdatedEventPayloadFragment on WidgetSubscriptionsUpdatedEventPayload {
    id
    widgetSubscriptions {
      widgetId
      subscribers {
        username
      }
    }
  }
`;
var commonFields = `
  fragment commonFields on Widget {
    id
    __typename
    diagnostics {
      id
      kind
      message
    }
    hasHelpText
    readOnly
  }
`;
var widgetFields = (contributions) => `
  ${commonFields}
  
  fragment textfieldFields on Textfield {
    label
    iconURL
    stringValue: value
    supportsCompletion
    style {
      backgroundColor
      foregroundColor
      fontSize
      italic
      bold
      underline
      strikeThrough
    }
  }

  fragment textareaFields on Textarea {
    label
    iconURL
    stringValue: value
    supportsCompletion
    style {
      backgroundColor
      foregroundColor
      fontSize
      italic
      bold
      underline
      strikeThrough
    }
  }

  fragment checkboxFields on Checkbox {
    label
    iconURL
    booleanValue: value
    style {
      color
      labelPlacement
    }
  }

  fragment selectFields on Select {
    label
    iconURL
    value
    options {
      id
      label
      iconURL
    }
    style {
      backgroundColor
      foregroundColor
      fontSize
      italic
      bold
      underline
      strikeThrough
    }
  }

  fragment multiSelectFields on MultiSelect {
    label
    iconURL
    values
    options {
      id
      label
      iconURL
    }
    style {
      backgroundColor
      foregroundColor
      fontSize
      italic
      bold
      underline
      strikeThrough
    }
  }

  fragment radioFields on Radio {
    label
    iconURL
    options {
      id
      label
      selected
    }
    style {
      color
      fontSize
      italic
      bold
      underline
      strikeThrough
    }
  }

  fragment listFields on List {
    label
    iconURL
    items {
      id
      label
      kind
      iconURL
      deletable
    }
    style {
      color
      fontSize
      italic
      bold
      underline
      strikeThrough
    }
  }

  fragment linkFields on Link {
    label
    iconURL
    url
    style {
      color
      fontSize
      italic
      bold
      underline
      strikeThrough
    }
  }

  fragment buttonFields on Button {
    label
    buttonLabel
    imageURL
    style {
      backgroundColor
      foregroundColor
      fontSize
      italic
      bold
      underline
      strikeThrough
    }
  }

  fragment toolbarActionFields on ToolbarAction {
    label
    buttonLabel
    imageURL
    style {
      backgroundColor
      foregroundColor
      fontSize
      italic
      bold
      underline
      strikeThrough
    }
  }

  fragment chartWidgetFields on ChartWidget {
    label
    chart {
      ... on BarChart {
        metadata {
          label
          kind
        }
        label
        entries {
          key
          value
        }
        style {
          barsColor
          fontSize
          italic
          bold
          underline
          strikeThrough
        }
        width
        height
      }
      ... on PieChart {
        metadata {
          label
          kind
        }
        label
        entries {
          key
          value
        }
        style {
          colors
          strokeColor
          strokeWidth
          fontSize
          italic
          bold
          underline
          strikeThrough
        }
      }
    }
  } 

  fragment labelWidgetFields on LabelWidget {
    label
    stringValue: value
    style {
      color
      fontSize
      italic
      bold
      underline
      strikeThrough
    }
  }

  fragment treeWidgetFields on TreeWidget {
    label
    iconURL
    expandedNodesIds
    nodes {
      id
      parentId
      label
      kind
      iconURL
      selectable
    }
  }

  fragment imageFields on Image {
    label
    iconURL
    url
    maxWidth
  }

  fragment richTextFields on RichText {
    label
    iconURL
    stringValue: value
  }

  ${contributions.map(
  (widget) => `
    fragment ${widget.name.toLowerCase()}Fields on ${widget.name} {
      ${widget.fields}
    }
    `
)}

  fragment widgetFields on Widget {
    ...commonFields
    ... on Textfield {
      ...textfieldFields
    }
    ... on Textarea {
      ...textareaFields
    }
    ... on Checkbox {
      ...checkboxFields
    }
    ... on Select {
      ...selectFields
    }
    ... on MultiSelect {
      ...multiSelectFields
    }
    ... on Radio {
      ...radioFields
    }
    ... on List {
      ...listFields
    }
    ... on Link {
      ...linkFields
    }
    ... on Button {
      ...buttonFields
    }
    ... on ToolbarAction {
      ...toolbarActionFields
    }
    ... on LabelWidget {
      ...labelWidgetFields
    }
    ... on ChartWidget {
      ...chartWidgetFields
    }
    ... on TreeWidget {
      ...treeWidgetFields
    }
    ... on Image {
      ...imageFields
    }
    ... on RichText {
      ...richTextFields
    }

    ${contributions.map(
  (widget) => `
      ... on ${widget.name} {
        ...${widget.name.toLowerCase()}Fields
      }
      `
)}
  }
`;
var flexboxContainerFields = (contributions) => `
  ${commonFields}
  ${widgetFields(contributions)}
  fragment flexboxContainerFields on FlexboxContainer {
    ...commonFields
    label
    flexDirection
    flexWrap
    flexGrow
    children {
      ...widgetFields
      ... on FlexboxContainer {
        ...commonFields
        label
        flexDirection
        flexWrap
        flexGrow
        children {
          ...widgetFields
          ... on FlexboxContainer {
            ...commonFields
            label
            flexDirection
            flexWrap
            flexGrow
            children {
              ...widgetFields
            }
            borderStyle {
              color
              lineStyle
              size
              radius
            }
          }
        }
        borderStyle {
          color
          lineStyle
          size
          radius
        }
      }
    }
    borderStyle {
      color
      lineStyle
      size
      radius
    }
  }
`;
var formRefreshedEventPayloadFragment = (contributions) => `
  ${widgetFields(contributions)}
  ${flexboxContainerFields(contributions)}
  fragment formRefreshedEventPayloadFragment on FormRefreshedEventPayload {
    id
    form {
      id
      metadata {
        label
      }
      pages {
        id
        label
        groups {
          id
          label
          displayMode
          toolbarActions {
            ...commonFields
            ...toolbarActionFields
          }
          borderStyle {
            color
            lineStyle
            size
            radius
          }
          widgets {
            ...widgetFields
            ... on FlexboxContainer {
              ...flexboxContainerFields
            }
          }
        }
        toolbarActions {
            ...commonFields
            ...toolbarActionFields
        }
      }
    }
  }
`;
var getHelpTextQuery = gql`
  query helpText($editingContextId: ID!, $formId: ID!, $widgetId: ID!) {
    viewer {
      editingContext(editingContextId: $editingContextId) {
        representation(representationId: $formId) {
          description {
            ... on FormDescription {
              helpText(widgetId: $widgetId)
            }
          }
        }
      }
    }
  }
`;
function HelpTooltip({ editingContextId, formId, widgetId, children }) {
  const [state, setState] = (0, import_react2.useState)({ open: false, content: null });
  const [fetchHelpText, { loading, data, error }] = useLazyQuery(
    getHelpTextQuery
  );
  (0, import_react2.useEffect)(() => {
    if (!loading) {
      if (error) {
        setState((prevState) => ({
          ...prevState,
          content: (0, import_jsx_runtime2.jsxs)("div", { children: [
            "`Error while loading the help text: $",
            error.message,
            "`"
          ] })
        }));
      }
      if (data) {
        const text = data.viewer.editingContext.representation.description.helpText;
        if (text === null || text.trim().length === 0) {
          setState((prevState) => ({ ...prevState, content: (0, import_jsx_runtime2.jsx)("i", { children: "No help provided" }) }));
        } else {
          const lines = text.split("\n");
          const content = (0, import_jsx_runtime2.jsx)("div", { children: lines.map((line, index2) => (0, import_jsx_runtime2.jsxs)(import_react2.Fragment, { children: [
            line,
            (0, import_jsx_runtime2.jsx)("br", {})
          ] }, index2)) });
          setState((prevState) => ({ ...prevState, content }));
        }
      }
    }
  }, [loading, data, error]);
  const handleOpen = () => {
    setState((prevState) => ({ ...prevState, open: true, content: (0, import_jsx_runtime2.jsx)(CircularProgress_default, { size: "1em" }) }));
    const variables = {
      editingContextId,
      formId,
      widgetId
    };
    fetchHelpText({ variables });
  };
  const handleClose = () => setState((prevState) => ({ ...prevState, open: false, content: null }));
  return (0, import_jsx_runtime2.jsx)(
    Tooltip_default,
    {
      open: state.open && state.content !== null,
      onClose: handleClose,
      onOpen: handleOpen,
      title: state.content || "",
      placement: "top",
      arrow: true,
      children: children || (0, import_jsx_runtime2.jsx)(import_HelpOutlineOutlined.default, { color: "secondary", style: { marginLeft: 8, fontSize: 16 } })
    }
  );
}
var usePropertySectionLabelStyles = makeStyles_default((theme) => ({
  propertySectionLabel: {
    display: "flex",
    flexDirection: "row",
    alignItems: "center"
  },
  subscribers: {
    marginLeft: "auto",
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    "& > *": {
      marginLeft: theme.spacing(0.5),
      marginRight: theme.spacing(0.5)
    }
  },
  avatar: {
    fontSize: "0.875rem",
    width: theme.spacing(2),
    height: theme.spacing(2)
  }
}));
var PropertySectionLabel = ({ editingContextId, formId, widget, subscribers }) => {
  const classes = usePropertySectionLabelStyles();
  return (0, import_jsx_runtime2.jsxs)("div", { className: classes.propertySectionLabel, children: [
    (0, import_jsx_runtime2.jsx)(Typography_default, { variant: "subtitle2", children: widget.label }),
    widget.hasHelpText ? (0, import_jsx_runtime2.jsx)(HelpTooltip, { editingContextId, formId, widgetId: widget.id }) : null,
    (0, import_jsx_runtime2.jsx)("div", { className: classes.subscribers, children: subscribers.map((subscriber) => (0, import_jsx_runtime2.jsx)(Tooltip_default, { title: subscriber.username, arrow: true, children: (0, import_jsx_runtime2.jsx)(Avatar_default, { classes: { root: classes.avatar }, children: subscriber.username.substring(0, 1).toUpperCase() }) }, subscriber.username)) })
  ] });
};
var getTextDecorationLineValue = (underline, strikeThrough) => {
  let value22 = null;
  if (underline) {
    if (strikeThrough) {
      value22 = "underline line-through";
    } else {
      value22 = "underline";
    }
  } else if (strikeThrough) {
    if (underline) {
      value22 = "underline line-through";
    } else {
      value22 = "line-through";
    }
  }
  return value22;
};
function useClickHandler(onSimpleClick, onDoubleClick, delay = 250) {
  const eventRef = (0, import_react2.useRef)(null);
  const [clicks, setClicks] = (0, import_react2.useState)(0);
  (0, import_react2.useEffect)(() => {
    let singleClickTimer;
    if (clicks === 1) {
      singleClickTimer = setTimeout(function() {
        onSimpleClick == null ? void 0 : onSimpleClick(eventRef.current);
        setClicks(0);
        eventRef.current = null;
      }, delay);
    } else if (clicks === 2) {
      onDoubleClick == null ? void 0 : onDoubleClick(eventRef.current);
      eventRef.current = null;
      setClicks(0);
    }
    return () => clearTimeout(singleClickTimer);
  }, [clicks, onSimpleClick, onDoubleClick, delay]);
  return (element) => {
    eventRef.current = element;
    setClicks(clicks + 1);
  };
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p))
          t[p] = s2[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var docCache = /* @__PURE__ */ new Map();
var fragmentSourceMap = /* @__PURE__ */ new Map();
var printFragmentWarnings = true;
var experimentalFragmentVariables = false;
function normalize2(string) {
  return string.replace(/[\s,]+/g, " ").trim();
}
function cacheKeyFromLoc(loc) {
  return normalize2(loc.source.body.substring(loc.start, loc.end));
}
function processFragments(ast) {
  var seenKeys = /* @__PURE__ */ new Set();
  var definitions = [];
  ast.definitions.forEach(function(fragmentDefinition) {
    if (fragmentDefinition.kind === "FragmentDefinition") {
      var fragmentName = fragmentDefinition.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
      var sourceKeySet = fragmentSourceMap.get(fragmentName);
      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }
      } else if (!sourceKeySet) {
        fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
      }
      sourceKeySet.add(sourceKey);
      if (!seenKeys.has(sourceKey)) {
        seenKeys.add(sourceKey);
        definitions.push(fragmentDefinition);
      }
    } else {
      definitions.push(fragmentDefinition);
    }
  });
  return __assign(__assign({}, ast), { definitions });
}
function stripLoc(doc) {
  var workSet = new Set(doc.definitions);
  workSet.forEach(function(node) {
    if (node.loc)
      delete node.loc;
    Object.keys(node).forEach(function(key) {
      var value22 = node[key];
      if (value22 && typeof value22 === "object") {
        workSet.add(value22);
      }
    });
  });
  var loc = doc.loc;
  if (loc) {
    delete loc.startToken;
    delete loc.endToken;
  }
  return doc;
}
function parseDocument(source) {
  var cacheKey = normalize2(source);
  if (!docCache.has(cacheKey)) {
    var parsed = parse(source, {
      experimentalFragmentVariables,
      allowLegacyFragmentVariables: experimentalFragmentVariables
    });
    if (!parsed || parsed.kind !== "Document") {
      throw new Error("Not a valid GraphQL document.");
    }
    docCache.set(cacheKey, stripLoc(processFragments(parsed)));
  }
  return docCache.get(cacheKey);
}
function gql2(literals) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (typeof literals === "string") {
    literals = [literals];
  }
  var result = literals[0];
  args.forEach(function(arg, i) {
    if (arg && arg.kind === "Document") {
      result += arg.loc.source.body;
    } else {
      result += arg;
    }
    result += literals[i + 1];
  });
  return parseDocument(result);
}
function resetCaches() {
  docCache.clear();
  fragmentSourceMap.clear();
}
function disableFragmentWarnings() {
  printFragmentWarnings = false;
}
function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}
function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
}
var extras = {
  gql: gql2,
  resetCaches,
  disableFragmentWarnings,
  enableExperimentalFragmentVariables,
  disableExperimentalFragmentVariables
};
(function(gql_1) {
  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
})(gql2 || (gql2 = {}));
gql2["default"] = gql2;
var gql$1 = gql2;
var useStyle$7 = makeStyles_default((theme) => ({
  style: {
    backgroundColor: ({ backgroundColor }) => backgroundColor ? getCSSColor(backgroundColor, theme) : theme.palette.primary.light,
    color: ({ foregroundColor }) => foregroundColor ? getCSSColor(foregroundColor, theme) : "white",
    fontSize: ({ fontSize }) => fontSize ? fontSize : null,
    fontStyle: ({ italic }) => italic ? "italic" : null,
    fontWeight: ({ bold }) => bold ? "bold" : null,
    textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough),
    "&:hover": {
      backgroundColor: ({ backgroundColor }) => backgroundColor ? getCSSColor(backgroundColor, theme) : theme.palette.primary.main,
      color: ({ foregroundColor }) => foregroundColor ? getCSSColor(foregroundColor, theme) : "white",
      fontSize: ({ fontSize }) => fontSize ? fontSize : null,
      fontStyle: ({ italic }) => italic ? "italic" : null,
      fontWeight: ({ bold }) => bold ? "bold" : null,
      textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough)
    }
  },
  icon: {
    marginRight: ({ iconOnly }) => iconOnly ? theme.spacing(0) : theme.spacing(2)
  }
}));
var pushButtonMutation$1 = gql$1`
  mutation pushButton($input: PushButtonInput!) {
    pushButton(input: $input) {
      __typename
      ... on ErrorPayload {
        messages {
          body
          level
        }
      }
      ... on SuccessPayload {
        messages {
          body
          level
        }
      }
    }
  }
`;
var updateWidgetFocusMutation$7 = gql$1`
  mutation updateWidgetFocus($input: UpdateWidgetFocusInput!) {
    updateWidgetFocus(input: $input) {
      __typename
      ... on ErrorPayload {
        messages {
          body
          level
        }
      }
    }
  }
`;
var isErrorPayload$8 = (payload) => payload.__typename === "ErrorPayload";
var isSuccessPayload$8 = (payload) => payload.__typename === "SuccessPayload";
var ButtonPropertySection = ({
  editingContextId,
  formId,
  widget,
  subscribers,
  readOnly
}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const props = {
    backgroundColor: ((_a = widget.style) == null ? void 0 : _a.backgroundColor) ?? null,
    foregroundColor: ((_b = widget.style) == null ? void 0 : _b.foregroundColor) ?? null,
    fontSize: ((_c = widget.style) == null ? void 0 : _c.fontSize) ?? null,
    italic: ((_d = widget.style) == null ? void 0 : _d.italic) ?? null,
    bold: ((_e = widget.style) == null ? void 0 : _e.bold) ?? null,
    underline: ((_f = widget.style) == null ? void 0 : _f.underline) ?? null,
    strikeThrough: ((_g = widget.style) == null ? void 0 : _g.strikeThrough) ?? null,
    iconOnly: widget.buttonLabel ? false : true
  };
  const classes = useStyle$7(props);
  const { httpOrigin } = (0, import_react2.useContext)(ServerContext);
  const [pushButton, { loading, data, error }] = useMutation(
    pushButtonMutation$1
  );
  const { addErrorMessage, addMessages } = useMultiToast();
  (0, import_react2.useEffect)(() => {
    if (!loading) {
      if (error) {
        addErrorMessage("An unexpected error has occurred, please refresh the page");
      }
      if (data) {
        const { pushButton: pushButton2 } = data;
        if (isErrorPayload$8(pushButton2) || isSuccessPayload$8(pushButton2)) {
          addMessages(pushButton2.messages);
        }
      }
    }
  }, [loading, error, data]);
  const [
    updateWidgetFocus,
    { loading: updateWidgetFocusLoading, data: updateWidgetFocusData, error: updateWidgetFocusError }
  ] = useMutation(updateWidgetFocusMutation$7);
  const sendUpdateWidgetFocus = (selected) => {
    const input = {
      id: crypto.randomUUID(),
      editingContextId,
      representationId: formId,
      widgetId: widget.id,
      selected
    };
    const variables = {
      input
    };
    updateWidgetFocus({ variables });
  };
  (0, import_react2.useEffect)(() => {
    if (!updateWidgetFocusLoading) {
      if (updateWidgetFocusError) {
        addErrorMessage("An unexpected error has occurred, please refresh the page");
      }
      if (updateWidgetFocusData) {
        const { updateWidgetFocus: updateWidgetFocus2 } = updateWidgetFocusData;
        if (isErrorPayload$8(updateWidgetFocus2)) {
          addMessages(updateWidgetFocus2.messages);
        }
      }
    }
  }, [updateWidgetFocusLoading, updateWidgetFocusData, updateWidgetFocusError]);
  const onFocus = () => sendUpdateWidgetFocus(true);
  const onBlur = () => {
    sendUpdateWidgetFocus(false);
  };
  const onClick = () => {
    const input = {
      id: crypto.randomUUID(),
      editingContextId,
      representationId: formId,
      buttonId: widget.id
    };
    const variables = { input };
    pushButton({ variables });
  };
  return (0, import_jsx_runtime2.jsxs)("div", { children: [
    (0, import_jsx_runtime2.jsx)(
      PropertySectionLabel,
      {
        editingContextId,
        formId,
        widget,
        subscribers,
        "data-testid": widget.label
      }
    ),
    (0, import_jsx_runtime2.jsxs)(
      Button_default,
      {
        "data-testid": widget.buttonLabel,
        variant: "contained",
        color: "primary",
        onClick,
        onBlur,
        onFocus,
        disabled: readOnly || widget.readOnly,
        classes: { root: classes.style },
        children: [
          ((_h = widget.imageURL) == null ? void 0 : _h.length) > 0 ? (0, import_jsx_runtime2.jsx)("img", { className: classes.icon, width: "16", height: "16", alt: widget.label, src: httpOrigin + widget.imageURL }) : null,
          widget.buttonLabel
        ]
      }
    )
  ] });
};
var useStyles = makeStyles_default(() => ({
  chart: {
    overflowX: "auto"
  }
}));
var ChartWidgetPropertySection = ({
  editingContextId,
  formId,
  widget,
  subscribers
}) => {
  const classes = useStyles();
  const { chart } = widget;
  let chartComponent;
  if (isBarChart(chart)) {
    chartComponent = (0, import_jsx_runtime2.jsx)("div", { className: classes.chart, children: (0, import_jsx_runtime2.jsx)(BarChart, { chart }) });
  } else if (isPieChart(chart)) {
    chartComponent = (0, import_jsx_runtime2.jsx)(PieChart, { width: 300, height: 300, chart });
  }
  let content;
  if (chartComponent) {
    content = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      (0, import_jsx_runtime2.jsx)(
        PropertySectionLabel,
        {
          editingContextId,
          formId,
          widget,
          subscribers
        }
      ),
      chartComponent
    ] });
  }
  return (0, import_jsx_runtime2.jsx)("div", { children: content });
};
var isBarChart = (chart) => {
  return chart.metadata.kind === "BarChart";
};
var isPieChart = (chart) => {
  return chart.metadata.kind === "PieChart";
};
var useStyle$6 = makeStyles_default((theme) => ({
  formControl: {
    alignItems: "flex-start"
  },
  style: {
    color: ({ color }) => color ? getCSSColor(color, theme) : theme.palette.primary.light
  },
  disabled: {}
}));
var editCheckboxMutation = gql`
  mutation editCheckbox($input: EditCheckboxInput!) {
    editCheckbox(input: $input) {
      __typename
      ... on ErrorPayload {
        messages {
          body
          level
        }
      }
      ... on SuccessPayload {
        messages {
          body
          level
        }
      }
    }
  }
`;
var updateWidgetFocusMutation$6 = gql`
  mutation updateWidgetFocus($input: UpdateWidgetFocusInput!) {
    updateWidgetFocus(input: $input) {
      __typename
      ... on ErrorPayload {
        messages {
          body
          level
        }
      }
    }
  }
`;
var isErrorPayload$7 = (payload) => payload.__typename === "ErrorPayload";
var isSuccessPayload$7 = (payload) => payload.__typename === "SuccessPayload";
var CheckboxPropertySection = ({
  editingContextId,
  formId,
  widget,
  subscribers,
  readOnly
}) => {
  var _a, _b, _c;
  const props = {
    color: ((_a = widget.style) == null ? void 0 : _a.color) ?? null
  };
  const classes = useStyle$6(props);
  const [editCheckbox, { loading, error, data }] = useMutation(editCheckboxMutation);
  const onChange = (event) => {
    const newValue = event.target.checked;
    const input = {
      id: crypto.randomUUID(),
      editingContextId,
      representationId: formId,
      checkboxId: widget.id,
      newValue
    };
    const variables = {
      input
    };
    editCheckbox({ variables });
  };
  const { addErrorMessage, addMessages } = useMultiToast();
  (0, import_react2.useEffect)(() => {
    if (!loading) {
      if (error) {
        addErrorMessage("An unexpected error has occurred, please refresh the page");
      }
      if (data) {
        const { editCheckbox: editCheckbox2 } = data;
        if (isErrorPayload$7(editCheckbox2) || isSuccessPayload$7(editCheckbox2)) {
          addMessages(editCheckbox2.messages);
        }
      }
    }
  }, [loading, error, data]);
  const [
    updateWidgetFocus,
    { loading: updateWidgetFocusLoading, data: updateWidgetFocusData, error: updateWidgetFocusError }
  ] = useMutation(updateWidgetFocusMutation$6);
  const sendUpdateWidgetFocus = (selected) => {
    const input = {
      id: crypto.randomUUID(),
      editingContextId,
      representationId: formId,
      widgetId: widget.id,
      selected
    };
    const variables = {
      input
    };
    updateWidgetFocus({ variables });
  };
  (0, import_react2.useEffect)(() => {
    if (!updateWidgetFocusLoading) {
      if (updateWidgetFocusError) {
        addErrorMessage("An unexpected error has occurred, please refresh the page");
      }
      if (updateWidgetFocusData) {
        const { updateWidgetFocus: updateWidgetFocus2 } = updateWidgetFocusData;
        if (isErrorPayload$7(updateWidgetFocus2)) {
          addMessages(updateWidgetFocus2.messages);
        }
      }
    }
  }, [updateWidgetFocusLoading, updateWidgetFocusData, updateWidgetFocusError]);
  const onFocus = () => sendUpdateWidgetFocus(true);
  const onBlur = () => sendUpdateWidgetFocus(false);
  return (0, import_jsx_runtime2.jsxs)(FormControl_default, { classes: { root: classes.formControl }, error: widget.diagnostics.length > 0, children: [
    (0, import_jsx_runtime2.jsx)(
      FormControlLabel_default,
      {
        labelPlacement: ((_b = widget.style) == null ? void 0 : _b.labelPlacement) ?? "end",
        label: (0, import_jsx_runtime2.jsx)(
          PropertySectionLabel,
          {
            editingContextId,
            formId,
            widget,
            subscribers
          }
        ),
        control: (0, import_jsx_runtime2.jsx)(
          Checkbox_default,
          {
            name: widget.label,
            color: "default",
            checked: widget.booleanValue,
            onChange,
            onFocus,
            onBlur,
            "data-testid": widget.label,
            disabled: readOnly || widget.readOnly,
            classes: { root: classes.style, disabled: classes.disabled }
          }
        )
      }
    ),
    (0, import_jsx_runtime2.jsx)(FormHelperText_default, { children: (_c = widget.diagnostics[0]) == null ? void 0 : _c.message })
  ] });
};
var useFlexboxContainerPropertySectionStyles = makeStyles_default(
  (theme) => ({
    containerAndLabel: {
      margin: ({ borderStyle }) => borderStyle ? theme.spacing(0.5) : 0,
      padding: ({ borderStyle }) => borderStyle ? theme.spacing(0.5) : 0,
      borderWidth: ({ borderStyle }) => (borderStyle == null ? void 0 : borderStyle.size) || 0,
      borderColor: ({ borderStyle }) => getCSSColor(borderStyle == null ? void 0 : borderStyle.color, theme) || "transparent",
      borderStyle: ({ borderStyle }) => (borderStyle == null ? void 0 : borderStyle.lineStyle) || "solid",
      borderRadius: ({ borderStyle }) => (borderStyle == null ? void 0 : borderStyle.radius) || 0
    },
    container: {
      display: "flex",
      flexWrap: ({ flexWrap }) => flexWrap,
      flexDirection: ({ flexDirection }) => flexDirection,
      "& > *": {
        marginBottom: theme.spacing(0)
      }
    },
    children: {
      flexGrow: ({ flexGrow }) => flexGrow
    }
  })
);
var FlexboxContainerPropertySection = ({
  editingContextId,
  formId,
  widget,
  widgetSubscriptions,
  readOnly
}) => {
  const classes = useFlexboxContainerPropertySectionStyles({
    flexDirection: widget.flexDirection,
    flexWrap: widget.flexWrap,
    flexGrow: widget.flexGrow,
    borderStyle: widget.borderStyle
  });
  let children = widget.children.map((childWidget) => (0, import_jsx_runtime2.jsx)("div", { className: classes.children, children: (0, import_jsx_runtime2.jsx)(
    PropertySection,
    {
      editingContextId,
      formId,
      widget: childWidget,
      widgetSubscriptions,
      readOnly: readOnly || widget.readOnly
    },
    childWidget.id
  ) }, childWidget.id));
  return (0, import_jsx_runtime2.jsxs)("div", { className: classes.containerAndLabel, "data-testid": `flexbox-${widget.label}`, children: [
    (0, import_jsx_runtime2.jsx)(PropertySectionLabel, { editingContextId, formId, widget, subscribers: [] }),
    (0, import_jsx_runtime2.jsx)("div", { className: classes.container, children })
  ] });
};
var useImageStyles = makeStyles_default(() => ({
  container: {
    display: "grid",
    gridTemplateColumns: ({ maxWidth }) => {
      if (maxWidth) {
        let max5 = maxWidth;
        if (maxWidth.match(/[0-9]$/)) {
          max5 = maxWidth + "px";
        }
        return `minmax(auto, ${max5})`;
      } else {
        return "1fr";
      }
    }
  }
}));
var ImagePropertySection = ({ editingContextId, formId, widget }) => {
  const { httpOrigin } = (0, import_react2.useContext)(ServerContext);
  const [validImage, setValidImage] = (0, import_react2.useState)(true);
  const onErrorLoadingImage = () => {
    setValidImage(false);
  };
  (0, import_react2.useEffect)(() => {
    setValidImage(true);
  }, [widget.url]);
  let imageURL;
  if (widget.url.startsWith("http://") || widget.url.startsWith("https://")) {
    imageURL = widget.url;
  } else {
    imageURL = httpOrigin + widget.url;
  }
  const classes = useImageStyles({
    maxWidth: widget.maxWidth
  });
  return (0, import_jsx_runtime2.jsxs)("div", { children: [
    (0, import_jsx_runtime2.jsx)(PropertySectionLabel, { editingContextId, formId, widget, subscribers: [] }),
    (0, import_jsx_runtime2.jsx)("div", { className: classes.container, children: validImage ? (0, import_jsx_runtime2.jsx)("img", { id: widget.id, src: imageURL, width: "100%", onError: onErrorLoadingImage }) : (0, import_jsx_runtime2.jsx)(Typography_default, { variant: "caption", children: "No image" }) })
  ] });
};
var useStyle$5 = makeStyles_default((theme) => ({
  style: {
    color: ({ color }) => color ? getCSSColor(color, theme) : null,
    fontSize: ({ fontSize }) => fontSize ? fontSize : null,
    fontStyle: ({ italic }) => italic ? "italic" : null,
    fontWeight: ({ bold }) => bold ? "bold" : null,
    textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough)
  }
}));
var LabelWidgetPropertySection = ({
  editingContextId,
  formId,
  widget,
  subscribers
}) => {
  var _a, _b, _c, _d, _e, _f;
  const props = {
    color: ((_a = widget.style) == null ? void 0 : _a.color) ?? null,
    fontSize: ((_b = widget.style) == null ? void 0 : _b.fontSize) ?? null,
    italic: ((_c = widget.style) == null ? void 0 : _c.italic) ?? null,
    bold: ((_d = widget.style) == null ? void 0 : _d.bold) ?? null,
    underline: ((_e = widget.style) == null ? void 0 : _e.underline) ?? null,
    strikeThrough: ((_f = widget.style) == null ? void 0 : _f.strikeThrough) ?? null
  };
  const classes = useStyle$5(props);
  return (0, import_jsx_runtime2.jsxs)("div", { children: [
    (0, import_jsx_runtime2.jsx)(
      PropertySectionLabel,
      {
        editingContextId,
        formId,
        widget,
        subscribers
      }
    ),
    (0, import_jsx_runtime2.jsx)(Typography_default, { className: classes.style, children: widget.stringValue })
  ] });
};
var useStyle$4 = makeStyles_default((theme) => ({
  style: {
    color: ({ color }) => color ? getCSSColor(color, theme) : null,
    fontSize: ({ fontSize }) => fontSize ? fontSize : null,
    fontStyle: ({ italic }) => italic ? "italic" : null,
    fontWeight: ({ bold }) => bold ? "bold" : null,
    textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough)
  },
  propertySectionLabel: {
    display: "flex",
    flexDirection: "row",
    alignItems: "center"
  }
}));
var LinkPropertySection = ({ editingContextId, formId, widget }) => {
  var _a, _b, _c, _d, _e, _f;
  const props = {
    color: ((_a = widget.style) == null ? void 0 : _a.color) ?? null,
    fontSize: ((_b = widget.style) == null ? void 0 : _b.fontSize) ?? null,
    italic: ((_c = widget.style) == null ? void 0 : _c.italic) ?? null,
    bold: ((_d = widget.style) == null ? void 0 : _d.bold) ?? null,
    underline: ((_e = widget.style) == null ? void 0 : _e.underline) ?? null,
    strikeThrough: ((_f = widget.style) == null ? void 0 : _f.strikeThrough) ?? null
  };
  const classes = useStyle$4(props);
  return (0, import_jsx_runtime2.jsxs)("div", { className: classes.propertySectionLabel, children: [
    (0, import_jsx_runtime2.jsx)(Link_default, { className: classes.style, id: widget.id, href: widget.url, rel: "noopener noreferrer", target: "_blank", children: widget.label }),
    widget.hasHelpText ? (0, import_jsx_runtime2.jsx)(HelpTooltip, { editingContextId, formId, widgetId: widget.id }) : null
  ] });
};
var deleteListItemMutation = gql`
  mutation deleteListItem($input: DeleteListItemInput!) {
    deleteListItem(input: $input) {
      __typename
      ... on ErrorPayload {
        messages {
          body
          level
        }
      }
      ... on SuccessPayload {
        messages {
          body
          level
        }
      }
    }
  }
`;
var clickListItemMutation = gql`
  mutation clickListItem($input: ClickListItemInput!) {
    clickListItem(input: $input) {
      __typename
      ... on ErrorPayload {
        messages {
          body
          level
        }
      }
      ... on SuccessPayload {
        messages {
          body
          level
        }
      }
    }
  }
`;
var useListPropertySectionStyles = makeStyles_default((theme) => ({
  cell: {
    display: "flex",
    flexDirection: "row",
    alignItems: "center"
  },
  canBeSelectedItem: {
    "&:hover": {
      textDecoration: "underline",
      cursor: "pointer"
    }
  },
  style: {
    color: ({ color }) => color ? getCSSColor(color, theme) : null,
    fontSize: ({ fontSize }) => fontSize ? fontSize : null,
    fontStyle: ({ italic }) => italic ? "italic" : null,
    fontWeight: ({ bold }) => bold ? "bold" : null,
    textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough),
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    flexGrow: 1
  }
}));
var NONE_WIDGET_ITEM_ID = "none";
var isErrorPayload$6 = (payload) => payload.__typename === "ErrorPayload";
var isSuccessPayload$6 = (payload) => payload.__typename === "SuccessPayload";
var ListPropertySection = ({
  editingContextId,
  formId,
  widget,
  subscribers,
  readOnly
}) => {
  var _a, _b, _c, _d, _e, _f, _g;
  const props = {
    color: ((_a = widget.style) == null ? void 0 : _a.color) ?? null,
    fontSize: ((_b = widget.style) == null ? void 0 : _b.fontSize) ?? null,
    italic: ((_c = widget.style) == null ? void 0 : _c.italic) ?? null,
    bold: ((_d = widget.style) == null ? void 0 : _d.bold) ?? null,
    underline: ((_e = widget.style) == null ? void 0 : _e.underline) ?? null,
    strikeThrough: ((_f = widget.style) == null ? void 0 : _f.strikeThrough) ?? null
  };
  const classes = useListPropertySectionStyles(props);
  const theme = useTheme();
  const { setSelection } = useSelection();
  const { showDeletionConfirmation } = useDeletionConfirmationDialog();
  let items = [...widget.items];
  if (items.length === 0) {
    items.push({
      id: NONE_WIDGET_ITEM_ID,
      iconURL: [],
      label: "None",
      kind: "Unknown",
      deletable: false
    });
  }
  const [deleteListItem, { loading: deleteLoading, error: deleteError, data: deleteData }] = useMutation(deleteListItemMutation);
  const [clickListItem, { loading: clickLoading, error: clickError, data: clickData }] = useMutation(clickListItemMutation);
  const onDelete = (_, item) => {
    const variables = {
      input: {
        id: crypto.randomUUID(),
        editingContextId,
        representationId: formId,
        listId: widget.id,
        listItemId: item.id
      }
    };
    showDeletionConfirmation(() => {
      deleteListItem({ variables });
    });
  };
  const { addErrorMessage, addMessages } = useMultiToast();
  (0, import_react2.useEffect)(() => {
    if (!deleteLoading) {
      if (deleteError) {
        addErrorMessage("An unexpected error has occurred, please refresh the page");
      }
      if (deleteData) {
        const { deleteListItem: deleteListItem2 } = deleteData;
        if (isErrorPayload$6(deleteListItem2) || isSuccessPayload$6(deleteListItem2)) {
          addMessages(deleteListItem2.messages);
        }
      }
    }
  }, [deleteLoading, deleteError, deleteData]);
  (0, import_react2.useEffect)(() => {
    if (!clickLoading) {
      if (clickError) {
        addErrorMessage("An unexpected error has occurred, please refresh the page");
      }
      if (clickData) {
        const { clickListItem: clickListItem2 } = clickData;
        if (isErrorPayload$6(clickListItem2) || isSuccessPayload$6(clickListItem2)) {
          addMessages(clickListItem2.messages);
        }
      }
    }
  }, [clickLoading, clickError, clickData]);
  const onSimpleClick = (item) => {
    const { id, label, kind } = item;
    setSelection({ entries: [{ id, label, kind }] });
    const variables = {
      input: {
        id: crypto.randomUUID(),
        editingContextId,
        representationId: formId,
        listId: widget.id,
        listItemId: item.id,
        clickEventKind: "SINGLE_CLICK"
      }
    };
    clickListItem({ variables });
  };
  const onDoubleClick = (item) => {
    const { id, label, kind } = item;
    setSelection({ entries: [{ id, label, kind }] });
    const variables = {
      input: {
        id: crypto.randomUUID(),
        editingContextId,
        representationId: formId,
        listId: widget.id,
        listItemId: item.id,
        clickEventKind: "DOUBLE_CLICK"
      }
    };
    clickListItem({ variables });
  };
  const clickHandler = useClickHandler(onSimpleClick, onDoubleClick);
  const getTableCellContent = (item) => {
    return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      (0, import_jsx_runtime2.jsx)(IconOverlay, { iconURL: item.iconURL, alt: item.label, customIconStyle: { marginRight: theme.spacing(2) } }),
      (0, import_jsx_runtime2.jsx)(
        Typography_default,
        {
          className: `${readOnly || widget.readOnly ? "" : classes.canBeSelectedItem} ${classes.style}`,
          onClick: () => readOnly || widget.readOnly ? {} : clickHandler(item),
          color: "textPrimary",
          "data-testid": `representation-${item.label}`,
          children: item.label
        }
      ),
      (0, import_jsx_runtime2.jsx)(
        IconButton_default,
        {
          "aria-label": "deleteListItem",
          onClick: (event) => onDelete(event, item),
          disabled: readOnly || !item.deletable || widget.readOnly,
          "data-testid": `delete-representation-${item.label}`,
          children: (0, import_jsx_runtime2.jsx)(import_Delete.default, {})
        }
      )
    ] });
  };
  return (0, import_jsx_runtime2.jsxs)(FormControl_default, { error: widget.diagnostics.length > 0, fullWidth: true, children: [
    (0, import_jsx_runtime2.jsx)(
      PropertySectionLabel,
      {
        editingContextId,
        formId,
        widget,
        subscribers
      }
    ),
    (0, import_jsx_runtime2.jsx)(Table_default, { size: "small", "data-testid": `table-${widget.label}`, children: (0, import_jsx_runtime2.jsx)(TableBody_default, { children: items.map((item) => (0, import_jsx_runtime2.jsx)(TableRow_default, { children: (0, import_jsx_runtime2.jsx)(TableCell_default, { className: classes.cell, children: getTableCellContent(item) }) }, item.id)) }) }),
    (0, import_jsx_runtime2.jsx)(FormHelperText_default, { children: (_g = widget.diagnostics[0]) == null ? void 0 : _g.message })
  ] });
};
var useStyle$3 = makeStyles_default((theme) => ({
  style: {
    backgroundColor: ({ backgroundColor }) => backgroundColor ? getCSSColor(backgroundColor, theme) : null,
    color: ({ foregroundColor }) => foregroundColor ? getCSSColor(foregroundColor, theme) : null,
    fontSize: ({ fontSize }) => fontSize ? fontSize : null,
    fontStyle: ({ italic }) => italic ? "italic" : null,
    fontWeight: ({ bold }) => bold ? "bold" : null,
    textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough)
  },
  iconRoot: {
    minWidth: theme.spacing(3)
  }
}));
var editMultiSelectMutation = gql`
  mutation editMultiSelect($input: EditMultiSelectInput!) {
    editMultiSelect(input: $input) {
      __typename
      ... on ErrorPayload {
        messages {
          body
          level
        }
      }
      ... on SuccessPayload {
        messages {
          body
          level
        }
      }
    }
  }
`;
var updateWidgetFocusMutation$5 = gql`
  mutation updateWidgetFocus($input: UpdateWidgetFocusInput!) {
    updateWidgetFocus(input: $input) {
      __typename
      ... on ErrorPayload {
        messages {
          body
          level
        }
      }
    }
  }
`;
var isErrorPayload$5 = (payload) => payload.__typename === "ErrorPayload";
var isSuccessPayload$5 = (payload) => payload.__typename === "SuccessPayload";
var MultiSelectPropertySection = ({
  editingContextId,
  formId,
  widget,
  subscribers,
  readOnly
}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const props = {
    backgroundColor: ((_a = widget.style) == null ? void 0 : _a.backgroundColor) ?? null,
    foregroundColor: ((_b = widget.style) == null ? void 0 : _b.foregroundColor) ?? null,
    fontSize: ((_c = widget.style) == null ? void 0 : _c.fontSize) ?? null,
    italic: ((_d = widget.style) == null ? void 0 : _d.italic) ?? null,
    bold: ((_e = widget.style) == null ? void 0 : _e.bold) ?? null,
    underline: ((_f = widget.style) == null ? void 0 : _f.underline) ?? null,
    strikeThrough: ((_g = widget.style) == null ? void 0 : _g.strikeThrough) ?? null
  };
  const classes = useStyle$3(props);
  const [isFocused, setFocus] = (0, import_react2.useState)(false);
  const [editMultiSelect, { loading, error, data }] = useMutation(editMultiSelectMutation);
  const onChange = (event) => {
    const newValues = event.target.value;
    const variables = {
      input: {
        id: crypto.randomUUID(),
        editingContextId,
        representationId: formId,
        selectId: widget.id,
        newValues
      }
    };
    editMultiSelect({ variables });
  };
  const { addErrorMessage, addMessages } = useMultiToast();
  (0, import_react2.useEffect)(() => {
    if (!loading) {
      if (error) {
        addErrorMessage("An unexpected error has occurred, please refresh the page");
      }
      if (data) {
        const { editMultiSelect: editMultiSelect2 } = data;
        if (isErrorPayload$5(editMultiSelect2) || isSuccessPayload$5(editMultiSelect2)) {
          addMessages(editMultiSelect2.messages);
        }
      }
    }
  }, [loading, error, data]);
  const [
    updateWidgetFocus,
    { loading: updateWidgetFocusLoading, data: updateWidgetFocusData, error: updateWidgetFocusError }
  ] = useMutation(updateWidgetFocusMutation$5);
  const sendUpdateWidgetFocus = (selected) => {
    const variables = {
      input: {
        id: crypto.randomUUID(),
        editingContextId,
        representationId: formId,
        widgetId: widget.id,
        selected
      }
    };
    updateWidgetFocus({ variables });
  };
  (0, import_react2.useEffect)(() => {
    if (!updateWidgetFocusLoading) {
      if (updateWidgetFocusError) {
        addErrorMessage("An unexpected error has occurred, please refresh the page");
      }
      if (updateWidgetFocusData) {
        const { updateWidgetFocus: updateWidgetFocus2 } = updateWidgetFocusData;
        if (isErrorPayload$5(updateWidgetFocus2)) {
          addMessages(updateWidgetFocus2.messages);
        }
      }
    }
  }, [updateWidgetFocusLoading, updateWidgetFocusData, updateWidgetFocusError]);
  const onFocus = () => {
    if (!isFocused) {
      setFocus(true);
      sendUpdateWidgetFocus(true);
    }
  };
  const onBlur = () => {
    setFocus(false);
    sendUpdateWidgetFocus(false);
  };
  return (0, import_jsx_runtime2.jsxs)(FormControl_default, { error: widget.diagnostics.length > 0, children: [
    (0, import_jsx_runtime2.jsx)(
      PropertySectionLabel,
      {
        editingContextId,
        formId,
        widget,
        subscribers
      }
    ),
    (0, import_jsx_runtime2.jsx)(
      Select_default,
      {
        value: widget.values,
        onChange,
        displayEmpty: true,
        onFocus,
        onBlur,
        fullWidth: true,
        "data-testid": widget.label,
        disabled: readOnly || widget.readOnly,
        renderValue: (selected) => widget.options.filter((option) => selected.includes(option.id)).map((option) => option.label).join(", "),
        multiple: true,
        inputProps: widget.style ? {
          className: classes.style
        } : {},
        children: widget.options.map((option) => (0, import_jsx_runtime2.jsxs)(MenuItem_default, { value: option.id, children: [
          (0, import_jsx_runtime2.jsx)(Checkbox_default, { checked: widget.values.indexOf(option.id) > -1 }),
          option.iconURL.length > 0 && (0, import_jsx_runtime2.jsx)(ListItemIcon_default, { className: classes.iconRoot, children: (0, import_jsx_runtime2.jsx)(IconOverlay, { iconURL: option.iconURL, alt: option.label }) }),
          (0, import_jsx_runtime2.jsx)(
            ListItemText_default,
            {
              primary: option.label,
              primaryTypographyProps: widget.style ? {
                className: classes.style
              } : {}
            }
          )
        ] }, option.id))
      }
    ),
    (0, import_jsx_runtime2.jsx)(FormHelperText_default, { children: (_h = widget.diagnostics[0]) == null ? void 0 : _h.message })
  ] });
};
var editRadioMutation = gql`
  mutation editRadio($input: EditRadioInput!) {
    editRadio(input: $input) {
      __typename
      ... on ErrorPayload {
        messages {
          body
          level
        }
      }
      ... on SuccessPayload {
        messages {
          body
          level
        }
      }
    }
  }
`;
var updateWidgetFocusMutation$4 = gql`
  mutation updateWidgetFocus($input: UpdateWidgetFocusInput!) {
    updateWidgetFocus(input: $input) {
      __typename
      ... on ErrorPayload {
        messages {
          body
          level
        }
      }
    }
  }
`;
var useRadioPropertySectionStyles = makeStyles_default((theme) => ({
  radioGroupRoot: {
    flexDirection: "row"
  },
  style: {
    color: ({ color }) => color ? getCSSColor(color, theme) : null,
    fontSize: ({ fontSize }) => fontSize ? fontSize : null,
    fontStyle: ({ italic }) => italic ? "italic" : null,
    fontWeight: ({ bold }) => bold ? "bold" : null,
    textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough)
  }
}));
var isErrorPayload$4 = (payload) => payload.__typename === "ErrorPayload";
var isSuccessPayload$4 = (payload) => payload.__typename === "SuccessPayload";
var RadioPropertySection = ({
  editingContextId,
  formId,
  widget,
  subscribers,
  readOnly
}) => {
  var _a, _b, _c, _d, _e, _f, _g;
  const props = {
    color: ((_a = widget.style) == null ? void 0 : _a.color) ?? null,
    fontSize: ((_b = widget.style) == null ? void 0 : _b.fontSize) ?? null,
    italic: ((_c = widget.style) == null ? void 0 : _c.italic) ?? null,
    bold: ((_d = widget.style) == null ? void 0 : _d.bold) ?? null,
    underline: ((_e = widget.style) == null ? void 0 : _e.underline) ?? null,
    strikeThrough: ((_f = widget.style) == null ? void 0 : _f.strikeThrough) ?? null
  };
  const classes = useRadioPropertySectionStyles(props);
  const [editRadio, { loading, error, data }] = useMutation(editRadioMutation);
  const onChange = (event) => {
    const newValue = event.target.value;
    const input = {
      id: crypto.randomUUID(),
      editingContextId,
      representationId: formId,
      radioId: widget.id,
      newValue
    };
    const variables = { input };
    editRadio({ variables });
  };
  const { addErrorMessage, addMessages } = useMultiToast();
  (0, import_react2.useEffect)(() => {
    if (!loading) {
      if (error) {
        addErrorMessage("An unexpected error has occurred, please refresh the page");
      }
      if (data) {
        const { editRadio: editRadio2 } = data;
        if (isErrorPayload$4(editRadio2) || isSuccessPayload$4(editRadio2)) {
          addMessages(editRadio2.messages);
        }
      }
    }
  }, [loading, error, data]);
  const [
    updateWidgetFocus,
    { loading: updateWidgetFocusLoading, data: updateWidgetFocusData, error: updateWidgetFocusError }
  ] = useMutation(updateWidgetFocusMutation$4);
  const sendUpdateWidgetFocus = (selected) => {
    const input = {
      id: crypto.randomUUID(),
      editingContextId,
      representationId: formId,
      widgetId: widget.id,
      selected
    };
    const variables = {
      input
    };
    updateWidgetFocus({ variables });
  };
  (0, import_react2.useEffect)(() => {
    if (!updateWidgetFocusLoading) {
      if (updateWidgetFocusError) {
        addErrorMessage("An unexpected error has occurred, please refresh the page");
      }
      if (updateWidgetFocusData) {
        const { updateWidgetFocus: updateWidgetFocus2 } = updateWidgetFocusData;
        if (isErrorPayload$4(updateWidgetFocus2)) {
          addMessages(updateWidgetFocus2.messages);
        }
      }
    }
  }, [updateWidgetFocusLoading, updateWidgetFocusData, updateWidgetFocusError]);
  const onFocus = () => sendUpdateWidgetFocus(true);
  const onBlur = () => sendUpdateWidgetFocus(false);
  const selectedOption = widget.options.find((option) => option.selected);
  return (0, import_jsx_runtime2.jsxs)(FormControl_default, { error: widget.diagnostics.length > 0, children: [
    (0, import_jsx_runtime2.jsx)(
      PropertySectionLabel,
      {
        editingContextId,
        formId,
        widget,
        subscribers
      }
    ),
    (0, import_jsx_runtime2.jsx)(
      RadioGroup_default,
      {
        classes: { root: classes.radioGroupRoot },
        "aria-label": widget.label,
        name: widget.label,
        value: selectedOption ? selectedOption.id : null,
        onChange,
        children: widget.options.map((option) => (0, import_jsx_runtime2.jsx)(
          FormControlLabel_default,
          {
            value: option.id,
            control: (0, import_jsx_runtime2.jsx)(Radio_default, { color: "primary", onFocus, onBlur, "data-testid": option.label }),
            label: (0, import_jsx_runtime2.jsx)(
              Typography_default,
              {
                classes: widget.style ? {
                  root: classes.style
                } : {},
                children: option.label
              }
            ),
            disabled: readOnly || widget.readOnly
          },
          option.id
        ))
      }
    ),
    (0, import_jsx_runtime2.jsx)(FormHelperText_default, { children: (_g = widget.diagnostics[0]) == null ? void 0 : _g.message })
  ] });
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var LexicalCode_dev = {};
var prism = { exports: {} };
var hasRequiredPrism;
function requirePrism() {
  if (hasRequiredPrism)
    return prism.exports;
  hasRequiredPrism = 1;
  (function(module) {
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    var Prism2 = function(_self2) {
      var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _ = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: _self2.Prism && _self2.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function encode(tokens) {
            if (tokens instanceof Token) {
              return new Token(tokens.type, encode(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(o) {
            return Object.prototype.toString.call(o).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function deepClone(o, visited) {
            visited = visited || {};
            var clone;
            var id;
            switch (_.util.type(o)) {
              case "Object":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone = /** @type {Record<string, any>} */
                {};
                visited[id] = clone;
                for (var key in o) {
                  if (o.hasOwnProperty(key)) {
                    clone[key] = deepClone(o[key], visited);
                  }
                }
                return (
                  /** @type {any} */
                  clone
                );
              case "Array":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone = [];
                visited[id] = clone;
                o.forEach(function(v2, i) {
                  clone[i] = deepClone(v2, visited);
                });
                return (
                  /** @type {any} */
                  clone
                );
              default:
                return o;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(element) {
            while (element) {
              var m = lang.exec(element.className);
              if (m) {
                return m[1].toLowerCase();
              }
              element = element.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(element, language) {
            element.className = element.className.replace(RegExp(lang, "gi"), "");
            element.classList.add("language-" + language);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if ("currentScript" in document && 1 < 2) {
              return (
                /** @type {any} */
                document.currentScript
              );
            }
            try {
              throw new Error();
            } catch (err) {
              var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
              if (src) {
                var scripts = document.getElementsByTagName("script");
                for (var i in scripts) {
                  if (scripts[i].src == src) {
                    return scripts[i];
                  }
                }
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(element, className, defaultActivation) {
            var no = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(id, redef) {
            var lang2 = _.util.clone(_.languages[id]);
            for (var key in redef) {
              lang2[key] = redef[key];
            }
            return lang2;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(inside, before, insert, root) {
            root = root || /** @type {any} */
            _.languages;
            var grammar = root[inside];
            var ret = {};
            for (var token in grammar) {
              if (grammar.hasOwnProperty(token)) {
                if (token == before) {
                  for (var newToken in insert) {
                    if (insert.hasOwnProperty(newToken)) {
                      ret[newToken] = insert[newToken];
                    }
                  }
                }
                if (!insert.hasOwnProperty(token)) {
                  ret[token] = grammar[token];
                }
              }
            }
            var old = root[inside];
            root[inside] = ret;
            _.languages.DFS(_.languages, function(key, value22) {
              if (value22 === old && key != inside) {
                this[key] = ret;
              }
            });
            return ret;
          },
          // Traverse a language definition with Depth First Search
          DFS: function DFS(o, callback, type2, visited) {
            visited = visited || {};
            var objId = _.util.objId;
            for (var i in o) {
              if (o.hasOwnProperty(i)) {
                callback.call(o, i, o[i], type2 || i);
                var property = o[i];
                var propertyType = _.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i, visited);
                }
              }
            }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prism’s API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(async, callback) {
          _.highlightAllUnder(document, async, callback);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(container, async, callback) {
          var env = {
            callback,
            container,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _.hooks.run("before-highlightall", env);
          env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
          _.hooks.run("before-all-elements-highlight", env);
          for (var i = 0, element; element = env.elements[i++]; ) {
            _.highlightElement(element, async === true, env.callback);
          }
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(element, async, callback) {
          var language = _.util.getLanguage(element);
          var grammar = _.languages[language];
          _.util.setLanguage(element, language);
          var parent = element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre") {
            _.util.setLanguage(parent, language);
          }
          var code = element.textContent;
          var env = {
            element,
            language,
            grammar,
            code
          };
          function insertHighlightedCode(highlightedCode) {
            env.highlightedCode = highlightedCode;
            _.hooks.run("before-insert", env);
            env.element.innerHTML = env.highlightedCode;
            _.hooks.run("after-highlight", env);
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
          }
          _.hooks.run("before-sanity-check", env);
          parent = env.element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
            parent.setAttribute("tabindex", "0");
          }
          if (!env.code) {
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
            return;
          }
          _.hooks.run("before-highlight", env);
          if (!env.grammar) {
            insertHighlightedCode(_.util.encode(env.code));
            return;
          }
          if (async && _self2.Worker) {
            var worker = new Worker(_.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env.language,
              code: env.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
          }
        },
        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(text, grammar, language) {
          var env = {
            code: text,
            grammar,
            language
          };
          _.hooks.run("before-tokenize", env);
          if (!env.grammar) {
            throw new Error('The language "' + env.language + '" has no grammar.');
          }
          env.tokens = _.tokenize(env.code, env.grammar);
          _.hooks.run("after-tokenize", env);
          return Token.stringify(_.util.encode(env.tokens), env.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest) {
              grammar[token] = rest[token];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text);
          matchGrammar(text, tokenList, grammar, tokenList.head, 0);
          return toArray(tokenList);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(name2, callback) {
            var hooks = _.hooks.all;
            hooks[name2] = hooks[name2] || [];
            hooks[name2].push(callback);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(name2, env) {
            var callbacks = _.hooks.all[name2];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i = 0, callback; callback = callbacks[i++]; ) {
              callback(env);
            }
          }
        },
        Token
      };
      _self2.Prism = _;
      function Token(type2, content, alias, matchedStr) {
        this.type = type2;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify(o, language) {
        if (typeof o == "string") {
          return o;
        }
        if (Array.isArray(o)) {
          var s2 = "";
          o.forEach(function(e) {
            s2 += stringify(e, language);
          });
          return s2;
        }
        var env = {
          type: o.type,
          content: stringify(o.content, language),
          tag: "span",
          classes: ["token", o.type],
          attributes: {},
          language
        };
        var aliases = o.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env.classes, aliases);
          } else {
            env.classes.push(aliases);
          }
        }
        _.hooks.run("wrap", env);
        var attributes = "";
        for (var name2 in env.attributes) {
          attributes += " " + name2 + '="' + (env.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text);
        if (match && lookbehind && match[1]) {
          var lookbehindLength = match[1].length;
          match.index += lookbehindLength;
          match[0] = match[0].slice(lookbehindLength);
        }
        return match;
      }
      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          var patterns = grammar[token];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j = 0; j < patterns.length; ++j) {
            if (rematch && rematch.cause == token + "," + j) {
              return;
            }
            var patternObj = patterns[j];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match;
              if (greedy) {
                match = matchPattern(pattern, pos, text, lookbehind);
                if (!match || match.index >= text.length) {
                  break;
                }
                var from = match.index;
                var to = match.index + match[0].length;
                var p = pos;
                p += currentNode.value.length;
                while (from >= p) {
                  currentNode = currentNode.next;
                  p += currentNode.value.length;
                }
                p -= currentNode.value.length;
                pos = p;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k2 = currentNode; k2 !== tokenList.tail && (p < to || typeof k2.value === "string"); k2 = k2.next) {
                  removeCount++;
                  p += k2.value.length;
                }
                removeCount--;
                str = text.slice(pos, p);
                match.index -= pos;
              } else {
                match = matchPattern(pattern, 0, str, lookbehind);
                if (!match) {
                  continue;
                }
              }
              var from = match.index;
              var matchStr = match[0];
              var before = str.slice(0, from);
              var after = str.slice(from + matchStr.length);
              var reach = pos + str.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token + "," + j,
                  reach
                };
                matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value22) {
        var next = node.next;
        var newNode = { value: value22, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node, count3) {
        var next = node.next;
        for (var i = 0; i < count3 && next !== list.tail; i++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i;
      }
      function toArray(list) {
        var array3 = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array3.push(node.value);
          node = node.next;
        }
        return array3;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _;
        }
        if (!_.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang2 = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self2.postMessage(_.highlight(code, _.languages[lang2], lang2));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _;
      }
      var script = _.util.currentScript();
      if (script) {
        _.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_.manual) {
          _.highlightAll();
        }
      }
      if (!_.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _;
    }(_self);
    if (module.exports) {
      module.exports = Prism2;
    }
    if (typeof commonjsGlobal !== "undefined") {
      commonjsGlobal.Prism = Prism2;
    }
    Prism2.languages.markup = {
      "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
      },
      "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
      },
      "doctype": {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
            // see below
          },
          "string": {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          "punctuation": /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          "name": /[^\s<>'"]+/
        }
      },
      "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
      },
      "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          "tag": {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              "punctuation": /^<\/?/,
              "namespace": /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: true
                }
              ]
            }
          },
          "punctuation": /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              "namespace": /^[^\s>\/:]+:/
            }
          }
        }
      },
      "entity": [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    };
    Prism2.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism2.languages.markup["entity"];
    Prism2.languages.markup["doctype"].inside["internal-subset"].inside = Prism2.languages.markup;
    Prism2.hooks.add("wrap", function(env) {
      if (env.type === "entity") {
        env.attributes["title"] = env.content.replace(/&amp;/, "&");
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function addInlined(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: Prism2.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: includedCdataInside
          }
        };
        inside["language-" + lang] = {
          pattern: /[\s\S]+/,
          inside: Prism2.languages[lang]
        };
        var def = {};
        def[tagName] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return tagName;
          }), "i"),
          lookbehind: true,
          greedy: true,
          inside
        };
        Prism2.languages.insertBefore("markup", "cdata", def);
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(attrName, lang) {
        Prism2.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                "value": {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [lang, "language-" + lang],
                  inside: Prism2.languages[lang]
                },
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    });
    Prism2.languages.html = Prism2.languages.markup;
    Prism2.languages.mathml = Prism2.languages.markup;
    Prism2.languages.svg = Prism2.languages.markup;
    Prism2.languages.xml = Prism2.languages.extend("markup", {});
    Prism2.languages.ssml = Prism2.languages.xml;
    Prism2.languages.atom = Prism2.languages.xml;
    Prism2.languages.rss = Prism2.languages.xml;
    (function(Prism3) {
      var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      Prism3.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            "rule": /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            "keyword": {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
            // See rest below
          }
        },
        "url": {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: true,
          inside: {
            "function": /^url/i,
            "punctuation": /^\(|\)$/,
            "string": {
              pattern: RegExp("^" + string.source + "$"),
              alias: "url"
            }
          }
        },
        "selector": {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
          lookbehind: true
        },
        "string": {
          pattern: string,
          greedy: true
        },
        "property": {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        "punctuation": /[(){};:,]/
      };
      Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
      var markup = Prism3.languages.markup;
      if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
      }
    })(Prism2);
    Prism2.languages.clike = {
      "comment": [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      "boolean": /\b(?:false|true)\b/,
      "function": /\b\w+(?=\()/,
      "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      "punctuation": /[{}[\];(),.:]/
    };
    Prism2.languages.javascript = Prism2.languages.extend("clike", {
      "class-name": [
        Prism2.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: true
        }
      ],
      "keyword": [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      "number": {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: true
      },
      "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
    Prism2.languages.insertBefore("javascript", "keyword", {
      "regex": {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism2.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      "parameter": [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        }
      ],
      "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism2.languages.insertBefore("javascript", "string", {
      "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          "interpolation": {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Prism2.languages.javascript
            }
          },
          "string": /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
      }
    });
    Prism2.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
      }
    });
    if (Prism2.languages.markup) {
      Prism2.languages.markup.tag.addInlined("script", "javascript");
      Prism2.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
        "javascript"
      );
    }
    Prism2.languages.js = Prism2.languages.javascript;
    (function() {
      if (typeof Prism2 === "undefined" || typeof document === "undefined") {
        return;
      }
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
      }
      var LOADING_MESSAGE = "Loading…";
      var FAILURE_MESSAGE = function(status, message) {
        return "✖ Error " + status + " while fetching file: " + message;
      };
      var FAILURE_EMPTY_MESSAGE = "✖ Error: File does not exist or is empty";
      var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
      };
      var STATUS_ATTR = "data-src-status";
      var STATUS_LOADING = "loading";
      var STATUS_LOADED = "loaded";
      var STATUS_FAILED = "failed";
      var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
      function loadFile(src, success, error) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", src, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            if (xhr.status < 400 && xhr.responseText) {
              success(xhr.responseText);
            } else {
              if (xhr.status >= 400) {
                error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
              } else {
                error(FAILURE_EMPTY_MESSAGE);
              }
            }
          }
        };
        xhr.send(null);
      }
      function parseRange(range2) {
        var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range2 || "");
        if (m) {
          var start = Number(m[1]);
          var comma = m[2];
          var end = m[3];
          if (!comma) {
            return [start, start];
          }
          if (!end) {
            return [start, void 0];
          }
          return [start, Number(end)];
        }
        return void 0;
      }
      Prism2.hooks.add("before-highlightall", function(env) {
        env.selector += ", " + SELECTOR;
      });
      Prism2.hooks.add("before-sanity-check", function(env) {
        var pre = (
          /** @type {HTMLPreElement} */
          env.element
        );
        if (pre.matches(SELECTOR)) {
          env.code = "";
          pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
          var code = pre.appendChild(document.createElement("CODE"));
          code.textContent = LOADING_MESSAGE;
          var src = pre.getAttribute("data-src");
          var language = env.language;
          if (language === "none") {
            var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
            language = EXTENSIONS[extension] || extension;
          }
          Prism2.util.setLanguage(code, language);
          Prism2.util.setLanguage(pre, language);
          var autoloader = Prism2.plugins.autoloader;
          if (autoloader) {
            autoloader.loadLanguages(language);
          }
          loadFile(
            src,
            function(text) {
              pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
              var range2 = parseRange(pre.getAttribute("data-range"));
              if (range2) {
                var lines = text.split(/\r\n?|\n/g);
                var start = range2[0];
                var end = range2[1] == null ? lines.length : range2[1];
                if (start < 0) {
                  start += lines.length;
                }
                start = Math.max(0, Math.min(start - 1, lines.length));
                if (end < 0) {
                  end += lines.length;
                }
                end = Math.max(0, Math.min(end, lines.length));
                text = lines.slice(start, end).join("\n");
                if (!pre.hasAttribute("data-start")) {
                  pre.setAttribute("data-start", String(start + 1));
                }
              }
              code.textContent = text;
              Prism2.highlightElement(code);
            },
            function(error) {
              pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
              code.textContent = error;
            }
          );
        }
      });
      Prism2.plugins.fileHighlight = {
        /**
         * Executes the File Highlight plugin for all matching `pre` elements under the given container.
         *
         * Note: Elements which are already loaded or currently loading will not be touched by this method.
         *
         * @param {ParentNode} [container=document]
         */
        highlight: function highlight(container) {
          var elements = (container || document).querySelectorAll(SELECTOR);
          for (var i = 0, element; element = elements[i++]; ) {
            Prism2.highlightElement(element);
          }
        }
      };
      var logged = false;
      Prism2.fileHighlight = function() {
        if (!logged) {
          console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
          logged = true;
        }
        Prism2.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
  })(prism);
  return prism.exports;
}
var prismClike = {};
var hasRequiredPrismClike;
function requirePrismClike() {
  if (hasRequiredPrismClike)
    return prismClike;
  hasRequiredPrismClike = 1;
  Prism.languages.clike = {
    "comment": [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: true,
        greedy: true
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: true,
        greedy: true
      }
    ],
    "string": {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: true
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: true,
      inside: {
        "punctuation": /[.\\]/
      }
    },
    "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    "boolean": /\b(?:false|true)\b/,
    "function": /\b\w+(?=\()/,
    "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    "punctuation": /[{}[\];(),.:]/
  };
  return prismClike;
}
var prismJavascript = {};
var hasRequiredPrismJavascript;
function requirePrismJavascript() {
  if (hasRequiredPrismJavascript)
    return prismJavascript;
  hasRequiredPrismJavascript = 1;
  Prism.languages.javascript = Prism.languages.extend("clike", {
    "class-name": [
      Prism.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: true
      }
    ],
    "keyword": [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: true
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: true
      }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    "number": {
      pattern: RegExp(
        /(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
      ),
      lookbehind: true
    },
    "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  });
  Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
  Prism.languages.insertBefore("javascript", "keyword", {
    "regex": {
      pattern: RegExp(
        // lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: true,
          alias: "language-regex",
          inside: Prism.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    "parameter": [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: true,
        inside: Prism.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: true,
        inside: Prism.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: true,
        inside: Prism.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: true,
        inside: Prism.languages.javascript
      }
    ],
    "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  });
  Prism.languages.insertBefore("javascript", "string", {
    "hashbang": {
      pattern: /^#!.*/,
      greedy: true,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: true,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        "interpolation": {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: true,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: Prism.languages.javascript
          }
        },
        "string": /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: true,
      greedy: true,
      alias: "property"
    }
  });
  Prism.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: true,
      alias: "property"
    }
  });
  if (Prism.languages.markup) {
    Prism.languages.markup.tag.addInlined("script", "javascript");
    Prism.languages.markup.tag.addAttribute(
      /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
      "javascript"
    );
  }
  Prism.languages.js = Prism.languages.javascript;
  return prismJavascript;
}
var prismMarkup = {};
var hasRequiredPrismMarkup;
function requirePrismMarkup() {
  if (hasRequiredPrismMarkup)
    return prismMarkup;
  hasRequiredPrismMarkup = 1;
  Prism.languages.markup = {
    "comment": {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: true
    },
    "prolog": {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: true
    },
    "doctype": {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: true,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: true,
          greedy: true,
          inside: null
          // see below
        },
        "string": {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: true
        },
        "punctuation": /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        "name": /[^\s<>'"]+/
      }
    },
    "cdata": {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: true
    },
    "tag": {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: true,
      inside: {
        "tag": {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            "punctuation": /^<\/?/,
            "namespace": /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            "punctuation": [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: true
              }
            ]
          }
        },
        "punctuation": /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            "namespace": /^[^\s>\/:]+:/
          }
        }
      }
    },
    "entity": [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  };
  Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
  Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
  Prism.hooks.add("wrap", function(env) {
    if (env.type === "entity") {
      env.attributes["title"] = env.content.replace(/&amp;/, "&");
    }
  });
  Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function addInlined(tagName, lang) {
      var includedCdataInside = {};
      includedCdataInside["language-" + lang] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: true,
        inside: Prism.languages[lang]
      };
      includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
      var inside = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: includedCdataInside
        }
      };
      inside["language-" + lang] = {
        pattern: /[\s\S]+/,
        inside: Prism.languages[lang]
      };
      var def = {};
      def[tagName] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return tagName;
        }), "i"),
        lookbehind: true,
        greedy: true,
        inside
      };
      Prism.languages.insertBefore("markup", "cdata", def);
    }
  });
  Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(attrName, lang) {
      Prism.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: true,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              "value": {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: true,
                alias: [lang, "language-" + lang],
                inside: Prism.languages[lang]
              },
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  });
  Prism.languages.html = Prism.languages.markup;
  Prism.languages.mathml = Prism.languages.markup;
  Prism.languages.svg = Prism.languages.markup;
  Prism.languages.xml = Prism.languages.extend("markup", {});
  Prism.languages.ssml = Prism.languages.xml;
  Prism.languages.atom = Prism.languages.xml;
  Prism.languages.rss = Prism.languages.xml;
  return prismMarkup;
}
var prismMarkdown = {};
var hasRequiredPrismMarkdown;
function requirePrismMarkdown() {
  if (hasRequiredPrismMarkdown)
    return prismMarkdown;
  hasRequiredPrismMarkdown = 1;
  (function(Prism2) {
    var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
    function createInline(pattern) {
      pattern = pattern.replace(/<inner>/g, function() {
        return inner;
      });
      return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
    }
    var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
    var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
      return tableCell;
    });
    var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
    Prism2.languages.markdown = Prism2.languages.extend("markup", {});
    Prism2.languages.insertBefore("markdown", "prolog", {
      "front-matter-block": {
        pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
        lookbehind: true,
        greedy: true,
        inside: {
          "punctuation": /^---|---$/,
          "front-matter": {
            pattern: /\S+(?:\s+\S+)*/,
            alias: ["yaml", "language-yaml"],
            inside: Prism2.languages.yaml
          }
        }
      },
      "blockquote": {
        // > ...
        pattern: /^>(?:[\t ]*>)*/m,
        alias: "punctuation"
      },
      "table": {
        pattern: RegExp("^" + tableRow + tableLine + "(?:" + tableRow + ")*", "m"),
        inside: {
          "table-data-rows": {
            pattern: RegExp("^(" + tableRow + tableLine + ")(?:" + tableRow + ")*$"),
            lookbehind: true,
            inside: {
              "table-data": {
                pattern: RegExp(tableCell),
                inside: Prism2.languages.markdown
              },
              "punctuation": /\|/
            }
          },
          "table-line": {
            pattern: RegExp("^(" + tableRow + ")" + tableLine + "$"),
            lookbehind: true,
            inside: {
              "punctuation": /\||:?-{3,}:?/
            }
          },
          "table-header-row": {
            pattern: RegExp("^" + tableRow + "$"),
            inside: {
              "table-header": {
                pattern: RegExp(tableCell),
                alias: "important",
                inside: Prism2.languages.markdown
              },
              "punctuation": /\|/
            }
          }
        }
      },
      "code": [
        {
          // Prefixed by 4 spaces or 1 tab and preceded by an empty line
          pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
          lookbehind: true,
          alias: "keyword"
        },
        {
          // ```optional language
          // code block
          // ```
          pattern: /^```[\s\S]*?^```$/m,
          greedy: true,
          inside: {
            "code-block": {
              pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
              lookbehind: true
            },
            "code-language": {
              pattern: /^(```).+/,
              lookbehind: true
            },
            "punctuation": /```/
          }
        }
      ],
      "title": [
        {
          // title 1
          // =======
          // title 2
          // -------
          pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
          alias: "important",
          inside: {
            punctuation: /==+$|--+$/
          }
        },
        {
          // # title 1
          // ###### title 6
          pattern: /(^\s*)#.+/m,
          lookbehind: true,
          alias: "important",
          inside: {
            punctuation: /^#+|#+$/
          }
        }
      ],
      "hr": {
        // ***
        // ---
        // * * *
        // -----------
        pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
        lookbehind: true,
        alias: "punctuation"
      },
      "list": {
        // * item
        // + item
        // - item
        // 1. item
        pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
        lookbehind: true,
        alias: "punctuation"
      },
      "url-reference": {
        // [id]: http://example.com "Optional title"
        // [id]: http://example.com 'Optional title'
        // [id]: http://example.com (Optional title)
        // [id]: <http://example.com> "Optional title"
        pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
        inside: {
          "variable": {
            pattern: /^(!?\[)[^\]]+/,
            lookbehind: true
          },
          "string": /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
          "punctuation": /^[\[\]!:]|[<>]/
        },
        alias: "url"
      },
      "bold": {
        // **strong**
        // __strong__
        // allow one nested instance of italic text using the same delimiter
        pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
        lookbehind: true,
        greedy: true,
        inside: {
          "content": {
            pattern: /(^..)[\s\S]+(?=..$)/,
            lookbehind: true,
            inside: {}
            // see below
          },
          "punctuation": /\*\*|__/
        }
      },
      "italic": {
        // *em*
        // _em_
        // allow one nested instance of bold text using the same delimiter
        pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
        lookbehind: true,
        greedy: true,
        inside: {
          "content": {
            pattern: /(^.)[\s\S]+(?=.$)/,
            lookbehind: true,
            inside: {}
            // see below
          },
          "punctuation": /[*_]/
        }
      },
      "strike": {
        // ~~strike through~~
        // ~strike~
        // eslint-disable-next-line regexp/strict
        pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
        lookbehind: true,
        greedy: true,
        inside: {
          "content": {
            pattern: /(^~~?)[\s\S]+(?=\1$)/,
            lookbehind: true,
            inside: {}
            // see below
          },
          "punctuation": /~~?/
        }
      },
      "code-snippet": {
        // `code`
        // ``code``
        pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
        lookbehind: true,
        greedy: true,
        alias: ["code", "keyword"]
      },
      "url": {
        // [example](http://example.com "Optional title")
        // [example][id]
        // [example] [id]
        pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
        lookbehind: true,
        greedy: true,
        inside: {
          "operator": /^!/,
          "content": {
            pattern: /(^\[)[^\]]+(?=\])/,
            lookbehind: true,
            inside: {}
            // see below
          },
          "variable": {
            pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
            lookbehind: true
          },
          "url": {
            pattern: /(^\]\()[^\s)]+/,
            lookbehind: true
          },
          "string": {
            pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
            lookbehind: true
          }
        }
      }
    });
    ["url", "bold", "italic", "strike"].forEach(function(token) {
      ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside) {
        if (token !== inside) {
          Prism2.languages.markdown[token].inside.content.inside[inside] = Prism2.languages.markdown[inside];
        }
      });
    });
    Prism2.hooks.add("after-tokenize", function(env) {
      if (env.language !== "markdown" && env.language !== "md") {
        return;
      }
      function walkTokens(tokens) {
        if (!tokens || typeof tokens === "string") {
          return;
        }
        for (var i = 0, l = tokens.length; i < l; i++) {
          var token = tokens[i];
          if (token.type !== "code") {
            walkTokens(token.content);
            continue;
          }
          var codeLang = token.content[1];
          var codeBlock = token.content[3];
          if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
            var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
            lang = (/[a-z][\w-]*/i.exec(lang) || [""])[0].toLowerCase();
            var alias = "language-" + lang;
            if (!codeBlock.alias) {
              codeBlock.alias = [alias];
            } else if (typeof codeBlock.alias === "string") {
              codeBlock.alias = [codeBlock.alias, alias];
            } else {
              codeBlock.alias.push(alias);
            }
          }
        }
      }
      walkTokens(env.tokens);
    });
    Prism2.hooks.add("wrap", function(env) {
      if (env.type !== "code-block") {
        return;
      }
      var codeLang = "";
      for (var i = 0, l = env.classes.length; i < l; i++) {
        var cls = env.classes[i];
        var match = /language-(.+)/.exec(cls);
        if (match) {
          codeLang = match[1];
          break;
        }
      }
      var grammar = Prism2.languages[codeLang];
      if (!grammar) {
        if (codeLang && codeLang !== "none" && Prism2.plugins.autoloader) {
          var id = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
          env.attributes["id"] = id;
          Prism2.plugins.autoloader.loadLanguages(codeLang, function() {
            var ele = document.getElementById(id);
            if (ele) {
              ele.innerHTML = Prism2.highlight(ele.textContent, Prism2.languages[codeLang], codeLang);
            }
          });
        }
      } else {
        env.content = Prism2.highlight(textContent(env.content), grammar, codeLang);
      }
    });
    var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, "gi");
    var KNOWN_ENTITY_NAMES = {
      "amp": "&",
      "lt": "<",
      "gt": ">",
      "quot": '"'
    };
    var fromCodePoint = String.fromCodePoint || String.fromCharCode;
    function textContent(html2) {
      var text = html2.replace(tagPattern, "");
      text = text.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m, code) {
        code = code.toLowerCase();
        if (code[0] === "#") {
          var value22;
          if (code[1] === "x") {
            value22 = parseInt(code.slice(2), 16);
          } else {
            value22 = Number(code.slice(1));
          }
          return fromCodePoint(value22);
        } else {
          var known = KNOWN_ENTITY_NAMES[code];
          if (known) {
            return known;
          }
          return m;
        }
      });
      return text;
    }
    Prism2.languages.md = Prism2.languages.markdown;
  })(Prism);
  return prismMarkdown;
}
var prismC = {};
var hasRequiredPrismC;
function requirePrismC() {
  if (hasRequiredPrismC)
    return prismC;
  hasRequiredPrismC = 1;
  Prism.languages.c = Prism.languages.extend("clike", {
    "comment": {
      pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
      greedy: true
    },
    "string": {
      // https://en.cppreference.com/w/c/language/string_literal
      pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: true
    },
    "class-name": {
      pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
      lookbehind: true
    },
    "keyword": /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
    "function": /\b[a-z_]\w*(?=\s*\()/i,
    "number": /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
    "operator": />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
  });
  Prism.languages.insertBefore("c", "string", {
    "char": {
      // https://en.cppreference.com/w/c/language/character_constant
      pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
      greedy: true
    }
  });
  Prism.languages.insertBefore("c", "string", {
    "macro": {
      // allow for multiline macro definitions
      // spaces after the # character compile fine with gcc
      pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
      lookbehind: true,
      greedy: true,
      alias: "property",
      inside: {
        "string": [
          {
            // highlight the path of the include statement as a string
            pattern: /^(#\s*include\s*)<[^>]+>/,
            lookbehind: true
          },
          Prism.languages.c["string"]
        ],
        "char": Prism.languages.c["char"],
        "comment": Prism.languages.c["comment"],
        "macro-name": [
          {
            pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
            lookbehind: true
          },
          {
            pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
            lookbehind: true,
            alias: "function"
          }
        ],
        // highlight macro directives as keywords
        "directive": {
          pattern: /^(#\s*)[a-z]+/,
          lookbehind: true,
          alias: "keyword"
        },
        "directive-hash": /^#/,
        "punctuation": /##|\\(?=[\r\n])/,
        "expression": {
          pattern: /\S[\s\S]*/,
          inside: Prism.languages.c
        }
      }
    }
  });
  Prism.languages.insertBefore("c", "function", {
    // highlight predefined macros as constants
    "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
  });
  delete Prism.languages.c["boolean"];
  return prismC;
}
var prismCss = {};
var hasRequiredPrismCss;
function requirePrismCss() {
  if (hasRequiredPrismCss)
    return prismCss;
  hasRequiredPrismCss = 1;
  (function(Prism2) {
    var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    Prism2.languages.css = {
      "comment": /\/\*[\s\S]*?\*\//,
      "atrule": {
        pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
        inside: {
          "rule": /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: true,
            alias: "selector"
          },
          "keyword": {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: true
          }
          // See rest below
        }
      },
      "url": {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
        greedy: true,
        inside: {
          "function": /^url/i,
          "punctuation": /^\(|\)$/,
          "string": {
            pattern: RegExp("^" + string.source + "$"),
            alias: "url"
          }
        }
      },
      "selector": {
        pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
        lookbehind: true
      },
      "string": {
        pattern: string,
        greedy: true
      },
      "property": {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: true
      },
      "important": /!important\b/i,
      "function": {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: true
      },
      "punctuation": /[(){};:,]/
    };
    Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
    var markup = Prism2.languages.markup;
    if (markup) {
      markup.tag.addInlined("style", "css");
      markup.tag.addAttribute("style", "css");
    }
  })(Prism);
  return prismCss;
}
var prismObjectivec = {};
var hasRequiredPrismObjectivec;
function requirePrismObjectivec() {
  if (hasRequiredPrismObjectivec)
    return prismObjectivec;
  hasRequiredPrismObjectivec = 1;
  Prism.languages.objectivec = Prism.languages.extend("c", {
    "string": {
      pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: true
    },
    "keyword": /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
    "operator": /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
  });
  delete Prism.languages.objectivec["class-name"];
  Prism.languages.objc = Prism.languages.objectivec;
  return prismObjectivec;
}
var prismSql = {};
var hasRequiredPrismSql;
function requirePrismSql() {
  if (hasRequiredPrismSql)
    return prismSql;
  hasRequiredPrismSql = 1;
  Prism.languages.sql = {
    "comment": {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
      lookbehind: true
    },
    "variable": [
      {
        pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
        greedy: true
      },
      /@[\w.$]+/
    ],
    "string": {
      pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
      greedy: true,
      lookbehind: true
    },
    "identifier": {
      pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
      greedy: true,
      lookbehind: true,
      inside: {
        "punctuation": /^`|`$/
      }
    },
    "function": /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
    // Should we highlight user defined functions too?
    "keyword": /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
    "boolean": /\b(?:FALSE|NULL|TRUE)\b/i,
    "number": /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
    "operator": /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
    "punctuation": /[;[\]()`,.]/
  };
  return prismSql;
}
var prismPython = {};
var hasRequiredPrismPython;
function requirePrismPython() {
  if (hasRequiredPrismPython)
    return prismPython;
  hasRequiredPrismPython = 1;
  Prism.languages.python = {
    "comment": {
      pattern: /(^|[^\\])#.*/,
      lookbehind: true,
      greedy: true
    },
    "string-interpolation": {
      pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
      greedy: true,
      inside: {
        "interpolation": {
          // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
          pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
          lookbehind: true,
          inside: {
            "format-spec": {
              pattern: /(:)[^:(){}]+(?=\}$)/,
              lookbehind: true
            },
            "conversion-option": {
              pattern: /![sra](?=[:}]$)/,
              alias: "punctuation"
            },
            rest: null
          }
        },
        "string": /[\s\S]+/
      }
    },
    "triple-quoted-string": {
      pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
      greedy: true,
      alias: "string"
    },
    "string": {
      pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
      greedy: true
    },
    "function": {
      pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
      lookbehind: true
    },
    "class-name": {
      pattern: /(\bclass\s+)\w+/i,
      lookbehind: true
    },
    "decorator": {
      pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
      lookbehind: true,
      alias: ["annotation", "punctuation"],
      inside: {
        "punctuation": /\./
      }
    },
    "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
    "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
    "boolean": /\b(?:False|None|True)\b/,
    "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
    "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    "punctuation": /[{}[\];(),.:]/
  };
  Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;
  Prism.languages.py = Prism.languages.python;
  return prismPython;
}
var prismRust = {};
var hasRequiredPrismRust;
function requirePrismRust() {
  if (hasRequiredPrismRust)
    return prismRust;
  hasRequiredPrismRust = 1;
  (function(Prism2) {
    var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
    for (var i = 0; i < 2; i++) {
      multilineComment = multilineComment.replace(/<self>/g, function() {
        return multilineComment;
      });
    }
    multilineComment = multilineComment.replace(/<self>/g, function() {
      return /[^\s\S]/.source;
    });
    Prism2.languages.rust = {
      "comment": [
        {
          pattern: RegExp(/(^|[^\\])/.source + multilineComment),
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
        greedy: true
      },
      "char": {
        pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
        greedy: true
      },
      "attribute": {
        pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
        greedy: true,
        alias: "attr-name",
        inside: {
          "string": null
          // see below
        }
      },
      // Closure params should not be confused with bitwise OR |
      "closure-params": {
        pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
        lookbehind: true,
        greedy: true,
        inside: {
          "closure-punctuation": {
            pattern: /^\||\|$/,
            alias: "punctuation"
          },
          rest: null
          // see below
        }
      },
      "lifetime-annotation": {
        pattern: /'\w+/,
        alias: "symbol"
      },
      "fragment-specifier": {
        pattern: /(\$\w+:)[a-z]+/,
        lookbehind: true,
        alias: "punctuation"
      },
      "variable": /\$\w+/,
      "function-definition": {
        pattern: /(\bfn\s+)\w+/,
        lookbehind: true,
        alias: "function"
      },
      "type-definition": {
        pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
        lookbehind: true,
        alias: "class-name"
      },
      "module-declaration": [
        {
          pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
          lookbehind: true,
          alias: "namespace"
        },
        {
          pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
          lookbehind: true,
          alias: "namespace",
          inside: {
            "punctuation": /::/
          }
        }
      ],
      "keyword": [
        // https://github.com/rust-lang/reference/blob/master/src/keywords.md
        /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
        // primitives and str
        // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
        /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
      ],
      // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
      // and Rust's naming conventions recommend snake_case anyway.
      // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
      "function": /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
      "macro": {
        pattern: /\b\w+!/,
        alias: "property"
      },
      "constant": /\b[A-Z_][A-Z_\d]+\b/,
      "class-name": /\b[A-Z]\w*\b/,
      "namespace": {
        pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
        inside: {
          "punctuation": /::/
        }
      },
      // Hex, oct, bin, dec numbers with visual separators and type suffix
      "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
      "boolean": /\b(?:false|true)\b/,
      "punctuation": /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
      "operator": /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
    };
    Prism2.languages.rust["closure-params"].inside.rest = Prism2.languages.rust;
    Prism2.languages.rust["attribute"].inside["string"] = Prism2.languages.rust["string"];
  })(Prism);
  return prismRust;
}
var prismSwift = {};
var hasRequiredPrismSwift;
function requirePrismSwift() {
  if (hasRequiredPrismSwift)
    return prismSwift;
  hasRequiredPrismSwift = 1;
  Prism.languages.swift = {
    "comment": {
      // Nested comments are supported up to 2 levels
      pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
      lookbehind: true,
      greedy: true
    },
    "string-literal": [
      // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
      {
        pattern: RegExp(
          /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "interpolation": {
            pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: true,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\\($/,
            alias: "punctuation"
          },
          "punctuation": /\\(?=[\r\n])/,
          "string": /[\s\S]+/
        }
      },
      {
        pattern: RegExp(
          /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "interpolation": {
            pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: true,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\#+\($/,
            alias: "punctuation"
          },
          "string": /[\s\S]+/
        }
      }
    ],
    "directive": {
      // directives with conditions
      pattern: RegExp(
        /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
      ),
      alias: "property",
      inside: {
        "directive-name": /^#\w+/,
        "boolean": /\b(?:false|true)\b/,
        "number": /\b\d+(?:\.\d+)*\b/,
        "operator": /!|&&|\|\||[<>]=?/,
        "punctuation": /[(),]/
      }
    },
    "literal": {
      pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
      alias: "constant"
    },
    "other-directive": {
      pattern: /#\w+\b/,
      alias: "property"
    },
    "attribute": {
      pattern: /@\w+/,
      alias: "atrule"
    },
    "function-definition": {
      pattern: /(\bfunc\s+)\w+/,
      lookbehind: true,
      alias: "function"
    },
    "label": {
      // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
      pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
      lookbehind: true,
      alias: "important"
    },
    "keyword": /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
    "boolean": /\b(?:false|true)\b/,
    "nil": {
      pattern: /\bnil\b/,
      alias: "constant"
    },
    "short-argument": /\$\d+\b/,
    "omit": {
      pattern: /\b_\b/,
      alias: "keyword"
    },
    "number": /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
    // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
    "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
    "function": /\b[a-z_]\w*(?=\s*\()/i,
    "constant": /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
    // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
    // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
    // This regex only supports ASCII operators.
    "operator": /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
    "punctuation": /[{}[\]();,.:\\]/
  };
  Prism.languages.swift["string-literal"].forEach(function(rule) {
    rule.inside["interpolation"].inside = Prism.languages.swift;
  });
  return prismSwift;
}
var prismTypescript = {};
var hasRequiredPrismTypescript;
function requirePrismTypescript() {
  if (hasRequiredPrismTypescript)
    return prismTypescript;
  hasRequiredPrismTypescript = 1;
  (function(Prism2) {
    Prism2.languages.typescript = Prism2.languages.extend("javascript", {
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
        lookbehind: true,
        greedy: true,
        inside: null
        // see below
      },
      "builtin": /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
    });
    Prism2.languages.typescript.keyword.push(
      /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
      // keywords that have to be followed by an identifier
      /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
      // This is for `import type *, {}`
      /\btype\b(?=\s*(?:[\{*]|$))/
    );
    delete Prism2.languages.typescript["parameter"];
    delete Prism2.languages.typescript["literal-property"];
    var typeInside = Prism2.languages.extend("typescript", {});
    delete typeInside["class-name"];
    Prism2.languages.typescript["class-name"].inside = typeInside;
    Prism2.languages.insertBefore("typescript", "function", {
      "decorator": {
        pattern: /@[$\w\xA0-\uFFFF]+/,
        inside: {
          "at": {
            pattern: /^@/,
            alias: "operator"
          },
          "function": /^[\s\S]+/
        }
      },
      "generic-function": {
        // e.g. foo<T extends "bar" | "baz">( ...
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
        greedy: true,
        inside: {
          "function": /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
          "generic": {
            pattern: /<[\s\S]+/,
            // everything after the first <
            alias: "class-name",
            inside: typeInside
          }
        }
      }
    });
    Prism2.languages.ts = Prism2.languages.typescript;
  })(Prism);
  return prismTypescript;
}
var prismJava = {};
var hasRequiredPrismJava;
function requirePrismJava() {
  if (hasRequiredPrismJava)
    return prismJava;
  hasRequiredPrismJava = 1;
  (function(Prism2) {
    var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
    var classNamePrefix = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
    var className = {
      pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
      lookbehind: true,
      inside: {
        "namespace": {
          pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
          inside: {
            "punctuation": /\./
          }
        },
        "punctuation": /\./
      }
    };
    Prism2.languages.java = Prism2.languages.extend("clike", {
      "string": {
        pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
        lookbehind: true,
        greedy: true
      },
      "class-name": [
        className,
        {
          // variables, parameters, and constructor references
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
          lookbehind: true,
          inside: className.inside
        },
        {
          // class names based on keyword
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix + /[A-Z]\w*\b/.source),
          lookbehind: true,
          inside: className.inside
        }
      ],
      "keyword": keywords,
      "function": [
        Prism2.languages.clike.function,
        {
          pattern: /(::\s*)[a-z_]\w*/,
          lookbehind: true
        }
      ],
      "number": /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
      "operator": {
        pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
        lookbehind: true
      },
      "constant": /\b[A-Z][A-Z_\d]+\b/
    });
    Prism2.languages.insertBefore("java", "string", {
      "triple-quoted-string": {
        // http://openjdk.java.net/jeps/355#Description
        pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
        greedy: true,
        alias: "string"
      },
      "char": {
        pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
        greedy: true
      }
    });
    Prism2.languages.insertBefore("java", "class-name", {
      "annotation": {
        pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
        lookbehind: true,
        alias: "punctuation"
      },
      "generics": {
        pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
        inside: {
          "class-name": className,
          "keyword": keywords,
          "punctuation": /[<>(),.:]/,
          "operator": /[?&|]/
        }
      },
      "import": [
        {
          pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
          lookbehind: true,
          inside: {
            "namespace": className.inside.namespace,
            "punctuation": /\./,
            "operator": /\*/,
            "class-name": /\w+/
          }
        },
        {
          pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix + /(?:\w+|\*)(?=\s*;)/.source),
          lookbehind: true,
          alias: "static",
          inside: {
            "namespace": className.inside.namespace,
            "static": /\b\w+$/,
            "punctuation": /\./,
            "operator": /\*/,
            "class-name": /\w+/
          }
        }
      ],
      "namespace": {
        pattern: RegExp(
          /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
            return keywords.source;
          })
        ),
        lookbehind: true,
        inside: {
          "punctuation": /\./
        }
      }
    });
  })(Prism);
  return prismJava;
}
var prismCpp = {};
var hasRequiredPrismCpp;
function requirePrismCpp() {
  if (hasRequiredPrismCpp)
    return prismCpp;
  hasRequiredPrismCpp = 1;
  (function(Prism2) {
    var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
    var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
      return keyword.source;
    });
    Prism2.languages.cpp = Prism2.languages.extend("c", {
      "class-name": [
        {
          pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
            return keyword.source;
          })),
          lookbehind: true
        },
        // This is intended to capture the class name of method implementations like:
        //   void foo::bar() const {}
        // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
        // it starts with an uppercase letter. This approximation should give decent results.
        /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
        // This will capture the class name before destructors like:
        //   Foo::~Foo() {}
        /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
        // This also intends to capture the class name of method implementations but here the class has template
        // parameters, so it can't be a namespace (until C++ adds generic namespaces).
        /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
      ],
      "keyword": keyword,
      "number": {
        pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
        greedy: true
      },
      "operator": />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
      "boolean": /\b(?:false|true)\b/
    });
    Prism2.languages.insertBefore("cpp", "string", {
      "module": {
        // https://en.cppreference.com/w/cpp/language/modules
        pattern: RegExp(
          /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
          /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
          /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
            return modName;
          }) + ")"
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "string": /^[<"][\s\S]+/,
          "operator": /:/,
          "punctuation": /\./
        }
      },
      "raw-string": {
        pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
        alias: "string",
        greedy: true
      }
    });
    Prism2.languages.insertBefore("cpp", "keyword", {
      "generic-function": {
        pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
        inside: {
          "function": /^\w+/,
          "generic": {
            pattern: /<[\s\S]+/,
            alias: "class-name",
            inside: Prism2.languages.cpp
          }
        }
      }
    });
    Prism2.languages.insertBefore("cpp", "operator", {
      "double-colon": {
        pattern: /::/,
        alias: "punctuation"
      }
    });
    Prism2.languages.insertBefore("cpp", "class-name", {
      // the base clause is an optional list of parent classes
      // https://en.cppreference.com/w/cpp/language/class
      "base-clause": {
        pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
        lookbehind: true,
        greedy: true,
        inside: Prism2.languages.extend("cpp", {})
      }
    });
    Prism2.languages.insertBefore("inside", "double-colon", {
      // All untokenized words that are not namespaces should be class names
      "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
    }, Prism2.languages.cpp["base-clause"]);
  })(Prism);
  return prismCpp;
}
var LexicalUtils_dev = {};
var LexicalSelection_dev = {};
var hasRequiredLexicalSelection_dev;
function requireLexicalSelection_dev() {
  if (hasRequiredLexicalSelection_dev)
    return LexicalSelection_dev;
  hasRequiredLexicalSelection_dev = 1;
  var lexical = import_lexical.default;
  const CSS_TO_STYLES = /* @__PURE__ */ new Map();
  function getDOMTextNode(element) {
    let node = element;
    while (node != null) {
      if (node.nodeType === Node.TEXT_NODE) {
        return node;
      }
      node = node.firstChild;
    }
    return null;
  }
  function getDOMIndexWithinParent(node) {
    const parent = node.parentNode;
    if (parent == null) {
      throw new Error("Should never happen");
    }
    return [parent, Array.from(parent.childNodes).indexOf(node)];
  }
  function createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {
    const anchorKey = anchorNode.getKey();
    const focusKey = focusNode.getKey();
    const range2 = document.createRange();
    let anchorDOM = editor.getElementByKey(anchorKey);
    let focusDOM = editor.getElementByKey(focusKey);
    let anchorOffset = _anchorOffset;
    let focusOffset = _focusOffset;
    if (lexical.$isTextNode(anchorNode)) {
      anchorDOM = getDOMTextNode(anchorDOM);
    }
    if (lexical.$isTextNode(focusNode)) {
      focusDOM = getDOMTextNode(focusDOM);
    }
    if (anchorNode === void 0 || focusNode === void 0 || anchorDOM === null || focusDOM === null) {
      return null;
    }
    if (anchorDOM.nodeName === "BR") {
      [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);
    }
    if (focusDOM.nodeName === "BR") {
      [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);
    }
    const firstChild = anchorDOM.firstChild;
    if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === "BR" && anchorOffset === 0 && focusOffset === 0) {
      focusOffset = 1;
    }
    try {
      range2.setStart(anchorDOM, anchorOffset);
      range2.setEnd(focusDOM, focusOffset);
    } catch (e) {
      return null;
    }
    if (range2.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {
      range2.setStart(focusDOM, focusOffset);
      range2.setEnd(anchorDOM, anchorOffset);
    }
    return range2;
  }
  function createRectsFromDOMRange(editor, range2) {
    const rootElement = editor.getRootElement();
    if (rootElement === null) {
      return [];
    }
    const rootRect = rootElement.getBoundingClientRect();
    const computedStyle = getComputedStyle(rootElement);
    const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
    const selectionRects = Array.from(range2.getClientRects());
    let selectionRectsLength = selectionRects.length;
    let prevRect;
    for (let i = 0; i < selectionRectsLength; i++) {
      const selectionRect = selectionRects[i];
      const isDuplicateRect = prevRect && prevRect.top === selectionRect.top && prevRect.left === selectionRect.left && prevRect.width === selectionRect.width && prevRect.height === selectionRect.height;
      const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;
      if (isDuplicateRect || selectionSpansElement) {
        selectionRects.splice(i--, 1);
        selectionRectsLength--;
        continue;
      }
      prevRect = selectionRect;
    }
    return selectionRects;
  }
  function getStyleObjectFromRawCSS(css) {
    const styleObject = {};
    const styles = css.split(";");
    for (const style of styles) {
      if (style !== "") {
        const [key, value22] = style.split(/:([^]+)/);
        styleObject[key.trim()] = value22.trim();
      }
    }
    return styleObject;
  }
  function getStyleObjectFromCSS(css) {
    let value22 = CSS_TO_STYLES.get(css);
    if (value22 === void 0) {
      value22 = getStyleObjectFromRawCSS(css);
      CSS_TO_STYLES.set(css, value22);
    }
    return value22;
  }
  function getCSSFromStyleObject(styles) {
    let css = "";
    for (const style in styles) {
      if (style) {
        css += `${style}: ${styles[style]};`;
      }
    }
    return css;
  }
  function $updateElementNodeProperties(target, source) {
    target.__first = source.__first;
    target.__last = source.__last;
    target.__size = source.__size;
    target.__format = source.__format;
    target.__indent = source.__indent;
    target.__dir = source.__dir;
    return target;
  }
  function $updateTextNodeProperties(target, source) {
    target.__format = source.__format;
    target.__style = source.__style;
    target.__mode = source.__mode;
    target.__detail = source.__detail;
    return target;
  }
  function $cloneWithProperties(node) {
    const latest = node.getLatest();
    const constructor = latest.constructor;
    const clone = constructor.clone(latest);
    clone.__parent = latest.__parent;
    clone.__next = latest.__next;
    clone.__prev = latest.__prev;
    if (lexical.$isElementNode(latest) && lexical.$isElementNode(clone)) {
      return $updateElementNodeProperties(clone, latest);
    }
    if (lexical.$isTextNode(latest) && lexical.$isTextNode(clone)) {
      return $updateTextNodeProperties(clone, latest);
    }
    return clone;
  }
  function $sliceSelectedTextNodeContent(selection, textNode) {
    if (textNode.isSelected() && !textNode.isSegmented() && !textNode.isToken() && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {
      const anchorNode = selection.anchor.getNode();
      const focusNode = selection.focus.getNode();
      const isAnchor = textNode.is(anchorNode);
      const isFocus = textNode.is(focusNode);
      if (isAnchor || isFocus) {
        const isBackward = selection.isBackward();
        const [anchorOffset, focusOffset] = selection.getCharacterOffsets();
        const isSame = anchorNode.is(focusNode);
        const isFirst = textNode.is(isBackward ? focusNode : anchorNode);
        const isLast = textNode.is(isBackward ? anchorNode : focusNode);
        let startOffset = 0;
        let endOffset = void 0;
        if (isSame) {
          startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;
          endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;
        } else if (isFirst) {
          const offset = isBackward ? focusOffset : anchorOffset;
          startOffset = offset;
          endOffset = void 0;
        } else if (isLast) {
          const offset = isBackward ? anchorOffset : focusOffset;
          startOffset = 0;
          endOffset = offset;
        }
        textNode.__text = textNode.__text.slice(startOffset, endOffset);
        return textNode;
      }
    }
    return textNode;
  }
  function $isAtNodeEnd(point6) {
    if (point6.type === "text") {
      return point6.offset === point6.getNode().getTextContentSize();
    }
    return point6.offset === point6.getNode().getChildrenSize();
  }
  function trimTextContentFromAnchor(editor, anchor, delCount) {
    let currentNode = anchor.getNode();
    let remaining = delCount;
    if (lexical.$isElementNode(currentNode)) {
      const descendantNode = currentNode.getDescendantByIndex(anchor.offset);
      if (descendantNode !== null) {
        currentNode = descendantNode;
      }
    }
    while (remaining > 0 && currentNode !== null) {
      let nextNode = currentNode.getPreviousSibling();
      let additionalElementWhitespace = 0;
      if (nextNode === null) {
        let parent = currentNode.getParentOrThrow();
        let parentSibling = parent.getPreviousSibling();
        while (parentSibling === null) {
          parent = parent.getParent();
          if (parent === null) {
            nextNode = null;
            break;
          }
          parentSibling = parent.getPreviousSibling();
        }
        if (parent !== null) {
          additionalElementWhitespace = parent.isInline() ? 0 : 2;
          if (lexical.$isElementNode(parentSibling)) {
            nextNode = parentSibling.getLastDescendant();
          } else {
            nextNode = parentSibling;
          }
        }
      }
      let text = currentNode.getTextContent();
      if (text === "" && lexical.$isElementNode(currentNode) && !currentNode.isInline()) {
        text = "\n\n";
      }
      const textNodeSize = text.length;
      const offset = textNodeSize - remaining;
      const slicedText = text.slice(0, offset);
      if (!lexical.$isTextNode(currentNode) || remaining >= textNodeSize) {
        const parent = currentNode.getParent();
        currentNode.remove();
        if (parent != null && parent.getChildrenSize() === 0) {
          parent.remove();
        }
        remaining -= textNodeSize + additionalElementWhitespace;
        currentNode = nextNode;
      } else {
        const key = currentNode.getKey();
        const prevTextContent = editor.getEditorState().read(() => {
          const prevNode = lexical.$getNodeByKey(key);
          if (lexical.$isTextNode(prevNode) && prevNode.isSimpleText()) {
            return prevNode.getTextContent();
          }
          return null;
        });
        if (prevTextContent !== null && prevTextContent !== text) {
          const prevSelection = lexical.$getPreviousSelection();
          let target = currentNode;
          if (!currentNode.isSimpleText()) {
            const textNode = lexical.$createTextNode(prevTextContent);
            currentNode.replace(textNode);
            target = textNode;
          } else {
            currentNode.setTextContent(prevTextContent);
          }
          if (lexical.$isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {
            const prevOffset = prevSelection.anchor.offset;
            target.select(prevOffset, prevOffset);
          }
        } else if (currentNode.isSimpleText()) {
          const isSelected = anchor.key === key;
          let anchorOffset = anchor.offset;
          if (anchorOffset < remaining) {
            anchorOffset = textNodeSize;
          }
          const splitStart = isSelected ? anchorOffset - remaining : 0;
          const splitEnd = isSelected ? anchorOffset : offset;
          if (isSelected && splitStart === 0) {
            const [excessNode] = currentNode.splitText(splitStart, splitEnd);
            excessNode.remove();
          } else {
            const [, excessNode] = currentNode.splitText(splitStart, splitEnd);
            excessNode.remove();
          }
        } else {
          const textNode = lexical.$createTextNode(slicedText);
          currentNode.replace(textNode);
        }
        remaining = 0;
      }
    }
  }
  function $addNodeStyle(node) {
    const CSSText = node.getStyle();
    const styles = getStyleObjectFromRawCSS(CSSText);
    CSS_TO_STYLES.set(CSSText, styles);
  }
  function $patchStyle(target, patch) {
    const prevStyles = getStyleObjectFromCSS("getStyle" in target ? target.getStyle() : target.style);
    const newStyles = Object.entries(patch).reduce((styles, [key, value22]) => {
      if (value22 === null) {
        delete styles[key];
      } else {
        styles[key] = value22;
      }
      return styles;
    }, {
      ...prevStyles
    });
    const newCSSText = getCSSFromStyleObject(newStyles);
    target.setStyle(newCSSText);
    CSS_TO_STYLES.set(newCSSText, newStyles);
  }
  function $patchStyleText(selection, patch) {
    const selectedNodes = selection.getNodes();
    const selectedNodesLength = selectedNodes.length;
    const lastIndex = selectedNodesLength - 1;
    let firstNode = selectedNodes[0];
    let lastNode = selectedNodes[lastIndex];
    if (selection.isCollapsed()) {
      $patchStyle(selection, patch);
      return;
    }
    const anchor = selection.anchor;
    const focus = selection.focus;
    const firstNodeText = firstNode.getTextContent();
    const firstNodeTextLength = firstNodeText.length;
    const focusOffset = focus.offset;
    let anchorOffset = anchor.offset;
    const isBefore = anchor.isBefore(focus);
    let startOffset = isBefore ? anchorOffset : focusOffset;
    let endOffset = isBefore ? focusOffset : anchorOffset;
    const startType = isBefore ? anchor.type : focus.type;
    const endType = isBefore ? focus.type : anchor.type;
    const endKey = isBefore ? focus.key : anchor.key;
    if (lexical.$isTextNode(firstNode) && startOffset === firstNodeTextLength) {
      const nextSibling = firstNode.getNextSibling();
      if (lexical.$isTextNode(nextSibling)) {
        anchorOffset = 0;
        startOffset = 0;
        firstNode = nextSibling;
      }
    }
    if (firstNode.is(lastNode)) {
      if (lexical.$isTextNode(firstNode)) {
        startOffset = startType === "element" ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;
        endOffset = endType === "element" ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset;
        if (startOffset === endOffset) {
          return;
        }
        if (startOffset === 0 && endOffset === firstNodeTextLength) {
          $patchStyle(firstNode, patch);
          firstNode.select(startOffset, endOffset);
        } else {
          const splitNodes = firstNode.splitText(startOffset, endOffset);
          const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];
          $patchStyle(replacement, patch);
          replacement.select(0, endOffset - startOffset);
        }
      }
    } else {
      if (lexical.$isTextNode(firstNode) && startOffset < firstNode.getTextContentSize()) {
        if (startOffset !== 0) {
          firstNode = firstNode.splitText(startOffset)[1];
          startOffset = 0;
        }
        $patchStyle(firstNode, patch);
      }
      if (lexical.$isTextNode(lastNode)) {
        const lastNodeText = lastNode.getTextContent();
        const lastNodeTextLength = lastNodeText.length;
        if (lastNode.__key !== endKey && endOffset !== 0) {
          endOffset = lastNodeTextLength;
        }
        if (endOffset !== lastNodeTextLength) {
          [lastNode] = lastNode.splitText(endOffset);
        }
        if (endOffset !== 0) {
          $patchStyle(lastNode, patch);
        }
      }
      for (let i = 1; i < lastIndex; i++) {
        const selectedNode = selectedNodes[i];
        const selectedNodeKey = selectedNode.getKey();
        if (lexical.$isTextNode(selectedNode) && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {
          $patchStyle(selectedNode, patch);
        }
      }
    }
  }
  function $setBlocksType_experimental(selection, createElement2) {
    if (selection.anchor.key === "root") {
      const element = createElement2();
      const root = lexical.$getRoot();
      const firstChild = root.getFirstChild();
      if (firstChild)
        firstChild.replace(element, true);
      else
        root.append(element);
      return;
    }
    const nodes = selection.getNodes();
    if (selection.anchor.type === "text") {
      let firstBlock = selection.anchor.getNode().getParent();
      firstBlock = firstBlock.isInline() ? firstBlock.getParent() : firstBlock;
      if (nodes.indexOf(firstBlock) === -1)
        nodes.push(firstBlock);
    }
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (!isBlock(node))
        continue;
      const targetElement = createElement2();
      targetElement.setFormat(node.getFormatType());
      targetElement.setIndent(node.getIndent());
      node.replace(targetElement, true);
    }
  }
  function isBlock(node) {
    return lexical.$isElementNode(node) && !lexical.$isRootOrShadowRoot(node) && !node.isInline();
  }
  function isPointAttached(point6) {
    return point6.getNode().isAttached();
  }
  function $removeParentEmptyElements(startingNode) {
    let node = startingNode;
    while (node !== null && !lexical.$isRootOrShadowRoot(node)) {
      const latest = node.getLatest();
      const parentNode = node.getParent();
      if (latest.getChildrenSize() === 0) {
        node.remove(true);
      }
      node = parentNode;
    }
  }
  function $wrapNodes(selection, createElement2, wrappingElement = null) {
    const nodes = selection.getNodes();
    const nodesLength = nodes.length;
    const anchor = selection.anchor;
    if (nodesLength === 0 || nodesLength === 1 && anchor.type === "element" && anchor.getNode().getChildrenSize() === 0) {
      const target = anchor.type === "text" ? anchor.getNode().getParentOrThrow() : anchor.getNode();
      const children = target.getChildren();
      let element = createElement2();
      element.setFormat(target.getFormatType());
      element.setIndent(target.getIndent());
      children.forEach((child) => element.append(child));
      if (wrappingElement) {
        element = wrappingElement.append(element);
      }
      target.replace(element);
      return;
    }
    let topLevelNode = null;
    let descendants = [];
    for (let i = 0; i < nodesLength; i++) {
      const node = nodes[i];
      if (lexical.$isRootOrShadowRoot(node)) {
        $wrapNodesImpl(selection, descendants, descendants.length, createElement2, wrappingElement);
        descendants = [];
        topLevelNode = node;
      } else if (topLevelNode === null || topLevelNode !== null && lexical.$hasAncestor(node, topLevelNode)) {
        descendants.push(node);
      } else {
        $wrapNodesImpl(selection, descendants, descendants.length, createElement2, wrappingElement);
        descendants = [node];
      }
    }
    $wrapNodesImpl(selection, descendants, descendants.length, createElement2, wrappingElement);
  }
  function $wrapNodesImpl(selection, nodes, nodesLength, createElement2, wrappingElement = null) {
    if (nodes.length === 0) {
      return;
    }
    const firstNode = nodes[0];
    const elementMapping = /* @__PURE__ */ new Map();
    const elements = [];
    let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();
    if (target.isInline()) {
      target = target.getParentOrThrow();
    }
    let targetIsPrevSibling = false;
    while (target !== null) {
      const prevSibling = target.getPreviousSibling();
      if (prevSibling !== null) {
        target = prevSibling;
        targetIsPrevSibling = true;
        break;
      }
      target = target.getParentOrThrow();
      if (lexical.$isRootOrShadowRoot(target)) {
        break;
      }
    }
    const emptyElements = /* @__PURE__ */ new Set();
    for (let i = 0; i < nodesLength; i++) {
      const node = nodes[i];
      if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {
        emptyElements.add(node.getKey());
      }
    }
    const movedNodes = /* @__PURE__ */ new Set();
    for (let i = 0; i < nodesLength; i++) {
      const node = nodes[i];
      let parent = node.getParent();
      if (parent !== null && parent.isInline()) {
        parent = parent.getParent();
      }
      if (parent !== null && lexical.$isLeafNode(node) && !movedNodes.has(node.getKey())) {
        const parentKey = parent.getKey();
        if (elementMapping.get(parentKey) === void 0) {
          const targetElement = createElement2();
          targetElement.setFormat(parent.getFormatType());
          targetElement.setIndent(parent.getIndent());
          elements.push(targetElement);
          elementMapping.set(parentKey, targetElement);
          parent.getChildren().forEach((child) => {
            targetElement.append(child);
            movedNodes.add(child.getKey());
            if (lexical.$isElementNode(child)) {
              child.getChildrenKeys().forEach((key) => movedNodes.add(key));
            }
          });
          $removeParentEmptyElements(parent);
        }
      } else if (emptyElements.has(node.getKey())) {
        const targetElement = createElement2();
        targetElement.setFormat(node.getFormatType());
        targetElement.setIndent(node.getIndent());
        elements.push(targetElement);
        node.remove(true);
      }
    }
    if (wrappingElement !== null) {
      for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        wrappingElement.append(element);
      }
    }
    let lastElement = null;
    if (lexical.$isRootOrShadowRoot(target)) {
      if (targetIsPrevSibling) {
        if (wrappingElement !== null) {
          target.insertAfter(wrappingElement);
        } else {
          for (let i = elements.length - 1; i >= 0; i--) {
            const element = elements[i];
            target.insertAfter(element);
          }
        }
      } else {
        const firstChild = target.getFirstChild();
        if (lexical.$isElementNode(firstChild)) {
          target = firstChild;
        }
        if (firstChild === null) {
          if (wrappingElement) {
            target.append(wrappingElement);
          } else {
            for (let i = 0; i < elements.length; i++) {
              const element = elements[i];
              target.append(element);
              lastElement = element;
            }
          }
        } else {
          if (wrappingElement !== null) {
            firstChild.insertBefore(wrappingElement);
          } else {
            for (let i = 0; i < elements.length; i++) {
              const element = elements[i];
              firstChild.insertBefore(element);
              lastElement = element;
            }
          }
        }
      }
    } else {
      if (wrappingElement) {
        target.insertAfter(wrappingElement);
      } else {
        for (let i = elements.length - 1; i >= 0; i--) {
          const element = elements[i];
          target.insertAfter(element);
          lastElement = element;
        }
      }
    }
    const prevSelection = lexical.$getPreviousSelection();
    if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {
      lexical.$setSelection(prevSelection.clone());
    } else if (lastElement !== null) {
      lastElement.selectEnd();
    } else {
      selection.dirty = true;
    }
  }
  function $shouldOverrideDefaultCharacterSelection(selection, isBackward) {
    const possibleNode = lexical.$getAdjacentNode(selection.focus, isBackward);
    return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();
  }
  function $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {
    selection.modify(isHoldingShift ? "extend" : "move", isBackward, granularity);
  }
  function $isParentElementRTL(selection) {
    const anchorNode = selection.anchor.getNode();
    const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();
    return parent.getDirection() === "rtl";
  }
  function $moveCharacter(selection, isHoldingShift, isBackward) {
    const isRTL = $isParentElementRTL(selection);
    $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, "character");
  }
  function $selectAll(selection) {
    const anchor = selection.anchor;
    const focus = selection.focus;
    const anchorNode = anchor.getNode();
    const topParent = anchorNode.getTopLevelElementOrThrow();
    const root = topParent.getParentOrThrow();
    let firstNode = root.getFirstDescendant();
    let lastNode = root.getLastDescendant();
    let firstType = "element";
    let lastType = "element";
    let lastOffset = 0;
    if (lexical.$isTextNode(firstNode)) {
      firstType = "text";
    } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {
      firstNode = firstNode.getParentOrThrow();
    }
    if (lexical.$isTextNode(lastNode)) {
      lastType = "text";
      lastOffset = lastNode.getTextContentSize();
    } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {
      lastNode = lastNode.getParentOrThrow();
    }
    if (firstNode && lastNode) {
      anchor.set(firstNode.getKey(), 0, firstType);
      focus.set(lastNode.getKey(), lastOffset, lastType);
    }
  }
  function $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {
    const css = node.getStyle();
    const styleObject = getStyleObjectFromCSS(css);
    if (styleObject !== null) {
      return styleObject[styleProperty] || defaultValue;
    }
    return defaultValue;
  }
  function $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = "") {
    let styleValue = null;
    const nodes = selection.getNodes();
    const anchor = selection.anchor;
    const focus = selection.focus;
    const isBackward = selection.isBackward();
    const endOffset = isBackward ? focus.offset : anchor.offset;
    const endNode = isBackward ? focus.getNode() : anchor.getNode();
    if (selection.style !== "") {
      const css = selection.style;
      const styleObject = getStyleObjectFromCSS(css);
      if (styleObject !== null && styleProperty in styleObject) {
        return styleObject[styleProperty];
      }
    }
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (i !== 0 && endOffset === 0 && node.is(endNode)) {
        continue;
      }
      if (lexical.$isTextNode(node)) {
        const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);
        if (styleValue === null) {
          styleValue = nodeStyleValue;
        } else if (styleValue !== nodeStyleValue) {
          styleValue = "";
          break;
        }
      }
    }
    return styleValue === null ? defaultValue : styleValue;
  }
  LexicalSelection_dev.$addNodeStyle = $addNodeStyle;
  LexicalSelection_dev.$cloneWithProperties = $cloneWithProperties;
  LexicalSelection_dev.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;
  LexicalSelection_dev.$isAtNodeEnd = $isAtNodeEnd;
  LexicalSelection_dev.$isParentElementRTL = $isParentElementRTL;
  LexicalSelection_dev.$moveCaretSelection = $moveCaretSelection;
  LexicalSelection_dev.$moveCharacter = $moveCharacter;
  LexicalSelection_dev.$patchStyleText = $patchStyleText;
  LexicalSelection_dev.$selectAll = $selectAll;
  LexicalSelection_dev.$setBlocksType_experimental = $setBlocksType_experimental;
  LexicalSelection_dev.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;
  LexicalSelection_dev.$sliceSelectedTextNodeContent = $sliceSelectedTextNodeContent;
  LexicalSelection_dev.$wrapNodes = $wrapNodes;
  LexicalSelection_dev.createDOMRange = createDOMRange;
  LexicalSelection_dev.createRectsFromDOMRange = createRectsFromDOMRange;
  LexicalSelection_dev.getStyleObjectFromCSS = getStyleObjectFromCSS;
  LexicalSelection_dev.trimTextContentFromAnchor = trimTextContentFromAnchor;
  return LexicalSelection_dev;
}
var LexicalSelection_1;
var hasRequiredLexicalSelection;
function requireLexicalSelection() {
  if (hasRequiredLexicalSelection)
    return LexicalSelection_1;
  hasRequiredLexicalSelection = 1;
  const LexicalSelection = true ? requireLexicalSelection_dev() : requireLexicalSelection_prod();
  LexicalSelection_1 = LexicalSelection;
  return LexicalSelection_1;
}
var hasRequiredLexicalUtils_dev;
function requireLexicalUtils_dev() {
  if (hasRequiredLexicalUtils_dev)
    return LexicalUtils_dev;
  hasRequiredLexicalUtils_dev = 1;
  var selection = requireLexicalSelection();
  var lexical = import_lexical.default;
  function addClassNamesToElement(element, ...classNames) {
    classNames.forEach((className) => {
      if (typeof className === "string") {
        const classesToAdd = className.split(" ").filter((n) => n !== "");
        element.classList.add(...classesToAdd);
      }
    });
  }
  function removeClassNamesFromElement(element, ...classNames) {
    classNames.forEach((className) => {
      if (typeof className === "string") {
        element.classList.remove(...className.split(" "));
      }
    });
  }
  function isMimeType(file, acceptableMimeTypes) {
    for (const acceptableType of acceptableMimeTypes) {
      if (file.type.startsWith(acceptableType)) {
        return true;
      }
    }
    return false;
  }
  function mediaFileReader(files, acceptableMimeTypes) {
    const filesIterator = files[Symbol.iterator]();
    return new Promise((resolve, reject) => {
      const processed = [];
      const handleNextFile = () => {
        const {
          done,
          value: file
        } = filesIterator.next();
        if (done) {
          return resolve(processed);
        }
        const fileReader = new FileReader();
        fileReader.addEventListener("error", reject);
        fileReader.addEventListener("load", () => {
          const result = fileReader.result;
          if (typeof result === "string") {
            processed.push({
              file,
              result
            });
          }
          handleNextFile();
        });
        if (isMimeType(file, acceptableMimeTypes)) {
          fileReader.readAsDataURL(file);
        } else {
          handleNextFile();
        }
      };
      handleNextFile();
    });
  }
  function $dfs(startingNode, endingNode) {
    const nodes = [];
    const start = (startingNode || lexical.$getRoot()).getLatest();
    const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);
    let node = start;
    let depth = $getDepth(node);
    while (node !== null && !node.is(end)) {
      nodes.push({
        depth,
        node
      });
      if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {
        node = node.getFirstChild();
        depth++;
      } else {
        let sibling = null;
        while (sibling === null && node !== null) {
          sibling = node.getNextSibling();
          if (sibling === null) {
            node = node.getParent();
            depth--;
          } else {
            node = sibling;
          }
        }
      }
    }
    if (node !== null && node.is(end)) {
      nodes.push({
        depth,
        node
      });
    }
    return nodes;
  }
  function $getDepth(node) {
    let innerNode = node;
    let depth = 0;
    while ((innerNode = innerNode.getParent()) !== null) {
      depth++;
    }
    return depth;
  }
  function $getNearestNodeOfType(node, klass) {
    let parent = node;
    while (parent != null) {
      if (parent instanceof klass) {
        return parent;
      }
      parent = parent.getParent();
    }
    return null;
  }
  function $getNearestBlockElementAncestorOrThrow(startNode) {
    const blockNode = $findMatchingParent(startNode, (node) => lexical.$isElementNode(node) && !node.isInline());
    if (!lexical.$isElementNode(blockNode)) {
      {
        throw Error(`Expected node ${startNode.__key} to have closest block element node.`);
      }
    }
    return blockNode;
  }
  function $findMatchingParent(startingNode, findFn) {
    let curr = startingNode;
    while (curr !== lexical.$getRoot() && curr != null) {
      if (findFn(curr)) {
        return curr;
      }
      curr = curr.getParent();
    }
    return null;
  }
  function mergeRegister(...func) {
    return () => {
      func.forEach((f) => f());
    };
  }
  function registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {
    const $isTargetNode = (node) => {
      return node instanceof targetNode;
    };
    const $findMatch = (node) => {
      const children = node.getChildren();
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if ($isTargetNode(child)) {
          return null;
        }
      }
      let parentNode = node;
      let childNode = node;
      while (parentNode !== null) {
        childNode = parentNode;
        parentNode = parentNode.getParent();
        if ($isTargetNode(parentNode)) {
          return {
            child: childNode,
            parent: parentNode
          };
        }
      }
      return null;
    };
    const elementNodeTransform = (node) => {
      const match = $findMatch(node);
      if (match !== null) {
        const {
          child,
          parent
        } = match;
        if (child.is(node)) {
          handleOverlap(parent, node);
          const nextSiblings = child.getNextSiblings();
          const nextSiblingsLength = nextSiblings.length;
          parent.insertAfter(child);
          if (nextSiblingsLength !== 0) {
            const newParent = cloneNode(parent);
            child.insertAfter(newParent);
            for (let i = 0; i < nextSiblingsLength; i++) {
              newParent.append(nextSiblings[i]);
            }
          }
          if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {
            parent.remove();
          }
        }
      }
    };
    return editor.registerNodeTransform(targetNode, elementNodeTransform);
  }
  function $restoreEditorState(editor, editorState) {
    const FULL_RECONCILE = 2;
    const nodeMap = /* @__PURE__ */ new Map();
    const activeEditorState = editor._pendingEditorState;
    for (const [key, node] of editorState._nodeMap) {
      const clone = selection.$cloneWithProperties(node);
      if (lexical.$isTextNode(clone)) {
        clone.__text = node.__text;
      }
      nodeMap.set(key, clone);
    }
    if (activeEditorState) {
      activeEditorState._nodeMap = nodeMap;
    }
    editor._dirtyType = FULL_RECONCILE;
    const selection$1 = editorState._selection;
    lexical.$setSelection(selection$1 === null ? null : selection$1.clone());
  }
  function $insertNodeToNearestRoot(node) {
    const selection2 = lexical.$getSelection();
    if (lexical.$isRangeSelection(selection2)) {
      const {
        focus
      } = selection2;
      const focusNode = focus.getNode();
      const focusOffset = focus.offset;
      if (lexical.$isRootOrShadowRoot(focusNode)) {
        const focusChild = focusNode.getChildAtIndex(focusOffset);
        if (focusChild == null) {
          focusNode.append(node);
        } else {
          focusChild.insertBefore(node);
        }
        node.selectNext();
      } else {
        let splitNode;
        let splitOffset;
        if (lexical.$isTextNode(focusNode)) {
          splitNode = focusNode.getParentOrThrow();
          splitOffset = focusNode.getIndexWithinParent();
          if (focusOffset > 0) {
            splitOffset += 1;
            focusNode.splitText(focusOffset);
          }
        } else {
          splitNode = focusNode;
          splitOffset = focusOffset;
        }
        const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);
        rightTree.insertBefore(node);
        rightTree.selectStart();
      }
    } else {
      if (lexical.$isNodeSelection(selection2) || lexical.DEPRECATED_$isGridSelection(selection2)) {
        const nodes = selection2.getNodes();
        nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);
      } else {
        const root = lexical.$getRoot();
        root.append(node);
      }
      const paragraphNode = lexical.$createParagraphNode();
      node.insertAfter(paragraphNode);
      paragraphNode.select();
    }
    return node.getLatest();
  }
  function $wrapNodeInElement(node, createElementNode) {
    const elementNode = createElementNode();
    node.replace(elementNode);
    elementNode.append(node);
    return elementNode;
  }
  function isHTMLAnchorElement(x4) {
    return isHTMLElement(x4) && x4.tagName === "A";
  }
  function isHTMLElement(x4) {
    return x4.nodeType === 1;
  }
  LexicalUtils_dev.$splitNode = lexical.$splitNode;
  LexicalUtils_dev.$dfs = $dfs;
  LexicalUtils_dev.$findMatchingParent = $findMatchingParent;
  LexicalUtils_dev.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;
  LexicalUtils_dev.$getNearestNodeOfType = $getNearestNodeOfType;
  LexicalUtils_dev.$insertNodeToNearestRoot = $insertNodeToNearestRoot;
  LexicalUtils_dev.$restoreEditorState = $restoreEditorState;
  LexicalUtils_dev.$wrapNodeInElement = $wrapNodeInElement;
  LexicalUtils_dev.addClassNamesToElement = addClassNamesToElement;
  LexicalUtils_dev.isHTMLAnchorElement = isHTMLAnchorElement;
  LexicalUtils_dev.isHTMLElement = isHTMLElement;
  LexicalUtils_dev.isMimeType = isMimeType;
  LexicalUtils_dev.mediaFileReader = mediaFileReader;
  LexicalUtils_dev.mergeRegister = mergeRegister;
  LexicalUtils_dev.registerNestedElementResolver = registerNestedElementResolver;
  LexicalUtils_dev.removeClassNamesFromElement = removeClassNamesFromElement;
  return LexicalUtils_dev;
}
var LexicalUtils_1;
var hasRequiredLexicalUtils;
function requireLexicalUtils() {
  if (hasRequiredLexicalUtils)
    return LexicalUtils_1;
  hasRequiredLexicalUtils = 1;
  const LexicalUtils = true ? requireLexicalUtils_dev() : requireLexicalUtils_prod();
  LexicalUtils_1 = LexicalUtils;
  return LexicalUtils_1;
}
var hasRequiredLexicalCode_dev;
function requireLexicalCode_dev() {
  if (hasRequiredLexicalCode_dev)
    return LexicalCode_dev;
  hasRequiredLexicalCode_dev = 1;
  var Prism2 = requirePrism();
  requirePrismClike();
  requirePrismJavascript();
  requirePrismMarkup();
  requirePrismMarkdown();
  requirePrismC();
  requirePrismCss();
  requirePrismObjectivec();
  requirePrismSql();
  requirePrismPython();
  requirePrismRust();
  requirePrismSwift();
  requirePrismTypescript();
  requirePrismJava();
  requirePrismCpp();
  var utils = requireLexicalUtils();
  var lexical = import_lexical.default;
  const mapToPrismLanguage = (language) => {
    return language != null && Prism2.languages.hasOwnProperty(language) ? language : void 0;
  };
  function hasChildDOMNodeTag(node, tagName) {
    for (const child of node.childNodes) {
      if (utils.isHTMLElement(child) && child.tagName === tagName) {
        return true;
      }
      hasChildDOMNodeTag(child, tagName);
    }
    return false;
  }
  const LANGUAGE_DATA_ATTRIBUTE = "data-highlight-language";
  class CodeNode extends lexical.ElementNode {
    /** @internal */
    static getType() {
      return "code";
    }
    static clone(node) {
      return new CodeNode(node.__language, node.__key);
    }
    constructor(language, key) {
      super(key);
      this.__language = mapToPrismLanguage(language);
    }
    // View
    createDOM(config) {
      const element = document.createElement("code");
      utils.addClassNamesToElement(element, config.theme.code);
      element.setAttribute("spellcheck", "false");
      const language = this.getLanguage();
      if (language) {
        element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);
      }
      return element;
    }
    updateDOM(prevNode, dom, config) {
      const language = this.__language;
      const prevLanguage = prevNode.__language;
      if (language) {
        if (language !== prevLanguage) {
          dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);
        }
      } else if (prevLanguage) {
        dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);
      }
      return false;
    }
    static importDOM() {
      return {
        // Typically <pre> is used for code blocks, and <code> for inline code styles
        // but if it's a multi line <code> we'll create a block. Pass through to
        // inline format handled by TextNode otherwise.
        code: (node) => {
          const isMultiLine = node.textContent != null && (/\r?\n/.test(node.textContent) || hasChildDOMNodeTag(node, "BR"));
          return isMultiLine ? {
            conversion: convertPreElement,
            priority: 1
          } : null;
        },
        div: (node) => ({
          conversion: convertDivElement,
          priority: 1
        }),
        pre: (node) => ({
          conversion: convertPreElement,
          priority: 0
        }),
        table: (node) => {
          const table = node;
          if (isGitHubCodeTable(table)) {
            return {
              conversion: convertTableElement,
              priority: 3
            };
          }
          return null;
        },
        td: (node) => {
          const td = node;
          const table = td.closest("table");
          if (isGitHubCodeCell(td)) {
            return {
              conversion: convertTableCellElement,
              priority: 3
            };
          }
          if (table && isGitHubCodeTable(table)) {
            return {
              conversion: convertCodeNoop,
              priority: 3
            };
          }
          return null;
        },
        tr: (node) => {
          const tr = node;
          const table = tr.closest("table");
          if (table && isGitHubCodeTable(table)) {
            return {
              conversion: convertCodeNoop,
              priority: 3
            };
          }
          return null;
        }
      };
    }
    static importJSON(serializedNode) {
      const node = $createCodeNode(serializedNode.language);
      node.setFormat(serializedNode.format);
      node.setIndent(serializedNode.indent);
      node.setDirection(serializedNode.direction);
      return node;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        language: this.getLanguage(),
        type: "code",
        version: 1
      };
    }
    // Mutation
    insertNewAfter(selection, restoreSelection = true) {
      const children = this.getChildren();
      const childrenLength = children.length;
      if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === "\n" && children[childrenLength - 2].getTextContent() === "\n" && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {
        children[childrenLength - 1].remove();
        children[childrenLength - 2].remove();
        const newElement = lexical.$createParagraphNode();
        this.insertAfter(newElement, restoreSelection);
        return newElement;
      }
      const anchor = selection.anchor.getNode();
      const firstNode = getFirstCodeHighlightNodeOfLine(anchor);
      if (firstNode != null) {
        let leadingWhitespace = 0;
        const firstNodeText = firstNode.getTextContent();
        while (leadingWhitespace < firstNodeText.length && /[\t ]/.test(firstNodeText[leadingWhitespace])) {
          leadingWhitespace += 1;
        }
        if (leadingWhitespace > 0) {
          const whitespace = firstNodeText.substring(0, leadingWhitespace);
          const indentedChild = $createCodeHighlightNode(whitespace);
          anchor.insertAfter(indentedChild);
          selection.insertNodes([lexical.$createLineBreakNode()]);
          indentedChild.select();
          return indentedChild;
        }
      }
      return null;
    }
    canInsertTab() {
      const selection = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {
        return false;
      }
      return true;
    }
    canIndent() {
      return false;
    }
    collapseAtStart() {
      const paragraph = lexical.$createParagraphNode();
      const children = this.getChildren();
      children.forEach((child) => paragraph.append(child));
      this.replace(paragraph);
      return true;
    }
    setLanguage(language) {
      const writable = this.getWritable();
      writable.__language = mapToPrismLanguage(language);
    }
    getLanguage() {
      return this.getLatest().__language;
    }
  }
  function $createCodeNode(language) {
    return lexical.$applyNodeReplacement(new CodeNode(language));
  }
  function $isCodeNode(node) {
    return node instanceof CodeNode;
  }
  function convertPreElement(domNode) {
    return {
      node: $createCodeNode(),
      preformatted: true
    };
  }
  function convertDivElement(domNode) {
    const div = domNode;
    const isCode = isCodeElement(div);
    if (!isCode && !isCodeChildElement(div)) {
      return {
        node: null
      };
    }
    return {
      after: (childLexicalNodes) => {
        const domParent = domNode.parentNode;
        if (domParent != null && domNode !== domParent.lastChild) {
          childLexicalNodes.push(lexical.$createLineBreakNode());
        }
        return childLexicalNodes;
      },
      node: isCode ? $createCodeNode() : null,
      preformatted: isCode
    };
  }
  function convertTableElement() {
    return {
      node: $createCodeNode(),
      preformatted: true
    };
  }
  function convertCodeNoop() {
    return {
      node: null
    };
  }
  function convertTableCellElement(domNode) {
    const cell = domNode;
    return {
      after: (childLexicalNodes) => {
        if (cell.parentNode && cell.parentNode.nextSibling) {
          childLexicalNodes.push(lexical.$createLineBreakNode());
        }
        return childLexicalNodes;
      },
      node: null
    };
  }
  function isCodeElement(div) {
    return div.style.fontFamily.match("monospace") !== null;
  }
  function isCodeChildElement(node) {
    let parent = node.parentElement;
    while (parent !== null) {
      if (isCodeElement(parent)) {
        return true;
      }
      parent = parent.parentElement;
    }
    return false;
  }
  function isGitHubCodeCell(cell) {
    return cell.classList.contains("js-file-line");
  }
  function isGitHubCodeTable(table) {
    return table.classList.contains("js-file-line-container");
  }
  const DEFAULT_CODE_LANGUAGE = "javascript";
  const CODE_LANGUAGE_FRIENDLY_NAME_MAP = {
    c: "C",
    clike: "C-like",
    cpp: "C++",
    css: "CSS",
    html: "HTML",
    java: "Java",
    js: "JavaScript",
    markdown: "Markdown",
    objc: "Objective-C",
    plain: "Plain Text",
    py: "Python",
    rust: "Rust",
    sql: "SQL",
    swift: "Swift",
    typescript: "TypeScript",
    xml: "XML"
  };
  const CODE_LANGUAGE_MAP = {
    cpp: "cpp",
    java: "java",
    javascript: "js",
    md: "markdown",
    plaintext: "plain",
    python: "py",
    text: "plain",
    ts: "typescript"
  };
  function normalizeCodeLang(lang) {
    return CODE_LANGUAGE_MAP[lang] || lang;
  }
  function getLanguageFriendlyName(lang) {
    const _lang = normalizeCodeLang(lang);
    return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;
  }
  const getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;
  const getCodeLanguages = () => Object.keys(Prism2.languages).filter(
    // Prism has several language helpers mixed into languages object
    // so filtering them out here to get langs list
    (language) => typeof Prism2.languages[language] !== "function"
  ).sort();
  class CodeHighlightNode extends lexical.TextNode {
    /** @internal */
    constructor(text, highlightType, key) {
      super(text, key);
      this.__highlightType = highlightType;
    }
    static getType() {
      return "code-highlight";
    }
    static clone(node) {
      return new CodeHighlightNode(node.__text, node.__highlightType || void 0, node.__key);
    }
    getHighlightType() {
      const self2 = this.getLatest();
      return self2.__highlightType;
    }
    createDOM(config) {
      const element = super.createDOM(config);
      const className = getHighlightThemeClass(config.theme, this.__highlightType);
      utils.addClassNamesToElement(element, className);
      return element;
    }
    updateDOM(prevNode, dom, config) {
      const update = super.updateDOM(prevNode, dom, config);
      const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);
      const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);
      if (prevClassName !== nextClassName) {
        if (prevClassName) {
          utils.removeClassNamesFromElement(dom, prevClassName);
        }
        if (nextClassName) {
          utils.addClassNamesToElement(dom, nextClassName);
        }
      }
      return update;
    }
    static importJSON(serializedNode) {
      const node = $createCodeHighlightNode(serializedNode.text, serializedNode.highlightType);
      node.setFormat(serializedNode.format);
      node.setDetail(serializedNode.detail);
      node.setMode(serializedNode.mode);
      node.setStyle(serializedNode.style);
      return node;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        highlightType: this.getHighlightType(),
        type: "code-highlight",
        version: 1
      };
    }
    // Prevent formatting (bold, underline, etc)
    setFormat(format3) {
      return this;
    }
    isParentRequired() {
      return true;
    }
    createParentElementNode() {
      return $createCodeNode();
    }
  }
  function getHighlightThemeClass(theme, highlightType) {
    return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];
  }
  function $createCodeHighlightNode(text, highlightType) {
    return lexical.$applyNodeReplacement(new CodeHighlightNode(text, highlightType));
  }
  function $isCodeHighlightNode(node) {
    return node instanceof CodeHighlightNode;
  }
  function getFirstCodeHighlightNodeOfLine(anchor) {
    let currentNode = null;
    const previousSiblings = anchor.getPreviousSiblings();
    previousSiblings.push(anchor);
    while (previousSiblings.length > 0) {
      const node = previousSiblings.pop();
      if ($isCodeHighlightNode(node)) {
        currentNode = node;
      }
      if (lexical.$isLineBreakNode(node)) {
        break;
      }
    }
    return currentNode;
  }
  function getLastCodeHighlightNodeOfLine(anchor) {
    let currentNode = null;
    const nextSiblings = anchor.getNextSiblings();
    nextSiblings.unshift(anchor);
    while (nextSiblings.length > 0) {
      const node = nextSiblings.shift();
      if ($isCodeHighlightNode(node)) {
        currentNode = node;
      }
      if (lexical.$isLineBreakNode(node)) {
        break;
      }
    }
    return currentNode;
  }
  const PrismTokenizer = {
    defaultLanguage: DEFAULT_CODE_LANGUAGE,
    tokenize(code, language) {
      return Prism2.tokenize(code, Prism2.languages[language || ""] || Prism2.languages[this.defaultLanguage]);
    }
  };
  function isSpaceOrTabChar(char) {
    return char === " " || char === "	";
  }
  function findFirstNotSpaceOrTabCharAtText(text, isForward) {
    const length = text.length;
    let offset = -1;
    if (isForward) {
      for (let i = 0; i < length; i++) {
        const char = text[i];
        if (!isSpaceOrTabChar(char)) {
          offset = i;
          break;
        }
      }
    } else {
      for (let i = length - 1; i > -1; i--) {
        const char = text[i];
        if (!isSpaceOrTabChar(char)) {
          offset = i;
          break;
        }
      }
    }
    return offset;
  }
  function getStartOfCodeInLine(anchor) {
    let currentNode = null;
    let currentNodeOffset = -1;
    const previousSiblings = anchor.getPreviousSiblings();
    previousSiblings.push(anchor);
    while (previousSiblings.length > 0) {
      const node = previousSiblings.pop();
      if ($isCodeHighlightNode(node)) {
        const text = node.getTextContent();
        const offset = findFirstNotSpaceOrTabCharAtText(text, true);
        if (offset !== -1) {
          currentNode = node;
          currentNodeOffset = offset;
        }
      }
      if (lexical.$isLineBreakNode(node)) {
        break;
      }
    }
    if (currentNode === null) {
      const nextSiblings = anchor.getNextSiblings();
      while (nextSiblings.length > 0) {
        const node = nextSiblings.shift();
        if ($isCodeHighlightNode(node)) {
          const text = node.getTextContent();
          const offset = findFirstNotSpaceOrTabCharAtText(text, true);
          if (offset !== -1) {
            currentNode = node;
            currentNodeOffset = offset;
            break;
          }
        }
        if (lexical.$isLineBreakNode(node)) {
          break;
        }
      }
    }
    return {
      node: currentNode,
      offset: currentNodeOffset
    };
  }
  function getEndOfCodeInLine(anchor) {
    let currentNode = null;
    let currentNodeOffset = -1;
    const nextSiblings = anchor.getNextSiblings();
    nextSiblings.unshift(anchor);
    while (nextSiblings.length > 0) {
      const node = nextSiblings.shift();
      if ($isCodeHighlightNode(node)) {
        const text = node.getTextContent();
        const offset = findFirstNotSpaceOrTabCharAtText(text, false);
        if (offset !== -1) {
          currentNode = node;
          currentNodeOffset = offset + 1;
        }
      }
      if (lexical.$isLineBreakNode(node)) {
        break;
      }
    }
    if (currentNode === null) {
      const previousSiblings = anchor.getPreviousSiblings();
      while (previousSiblings.length > 0) {
        const node = previousSiblings.pop();
        if ($isCodeHighlightNode(node)) {
          const text = node.getTextContent();
          const offset = findFirstNotSpaceOrTabCharAtText(text, false);
          if (offset !== -1) {
            currentNode = node;
            currentNodeOffset = offset + 1;
            break;
          }
        }
        if (lexical.$isLineBreakNode(node)) {
          break;
        }
      }
    }
    return {
      node: currentNode,
      offset: currentNodeOffset
    };
  }
  function textNodeTransform(node, editor, tokenizer) {
    const parentNode = node.getParent();
    if ($isCodeNode(parentNode)) {
      codeNodeTransform(parentNode, editor, tokenizer);
    } else if ($isCodeHighlightNode(node)) {
      node.replace(lexical.$createTextNode(node.__text));
    }
  }
  function updateCodeGutter(node, editor) {
    const codeElement = editor.getElementByKey(node.getKey());
    if (codeElement === null) {
      return;
    }
    const children = node.getChildren();
    const childrenLength = children.length;
    if (childrenLength === codeElement.__cachedChildrenLength) {
      return;
    }
    codeElement.__cachedChildrenLength = childrenLength;
    let gutter = "1";
    let count3 = 1;
    for (let i = 0; i < childrenLength; i++) {
      if (lexical.$isLineBreakNode(children[i])) {
        gutter += "\n" + ++count3;
      }
    }
    codeElement.setAttribute("data-gutter", gutter);
  }
  const nodesCurrentlyHighlighting = /* @__PURE__ */ new Set();
  function codeNodeTransform(node, editor, tokenizer) {
    const nodeKey = node.getKey();
    if (nodesCurrentlyHighlighting.has(nodeKey)) {
      return;
    }
    nodesCurrentlyHighlighting.add(nodeKey);
    if (node.getLanguage() === void 0) {
      node.setLanguage(tokenizer.defaultLanguage);
    }
    editor.update(() => {
      updateAndRetainSelection(nodeKey, () => {
        const currentNode = lexical.$getNodeByKey(nodeKey);
        if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {
          return false;
        }
        const code = currentNode.getTextContent();
        const tokens = tokenizer.tokenize(code, currentNode.getLanguage() || tokenizer.defaultLanguage);
        const highlightNodes = getHighlightNodes(tokens);
        const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);
        const {
          from,
          to,
          nodesForReplacement
        } = diffRange;
        if (from !== to || nodesForReplacement.length) {
          node.splice(from, to - from, nodesForReplacement);
          return true;
        }
        return false;
      });
    }, {
      onUpdate: () => {
        nodesCurrentlyHighlighting.delete(nodeKey);
      },
      skipTransforms: true
    });
  }
  function getHighlightNodes(tokens) {
    const nodes = [];
    tokens.forEach((token) => {
      if (typeof token === "string") {
        const partials = token.split("\n");
        for (let i = 0; i < partials.length; i++) {
          const text = partials[i];
          if (text.length) {
            nodes.push($createCodeHighlightNode(text));
          }
          if (i < partials.length - 1) {
            nodes.push(lexical.$createLineBreakNode());
          }
        }
      } else {
        const {
          content
        } = token;
        if (typeof content === "string") {
          nodes.push($createCodeHighlightNode(content, token.type));
        } else if (Array.isArray(content) && content.length === 1 && typeof content[0] === "string") {
          nodes.push($createCodeHighlightNode(content[0], token.type));
        } else if (Array.isArray(content)) {
          nodes.push(...getHighlightNodes(content));
        }
      }
    });
    return nodes;
  }
  function updateAndRetainSelection(nodeKey, updateFn) {
    const node = lexical.$getNodeByKey(nodeKey);
    if (!$isCodeNode(node) || !node.isAttached()) {
      return;
    }
    const selection = lexical.$getSelection();
    if (!lexical.$isRangeSelection(selection)) {
      updateFn();
      return;
    }
    const anchor = selection.anchor;
    const anchorOffset = anchor.offset;
    const isNewLineAnchor = anchor.type === "element" && lexical.$isLineBreakNode(node.getChildAtIndex(anchor.offset - 1));
    let textOffset = 0;
    if (!isNewLineAnchor) {
      const anchorNode = anchor.getNode();
      textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {
        return offset + _node.getTextContentSize();
      }, 0);
    }
    const hasChanges = updateFn();
    if (!hasChanges) {
      return;
    }
    if (isNewLineAnchor) {
      anchor.getNode().select(anchorOffset, anchorOffset);
      return;
    }
    node.getChildren().some((_node) => {
      const isText = lexical.$isTextNode(_node);
      if (isText || lexical.$isLineBreakNode(_node)) {
        const textContentSize = _node.getTextContentSize();
        if (isText && textContentSize >= textOffset) {
          _node.select(textOffset, textOffset);
          return true;
        }
        textOffset -= textContentSize;
      }
      return false;
    });
  }
  function getDiffRange(prevNodes, nextNodes) {
    let leadingMatch = 0;
    while (leadingMatch < prevNodes.length) {
      if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {
        break;
      }
      leadingMatch++;
    }
    const prevNodesLength = prevNodes.length;
    const nextNodesLength = nextNodes.length;
    const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;
    let trailingMatch = 0;
    while (trailingMatch < maxTrailingMatch) {
      trailingMatch++;
      if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {
        trailingMatch--;
        break;
      }
    }
    const from = leadingMatch;
    const to = prevNodesLength - trailingMatch;
    const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);
    return {
      from,
      nodesForReplacement,
      to
    };
  }
  function isEqual(nodeA, nodeB) {
    if ($isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB)) {
      return nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType;
    }
    if (lexical.$isLineBreakNode(nodeA) && lexical.$isLineBreakNode(nodeB)) {
      return true;
    }
    return false;
  }
  function handleMultilineIndent(type2) {
    const selection = lexical.$getSelection();
    if (!lexical.$isRangeSelection(selection) || selection.isCollapsed()) {
      return false;
    }
    const nodes = selection.getNodes();
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (!$isCodeHighlightNode(node) && !lexical.$isLineBreakNode(node)) {
        return false;
      }
    }
    const startOfLine = getFirstCodeHighlightNodeOfLine(nodes[0]);
    if (startOfLine != null) {
      doIndent(startOfLine, type2);
    }
    for (let i = 1; i < nodes.length; i++) {
      const node = nodes[i];
      if (lexical.$isLineBreakNode(nodes[i - 1]) && $isCodeHighlightNode(node)) {
        doIndent(node, type2);
      }
    }
    return true;
  }
  function doIndent(node, type2) {
    const text = node.getTextContent();
    if (type2 === lexical.INDENT_CONTENT_COMMAND) {
      if (text.length > 0 && /\s/.test(text[0])) {
        node.setTextContent("	" + text);
      } else {
        const indentNode = $createCodeHighlightNode("	");
        node.insertBefore(indentNode);
      }
    } else {
      if (text.indexOf("	") === 0) {
        if (text.length === 1) {
          node.remove();
        } else {
          node.setTextContent(text.substring(1));
        }
      }
    }
  }
  function handleShiftLines(type2, event) {
    const selection = lexical.$getSelection();
    if (!lexical.$isRangeSelection(selection)) {
      return false;
    }
    const {
      anchor,
      focus
    } = selection;
    const anchorOffset = anchor.offset;
    const focusOffset = focus.offset;
    const anchorNode = anchor.getNode();
    const focusNode = focus.getNode();
    const arrowIsUp = type2 === lexical.KEY_ARROW_UP_COMMAND;
    if (!$isCodeHighlightNode(anchorNode) || !$isCodeHighlightNode(focusNode)) {
      return false;
    }
    if (!event.altKey) {
      if (selection.isCollapsed()) {
        const codeNode = anchorNode.getParentOrThrow();
        if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {
          const codeNodeSibling = codeNode.getPreviousSibling();
          if (codeNodeSibling === null) {
            codeNode.selectPrevious();
            event.preventDefault();
            return true;
          }
        } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {
          const codeNodeSibling = codeNode.getNextSibling();
          if (codeNodeSibling === null) {
            codeNode.selectNext();
            event.preventDefault();
            return true;
          }
        }
      }
      return false;
    }
    const start = getFirstCodeHighlightNodeOfLine(anchorNode);
    const end = getLastCodeHighlightNodeOfLine(focusNode);
    if (start == null || end == null) {
      return false;
    }
    const range2 = start.getNodesBetween(end);
    for (let i = 0; i < range2.length; i++) {
      const node = range2[i];
      if (!$isCodeHighlightNode(node) && !lexical.$isLineBreakNode(node)) {
        return false;
      }
    }
    event.preventDefault();
    event.stopPropagation();
    const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();
    if (!lexical.$isLineBreakNode(linebreak)) {
      return true;
    }
    const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();
    if (sibling == null) {
      return true;
    }
    const maybeInsertionPoint = arrowIsUp ? getFirstCodeHighlightNodeOfLine(sibling) : getLastCodeHighlightNodeOfLine(sibling);
    let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;
    linebreak.remove();
    range2.forEach((node) => node.remove());
    if (type2 === lexical.KEY_ARROW_UP_COMMAND) {
      range2.forEach((node) => insertionPoint.insertBefore(node));
      insertionPoint.insertBefore(linebreak);
    } else {
      insertionPoint.insertAfter(linebreak);
      insertionPoint = linebreak;
      range2.forEach((node) => {
        insertionPoint.insertAfter(node);
        insertionPoint = node;
      });
    }
    selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);
    return true;
  }
  function handleMoveTo(type2, event) {
    const selection = lexical.$getSelection();
    if (!lexical.$isRangeSelection(selection)) {
      return false;
    }
    const {
      anchor,
      focus
    } = selection;
    const anchorNode = anchor.getNode();
    const focusNode = focus.getNode();
    const isMoveToStart = type2 === lexical.MOVE_TO_START;
    if (!$isCodeHighlightNode(anchorNode) || !$isCodeHighlightNode(focusNode)) {
      return false;
    }
    let node;
    let offset;
    if (isMoveToStart) {
      ({
        node,
        offset
      } = getStartOfCodeInLine(focusNode));
    } else {
      ({
        node,
        offset
      } = getEndOfCodeInLine(focusNode));
    }
    if (node !== null && offset !== -1) {
      selection.setTextNodeRange(node, offset, node, offset);
    }
    event.preventDefault();
    event.stopPropagation();
    return true;
  }
  function registerCodeHighlighting(editor, tokenizer) {
    if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {
      throw new Error("CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor");
    }
    if (tokenizer == null) {
      tokenizer = PrismTokenizer;
    }
    return utils.mergeRegister(editor.registerMutationListener(CodeNode, (mutations) => {
      editor.update(() => {
        for (const [key, type2] of mutations) {
          if (type2 !== "destroyed") {
            const node = lexical.$getNodeByKey(key);
            if (node !== null) {
              updateCodeGutter(node, editor);
            }
          }
        }
      });
    }), editor.registerNodeTransform(CodeNode, (node) => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(lexical.TextNode, (node) => textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, (node) => textNodeTransform(node, editor, tokenizer)), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, (payload) => handleMultilineIndent(lexical.INDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, (payload) => handleMultilineIndent(lexical.OUTDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, (payload) => handleShiftLines(lexical.KEY_ARROW_UP_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, (payload) => handleShiftLines(lexical.KEY_ARROW_DOWN_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_END, (payload) => handleMoveTo(lexical.MOVE_TO_END, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_START, (payload) => handleMoveTo(lexical.MOVE_TO_START, payload), lexical.COMMAND_PRIORITY_LOW));
  }
  LexicalCode_dev.$createCodeHighlightNode = $createCodeHighlightNode;
  LexicalCode_dev.$createCodeNode = $createCodeNode;
  LexicalCode_dev.$isCodeHighlightNode = $isCodeHighlightNode;
  LexicalCode_dev.$isCodeNode = $isCodeNode;
  LexicalCode_dev.CODE_LANGUAGE_FRIENDLY_NAME_MAP = CODE_LANGUAGE_FRIENDLY_NAME_MAP;
  LexicalCode_dev.CODE_LANGUAGE_MAP = CODE_LANGUAGE_MAP;
  LexicalCode_dev.CodeHighlightNode = CodeHighlightNode;
  LexicalCode_dev.CodeNode = CodeNode;
  LexicalCode_dev.DEFAULT_CODE_LANGUAGE = DEFAULT_CODE_LANGUAGE;
  LexicalCode_dev.PrismTokenizer = PrismTokenizer;
  LexicalCode_dev.getCodeLanguages = getCodeLanguages;
  LexicalCode_dev.getDefaultCodeLanguage = getDefaultCodeLanguage;
  LexicalCode_dev.getEndOfCodeInLine = getEndOfCodeInLine;
  LexicalCode_dev.getFirstCodeHighlightNodeOfLine = getFirstCodeHighlightNodeOfLine;
  LexicalCode_dev.getLanguageFriendlyName = getLanguageFriendlyName;
  LexicalCode_dev.getLastCodeHighlightNodeOfLine = getLastCodeHighlightNodeOfLine;
  LexicalCode_dev.getStartOfCodeInLine = getStartOfCodeInLine;
  LexicalCode_dev.normalizeCodeLang = normalizeCodeLang;
  LexicalCode_dev.registerCodeHighlighting = registerCodeHighlighting;
  return LexicalCode_dev;
}
var LexicalCode = true ? requireLexicalCode_dev() : requireLexicalCode_prod();
var LexicalCode_1 = LexicalCode;
var LexicalLink_dev = {};
var hasRequiredLexicalLink_dev;
function requireLexicalLink_dev() {
  if (hasRequiredLexicalLink_dev)
    return LexicalLink_dev;
  hasRequiredLexicalLink_dev = 1;
  var utils = requireLexicalUtils();
  var lexical = import_lexical.default;
  class LinkNode extends lexical.ElementNode {
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "link";
    }
    static clone(node) {
      return new LinkNode(node.__url, {
        rel: node.__rel,
        target: node.__target
      }, node.__key);
    }
    constructor(url, attributes = {}, key) {
      super(key);
      const {
        target = null,
        rel = null
      } = attributes;
      this.__url = url;
      this.__target = target;
      this.__rel = rel;
    }
    createDOM(config) {
      const element = document.createElement("a");
      element.href = this.__url;
      if (this.__target !== null) {
        element.target = this.__target;
      }
      if (this.__rel !== null) {
        element.rel = this.__rel;
      }
      utils.addClassNamesToElement(element, config.theme.link);
      return element;
    }
    updateDOM(prevNode, anchor, config) {
      const url = this.__url;
      const target = this.__target;
      const rel = this.__rel;
      if (url !== prevNode.__url) {
        anchor.href = url;
      }
      if (target !== prevNode.__target) {
        if (target) {
          anchor.target = target;
        } else {
          anchor.removeAttribute("target");
        }
      }
      if (rel !== prevNode.__rel) {
        if (rel) {
          anchor.rel = rel;
        } else {
          anchor.removeAttribute("rel");
        }
      }
      return false;
    }
    static importDOM() {
      return {
        a: (node) => ({
          conversion: convertAnchorElement,
          priority: 1
        })
      };
    }
    static importJSON(serializedNode) {
      const node = $createLinkNode(serializedNode.url, {
        rel: serializedNode.rel,
        target: serializedNode.target
      });
      node.setFormat(serializedNode.format);
      node.setIndent(serializedNode.indent);
      node.setDirection(serializedNode.direction);
      return node;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        rel: this.getRel(),
        target: this.getTarget(),
        type: "link",
        url: this.getURL(),
        version: 1
      };
    }
    getURL() {
      return this.getLatest().__url;
    }
    setURL(url) {
      const writable = this.getWritable();
      writable.__url = url;
    }
    getTarget() {
      return this.getLatest().__target;
    }
    setTarget(target) {
      const writable = this.getWritable();
      writable.__target = target;
    }
    getRel() {
      return this.getLatest().__rel;
    }
    setRel(rel) {
      const writable = this.getWritable();
      writable.__rel = rel;
    }
    insertNewAfter(selection, restoreSelection = true) {
      const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);
      if (lexical.$isElementNode(element)) {
        const linkNode = $createLinkNode(this.__url, {
          rel: this.__rel,
          target: this.__target
        });
        element.append(linkNode);
        return linkNode;
      }
      return null;
    }
    canInsertTextBefore() {
      return false;
    }
    canInsertTextAfter() {
      return false;
    }
    canBeEmpty() {
      return false;
    }
    isInline() {
      return true;
    }
    extractWithChild(child, selection, destination) {
      if (!lexical.$isRangeSelection(selection)) {
        return false;
      }
      const anchorNode = selection.anchor.getNode();
      const focusNode = selection.focus.getNode();
      return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;
    }
  }
  function convertAnchorElement(domNode) {
    let node = null;
    if (utils.isHTMLAnchorElement(domNode)) {
      const content = domNode.textContent;
      if (content !== null && content !== "") {
        node = $createLinkNode(domNode.getAttribute("href") || "", {
          rel: domNode.getAttribute("rel"),
          target: domNode.getAttribute("target")
        });
      }
    }
    return {
      node
    };
  }
  function $createLinkNode(url, attributes) {
    return lexical.$applyNodeReplacement(new LinkNode(url, attributes));
  }
  function $isLinkNode(node) {
    return node instanceof LinkNode;
  }
  class AutoLinkNode extends LinkNode {
    static getType() {
      return "autolink";
    }
    static clone(node) {
      return new AutoLinkNode(node.__url, {
        rel: node.__rel,
        target: node.__target
      }, node.__key);
    }
    static importJSON(serializedNode) {
      const node = $createAutoLinkNode(serializedNode.url, {
        rel: serializedNode.rel,
        target: serializedNode.target
      });
      node.setFormat(serializedNode.format);
      node.setIndent(serializedNode.indent);
      node.setDirection(serializedNode.direction);
      return node;
    }
    static importDOM() {
      return null;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "autolink",
        version: 1
      };
    }
    insertNewAfter(selection, restoreSelection = true) {
      const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);
      if (lexical.$isElementNode(element)) {
        const linkNode = $createAutoLinkNode(this.__url, {
          rel: this._rel,
          target: this.__target
        });
        element.append(linkNode);
        return linkNode;
      }
      return null;
    }
  }
  function $createAutoLinkNode(url, attributes) {
    return lexical.$applyNodeReplacement(new AutoLinkNode(url, attributes));
  }
  function $isAutoLinkNode(node) {
    return node instanceof AutoLinkNode;
  }
  const TOGGLE_LINK_COMMAND = lexical.createCommand("TOGGLE_LINK_COMMAND");
  function toggleLink(url, attributes = {}) {
    const {
      target
    } = attributes;
    const rel = attributes.rel === void 0 ? "noopener" : attributes.rel;
    const selection = lexical.$getSelection();
    if (!lexical.$isRangeSelection(selection)) {
      return;
    }
    const nodes = selection.extract();
    if (url === null) {
      nodes.forEach((node) => {
        const parent = node.getParent();
        if ($isLinkNode(parent)) {
          const children = parent.getChildren();
          for (let i = 0; i < children.length; i++) {
            parent.insertBefore(children[i]);
          }
          parent.remove();
        }
      });
    } else {
      if (nodes.length === 1) {
        const firstNode = nodes[0];
        const linkNode2 = $isLinkNode(firstNode) ? firstNode : $getLinkAncestor(firstNode);
        if (linkNode2 !== null) {
          linkNode2.setURL(url);
          if (target !== void 0) {
            linkNode2.setTarget(target);
          }
          if (rel !== null) {
            linkNode2.setRel(rel);
          }
          return;
        }
      }
      let prevParent = null;
      let linkNode = null;
      nodes.forEach((node) => {
        const parent = node.getParent();
        if (parent === linkNode || parent === null || lexical.$isElementNode(node) && !node.isInline()) {
          return;
        }
        if ($isLinkNode(parent)) {
          linkNode = parent;
          parent.setURL(url);
          if (target !== void 0) {
            parent.setTarget(target);
          }
          if (rel !== null) {
            linkNode.setRel(rel);
          }
          return;
        }
        if (!parent.is(prevParent)) {
          prevParent = parent;
          linkNode = $createLinkNode(url, {
            rel,
            target
          });
          if ($isLinkNode(parent)) {
            if (node.getPreviousSibling() === null) {
              parent.insertBefore(linkNode);
            } else {
              parent.insertAfter(linkNode);
            }
          } else {
            node.insertBefore(linkNode);
          }
        }
        if ($isLinkNode(node)) {
          if (node.is(linkNode)) {
            return;
          }
          if (linkNode !== null) {
            const children = node.getChildren();
            for (let i = 0; i < children.length; i++) {
              linkNode.append(children[i]);
            }
          }
          node.remove();
          return;
        }
        if (linkNode !== null) {
          linkNode.append(node);
        }
      });
    }
  }
  function $getLinkAncestor(node) {
    return $getAncestor(node, (ancestor) => $isLinkNode(ancestor));
  }
  function $getAncestor(node, predicate) {
    let parent = node;
    while (parent !== null && (parent = parent.getParent()) !== null && !predicate(parent))
      ;
    return parent;
  }
  LexicalLink_dev.$createAutoLinkNode = $createAutoLinkNode;
  LexicalLink_dev.$createLinkNode = $createLinkNode;
  LexicalLink_dev.$isAutoLinkNode = $isAutoLinkNode;
  LexicalLink_dev.$isLinkNode = $isLinkNode;
  LexicalLink_dev.AutoLinkNode = AutoLinkNode;
  LexicalLink_dev.LinkNode = LinkNode;
  LexicalLink_dev.TOGGLE_LINK_COMMAND = TOGGLE_LINK_COMMAND;
  LexicalLink_dev.toggleLink = toggleLink;
  return LexicalLink_dev;
}
var LexicalLink = true ? requireLexicalLink_dev() : requireLexicalLink_prod();
var LexicalLink_1 = LexicalLink;
var LexicalList_dev = {};
var hasRequiredLexicalList_dev;
function requireLexicalList_dev() {
  if (hasRequiredLexicalList_dev)
    return LexicalList_dev;
  hasRequiredLexicalList_dev = 1;
  var lexical = import_lexical.default;
  var utils = requireLexicalUtils();
  function $getListDepth(listNode) {
    let depth = 1;
    let parent = listNode.getParent();
    while (parent != null) {
      if ($isListItemNode(parent)) {
        const parentList = parent.getParent();
        if ($isListNode(parentList)) {
          depth++;
          parent = parentList.getParent();
          continue;
        }
        {
          throw Error(`A ListItemNode must have a ListNode for a parent.`);
        }
      }
      return depth;
    }
    return depth;
  }
  function $getTopListNode(listItem) {
    let list = listItem.getParent();
    if (!$isListNode(list)) {
      {
        throw Error(`A ListItemNode must have a ListNode for a parent.`);
      }
    }
    let parent = list;
    while (parent !== null) {
      parent = parent.getParent();
      if ($isListNode(parent)) {
        list = parent;
      }
    }
    return list;
  }
  function $getAllListItems(node) {
    let listItemNodes = [];
    const listChildren = node.getChildren().filter($isListItemNode);
    for (let i = 0; i < listChildren.length; i++) {
      const listItemNode = listChildren[i];
      const firstChild = listItemNode.getFirstChild();
      if ($isListNode(firstChild)) {
        listItemNodes = listItemNodes.concat($getAllListItems(firstChild));
      } else {
        listItemNodes.push(listItemNode);
      }
    }
    return listItemNodes;
  }
  function isNestedListNode(node) {
    return $isListItemNode(node) && $isListNode(node.getFirstChild());
  }
  function $removeHighestEmptyListParent(sublist) {
    let emptyListPtr = sublist;
    while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {
      const parent = emptyListPtr.getParent();
      if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {
        break;
      }
      emptyListPtr = parent;
    }
    emptyListPtr.remove();
  }
  function wrapInListItem(node) {
    const listItemWrapper = $createListItemNode();
    return listItemWrapper.append(node);
  }
  function $isSelectingEmptyListItem(anchorNode, nodes) {
    return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);
  }
  function $getListItemValue(listItem) {
    const list = listItem.getParent();
    let value22 = 1;
    if (list != null) {
      if (!$isListNode(list)) {
        {
          throw Error(`$getListItemValue: list node is not parent of list item node`);
        }
      } else {
        value22 = list.getStart();
      }
    }
    const siblings = listItem.getPreviousSiblings();
    for (let i = 0; i < siblings.length; i++) {
      const sibling = siblings[i];
      if ($isListItemNode(sibling) && !$isListNode(sibling.getFirstChild())) {
        value22++;
      }
    }
    return value22;
  }
  function insertList(editor, listType) {
    editor.update(() => {
      const selection = lexical.$getSelection();
      if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {
        const nodes = selection.getNodes();
        const anchor = selection.anchor;
        const anchorNode = anchor.getNode();
        const anchorNodeParent = anchorNode.getParent();
        if ($isSelectingEmptyListItem(anchorNode, nodes)) {
          const list = $createListNode(listType);
          if (lexical.$isRootOrShadowRoot(anchorNodeParent)) {
            anchorNode.replace(list);
            const listItem = $createListItemNode();
            if (lexical.$isElementNode(anchorNode)) {
              listItem.setFormat(anchorNode.getFormatType());
              listItem.setIndent(anchorNode.getIndent());
            }
            list.append(listItem);
          } else if ($isListItemNode(anchorNode)) {
            const parent = anchorNode.getParentOrThrow();
            append2(list, parent.getChildren());
            parent.replace(list);
          }
          return;
        } else {
          const handled = /* @__PURE__ */ new Set();
          for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (lexical.$isElementNode(node) && node.isEmpty() && !handled.has(node.getKey())) {
              createListOrMerge(node, listType);
              continue;
            }
            if (lexical.$isLeafNode(node)) {
              let parent = node.getParent();
              while (parent != null) {
                const parentKey = parent.getKey();
                if ($isListNode(parent)) {
                  if (!handled.has(parentKey)) {
                    const newListNode = $createListNode(listType);
                    append2(newListNode, parent.getChildren());
                    parent.replace(newListNode);
                    updateChildrenListItemValue(newListNode);
                    handled.add(parentKey);
                  }
                  break;
                } else {
                  const nextParent = parent.getParent();
                  if (lexical.$isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {
                    handled.add(parentKey);
                    createListOrMerge(parent, listType);
                    break;
                  }
                  parent = nextParent;
                }
              }
            }
          }
        }
      }
    });
  }
  function append2(node, nodesToAppend) {
    node.splice(node.getChildrenSize(), 0, nodesToAppend);
  }
  function createListOrMerge(node, listType) {
    if ($isListNode(node)) {
      return node;
    }
    const previousSibling = node.getPreviousSibling();
    const nextSibling = node.getNextSibling();
    const listItem = $createListItemNode();
    listItem.setFormat(node.getFormatType());
    listItem.setIndent(node.getIndent());
    append2(listItem, node.getChildren());
    if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {
      previousSibling.append(listItem);
      node.remove();
      if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {
        append2(previousSibling, nextSibling.getChildren());
        nextSibling.remove();
      }
      return previousSibling;
    } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {
      nextSibling.getFirstChildOrThrow().insertBefore(listItem);
      node.remove();
      return nextSibling;
    } else {
      const list = $createListNode(listType);
      list.append(listItem);
      node.replace(list);
      updateChildrenListItemValue(list);
      return list;
    }
  }
  function removeList(editor) {
    editor.update(() => {
      const selection = lexical.$getSelection();
      if (lexical.$isRangeSelection(selection)) {
        const listNodes = /* @__PURE__ */ new Set();
        const nodes = selection.getNodes();
        const anchorNode = selection.anchor.getNode();
        if ($isSelectingEmptyListItem(anchorNode, nodes)) {
          listNodes.add($getTopListNode(anchorNode));
        } else {
          for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (lexical.$isLeafNode(node)) {
              const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode);
              if (listItemNode != null) {
                listNodes.add($getTopListNode(listItemNode));
              }
            }
          }
        }
        for (const listNode of listNodes) {
          let insertionPoint = listNode;
          const listItems = $getAllListItems(listNode);
          for (const listItemNode of listItems) {
            const paragraph = lexical.$createParagraphNode();
            append2(paragraph, listItemNode.getChildren());
            insertionPoint.insertAfter(paragraph);
            insertionPoint = paragraph;
            if (listItemNode.__key === selection.anchor.key) {
              selection.anchor.set(paragraph.getKey(), 0, "element");
            }
            if (listItemNode.__key === selection.focus.key) {
              selection.focus.set(paragraph.getKey(), 0, "element");
            }
            listItemNode.remove();
          }
          listNode.remove();
        }
      }
    });
  }
  function updateChildrenListItemValue(list, children) {
    const childrenOrExisting = children || list.getChildren();
    if (childrenOrExisting !== void 0) {
      for (let i = 0; i < childrenOrExisting.length; i++) {
        const child = childrenOrExisting[i];
        if ($isListItemNode(child)) {
          const prevValue = child.getValue();
          const nextValue = $getListItemValue(child);
          if (prevValue !== nextValue) {
            child.setValue(nextValue);
          }
        }
      }
    }
  }
  function $handleIndent(listItemNode) {
    const removed = /* @__PURE__ */ new Set();
    if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {
      return;
    }
    const parent = listItemNode.getParent();
    const nextSibling = listItemNode.getNextSibling();
    const previousSibling = listItemNode.getPreviousSibling();
    if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {
      const innerList = previousSibling.getFirstChild();
      if ($isListNode(innerList)) {
        innerList.append(listItemNode);
        const nextInnerList = nextSibling.getFirstChild();
        if ($isListNode(nextInnerList)) {
          const children = nextInnerList.getChildren();
          append2(innerList, children);
          nextSibling.remove();
          removed.add(nextSibling.getKey());
        }
        updateChildrenListItemValue(innerList);
      }
    } else if (isNestedListNode(nextSibling)) {
      const innerList = nextSibling.getFirstChild();
      if ($isListNode(innerList)) {
        const firstChild = innerList.getFirstChild();
        if (firstChild !== null) {
          firstChild.insertBefore(listItemNode);
        }
        updateChildrenListItemValue(innerList);
      }
    } else if (isNestedListNode(previousSibling)) {
      const innerList = previousSibling.getFirstChild();
      if ($isListNode(innerList)) {
        innerList.append(listItemNode);
        updateChildrenListItemValue(innerList);
      }
    } else {
      if ($isListNode(parent)) {
        const newListItem = $createListItemNode();
        const newList = $createListNode(parent.getListType());
        newListItem.append(newList);
        newList.append(listItemNode);
        if (previousSibling) {
          previousSibling.insertAfter(newListItem);
        } else if (nextSibling) {
          nextSibling.insertBefore(newListItem);
        } else {
          parent.append(newListItem);
        }
      }
    }
    if ($isListNode(parent)) {
      updateChildrenListItemValue(parent);
    }
  }
  function $handleOutdent(listItemNode) {
    if (isNestedListNode(listItemNode)) {
      return;
    }
    const parentList = listItemNode.getParent();
    const grandparentListItem = parentList ? parentList.getParent() : void 0;
    const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : void 0;
    if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {
      const firstChild = parentList ? parentList.getFirstChild() : void 0;
      const lastChild = parentList ? parentList.getLastChild() : void 0;
      if (listItemNode.is(firstChild)) {
        grandparentListItem.insertBefore(listItemNode);
        if (parentList.isEmpty()) {
          grandparentListItem.remove();
        }
      } else if (listItemNode.is(lastChild)) {
        grandparentListItem.insertAfter(listItemNode);
        if (parentList.isEmpty()) {
          grandparentListItem.remove();
        }
      } else {
        const listType = parentList.getListType();
        const previousSiblingsListItem = $createListItemNode();
        const previousSiblingsList = $createListNode(listType);
        previousSiblingsListItem.append(previousSiblingsList);
        listItemNode.getPreviousSiblings().forEach((sibling) => previousSiblingsList.append(sibling));
        const nextSiblingsListItem = $createListItemNode();
        const nextSiblingsList = $createListNode(listType);
        nextSiblingsListItem.append(nextSiblingsList);
        append2(nextSiblingsList, listItemNode.getNextSiblings());
        grandparentListItem.insertBefore(previousSiblingsListItem);
        grandparentListItem.insertAfter(nextSiblingsListItem);
        grandparentListItem.replace(listItemNode);
      }
      updateChildrenListItemValue(parentList);
      updateChildrenListItemValue(greatGrandparentList);
    }
  }
  function $handleListInsertParagraph() {
    const selection = lexical.$getSelection();
    if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {
      return false;
    }
    const anchor = selection.anchor.getNode();
    if (!$isListItemNode(anchor) || anchor.getTextContent() !== "") {
      return false;
    }
    const topListNode = $getTopListNode(anchor);
    const parent = anchor.getParent();
    if (!$isListNode(parent)) {
      throw Error(`A ListItemNode must have a ListNode for a parent.`);
    }
    const grandparent = parent.getParent();
    let replacementNode;
    if (lexical.$isRootOrShadowRoot(grandparent)) {
      replacementNode = lexical.$createParagraphNode();
      topListNode.insertAfter(replacementNode);
    } else if ($isListItemNode(grandparent)) {
      replacementNode = $createListItemNode();
      grandparent.insertAfter(replacementNode);
    } else {
      return false;
    }
    replacementNode.select();
    const nextSiblings = anchor.getNextSiblings();
    if (nextSiblings.length > 0) {
      const newList = $createListNode(parent.getListType());
      if (lexical.$isParagraphNode(replacementNode)) {
        replacementNode.insertAfter(newList);
      } else {
        const newListItem = $createListItemNode();
        newListItem.append(newList);
        replacementNode.insertAfter(newListItem);
      }
      nextSiblings.forEach((sibling) => {
        sibling.remove();
        newList.append(sibling);
      });
    }
    $removeHighestEmptyListParent(anchor);
    return true;
  }
  class ListItemNode extends lexical.ElementNode {
    /** @internal */
    /** @internal */
    static getType() {
      return "listitem";
    }
    static clone(node) {
      return new ListItemNode(node.__value, node.__checked, node.__key);
    }
    constructor(value22, checked, key) {
      super(key);
      this.__value = value22 === void 0 ? 1 : value22;
      this.__checked = checked;
    }
    createDOM(config) {
      const element = document.createElement("li");
      const parent = this.getParent();
      if ($isListNode(parent)) {
        updateChildrenListItemValue(parent);
        updateListItemChecked(element, this, null, parent);
      }
      element.value = this.__value;
      $setListItemThemeClassNames(element, config.theme, this);
      return element;
    }
    updateDOM(prevNode, dom, config) {
      const parent = this.getParent();
      if ($isListNode(parent)) {
        updateChildrenListItemValue(parent);
        updateListItemChecked(dom, this, prevNode, parent);
      }
      dom.value = this.__value;
      $setListItemThemeClassNames(dom, config.theme, this);
      return false;
    }
    static importDOM() {
      return {
        li: (node) => ({
          conversion: convertListItemElement,
          priority: 0
        })
      };
    }
    static importJSON(serializedNode) {
      const node = new ListItemNode(serializedNode.value, serializedNode.checked);
      node.setFormat(serializedNode.format);
      node.setIndent(serializedNode.indent);
      node.setDirection(serializedNode.direction);
      return node;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        checked: this.getChecked(),
        type: "listitem",
        value: this.getValue(),
        version: 1
      };
    }
    append(...nodes) {
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (lexical.$isElementNode(node) && this.canMergeWith(node)) {
          const children = node.getChildren();
          this.append(...children);
          node.remove();
        } else {
          super.append(node);
        }
      }
      return this;
    }
    replace(replaceWithNode, includeChildren) {
      if ($isListItemNode(replaceWithNode)) {
        return super.replace(replaceWithNode);
      }
      const list = this.getParentOrThrow();
      if ($isListNode(list)) {
        const childrenKeys = list.getChildrenKeys();
        const childrenLength = childrenKeys.length;
        const index2 = childrenKeys.indexOf(this.__key);
        if (index2 === 0) {
          list.insertBefore(replaceWithNode);
        } else if (index2 === childrenLength - 1) {
          list.insertAfter(replaceWithNode);
        } else {
          const newList = $createListNode(list.getListType());
          const children = list.getChildren();
          for (let i = index2 + 1; i < childrenLength; i++) {
            const child = children[i];
            newList.append(child);
          }
          list.insertAfter(replaceWithNode);
          replaceWithNode.insertAfter(newList);
        }
        if (includeChildren) {
          this.getChildren().forEach((child) => {
            replaceWithNode.append(child);
          });
        }
        this.remove();
        if (childrenLength === 1) {
          list.remove();
        }
      }
      return replaceWithNode;
    }
    insertAfter(node, restoreSelection = true) {
      const listNode = this.getParentOrThrow();
      if (!$isListNode(listNode)) {
        {
          throw Error(`insertAfter: list node is not parent of list item node`);
        }
      }
      const siblings = this.getNextSiblings();
      if ($isListItemNode(node)) {
        const after = super.insertAfter(node, restoreSelection);
        const afterListNode = node.getParentOrThrow();
        if ($isListNode(afterListNode)) {
          updateChildrenListItemValue(afterListNode);
        }
        return after;
      }
      if ($isListNode(node) && node.getListType() === listNode.getListType()) {
        let child = node;
        const children = node.getChildren();
        for (let i = children.length - 1; i >= 0; i--) {
          child = children[i];
          this.insertAfter(child, restoreSelection);
        }
        return child;
      }
      listNode.insertAfter(node, restoreSelection);
      if (siblings.length !== 0) {
        const newListNode = $createListNode(listNode.getListType());
        siblings.forEach((sibling) => newListNode.append(sibling));
        node.insertAfter(newListNode, restoreSelection);
      }
      return node;
    }
    remove(preserveEmptyParent) {
      const nextSibling = this.getNextSibling();
      super.remove(preserveEmptyParent);
      if (nextSibling !== null) {
        const parent = nextSibling.getParent();
        if ($isListNode(parent)) {
          updateChildrenListItemValue(parent);
        }
      }
    }
    insertNewAfter(_, restoreSelection = true) {
      const newElement = $createListItemNode(this.__checked == null ? void 0 : false);
      this.insertAfter(newElement, restoreSelection);
      return newElement;
    }
    collapseAtStart(selection) {
      const paragraph = lexical.$createParagraphNode();
      const children = this.getChildren();
      children.forEach((child) => paragraph.append(child));
      const listNode = this.getParentOrThrow();
      const listNodeParent = listNode.getParentOrThrow();
      const isIndented = $isListItemNode(listNodeParent);
      if (listNode.getChildrenSize() === 1) {
        if (isIndented) {
          listNode.remove();
          listNodeParent.select();
        } else {
          listNode.insertBefore(paragraph);
          listNode.remove();
          const anchor = selection.anchor;
          const focus = selection.focus;
          const key = paragraph.getKey();
          if (anchor.type === "element" && anchor.getNode().is(this)) {
            anchor.set(key, anchor.offset, "element");
          }
          if (focus.type === "element" && focus.getNode().is(this)) {
            focus.set(key, focus.offset, "element");
          }
        }
      } else {
        listNode.insertBefore(paragraph);
        this.remove();
      }
      return true;
    }
    getValue() {
      const self2 = this.getLatest();
      return self2.__value;
    }
    setValue(value22) {
      const self2 = this.getWritable();
      self2.__value = value22;
    }
    getChecked() {
      const self2 = this.getLatest();
      return self2.__checked;
    }
    setChecked(checked) {
      const self2 = this.getWritable();
      self2.__checked = checked;
    }
    toggleChecked() {
      this.setChecked(!this.__checked);
    }
    getIndent() {
      const parent = this.getParent();
      if (parent === null) {
        return this.getLatest().__indent;
      }
      let listNodeParent = parent.getParentOrThrow();
      let indentLevel = 0;
      while ($isListItemNode(listNodeParent)) {
        listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();
        indentLevel++;
      }
      return indentLevel;
    }
    setIndent(indent) {
      let currentIndent = this.getIndent();
      while (currentIndent !== indent) {
        if (currentIndent < indent) {
          $handleIndent(this);
          currentIndent++;
        } else {
          $handleOutdent(this);
          currentIndent--;
        }
      }
      return this;
    }
    insertBefore(nodeToInsert) {
      if ($isListItemNode(nodeToInsert)) {
        const parent = this.getParentOrThrow();
        if ($isListNode(parent)) {
          const siblings = this.getNextSiblings();
          updateChildrenListItemValue(parent, siblings);
        }
      }
      return super.insertBefore(nodeToInsert);
    }
    canInsertAfter(node) {
      return $isListItemNode(node);
    }
    canReplaceWith(replacement) {
      return $isListItemNode(replacement);
    }
    canMergeWith(node) {
      return lexical.$isParagraphNode(node) || $isListItemNode(node);
    }
    extractWithChild(child, selection) {
      if (!lexical.$isRangeSelection(selection)) {
        return false;
      }
      const anchorNode = selection.anchor.getNode();
      const focusNode = selection.focus.getNode();
      return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;
    }
    isParentRequired() {
      return true;
    }
    createParentElementNode() {
      return $createListNode("bullet");
    }
  }
  function $setListItemThemeClassNames(dom, editorThemeClasses, node) {
    const classesToAdd = [];
    const classesToRemove = [];
    const listTheme = editorThemeClasses.list;
    const listItemClassName = listTheme ? listTheme.listitem : void 0;
    let nestedListItemClassName;
    if (listTheme && listTheme.nested) {
      nestedListItemClassName = listTheme.nested.listitem;
    }
    if (listItemClassName !== void 0) {
      const listItemClasses = listItemClassName.split(" ");
      classesToAdd.push(...listItemClasses);
    }
    if (listTheme) {
      const parentNode = node.getParent();
      const isCheckList = $isListNode(parentNode) && parentNode.getListType() === "check";
      const checked = node.getChecked();
      if (!isCheckList || checked) {
        classesToRemove.push(listTheme.listitemUnchecked);
      }
      if (!isCheckList || !checked) {
        classesToRemove.push(listTheme.listitemChecked);
      }
      if (isCheckList) {
        classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);
      }
    }
    if (nestedListItemClassName !== void 0) {
      const nestedListItemClasses = nestedListItemClassName.split(" ");
      if (node.getChildren().some((child) => $isListNode(child))) {
        classesToAdd.push(...nestedListItemClasses);
      } else {
        classesToRemove.push(...nestedListItemClasses);
      }
    }
    if (classesToRemove.length > 0) {
      utils.removeClassNamesFromElement(dom, ...classesToRemove);
    }
    if (classesToAdd.length > 0) {
      utils.addClassNamesToElement(dom, ...classesToAdd);
    }
  }
  function updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {
    const isCheckList = listNode.getListType() === "check";
    if (isCheckList) {
      if ($isListNode(listItemNode.getFirstChild())) {
        dom.removeAttribute("role");
        dom.removeAttribute("tabIndex");
        dom.removeAttribute("aria-checked");
      } else {
        dom.setAttribute("role", "checkbox");
        dom.setAttribute("tabIndex", "-1");
        if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {
          dom.setAttribute("aria-checked", listItemNode.getChecked() ? "true" : "false");
        }
      }
    } else {
      if (listItemNode.getChecked() != null) {
        listItemNode.setChecked(void 0);
      }
    }
  }
  function convertListItemElement(domNode) {
    const checked = utils.isHTMLElement(domNode) && domNode.getAttribute("aria-checked") === "true";
    return {
      node: $createListItemNode(checked)
    };
  }
  function $createListItemNode(checked) {
    return lexical.$applyNodeReplacement(new ListItemNode(void 0, checked));
  }
  function $isListItemNode(node) {
    return node instanceof ListItemNode;
  }
  class ListNode extends lexical.ElementNode {
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "list";
    }
    static clone(node) {
      const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];
      return new ListNode(listType, node.__start, node.__key);
    }
    constructor(listType, start, key) {
      super(key);
      const _listType = TAG_TO_LIST_TYPE[listType] || listType;
      this.__listType = _listType;
      this.__tag = _listType === "number" ? "ol" : "ul";
      this.__start = start;
    }
    getTag() {
      return this.__tag;
    }
    getListType() {
      return this.__listType;
    }
    getStart() {
      return this.__start;
    }
    // View
    createDOM(config, _editor) {
      const tag = this.__tag;
      const dom = document.createElement(tag);
      if (this.__start !== 1) {
        dom.setAttribute("start", String(this.__start));
      }
      dom.__lexicalListType = this.__listType;
      setListThemeClassNames(dom, config.theme, this);
      return dom;
    }
    updateDOM(prevNode, dom, config) {
      if (prevNode.__tag !== this.__tag) {
        return true;
      }
      setListThemeClassNames(dom, config.theme, this);
      return false;
    }
    static importDOM() {
      return {
        ol: (node) => ({
          conversion: convertListNode,
          priority: 0
        }),
        ul: (node) => ({
          conversion: convertListNode,
          priority: 0
        })
      };
    }
    static importJSON(serializedNode) {
      const node = $createListNode(serializedNode.listType, serializedNode.start);
      node.setFormat(serializedNode.format);
      node.setIndent(serializedNode.indent);
      node.setDirection(serializedNode.direction);
      return node;
    }
    exportDOM(editor) {
      const {
        element
      } = super.exportDOM(editor);
      if (element) {
        if (this.__start !== 1) {
          element.setAttribute("start", String(this.__start));
        }
        if (this.__listType === "check") {
          element.setAttribute("__lexicalListType", "check");
        }
      }
      return {
        element
      };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        listType: this.getListType(),
        start: this.getStart(),
        tag: this.getTag(),
        type: "list",
        version: 1
      };
    }
    canBeEmpty() {
      return false;
    }
    canIndent() {
      return false;
    }
    append(...nodesToAppend) {
      for (let i = 0; i < nodesToAppend.length; i++) {
        const currentNode = nodesToAppend[i];
        if ($isListItemNode(currentNode)) {
          super.append(currentNode);
        } else {
          const listItemNode = $createListItemNode();
          if ($isListNode(currentNode)) {
            listItemNode.append(currentNode);
          } else if (lexical.$isElementNode(currentNode)) {
            const textNode = lexical.$createTextNode(currentNode.getTextContent());
            listItemNode.append(textNode);
          } else {
            listItemNode.append(currentNode);
          }
          super.append(listItemNode);
        }
      }
      return this;
    }
    extractWithChild(child) {
      return $isListItemNode(child);
    }
  }
  function setListThemeClassNames(dom, editorThemeClasses, node) {
    const classesToAdd = [];
    const classesToRemove = [];
    const listTheme = editorThemeClasses.list;
    if (listTheme !== void 0) {
      const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];
      const listDepth = $getListDepth(node) - 1;
      const normalizedListDepth = listDepth % listLevelsClassNames.length;
      const listLevelClassName = listLevelsClassNames[normalizedListDepth];
      const listClassName = listTheme[node.__tag];
      let nestedListClassName;
      const nestedListTheme = listTheme.nested;
      if (nestedListTheme !== void 0 && nestedListTheme.list) {
        nestedListClassName = nestedListTheme.list;
      }
      if (listClassName !== void 0) {
        classesToAdd.push(listClassName);
      }
      if (listLevelClassName !== void 0) {
        const listItemClasses = listLevelClassName.split(" ");
        classesToAdd.push(...listItemClasses);
        for (let i = 0; i < listLevelsClassNames.length; i++) {
          if (i !== normalizedListDepth) {
            classesToRemove.push(node.__tag + i);
          }
        }
      }
      if (nestedListClassName !== void 0) {
        const nestedListItemClasses = nestedListClassName.split(" ");
        if (listDepth > 1) {
          classesToAdd.push(...nestedListItemClasses);
        } else {
          classesToRemove.push(...nestedListItemClasses);
        }
      }
    }
    if (classesToRemove.length > 0) {
      utils.removeClassNamesFromElement(dom, ...classesToRemove);
    }
    if (classesToAdd.length > 0) {
      utils.addClassNamesToElement(dom, ...classesToAdd);
    }
  }
  function normalizeChildren(nodes) {
    const normalizedListItems = [];
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if ($isListItemNode(node)) {
        normalizedListItems.push(node);
        const children = node.getChildren();
        if (children.length > 1) {
          children.forEach((child) => {
            if ($isListNode(child)) {
              normalizedListItems.push(wrapInListItem(child));
            }
          });
        }
      } else {
        normalizedListItems.push(wrapInListItem(node));
      }
    }
    return normalizedListItems;
  }
  function convertListNode(domNode) {
    const nodeName = domNode.nodeName.toLowerCase();
    let node = null;
    if (nodeName === "ol") {
      node = $createListNode("number");
    } else if (nodeName === "ul") {
      if (utils.isHTMLElement(domNode) && domNode.getAttribute("__lexicallisttype") === "check") {
        node = $createListNode("check");
      } else {
        node = $createListNode("bullet");
      }
    }
    return {
      after: normalizeChildren,
      node
    };
  }
  const TAG_TO_LIST_TYPE = {
    ol: "number",
    ul: "bullet"
  };
  function $createListNode(listType, start = 1) {
    return lexical.$applyNodeReplacement(new ListNode(listType, start));
  }
  function $isListNode(node) {
    return node instanceof ListNode;
  }
  const INSERT_UNORDERED_LIST_COMMAND = lexical.createCommand("INSERT_UNORDERED_LIST_COMMAND");
  const INSERT_ORDERED_LIST_COMMAND = lexical.createCommand("INSERT_ORDERED_LIST_COMMAND");
  const INSERT_CHECK_LIST_COMMAND = lexical.createCommand("INSERT_CHECK_LIST_COMMAND");
  const REMOVE_LIST_COMMAND = lexical.createCommand("REMOVE_LIST_COMMAND");
  LexicalList_dev.$createListItemNode = $createListItemNode;
  LexicalList_dev.$createListNode = $createListNode;
  LexicalList_dev.$getListDepth = $getListDepth;
  LexicalList_dev.$handleListInsertParagraph = $handleListInsertParagraph;
  LexicalList_dev.$isListItemNode = $isListItemNode;
  LexicalList_dev.$isListNode = $isListNode;
  LexicalList_dev.INSERT_CHECK_LIST_COMMAND = INSERT_CHECK_LIST_COMMAND;
  LexicalList_dev.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND;
  LexicalList_dev.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND;
  LexicalList_dev.ListItemNode = ListItemNode;
  LexicalList_dev.ListNode = ListNode;
  LexicalList_dev.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND;
  LexicalList_dev.insertList = insertList;
  LexicalList_dev.removeList = removeList;
  return LexicalList_dev;
}
var LexicalList = true ? requireLexicalList_dev() : requireLexicalList_prod();
var LexicalList_1 = LexicalList;
var LexicalMarkdown_dev = {};
var LexicalRichText_dev = {};
var LexicalClipboard_dev = {};
var LexicalHtml_dev = {};
var hasRequiredLexicalHtml_dev;
function requireLexicalHtml_dev() {
  if (hasRequiredLexicalHtml_dev)
    return LexicalHtml_dev;
  hasRequiredLexicalHtml_dev = 1;
  var selection = requireLexicalSelection();
  var lexical = import_lexical.default;
  function $generateNodesFromDOM(editor, dom) {
    let lexicalNodes = [];
    const elements = dom.body ? Array.from(dom.body.childNodes) : [];
    const elementsLength = elements.length;
    for (let i = 0; i < elementsLength; i++) {
      const element = elements[i];
      if (!IGNORE_TAGS.has(element.nodeName)) {
        const lexicalNode = $createNodesFromDOM(element, editor);
        if (lexicalNode !== null) {
          lexicalNodes = lexicalNodes.concat(lexicalNode);
        }
      }
    }
    return lexicalNodes;
  }
  function $generateHtmlFromNodes(editor, selection2) {
    if (typeof document === "undefined" || typeof window === "undefined") {
      throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
    }
    const container = document.createElement("div");
    const root = lexical.$getRoot();
    const topLevelChildren = root.getChildren();
    for (let i = 0; i < topLevelChildren.length; i++) {
      const topLevelNode = topLevelChildren[i];
      $appendNodesToHTML(editor, topLevelNode, container, selection2);
    }
    return container.innerHTML;
  }
  function $appendNodesToHTML(editor, currentNode, parentElement, selection$1 = null) {
    let shouldInclude = selection$1 != null ? currentNode.isSelected() : true;
    const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy("html");
    let target = currentNode;
    if (selection$1 !== null) {
      let clone = selection.$cloneWithProperties(currentNode);
      clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;
      target = clone;
    }
    const children = lexical.$isElementNode(target) ? target.getChildren() : [];
    const {
      element,
      after
    } = target.exportDOM(editor);
    if (!element) {
      return false;
    }
    const fragment = new DocumentFragment();
    for (let i = 0; i < children.length; i++) {
      const childNode = children[i];
      const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);
      if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, "html")) {
        shouldInclude = true;
      }
    }
    if (shouldInclude && !shouldExclude) {
      element.append(fragment);
      parentElement.append(element);
      if (after) {
        const newElement = after.call(target, element);
        if (newElement)
          element.replaceWith(newElement);
      }
    } else {
      parentElement.append(fragment);
    }
    return shouldInclude;
  }
  function getConversionFunction(domNode, editor) {
    const {
      nodeName
    } = domNode;
    const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());
    let currentConversion = null;
    if (cachedConversions !== void 0) {
      for (const cachedConversion of cachedConversions) {
        const domConversion = cachedConversion(domNode);
        if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {
          currentConversion = domConversion;
        }
      }
    }
    return currentConversion !== null ? currentConversion.conversion : null;
  }
  const IGNORE_TAGS = /* @__PURE__ */ new Set(["STYLE"]);
  function $createNodesFromDOM(node, editor, forChildMap = /* @__PURE__ */ new Map(), parentLexicalNode, preformatted = false) {
    let lexicalNodes = [];
    if (IGNORE_TAGS.has(node.nodeName)) {
      return lexicalNodes;
    }
    let currentLexicalNode = null;
    const transformFunction = getConversionFunction(node, editor);
    const transformOutput = transformFunction ? transformFunction(node, void 0, preformatted) : null;
    let postTransform = null;
    if (transformOutput !== null) {
      postTransform = transformOutput.after;
      currentLexicalNode = transformOutput.node;
      if (currentLexicalNode !== null) {
        for (const [, forChildFunction] of forChildMap) {
          currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);
          if (!currentLexicalNode) {
            break;
          }
        }
        if (currentLexicalNode) {
          lexicalNodes.push(currentLexicalNode);
        }
      }
      if (transformOutput.forChild != null) {
        forChildMap.set(node.nodeName, transformOutput.forChild);
      }
    }
    const children = node.childNodes;
    let childLexicalNodes = [];
    for (let i = 0; i < children.length; i++) {
      childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode, preformatted || (transformOutput && transformOutput.preformatted) === true));
    }
    if (postTransform != null) {
      childLexicalNodes = postTransform(childLexicalNodes);
    }
    if (currentLexicalNode == null) {
      lexicalNodes = lexicalNodes.concat(childLexicalNodes);
    } else {
      if (lexical.$isElementNode(currentLexicalNode)) {
        currentLexicalNode.append(...childLexicalNodes);
      }
    }
    return lexicalNodes;
  }
  LexicalHtml_dev.$generateHtmlFromNodes = $generateHtmlFromNodes;
  LexicalHtml_dev.$generateNodesFromDOM = $generateNodesFromDOM;
  return LexicalHtml_dev;
}
var LexicalHtml_1;
var hasRequiredLexicalHtml;
function requireLexicalHtml() {
  if (hasRequiredLexicalHtml)
    return LexicalHtml_1;
  hasRequiredLexicalHtml = 1;
  const LexicalHtml = true ? requireLexicalHtml_dev() : requireLexicalHtml_prod();
  LexicalHtml_1 = LexicalHtml;
  return LexicalHtml_1;
}
var hasRequiredLexicalClipboard_dev;
function requireLexicalClipboard_dev() {
  if (hasRequiredLexicalClipboard_dev)
    return LexicalClipboard_dev;
  hasRequiredLexicalClipboard_dev = 1;
  var html2 = requireLexicalHtml();
  var selection = requireLexicalSelection();
  var utils = requireLexicalUtils();
  var lexical = import_lexical.default;
  function $getHtmlContent(editor) {
    const selection2 = lexical.$getSelection();
    if (selection2 == null) {
      {
        throw Error(`Expected valid LexicalSelection`);
      }
    }
    if (lexical.$isRangeSelection(selection2) && selection2.isCollapsed() || selection2.getNodes().length === 0) {
      return "";
    }
    return html2.$generateHtmlFromNodes(editor, selection2);
  }
  function $getLexicalContent(editor) {
    const selection2 = lexical.$getSelection();
    if (selection2 == null) {
      {
        throw Error(`Expected valid LexicalSelection`);
      }
    }
    if (lexical.$isRangeSelection(selection2) && selection2.isCollapsed() || selection2.getNodes().length === 0) {
      return null;
    }
    return JSON.stringify($generateJSONFromSelectedNodes(editor, selection2));
  }
  function $insertDataTransferForPlainText(dataTransfer, selection2) {
    const text = dataTransfer.getData("text/plain");
    if (text != null) {
      selection2.insertRawText(text);
    }
  }
  function $insertDataTransferForRichText(dataTransfer, selection2, editor) {
    const lexicalString = dataTransfer.getData("application/x-lexical-editor");
    if (lexicalString) {
      try {
        const payload = JSON.parse(lexicalString);
        if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {
          const nodes = $generateNodesFromSerializedNodes(payload.nodes);
          return $insertGeneratedNodes(editor, nodes, selection2);
        }
      } catch {
      }
    }
    const htmlString = dataTransfer.getData("text/html");
    if (htmlString) {
      try {
        const parser2 = new DOMParser();
        const dom = parser2.parseFromString(htmlString, "text/html");
        const nodes = html2.$generateNodesFromDOM(editor, dom);
        return $insertGeneratedNodes(editor, nodes, selection2);
      } catch {
      }
    }
    const text = dataTransfer.getData("text/plain");
    if (text != null) {
      if (lexical.$isRangeSelection(selection2)) {
        const lines = text.split(/\r?\n/);
        const linesLength = lines.length;
        for (let i = 0; i < linesLength; i++) {
          selection2.insertText(lines[i]);
          if (i < linesLength - 1) {
            selection2.insertParagraph();
          }
        }
      } else {
        selection2.insertRawText(text);
      }
    }
  }
  function $insertGeneratedNodes(editor, nodes, selection2) {
    const isSelectionInsideOfGrid = lexical.DEPRECATED_$isGridSelection(selection2) || utils.$findMatchingParent(selection2.anchor.getNode(), (n) => lexical.DEPRECATED_$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection2.focus.getNode(), (n) => lexical.DEPRECATED_$isGridCellNode(n)) !== null;
    if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.DEPRECATED_$isGridNode(nodes[0])) {
      $mergeGridNodesStrategy(nodes, selection2, false, editor);
      return;
    }
    $basicInsertStrategy(nodes, selection2);
    return;
  }
  function $basicInsertStrategy(nodes, selection2) {
    const topLevelBlocks = [];
    let currentBlock = null;
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      const isLineBreakNode = lexical.$isLineBreakNode(node);
      if (isLineBreakNode || lexical.$isDecoratorNode(node) && node.isInline() || lexical.$isElementNode(node) && node.isInline() || lexical.$isTextNode(node) || node.isParentRequired()) {
        if (currentBlock === null) {
          currentBlock = node.createParentElementNode();
          topLevelBlocks.push(currentBlock);
          if (isLineBreakNode) {
            continue;
          }
        }
        if (currentBlock !== null) {
          currentBlock.append(node);
        }
      } else {
        topLevelBlocks.push(node);
        currentBlock = null;
      }
    }
    if (lexical.$isRangeSelection(selection2)) {
      selection2.insertNodes(topLevelBlocks);
    } else if (lexical.DEPRECATED_$isGridSelection(selection2)) {
      const anchorCell = selection2.anchor.getNode();
      if (!lexical.DEPRECATED_$isGridCellNode(anchorCell)) {
        {
          throw Error(`Expected Grid Cell in Grid Selection`);
        }
      }
      anchorCell.append(...topLevelBlocks);
    }
  }
  function $mergeGridNodesStrategy(nodes, selection2, isFromLexical, editor) {
    if (nodes.length !== 1 || !lexical.DEPRECATED_$isGridNode(nodes[0])) {
      {
        throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);
      }
    }
    const newGrid = nodes[0];
    const newGridRows = newGrid.getChildren();
    const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();
    const newRowCount = newGrid.getChildrenSize();
    const gridCellNode = utils.$findMatchingParent(selection2.anchor.getNode(), (n) => lexical.DEPRECATED_$isGridCellNode(n));
    const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, (n) => lexical.DEPRECATED_$isGridRowNode(n));
    const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, (n) => lexical.DEPRECATED_$isGridNode(n));
    if (!lexical.DEPRECATED_$isGridCellNode(gridCellNode) || !lexical.DEPRECATED_$isGridRowNode(gridRowNode) || !lexical.DEPRECATED_$isGridNode(gridNode)) {
      {
        throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);
      }
    }
    const startY = gridRowNode.getIndexWithinParent();
    const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);
    const startX = gridCellNode.getIndexWithinParent();
    const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);
    const fromX = Math.min(startX, stopX);
    const fromY = Math.min(startY, stopY);
    const toX = Math.max(startX, stopX);
    const toY = Math.max(startY, stopY);
    const gridRowNodes = gridNode.getChildren();
    let newRowIdx = 0;
    let newAnchorCellKey;
    let newFocusCellKey;
    for (let r = fromY; r <= toY; r++) {
      const currentGridRowNode = gridRowNodes[r];
      if (!lexical.DEPRECATED_$isGridRowNode(currentGridRowNode)) {
        {
          throw Error(`getNodes: expected to find GridRowNode`);
        }
      }
      const newGridRowNode = newGridRows[newRowIdx];
      if (!lexical.DEPRECATED_$isGridRowNode(newGridRowNode)) {
        {
          throw Error(`getNodes: expected to find GridRowNode`);
        }
      }
      const gridCellNodes = currentGridRowNode.getChildren();
      const newGridCellNodes = newGridRowNode.getChildren();
      let newColumnIdx = 0;
      for (let c3 = fromX; c3 <= toX; c3++) {
        const currentGridCellNode = gridCellNodes[c3];
        if (!lexical.DEPRECATED_$isGridCellNode(currentGridCellNode)) {
          {
            throw Error(`getNodes: expected to find GridCellNode`);
          }
        }
        const newGridCellNode = newGridCellNodes[newColumnIdx];
        if (!lexical.DEPRECATED_$isGridCellNode(newGridCellNode)) {
          {
            throw Error(`getNodes: expected to find GridCellNode`);
          }
        }
        if (r === fromY && c3 === fromX) {
          newAnchorCellKey = currentGridCellNode.getKey();
        } else if (r === toY && c3 === toX) {
          newFocusCellKey = currentGridCellNode.getKey();
        }
        const originalChildren = currentGridCellNode.getChildren();
        newGridCellNode.getChildren().forEach((child) => {
          if (lexical.$isTextNode(child)) {
            const paragraphNode = lexical.$createParagraphNode();
            paragraphNode.append(child);
            currentGridCellNode.append(child);
          } else {
            currentGridCellNode.append(child);
          }
        });
        originalChildren.forEach((n) => n.remove());
        newColumnIdx++;
      }
      newRowIdx++;
    }
    if (newAnchorCellKey && newFocusCellKey) {
      const newGridSelection = lexical.DEPRECATED_$createGridSelection();
      newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);
      lexical.$setSelection(newGridSelection);
      editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, void 0);
    }
  }
  function exportNodeToJSON(node) {
    const serializedNode = node.exportJSON();
    const nodeClass = node.constructor;
    if (serializedNode.type !== nodeClass.getType()) {
      {
        throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);
      }
    }
    const serializedChildren = serializedNode.children;
    if (lexical.$isElementNode(node)) {
      if (!Array.isArray(serializedChildren)) {
        {
          throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
        }
      }
    }
    return serializedNode;
  }
  function $appendNodesToJSON(editor, selection$1, currentNode, targetArray = []) {
    let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;
    const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy("html");
    let target = currentNode;
    if (selection$1 !== null) {
      let clone = selection.$cloneWithProperties(currentNode);
      clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;
      target = clone;
    }
    const children = lexical.$isElementNode(target) ? target.getChildren() : [];
    const serializedNode = exportNodeToJSON(target);
    if (lexical.$isTextNode(target)) {
      const text = target.__text;
      if (text.length > 0) {
        serializedNode.text = text;
      } else {
        shouldInclude = false;
      }
    }
    for (let i = 0; i < children.length; i++) {
      const childNode = children[i];
      const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);
      if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, "clone")) {
        shouldInclude = true;
      }
    }
    if (shouldInclude && !shouldExclude) {
      targetArray.push(serializedNode);
    } else if (Array.isArray(serializedNode.children)) {
      for (let i = 0; i < serializedNode.children.length; i++) {
        const serializedChildNode = serializedNode.children[i];
        targetArray.push(serializedChildNode);
      }
    }
    return shouldInclude;
  }
  function $generateJSONFromSelectedNodes(editor, selection2) {
    const nodes = [];
    const root = lexical.$getRoot();
    const topLevelChildren = root.getChildren();
    for (let i = 0; i < topLevelChildren.length; i++) {
      const topLevelNode = topLevelChildren[i];
      $appendNodesToJSON(editor, selection2, topLevelNode, nodes);
    }
    return {
      namespace: editor._config.namespace,
      nodes
    };
  }
  function $generateNodesFromSerializedNodes(serializedNodes) {
    const nodes = [];
    for (let i = 0; i < serializedNodes.length; i++) {
      const serializedNode = serializedNodes[i];
      const node = lexical.$parseSerializedNode(serializedNode);
      if (lexical.$isTextNode(node)) {
        selection.$addNodeStyle(node);
      }
      nodes.push(node);
    }
    return nodes;
  }
  const EVENT_LATENCY = 50;
  let clipboardEventTimeout = null;
  async function copyToClipboard__EXPERIMENTAL(editor, event) {
    if (clipboardEventTimeout !== null) {
      return false;
    }
    if (event !== null) {
      return new Promise((resolve, reject) => {
        editor.update(() => {
          resolve($copyToClipboardEvent(editor, event));
        });
      });
    }
    const rootElement = editor.getRootElement();
    const domSelection = document.getSelection();
    if (rootElement === null || domSelection === null) {
      return false;
    }
    const element = document.createElement("span");
    element.style.cssText = "position: fixed; top: -1000px;";
    element.append(document.createTextNode("#"));
    rootElement.append(element);
    const range2 = new Range();
    range2.setStart(element, 0);
    range2.setEnd(element, 1);
    domSelection.removeAllRanges();
    domSelection.addRange(range2);
    return new Promise((resolve, reject) => {
      const removeListener = editor.registerCommand(lexical.COPY_COMMAND, (secondEvent) => {
        if (secondEvent instanceof ClipboardEvent) {
          removeListener();
          if (clipboardEventTimeout !== null) {
            window.clearTimeout(clipboardEventTimeout);
            clipboardEventTimeout = null;
          }
          resolve($copyToClipboardEvent(editor, secondEvent));
        }
        return true;
      }, lexical.COMMAND_PRIORITY_CRITICAL);
      clipboardEventTimeout = window.setTimeout(() => {
        removeListener();
        clipboardEventTimeout = null;
        resolve(false);
      }, EVENT_LATENCY);
      document.execCommand("copy");
      element.remove();
    });
  }
  function $copyToClipboardEvent(editor, event) {
    const domSelection = window.getSelection();
    if (!domSelection) {
      return false;
    }
    const anchorDOM = domSelection.anchorNode;
    const focusDOM = domSelection.focusNode;
    if (anchorDOM !== null && focusDOM !== null && !lexical.isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
      return false;
    }
    event.preventDefault();
    const clipboardData = event.clipboardData;
    const selection2 = lexical.$getSelection();
    if (clipboardData === null || selection2 === null) {
      return false;
    }
    const htmlString = $getHtmlContent(editor);
    const lexicalString = $getLexicalContent(editor);
    let plainString = "";
    if (selection2 !== null) {
      plainString = selection2.getTextContent();
    }
    if (htmlString !== null) {
      clipboardData.setData("text/html", htmlString);
    }
    if (lexicalString !== null) {
      clipboardData.setData("application/x-lexical-editor", lexicalString);
    }
    clipboardData.setData("text/plain", plainString);
    return true;
  }
  LexicalClipboard_dev.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;
  LexicalClipboard_dev.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;
  LexicalClipboard_dev.$getHtmlContent = $getHtmlContent;
  LexicalClipboard_dev.$getLexicalContent = $getLexicalContent;
  LexicalClipboard_dev.$insertDataTransferForPlainText = $insertDataTransferForPlainText;
  LexicalClipboard_dev.$insertDataTransferForRichText = $insertDataTransferForRichText;
  LexicalClipboard_dev.$insertGeneratedNodes = $insertGeneratedNodes;
  LexicalClipboard_dev.copyToClipboard__EXPERIMENTAL = copyToClipboard__EXPERIMENTAL;
  return LexicalClipboard_dev;
}
var LexicalClipboard_1;
var hasRequiredLexicalClipboard;
function requireLexicalClipboard() {
  if (hasRequiredLexicalClipboard)
    return LexicalClipboard_1;
  hasRequiredLexicalClipboard = 1;
  const LexicalClipboard = true ? requireLexicalClipboard_dev() : requireLexicalClipboard_prod();
  LexicalClipboard_1 = LexicalClipboard;
  return LexicalClipboard_1;
}
var hasRequiredLexicalRichText_dev;
function requireLexicalRichText_dev() {
  if (hasRequiredLexicalRichText_dev)
    return LexicalRichText_dev;
  hasRequiredLexicalRichText_dev = 1;
  var clipboard = requireLexicalClipboard();
  var selection = requireLexicalSelection();
  var utils = requireLexicalUtils();
  var lexical = import_lexical.default;
  function caretFromPoint(x4, y4) {
    if (typeof document.caretRangeFromPoint !== "undefined") {
      const range2 = document.caretRangeFromPoint(x4, y4);
      if (range2 === null) {
        return null;
      }
      return {
        node: range2.startContainer,
        offset: range2.startOffset
      };
    } else if (document.caretPositionFromPoint !== "undefined") {
      const range2 = document.caretPositionFromPoint(x4, y4);
      if (range2 === null) {
        return null;
      }
      return {
        node: range2.offsetNode,
        offset: range2.offset
      };
    } else {
      return null;
    }
  }
  const CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
  const documentMode = CAN_USE_DOM && "documentMode" in document ? document.documentMode : null;
  const CAN_USE_BEFORE_INPUT = CAN_USE_DOM && "InputEvent" in window && !documentMode ? "getTargetRanges" in new window.InputEvent("input") : false;
  const IS_SAFARI = CAN_USE_DOM && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
  const IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  const IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);
  const IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME;
  const DRAG_DROP_PASTE = lexical.createCommand("DRAG_DROP_PASTE_FILE");
  class QuoteNode extends lexical.ElementNode {
    static getType() {
      return "quote";
    }
    static clone(node) {
      return new QuoteNode(node.__key);
    }
    constructor(key) {
      super(key);
    }
    // View
    createDOM(config) {
      const element = document.createElement("blockquote");
      utils.addClassNamesToElement(element, config.theme.quote);
      return element;
    }
    updateDOM(prevNode, dom) {
      return false;
    }
    static importDOM() {
      return {
        blockquote: (node) => ({
          conversion: convertBlockquoteElement,
          priority: 0
        })
      };
    }
    static importJSON(serializedNode) {
      const node = $createQuoteNode();
      node.setFormat(serializedNode.format);
      node.setIndent(serializedNode.indent);
      node.setDirection(serializedNode.direction);
      return node;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "quote"
      };
    }
    // Mutation
    insertNewAfter(_, restoreSelection) {
      const newBlock = lexical.$createParagraphNode();
      const direction = this.getDirection();
      newBlock.setDirection(direction);
      this.insertAfter(newBlock, restoreSelection);
      return newBlock;
    }
    collapseAtStart() {
      const paragraph = lexical.$createParagraphNode();
      const children = this.getChildren();
      children.forEach((child) => paragraph.append(child));
      this.replace(paragraph);
      return true;
    }
  }
  function $createQuoteNode() {
    return lexical.$applyNodeReplacement(new QuoteNode());
  }
  function $isQuoteNode(node) {
    return node instanceof QuoteNode;
  }
  class HeadingNode extends lexical.ElementNode {
    /** @internal */
    static getType() {
      return "heading";
    }
    static clone(node) {
      return new HeadingNode(node.__tag, node.__key);
    }
    constructor(tag, key) {
      super(key);
      this.__tag = tag;
    }
    getTag() {
      return this.__tag;
    }
    // View
    createDOM(config) {
      const tag = this.__tag;
      const element = document.createElement(tag);
      const theme = config.theme;
      const classNames = theme.heading;
      if (classNames !== void 0) {
        const className = classNames[tag];
        utils.addClassNamesToElement(element, className);
      }
      return element;
    }
    updateDOM(prevNode, dom) {
      return false;
    }
    static importDOM() {
      return {
        h1: (node) => ({
          conversion: convertHeadingElement,
          priority: 0
        }),
        h2: (node) => ({
          conversion: convertHeadingElement,
          priority: 0
        }),
        h3: (node) => ({
          conversion: convertHeadingElement,
          priority: 0
        }),
        h4: (node) => ({
          conversion: convertHeadingElement,
          priority: 0
        }),
        h5: (node) => ({
          conversion: convertHeadingElement,
          priority: 0
        }),
        h6: (node) => ({
          conversion: convertHeadingElement,
          priority: 0
        }),
        p: (node) => {
          const paragraph = node;
          const firstChild = paragraph.firstChild;
          if (firstChild !== null && isGoogleDocsTitle(firstChild)) {
            return {
              conversion: () => ({
                node: null
              }),
              priority: 3
            };
          }
          return null;
        },
        span: (node) => {
          if (isGoogleDocsTitle(node)) {
            return {
              conversion: (domNode) => {
                return {
                  node: $createHeadingNode("h1")
                };
              },
              priority: 3
            };
          }
          return null;
        }
      };
    }
    static importJSON(serializedNode) {
      const node = $createHeadingNode(serializedNode.tag);
      node.setFormat(serializedNode.format);
      node.setIndent(serializedNode.indent);
      node.setDirection(serializedNode.direction);
      return node;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        tag: this.getTag(),
        type: "heading",
        version: 1
      };
    }
    // Mutation
    insertNewAfter(selection2, restoreSelection = true) {
      const anchorOffet = selection2 ? selection2.anchor.offset : 0;
      const newElement = anchorOffet > 0 && anchorOffet < this.getTextContentSize() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();
      const direction = this.getDirection();
      newElement.setDirection(direction);
      this.insertAfter(newElement, restoreSelection);
      return newElement;
    }
    collapseAtStart() {
      const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();
      const children = this.getChildren();
      children.forEach((child) => newElement.append(child));
      this.replace(newElement);
      return true;
    }
    extractWithChild() {
      return true;
    }
  }
  function isGoogleDocsTitle(domNode) {
    if (domNode.nodeName.toLowerCase() === "span") {
      return domNode.style.fontSize === "26pt";
    }
    return false;
  }
  function convertHeadingElement(domNode) {
    const nodeName = domNode.nodeName.toLowerCase();
    let node = null;
    if (nodeName === "h1" || nodeName === "h2" || nodeName === "h3" || nodeName === "h4" || nodeName === "h5" || nodeName === "h6") {
      node = $createHeadingNode(nodeName);
    }
    return {
      node
    };
  }
  function convertBlockquoteElement() {
    const node = $createQuoteNode();
    return {
      node
    };
  }
  function $createHeadingNode(headingTag) {
    return lexical.$applyNodeReplacement(new HeadingNode(headingTag));
  }
  function $isHeadingNode(node) {
    return node instanceof HeadingNode;
  }
  function onPasteForRichText(event, editor) {
    event.preventDefault();
    editor.update(() => {
      const selection2 = lexical.$getSelection();
      const clipboardData = event instanceof InputEvent || event instanceof KeyboardEvent ? null : event.clipboardData;
      if (clipboardData != null && (lexical.$isRangeSelection(selection2) || lexical.DEPRECATED_$isGridSelection(selection2))) {
        clipboard.$insertDataTransferForRichText(clipboardData, selection2, editor);
      }
    }, {
      tag: "paste"
    });
  }
  async function onCutForRichText(event, editor) {
    await clipboard.copyToClipboard__EXPERIMENTAL(editor, event instanceof ClipboardEvent ? event : null);
    editor.update(() => {
      const selection2 = lexical.$getSelection();
      if (lexical.$isRangeSelection(selection2)) {
        selection2.removeText();
      } else if (lexical.$isNodeSelection(selection2)) {
        selection2.getNodes().forEach((node) => node.remove());
      }
    });
  }
  function eventFiles(event) {
    let dataTransfer = null;
    if (event instanceof DragEvent) {
      dataTransfer = event.dataTransfer;
    } else if (event instanceof ClipboardEvent) {
      dataTransfer = event.clipboardData;
    }
    if (dataTransfer === null) {
      return [false, [], false];
    }
    const types = dataTransfer.types;
    const hasFiles = types.includes("Files");
    const hasContent = types.includes("text/html") || types.includes("text/plain");
    return [hasFiles, Array.from(dataTransfer.files), hasContent];
  }
  function handleIndentAndOutdent(insertTab, indentOrOutdent) {
    const selection2 = lexical.$getSelection();
    if (!lexical.$isRangeSelection(selection2)) {
      return;
    }
    const alreadyHandled = /* @__PURE__ */ new Set();
    const nodes = selection2.getNodes();
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      const key = node.getKey();
      if (alreadyHandled.has(key)) {
        continue;
      }
      const parentBlock = utils.$getNearestBlockElementAncestorOrThrow(node);
      const parentKey = parentBlock.getKey();
      if (parentBlock.canInsertTab()) {
        insertTab(node);
        alreadyHandled.add(key);
      } else if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {
        alreadyHandled.add(parentKey);
        indentOrOutdent(parentBlock);
      }
    }
  }
  function $isTargetWithinDecorator(target) {
    const node = lexical.$getNearestNodeFromDOMNode(target);
    return lexical.$isDecoratorNode(node);
  }
  function $isSelectionAtEndOfRoot(selection2) {
    const focus = selection2.focus;
    return focus.key === "root" && focus.offset === lexical.$getRoot().getChildrenSize();
  }
  function registerRichText(editor) {
    const removeListener = utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, (payload) => {
      const selection2 = lexical.$getSelection();
      if (lexical.$isNodeSelection(selection2)) {
        selection2.clear();
        return true;
      }
      return false;
    }, 0), editor.registerCommand(lexical.DELETE_CHARACTER_COMMAND, (isBackward) => {
      const selection2 = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection2)) {
        return false;
      }
      selection2.deleteCharacter(isBackward);
      return true;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_WORD_COMMAND, (isBackward) => {
      const selection2 = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection2)) {
        return false;
      }
      selection2.deleteWord(isBackward);
      return true;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_LINE_COMMAND, (isBackward) => {
      const selection2 = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection2)) {
        return false;
      }
      selection2.deleteLine(isBackward);
      return true;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, (eventOrText) => {
      const selection2 = lexical.$getSelection();
      if (typeof eventOrText === "string") {
        if (lexical.$isRangeSelection(selection2)) {
          selection2.insertText(eventOrText);
        } else if (lexical.DEPRECATED_$isGridSelection(selection2))
          ;
      } else {
        if (!lexical.$isRangeSelection(selection2) && !lexical.DEPRECATED_$isGridSelection(selection2)) {
          return false;
        }
        const dataTransfer = eventOrText.dataTransfer;
        if (dataTransfer != null) {
          clipboard.$insertDataTransferForRichText(dataTransfer, selection2, editor);
        } else if (lexical.$isRangeSelection(selection2)) {
          const data = eventOrText.data;
          if (data) {
            selection2.insertText(data);
          }
          return true;
        }
      }
      return true;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REMOVE_TEXT_COMMAND, () => {
      const selection2 = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection2)) {
        return false;
      }
      selection2.removeText();
      return true;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, (format3) => {
      const selection2 = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection2)) {
        return false;
      }
      selection2.formatText(format3);
      return true;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_ELEMENT_COMMAND, (format3) => {
      const selection2 = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection2) && !lexical.$isNodeSelection(selection2)) {
        return false;
      }
      const nodes = selection2.getNodes();
      for (const node of nodes) {
        const element = utils.$getNearestBlockElementAncestorOrThrow(node);
        element.setFormat(format3);
      }
      return true;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_LINE_BREAK_COMMAND, (selectStart) => {
      const selection2 = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection2)) {
        return false;
      }
      selection2.insertLineBreak(selectStart);
      return true;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {
      const selection2 = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection2)) {
        return false;
      }
      selection2.insertParagraph();
      return true;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, () => {
      handleIndentAndOutdent(() => {
        editor.dispatchCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, "	");
      }, (block) => {
        const indent = block.getIndent();
        if (indent !== 10) {
          block.setIndent(indent + 1);
        }
      });
      return true;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, () => {
      handleIndentAndOutdent((node) => {
        if (lexical.$isTextNode(node)) {
          const textContent = node.getTextContent();
          const character = textContent[textContent.length - 1];
          if (character === "	") {
            editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);
          }
        }
      }, (block) => {
        const indent = block.getIndent();
        if (indent !== 0) {
          block.setIndent(indent - 1);
        }
      });
      return true;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, (event) => {
      const selection2 = lexical.$getSelection();
      if (lexical.$isNodeSelection(selection2) && !$isTargetWithinDecorator(event.target)) {
        const nodes = selection2.getNodes();
        if (nodes.length > 0) {
          nodes[0].selectPrevious();
          return true;
        }
      } else if (lexical.$isRangeSelection(selection2)) {
        const possibleNode = lexical.$getAdjacentNode(selection2.focus, true);
        if (lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {
          possibleNode.selectPrevious();
          event.preventDefault();
          return true;
        } else if (lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {
          possibleNode.select();
          event.preventDefault();
          return true;
        }
      }
      return false;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, (event) => {
      const selection2 = lexical.$getSelection();
      if (lexical.$isNodeSelection(selection2)) {
        const nodes = selection2.getNodes();
        if (nodes.length > 0) {
          nodes[0].selectNext(0, 0);
          return true;
        }
      } else if (lexical.$isRangeSelection(selection2)) {
        if ($isSelectionAtEndOfRoot(selection2)) {
          event.preventDefault();
          return true;
        }
        const possibleNode = lexical.$getAdjacentNode(selection2.focus, false);
        if (lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {
          possibleNode.selectNext();
          event.preventDefault();
          return true;
        }
      }
      return false;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, (event) => {
      const selection$1 = lexical.$getSelection();
      if (lexical.$isNodeSelection(selection$1)) {
        const nodes = selection$1.getNodes();
        if (nodes.length > 0) {
          event.preventDefault();
          nodes[0].selectPrevious();
          return true;
        }
      }
      if (!lexical.$isRangeSelection(selection$1)) {
        return false;
      }
      if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, true)) {
        const isHoldingShift = event.shiftKey;
        event.preventDefault();
        selection.$moveCharacter(selection$1, isHoldingShift, true);
        return true;
      }
      return false;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, (event) => {
      const selection$1 = lexical.$getSelection();
      if (lexical.$isNodeSelection(selection$1) && !$isTargetWithinDecorator(event.target)) {
        const nodes = selection$1.getNodes();
        if (nodes.length > 0) {
          event.preventDefault();
          nodes[0].selectNext(0, 0);
          return true;
        }
      }
      if (!lexical.$isRangeSelection(selection$1)) {
        return false;
      }
      const isHoldingShift = event.shiftKey;
      if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, false)) {
        event.preventDefault();
        selection.$moveCharacter(selection$1, isHoldingShift, false);
        return true;
      }
      return false;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, (event) => {
      if ($isTargetWithinDecorator(event.target)) {
        return false;
      }
      const selection2 = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection2)) {
        return false;
      }
      event.preventDefault();
      const {
        anchor
      } = selection2;
      const anchorNode = anchor.getNode();
      if (selection2.isCollapsed() && anchor.offset === 0 && !lexical.$isRootNode(anchorNode)) {
        const element = utils.$getNearestBlockElementAncestorOrThrow(anchorNode);
        if (element.getIndent() > 0) {
          return editor.dispatchCommand(lexical.OUTDENT_CONTENT_COMMAND, void 0);
        }
      }
      return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_DELETE_COMMAND, (event) => {
      if ($isTargetWithinDecorator(event.target)) {
        return false;
      }
      const selection2 = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection2)) {
        return false;
      }
      event.preventDefault();
      return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, false);
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ENTER_COMMAND, (event) => {
      const selection2 = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection2)) {
        return false;
      }
      if (event !== null) {
        if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {
          return false;
        }
        event.preventDefault();
        if (event.shiftKey) {
          return editor.dispatchCommand(lexical.INSERT_LINE_BREAK_COMMAND, false);
        }
      }
      return editor.dispatchCommand(lexical.INSERT_PARAGRAPH_COMMAND, void 0);
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, () => {
      const selection2 = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection2)) {
        return false;
      }
      editor.blur();
      return true;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DROP_COMMAND, (event) => {
      const [, files] = eventFiles(event);
      if (files.length > 0) {
        const x4 = event.clientX;
        const y4 = event.clientY;
        const eventRange = caretFromPoint(x4, y4);
        if (eventRange !== null) {
          const {
            offset: domOffset,
            node: domNode
          } = eventRange;
          const node = lexical.$getNearestNodeFromDOMNode(domNode);
          if (node !== null) {
            const selection3 = lexical.$createRangeSelection();
            if (lexical.$isTextNode(node)) {
              selection3.anchor.set(node.getKey(), domOffset, "text");
              selection3.focus.set(node.getKey(), domOffset, "text");
            } else {
              const parentKey = node.getParentOrThrow().getKey();
              const offset = node.getIndexWithinParent() + 1;
              selection3.anchor.set(parentKey, offset, "element");
              selection3.focus.set(parentKey, offset, "element");
            }
            const normalizedSelection = lexical.$normalizeSelection__EXPERIMENTAL(selection3);
            lexical.$setSelection(normalizedSelection);
          }
          editor.dispatchCommand(DRAG_DROP_PASTE, files);
        }
        event.preventDefault();
        return true;
      }
      const selection2 = lexical.$getSelection();
      if (lexical.$isRangeSelection(selection2)) {
        return true;
      }
      return false;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGSTART_COMMAND, (event) => {
      const [isFileTransfer] = eventFiles(event);
      const selection2 = lexical.$getSelection();
      if (isFileTransfer && !lexical.$isRangeSelection(selection2)) {
        return false;
      }
      return true;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGOVER_COMMAND, (event) => {
      const [isFileTransfer] = eventFiles(event);
      const selection2 = lexical.$getSelection();
      if (isFileTransfer && !lexical.$isRangeSelection(selection2)) {
        return false;
      }
      const x4 = event.clientX;
      const y4 = event.clientY;
      const eventRange = caretFromPoint(x4, y4);
      if (eventRange !== null) {
        const node = lexical.$getNearestNodeFromDOMNode(eventRange.node);
        if (lexical.$isDecoratorNode(node)) {
          event.preventDefault();
        }
      }
      return true;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.COPY_COMMAND, (event) => {
      clipboard.copyToClipboard__EXPERIMENTAL(editor, event instanceof ClipboardEvent ? event : null);
      return true;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CUT_COMMAND, (event) => {
      onCutForRichText(event, editor);
      return true;
    }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.PASTE_COMMAND, (event) => {
      const [, files, hasTextContent] = eventFiles(event);
      if (files.length > 0 && !hasTextContent) {
        editor.dispatchCommand(DRAG_DROP_PASTE, files);
        return true;
      }
      const selection2 = lexical.$getSelection();
      if (lexical.$isRangeSelection(selection2) || lexical.DEPRECATED_$isGridSelection(selection2)) {
        onPasteForRichText(event, editor);
        return true;
      }
      return false;
    }, lexical.COMMAND_PRIORITY_EDITOR));
    return removeListener;
  }
  LexicalRichText_dev.$createHeadingNode = $createHeadingNode;
  LexicalRichText_dev.$createQuoteNode = $createQuoteNode;
  LexicalRichText_dev.$isHeadingNode = $isHeadingNode;
  LexicalRichText_dev.$isQuoteNode = $isQuoteNode;
  LexicalRichText_dev.DRAG_DROP_PASTE = DRAG_DROP_PASTE;
  LexicalRichText_dev.HeadingNode = HeadingNode;
  LexicalRichText_dev.QuoteNode = QuoteNode;
  LexicalRichText_dev.eventFiles = eventFiles;
  LexicalRichText_dev.registerRichText = registerRichText;
  return LexicalRichText_dev;
}
var LexicalRichText = true ? requireLexicalRichText_dev() : requireLexicalRichText_prod();
var LexicalRichText_1 = LexicalRichText;
var hasRequiredLexicalMarkdown_dev;
function requireLexicalMarkdown_dev() {
  if (hasRequiredLexicalMarkdown_dev)
    return LexicalMarkdown_dev;
  hasRequiredLexicalMarkdown_dev = 1;
  var lexical = import_lexical.default;
  var code = LexicalCode_1;
  var list = LexicalList_1;
  var richText = LexicalRichText_1;
  var utils = requireLexicalUtils();
  var link3 = LexicalLink_1;
  function indexBy(list2, callback) {
    const index2 = {};
    for (const item of list2) {
      const key = callback(item);
      if (index2[key]) {
        index2[key].push(item);
      } else {
        index2[key] = [item];
      }
    }
    return index2;
  }
  function transformersByType(transformers) {
    const byType = indexBy(transformers, (t) => t.type);
    return {
      element: byType.element || [],
      textFormat: byType["text-format"] || [],
      textMatch: byType["text-match"] || []
    };
  }
  const PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\s]/;
  function createMarkdownExport(transformers) {
    const byType = transformersByType(transformers);
    const textFormatTransformers = byType.textFormat.filter((transformer3) => transformer3.format.length === 1);
    return () => {
      const output = [];
      const children = lexical.$getRoot().getChildren();
      for (const child of children) {
        const result = exportTopLevelElements(child, byType.element, textFormatTransformers, byType.textMatch);
        if (result != null) {
          output.push(result);
        }
      }
      return output.join("\n\n");
    };
  }
  function exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {
    for (const transformer3 of elementTransformers) {
      const result = transformer3.export(node, (_node) => exportChildren(_node, textTransformersIndex, textMatchTransformers));
      if (result != null) {
        return result;
      }
    }
    if (lexical.$isElementNode(node)) {
      return exportChildren(node, textTransformersIndex, textMatchTransformers);
    } else if (lexical.$isDecoratorNode(node)) {
      return node.getTextContent();
    } else {
      return null;
    }
  }
  function exportChildren(node, textTransformersIndex, textMatchTransformers) {
    const output = [];
    const children = node.getChildren();
    mainLoop:
      for (const child of children) {
        for (const transformer3 of textMatchTransformers) {
          const result = transformer3.export(child, (parentNode) => exportChildren(parentNode, textTransformersIndex, textMatchTransformers), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex));
          if (result != null) {
            output.push(result);
            continue mainLoop;
          }
        }
        if (lexical.$isLineBreakNode(child)) {
          output.push("\n");
        } else if (lexical.$isTextNode(child)) {
          output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex));
        } else if (lexical.$isElementNode(child)) {
          output.push(exportChildren(child, textTransformersIndex, textMatchTransformers));
        } else if (lexical.$isDecoratorNode(child)) {
          output.push(child.getTextContent());
        }
      }
    return output.join("");
  }
  function exportTextFormat(node, textContent, textTransformers) {
    const frozenString = textContent.trim();
    let output = frozenString;
    const applied = /* @__PURE__ */ new Set();
    for (const transformer3 of textTransformers) {
      const format3 = transformer3.format[0];
      const tag = transformer3.tag;
      if (hasFormat(node, format3) && !applied.has(format3)) {
        applied.add(format3);
        const previousNode = getTextSibling(node, true);
        if (!hasFormat(previousNode, format3)) {
          output = tag + output;
        }
        const nextNode = getTextSibling(node, false);
        if (!hasFormat(nextNode, format3)) {
          output += tag;
        }
      }
    }
    return textContent.replace(frozenString, output);
  }
  function getTextSibling(node, backward) {
    let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();
    if (!sibling) {
      const parent = node.getParentOrThrow();
      if (parent.isInline()) {
        sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();
      }
    }
    while (sibling) {
      if (lexical.$isElementNode(sibling)) {
        if (!sibling.isInline()) {
          break;
        }
        const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();
        if (lexical.$isTextNode(descendant)) {
          return descendant;
        } else {
          sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();
        }
      }
      if (lexical.$isTextNode(sibling)) {
        return sibling;
      }
      if (!lexical.$isElementNode(sibling)) {
        return null;
      }
    }
    return null;
  }
  function hasFormat(node, format3) {
    return lexical.$isTextNode(node) && node.hasFormat(format3);
  }
  const CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
  const documentMode = CAN_USE_DOM && "documentMode" in document ? document.documentMode : null;
  CAN_USE_DOM && "InputEvent" in window && !documentMode ? "getTargetRanges" in new window.InputEvent("input") : false;
  const IS_SAFARI = CAN_USE_DOM && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
  const IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  const IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);
  const IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME;
  const MARKDOWN_EMPTY_LINE_REG_EXP = /^\s{0,3}$/;
  const CODE_BLOCK_REG_EXP = /^```(\w{1,10})?\s?$/;
  function createMarkdownImport(transformers) {
    const byType = transformersByType(transformers);
    const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);
    return (markdownString) => {
      const lines = markdownString.split("\n");
      const linesLength = lines.length;
      const root = lexical.$getRoot();
      root.clear();
      for (let i = 0; i < linesLength; i++) {
        const lineText = lines[i];
        const [codeBlockNode, shiftedIndex] = importCodeBlock(lines, i, root);
        if (codeBlockNode != null) {
          i = shiftedIndex;
          continue;
        }
        importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch);
      }
      const children = root.getChildren();
      for (const child of children) {
        if (isEmptyParagraph(child)) {
          child.remove();
        }
      }
      root.selectEnd();
    };
  }
  function isEmptyParagraph(node) {
    if (!lexical.$isParagraphNode(node)) {
      return false;
    }
    const firstChild = node.getFirstChild();
    return firstChild == null || node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());
  }
  function importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers) {
    const lineTextTrimmed = lineText.trim();
    const textNode = lexical.$createTextNode(lineTextTrimmed);
    const elementNode = lexical.$createParagraphNode();
    elementNode.append(textNode);
    rootNode.append(elementNode);
    for (const {
      regExp,
      replace
    } of elementTransformers) {
      const match = lineText.match(regExp);
      if (match) {
        textNode.setTextContent(lineText.slice(match[0].length));
        replace(elementNode, [textNode], match, true);
        break;
      }
    }
    importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers);
    if (elementNode.isAttached() && lineTextTrimmed.length > 0) {
      const previousNode = elementNode.getPreviousSibling();
      if (lexical.$isParagraphNode(previousNode) || richText.$isQuoteNode(previousNode) || list.$isListNode(previousNode)) {
        let targetNode = previousNode;
        if (list.$isListNode(previousNode)) {
          const lastDescendant = previousNode.getLastDescendant();
          if (lastDescendant == null) {
            targetNode = null;
          } else {
            targetNode = utils.$findMatchingParent(lastDescendant, list.$isListItemNode);
          }
        }
        if (targetNode != null && targetNode.getTextContentSize() > 0) {
          targetNode.splice(targetNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...elementNode.getChildren()]);
          elementNode.remove();
        }
      }
    }
  }
  function importCodeBlock(lines, startLineIndex, rootNode) {
    const openMatch = lines[startLineIndex].match(CODE_BLOCK_REG_EXP);
    if (openMatch) {
      let endLineIndex = startLineIndex;
      const linesLength = lines.length;
      while (++endLineIndex < linesLength) {
        const closeMatch = lines[endLineIndex].match(CODE_BLOCK_REG_EXP);
        if (closeMatch) {
          const codeBlockNode = code.$createCodeNode(openMatch[1]);
          const textNode = lexical.$createTextNode(lines.slice(startLineIndex + 1, endLineIndex).join("\n"));
          codeBlockNode.append(textNode);
          rootNode.append(codeBlockNode);
          return [codeBlockNode, endLineIndex];
        }
      }
    }
    return [null, startLineIndex];
  }
  function importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {
    const textContent = textNode.getTextContent();
    const match = findOutermostMatch(textContent, textFormatTransformersIndex);
    if (!match) {
      importTextMatchTransformers(textNode, textMatchTransformers);
      return;
    }
    let currentNode, remainderNode, leadingNode;
    if (match[0] === textContent) {
      currentNode = textNode;
    } else {
      const startIndex = match.index || 0;
      const endIndex = startIndex + match[0].length;
      if (startIndex === 0) {
        [currentNode, remainderNode] = textNode.splitText(endIndex);
      } else {
        [leadingNode, currentNode, remainderNode] = textNode.splitText(startIndex, endIndex);
      }
    }
    currentNode.setTextContent(match[2]);
    const transformer3 = textFormatTransformersIndex.transformersByTag[match[1]];
    if (transformer3) {
      for (const format3 of transformer3.format) {
        if (!currentNode.hasFormat(format3)) {
          currentNode.toggleFormat(format3);
        }
      }
    }
    if (!currentNode.hasFormat("code")) {
      importTextFormatTransformers(currentNode, textFormatTransformersIndex, textMatchTransformers);
    }
    if (leadingNode) {
      importTextFormatTransformers(leadingNode, textFormatTransformersIndex, textMatchTransformers);
    }
    if (remainderNode) {
      importTextFormatTransformers(remainderNode, textFormatTransformersIndex, textMatchTransformers);
    }
  }
  function importTextMatchTransformers(textNode_, textMatchTransformers) {
    let textNode = textNode_;
    mainLoop:
      while (textNode) {
        for (const transformer3 of textMatchTransformers) {
          const match = textNode.getTextContent().match(transformer3.importRegExp);
          if (!match) {
            continue;
          }
          const startIndex = match.index || 0;
          const endIndex = startIndex + match[0].length;
          let replaceNode, leftTextNode, rightTextNode;
          if (startIndex === 0) {
            [replaceNode, textNode] = textNode.splitText(endIndex);
          } else {
            [leftTextNode, replaceNode, rightTextNode] = textNode.splitText(startIndex, endIndex);
          }
          if (leftTextNode) {
            importTextMatchTransformers(leftTextNode, textMatchTransformers);
          }
          if (rightTextNode) {
            textNode = rightTextNode;
          }
          transformer3.replace(replaceNode, match);
          continue mainLoop;
        }
        break;
      }
  }
  function findOutermostMatch(textContent, textTransformersIndex) {
    const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);
    if (openTagsMatch == null) {
      return null;
    }
    for (const match of openTagsMatch) {
      const tag = match.replace(/^\s/, "");
      const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];
      if (fullMatchRegExp == null) {
        continue;
      }
      const fullMatch = textContent.match(fullMatchRegExp);
      const transformer3 = textTransformersIndex.transformersByTag[tag];
      if (fullMatch != null && transformer3 != null) {
        if (transformer3.intraword !== false) {
          return fullMatch;
        }
        const {
          index: index2 = 0
        } = fullMatch;
        const beforeChar = textContent[index2 - 1];
        const afterChar = textContent[index2 + fullMatch[0].length];
        if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {
          return fullMatch;
        }
      }
    }
    return null;
  }
  function createTextFormatTransformersIndex(textTransformers) {
    const transformersByTag = {};
    const fullMatchRegExpByTag = {};
    const openTagsRegExp = [];
    const escapeRegExp = `(?<![\\\\])`;
    for (const transformer3 of textTransformers) {
      const {
        tag
      } = transformer3;
      transformersByTag[tag] = transformer3;
      const tagRegExp = tag.replace(/(\*|\^|\+)/g, "\\$1");
      openTagsRegExp.push(tagRegExp);
      if (IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT) {
        fullMatchRegExpByTag[tag] = new RegExp(`(${tagRegExp})(?![${tagRegExp}\\s])(.*?[^${tagRegExp}\\s])${tagRegExp}(?!${tagRegExp})`);
      } else {
        fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\${tagRegExp}])(${tagRegExp})((\\\\${tagRegExp})?.*?[^${tagRegExp}\\s](\\\\${tagRegExp})?)((?<!\\\\)|(?<=\\\\\\\\))(${tagRegExp})(?![\\\\${tagRegExp}])`);
      }
    }
    return {
      // Reg exp to find open tag + content + close tag
      fullMatchRegExpByTag,
      // Reg exp to find opening tags
      openTagsRegExp: new RegExp((IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? "" : `${escapeRegExp}`) + "(" + openTagsRegExp.join("|") + ")", "g"),
      transformersByTag
    };
  }
  function runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {
    const grandParentNode = parentNode.getParent();
    if (!lexical.$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {
      return false;
    }
    const textContent = anchorNode.getTextContent();
    if (textContent[anchorOffset - 1] !== " ") {
      return false;
    }
    for (const {
      regExp,
      replace
    } of elementTransformers) {
      const match = textContent.match(regExp);
      if (match && match[0].length === anchorOffset) {
        const nextSiblings = anchorNode.getNextSiblings();
        const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);
        leadingNode.remove();
        const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;
        replace(parentNode, siblings, match, false);
        return true;
      }
    }
    return false;
  }
  function runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {
    let textContent = anchorNode.getTextContent();
    const lastChar = textContent[anchorOffset - 1];
    const transformers = transformersByTrigger[lastChar];
    if (transformers == null) {
      return false;
    }
    if (anchorOffset < textContent.length) {
      textContent = textContent.slice(0, anchorOffset);
    }
    for (const transformer3 of transformers) {
      const match = textContent.match(transformer3.regExp);
      if (match === null) {
        continue;
      }
      const startIndex = match.index || 0;
      const endIndex = startIndex + match[0].length;
      let replaceNode;
      if (startIndex === 0) {
        [replaceNode] = anchorNode.splitText(endIndex);
      } else {
        [, replaceNode] = anchorNode.splitText(startIndex, endIndex);
      }
      replaceNode.selectNext(0, 0);
      transformer3.replace(replaceNode, match);
      return true;
    }
    return false;
  }
  function runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {
    const textContent = anchorNode.getTextContent();
    const closeTagEndIndex = anchorOffset - 1;
    const closeChar = textContent[closeTagEndIndex];
    const matchers = textFormatTransformers[closeChar];
    if (!matchers) {
      return false;
    }
    for (const matcher of matchers) {
      const {
        tag
      } = matcher;
      const tagLength = tag.length;
      const closeTagStartIndex = closeTagEndIndex - tagLength + 1;
      if (tagLength > 1) {
        if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {
          continue;
        }
      }
      if (textContent[closeTagStartIndex - 1] === " ") {
        continue;
      }
      const afterCloseTagChar = textContent[closeTagEndIndex + 1];
      if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {
        continue;
      }
      const closeNode = anchorNode;
      let openNode = closeNode;
      let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag);
      let sibling = openNode;
      while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {
        if (lexical.$isLineBreakNode(sibling)) {
          break;
        }
        if (lexical.$isTextNode(sibling)) {
          const siblingTextContent = sibling.getTextContent();
          openNode = sibling;
          openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);
        }
      }
      if (openTagStartIndex < 0) {
        continue;
      }
      if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {
        continue;
      }
      const prevOpenNodeText = openNode.getTextContent();
      if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {
        continue;
      }
      const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];
      if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {
        continue;
      }
      const prevCloseNodeText = closeNode.getTextContent();
      const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);
      closeNode.setTextContent(closeNodeText);
      const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;
      openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));
      const selection = lexical.$getSelection();
      const nextSelection = lexical.$createRangeSelection();
      lexical.$setSelection(nextSelection);
      const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;
      nextSelection.anchor.set(openNode.__key, openTagStartIndex, "text");
      nextSelection.focus.set(closeNode.__key, newOffset, "text");
      for (const format3 of matcher.format) {
        if (!nextSelection.hasFormat(format3)) {
          nextSelection.formatText(format3);
        }
      }
      nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type);
      for (const format3 of matcher.format) {
        if (nextSelection.hasFormat(format3)) {
          nextSelection.toggleFormat(format3);
        }
      }
      if (lexical.$isRangeSelection(selection)) {
        nextSelection.format = selection.format;
      }
      return true;
    }
    return false;
  }
  function getOpenTagStartIndex(string, maxIndex2, tag) {
    const tagLength = tag.length;
    for (let i = maxIndex2; i >= tagLength; i--) {
      const startIndex = i - tagLength;
      if (isEqualSubString(string, startIndex, tag, 0, tagLength) && // Space after opening tag cancels transformation
      string[startIndex + tagLength] !== " ") {
        return startIndex;
      }
    }
    return -1;
  }
  function isEqualSubString(stringA, aStart, stringB, bStart, length) {
    for (let i = 0; i < length; i++) {
      if (stringA[aStart + i] !== stringB[bStart + i]) {
        return false;
      }
    }
    return true;
  }
  function registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {
    const byType = transformersByType(transformers);
    const textFormatTransformersIndex = indexBy(byType.textFormat, ({
      tag
    }) => tag[tag.length - 1]);
    const textMatchTransformersIndex = indexBy(byType.textMatch, ({
      trigger
    }) => trigger);
    for (const transformer3 of transformers) {
      const type2 = transformer3.type;
      if (type2 === "element" || type2 === "text-match") {
        const dependencies = transformer3.dependencies;
        if (!editor.hasNodes(dependencies)) {
          {
            throw Error(`MarkdownShortcuts: missing dependency for transformer. Ensure node dependency is included in editor initial config.`);
          }
        }
      }
    }
    const transform = (parentNode, anchorNode, anchorOffset) => {
      if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {
        return;
      }
      if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersIndex)) {
        return;
      }
      runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersIndex);
    };
    return editor.registerUpdateListener(({
      tags,
      dirtyLeaves,
      editorState,
      prevEditorState
    }) => {
      if (tags.has("historic")) {
        return;
      }
      const selection = editorState.read(lexical.$getSelection);
      const prevSelection = prevEditorState.read(lexical.$getSelection);
      if (!lexical.$isRangeSelection(prevSelection) || !lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {
        return;
      }
      const anchorKey = selection.anchor.key;
      const anchorOffset = selection.anchor.offset;
      const anchorNode = editorState._nodeMap.get(anchorKey);
      if (!lexical.$isTextNode(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset !== prevSelection.anchor.offset + 1) {
        return;
      }
      editor.update(() => {
        if (anchorNode.hasFormat("code")) {
          return;
        }
        const parentNode = anchorNode.getParent();
        if (parentNode === null || code.$isCodeNode(parentNode)) {
          return;
        }
        transform(parentNode, anchorNode, selection.anchor.offset);
      });
    });
  }
  const createBlockNode = (createNode) => {
    return (parentNode, children, match) => {
      const node = createNode(match);
      node.append(...children);
      parentNode.replace(node);
      node.select(0, 0);
    };
  };
  const LIST_INDENT_SIZE = 4;
  const listReplace = (listType) => {
    return (parentNode, children, match) => {
      const previousNode = parentNode.getPreviousSibling();
      const listItem = list.$createListItemNode(listType === "check" ? match[3] === "x" : void 0);
      if (list.$isListNode(previousNode) && previousNode.getListType() === listType) {
        previousNode.append(listItem);
        parentNode.remove();
      } else {
        const list$1 = list.$createListNode(listType, listType === "number" ? Number(match[2]) : void 0);
        list$1.append(listItem);
        parentNode.replace(list$1);
      }
      listItem.append(...children);
      listItem.select(0, 0);
      const indent = Math.floor(match[1].length / LIST_INDENT_SIZE);
      if (indent) {
        listItem.setIndent(indent);
      }
    };
  };
  const listExport = (listNode, exportChildren2, depth) => {
    const output = [];
    const children = listNode.getChildren();
    let index2 = 0;
    for (const listItemNode of children) {
      if (list.$isListItemNode(listItemNode)) {
        if (listItemNode.getChildrenSize() === 1) {
          const firstChild = listItemNode.getFirstChild();
          if (list.$isListNode(firstChild)) {
            output.push(listExport(firstChild, exportChildren2, depth + 1));
            continue;
          }
        }
        const indent = " ".repeat(depth * LIST_INDENT_SIZE);
        const listType = listNode.getListType();
        const prefix = listType === "number" ? `${listNode.getStart() + index2}. ` : listType === "check" ? `- [${listItemNode.getChecked() ? "x" : " "}] ` : "- ";
        output.push(indent + prefix + exportChildren2(listItemNode));
        index2++;
      }
    }
    return output.join("\n");
  };
  const HEADING = {
    dependencies: [richText.HeadingNode],
    export: (node, exportChildren2) => {
      if (!richText.$isHeadingNode(node)) {
        return null;
      }
      const level = Number(node.getTag().slice(1));
      return "#".repeat(level) + " " + exportChildren2(node);
    },
    regExp: /^(#{1,6})\s/,
    replace: createBlockNode((match) => {
      const tag = "h" + match[1].length;
      return richText.$createHeadingNode(tag);
    }),
    type: "element"
  };
  const QUOTE2 = {
    dependencies: [richText.QuoteNode],
    export: (node, exportChildren2) => {
      if (!richText.$isQuoteNode(node)) {
        return null;
      }
      const lines = exportChildren2(node).split("\n");
      const output = [];
      for (const line of lines) {
        output.push("> " + line);
      }
      return output.join("\n");
    },
    regExp: /^>\s/,
    replace: (parentNode, children, _match, isImport) => {
      if (isImport) {
        const previousNode = parentNode.getPreviousSibling();
        if (richText.$isQuoteNode(previousNode)) {
          previousNode.splice(previousNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...children]);
          previousNode.select(0, 0);
          parentNode.remove();
          return;
        }
      }
      const node = richText.$createQuoteNode();
      node.append(...children);
      parentNode.replace(node);
      node.select(0, 0);
    },
    type: "element"
  };
  const CODE = {
    dependencies: [code.CodeNode],
    export: (node) => {
      if (!code.$isCodeNode(node)) {
        return null;
      }
      const textContent = node.getTextContent();
      return "```" + (node.getLanguage() || "") + (textContent ? "\n" + textContent : "") + "\n```";
    },
    regExp: /^```(\w{1,10})?\s/,
    replace: createBlockNode((match) => {
      return code.$createCodeNode(match ? match[1] : void 0);
    }),
    type: "element"
  };
  const UNORDERED_LIST = {
    dependencies: [list.ListNode, list.ListItemNode],
    export: (node, exportChildren2) => {
      return list.$isListNode(node) ? listExport(node, exportChildren2, 0) : null;
    },
    regExp: /^(\s*)[-*+]\s/,
    replace: listReplace("bullet"),
    type: "element"
  };
  const CHECK_LIST = {
    dependencies: [list.ListNode, list.ListItemNode],
    export: (node, exportChildren2) => {
      return list.$isListNode(node) ? listExport(node, exportChildren2, 0) : null;
    },
    regExp: /^(\s*)(?:-\s)?\s?(\[(\s|x)?\])\s/i,
    replace: listReplace("check"),
    type: "element"
  };
  const ORDERED_LIST = {
    dependencies: [list.ListNode, list.ListItemNode],
    export: (node, exportChildren2) => {
      return list.$isListNode(node) ? listExport(node, exportChildren2, 0) : null;
    },
    regExp: /^(\s*)(\d{1,})\.\s/,
    replace: listReplace("number"),
    type: "element"
  };
  const INLINE_CODE = {
    format: ["code"],
    tag: "`",
    type: "text-format"
  };
  const HIGHLIGHT = {
    format: ["highlight"],
    tag: "==",
    type: "text-format"
  };
  const BOLD_ITALIC_STAR = {
    format: ["bold", "italic"],
    tag: "***",
    type: "text-format"
  };
  const BOLD_ITALIC_UNDERSCORE = {
    format: ["bold", "italic"],
    intraword: false,
    tag: "___",
    type: "text-format"
  };
  const BOLD_STAR = {
    format: ["bold"],
    tag: "**",
    type: "text-format"
  };
  const BOLD_UNDERSCORE = {
    format: ["bold"],
    intraword: false,
    tag: "__",
    type: "text-format"
  };
  const STRIKETHROUGH = {
    format: ["strikethrough"],
    tag: "~~",
    type: "text-format"
  };
  const ITALIC_STAR = {
    format: ["italic"],
    tag: "*",
    type: "text-format"
  };
  const ITALIC_UNDERSCORE = {
    format: ["italic"],
    intraword: false,
    tag: "_",
    type: "text-format"
  };
  const LINK = {
    dependencies: [link3.LinkNode],
    export: (node, exportChildren2, exportFormat) => {
      if (!link3.$isLinkNode(node)) {
        return null;
      }
      const linkContent = `[${node.getTextContent()}](${node.getURL()})`;
      const firstChild = node.getFirstChild();
      if (node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild)) {
        return exportFormat(firstChild, linkContent);
      } else {
        return linkContent;
      }
    },
    importRegExp: /(?:\[([^[]+)\])(?:\(([^()]+)\))/,
    regExp: /(?:\[([^[]+)\])(?:\(([^()]+)\))$/,
    replace: (textNode, match) => {
      const [, linkText, linkUrl] = match;
      const linkNode = link3.$createLinkNode(linkUrl);
      const linkTextNode = lexical.$createTextNode(linkText);
      linkTextNode.setFormat(textNode.getFormat());
      linkNode.append(linkTextNode);
      textNode.replace(linkNode);
    },
    trigger: ")",
    type: "text-match"
  };
  const ELEMENT_TRANSFORMERS = [HEADING, QUOTE2, CODE, UNORDERED_LIST, ORDERED_LIST];
  const TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];
  const TEXT_MATCH_TRANSFORMERS = [LINK];
  const TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];
  function $convertFromMarkdownString(markdown, transformers = TRANSFORMERS) {
    const importMarkdown = createMarkdownImport(transformers);
    return importMarkdown(markdown);
  }
  function $convertToMarkdownString(transformers = TRANSFORMERS) {
    const exportMarkdown = createMarkdownExport(transformers);
    return exportMarkdown();
  }
  LexicalMarkdown_dev.$convertFromMarkdownString = $convertFromMarkdownString;
  LexicalMarkdown_dev.$convertToMarkdownString = $convertToMarkdownString;
  LexicalMarkdown_dev.BOLD_ITALIC_STAR = BOLD_ITALIC_STAR;
  LexicalMarkdown_dev.BOLD_ITALIC_UNDERSCORE = BOLD_ITALIC_UNDERSCORE;
  LexicalMarkdown_dev.BOLD_STAR = BOLD_STAR;
  LexicalMarkdown_dev.BOLD_UNDERSCORE = BOLD_UNDERSCORE;
  LexicalMarkdown_dev.CHECK_LIST = CHECK_LIST;
  LexicalMarkdown_dev.CODE = CODE;
  LexicalMarkdown_dev.ELEMENT_TRANSFORMERS = ELEMENT_TRANSFORMERS;
  LexicalMarkdown_dev.HEADING = HEADING;
  LexicalMarkdown_dev.HIGHLIGHT = HIGHLIGHT;
  LexicalMarkdown_dev.INLINE_CODE = INLINE_CODE;
  LexicalMarkdown_dev.ITALIC_STAR = ITALIC_STAR;
  LexicalMarkdown_dev.ITALIC_UNDERSCORE = ITALIC_UNDERSCORE;
  LexicalMarkdown_dev.LINK = LINK;
  LexicalMarkdown_dev.ORDERED_LIST = ORDERED_LIST;
  LexicalMarkdown_dev.QUOTE = QUOTE2;
  LexicalMarkdown_dev.STRIKETHROUGH = STRIKETHROUGH;
  LexicalMarkdown_dev.TEXT_FORMAT_TRANSFORMERS = TEXT_FORMAT_TRANSFORMERS;
  LexicalMarkdown_dev.TEXT_MATCH_TRANSFORMERS = TEXT_MATCH_TRANSFORMERS;
  LexicalMarkdown_dev.TRANSFORMERS = TRANSFORMERS;
  LexicalMarkdown_dev.UNORDERED_LIST = UNORDERED_LIST;
  LexicalMarkdown_dev.registerMarkdownShortcuts = registerMarkdownShortcuts;
  return LexicalMarkdown_dev;
}
var LexicalMarkdown = true ? requireLexicalMarkdown_dev() : requireLexicalMarkdown_prod();
var LexicalMarkdown_1 = LexicalMarkdown;
var LexicalUtilsExports = requireLexicalUtils();
function ListPlugin() {
  const [editor] = (0, import_LexicalComposerContext.useLexicalComposerContext)();
  (0, import_react2.useEffect)(() => {
    return LexicalUtilsExports.mergeRegister(
      editor.registerCommand(
        LexicalList_1.INSERT_ORDERED_LIST_COMMAND,
        () => {
          LexicalList_1.insertList(editor, "number");
          return true;
        },
        import_lexical.COMMAND_PRIORITY_LOW
      ),
      editor.registerCommand(
        LexicalList_1.INSERT_UNORDERED_LIST_COMMAND,
        () => {
          LexicalList_1.insertList(editor, "bullet");
          return true;
        },
        import_lexical.COMMAND_PRIORITY_LOW
      ),
      editor.registerCommand(
        LexicalList_1.REMOVE_LIST_COMMAND,
        () => {
          LexicalList_1.removeList(editor);
          return true;
        },
        import_lexical.COMMAND_PRIORITY_LOW
      ),
      editor.registerCommand(
        import_lexical.INSERT_PARAGRAPH_COMMAND,
        () => {
          const hasHandledInsertParagraph = LexicalList_1.$handleListInsertParagraph();
          return hasHandledInsertParagraph;
        },
        import_lexical.COMMAND_PRIORITY_LOW
      )
    );
  }, [editor]);
  return null;
}
var LexicalSelectionExports = requireLexicalSelection();
var useToolbarStyles = makeStyles_default((theme) => ({
  paper: {
    display: "flex",
    flexDirection: "row",
    borderBottom: `1px solid ${theme.palette.divider}`,
    flexWrap: "wrap"
  },
  divider: {
    margin: theme.spacing(1, 0.5)
  },
  button: {
    color: theme.palette.primary.light,
    "&.Mui-selected:not(:disabled)": {
      color: theme.palette.primary.main
    }
  }
}));
var StyledToggleButtonGroup = withStyles_default((theme) => ({
  grouped: {
    margin: theme.spacing(0.5),
    border: "none",
    "&:not(:first-child)": {
      borderRadius: theme.shape.borderRadius
    },
    "&:first-child": {
      borderRadius: theme.shape.borderRadius
    }
  }
}))(ToggleButtonGroup_default);
var ToolbarPlugin = ({ readOnly }) => {
  const [editor] = (0, import_LexicalComposerContext.useLexicalComposerContext)();
  const [isBold, setIsBold] = (0, import_react2.useState)(false);
  const [isItalic, setIsItalic] = (0, import_react2.useState)(false);
  const [isStrikeTrough, setIsStrikeTrough] = (0, import_react2.useState)(false);
  const [isCode, setIsCode] = (0, import_react2.useState)(false);
  const [blockType, setBlockType] = (0, import_react2.useState)("paragraph");
  const updateButtons = (toggled2) => {
    setIsBold(toggled2.includes("bold"));
    setIsItalic(toggled2.includes("italic"));
    setIsStrikeTrough(toggled2.includes("strikethrough"));
    setIsCode(toggled2.includes("code"));
    if (toggled2.includes("paragraph")) {
      setBlockType("paragraph");
    }
    if (toggled2.includes("header1")) {
      setBlockType("header1");
    }
    if (toggled2.includes("number-list")) {
      setBlockType("number-list");
    }
    if (toggled2.includes("bullet-list")) {
      setBlockType("bullet-list");
    }
  };
  const updateToolbar = (0, import_react2.useCallback)(() => {
    const selection = (0, import_lexical.$getSelection)();
    if ((0, import_lexical.$isRangeSelection)(selection)) {
      const anchorNode = selection.anchor.getNode();
      const element = anchorNode.getKey() === "root" ? anchorNode : anchorNode.getTopLevelElementOrThrow();
      const elementKey = element.getKey();
      const elementDOM = editor.getElementByKey(elementKey);
      if (elementDOM !== null) {
        setIsBold(selection.hasFormat("bold"));
        setIsItalic(selection.hasFormat("italic"));
        setIsStrikeTrough(selection.hasFormat("strikethrough"));
        setIsCode(selection.hasFormat("code"));
        if (LexicalList_1.$isListNode(element)) {
          const parentList = LexicalUtilsExports.$getNearestNodeOfType(anchorNode, LexicalList_1.ListNode);
          const type2 = parentList ? parentList.getTag() : element.getTag();
          if (type2 === "ol") {
            setBlockType("number-list");
          } else if (type2 === "ul") {
            setBlockType("bullet-list");
          } else {
            setBlockType(type2);
          }
        } else {
          const type2 = LexicalRichText_1.$isHeadingNode(element) ? element.getTag() : element.getType();
          if (type2 === "h1") {
            setBlockType("header1");
          } else if (type2 === "paragraph") {
            setBlockType("paragraph");
          } else {
            setBlockType(type2);
          }
        }
      }
    }
  }, []);
  (0, import_react2.useEffect)(() => {
    return LexicalUtilsExports.mergeRegister(
      editor.registerUpdateListener(({ editorState }) => {
        editorState.read(() => {
          updateToolbar();
        });
      }),
      editor.registerCommand(
        import_lexical.SELECTION_CHANGE_COMMAND,
        (_payload, _newEditor) => {
          updateToolbar();
          return false;
        },
        import_lexical.COMMAND_PRIORITY_LOW
      )
    );
  }, [editor, updateToolbar]);
  const toggled = [blockType];
  if (isBold) {
    toggled.push("bold");
  }
  if (isItalic) {
    toggled.push("italic");
  }
  if (isStrikeTrough) {
    toggled.push("strikethrough");
  }
  if (isCode) {
    toggled.push("code");
  }
  const classes = useToolbarStyles({});
  return (0, import_jsx_runtime2.jsxs)(Paper_default, { elevation: 0, className: classes.paper, children: [
    (0, import_jsx_runtime2.jsxs)(StyledToggleButtonGroup, { size: "small", value: toggled, onChange: (_, newStyles) => updateButtons(newStyles), children: [
      (0, import_jsx_runtime2.jsx)(
        ToggleButton_default,
        {
          classes: { root: classes.button },
          disabled: readOnly,
          value: "paragraph",
          onClick: () => {
            editor.update(() => {
              const selection = (0, import_lexical.$getSelection)();
              if ((0, import_lexical.$isRangeSelection)(selection)) {
                LexicalSelectionExports.$wrapNodes(selection, () => (0, import_lexical.$createParagraphNode)());
              }
            });
          },
          children: (0, import_jsx_runtime2.jsx)(import_Subject.default, { fontSize: "small" })
        },
        "paragraph"
      ),
      (0, import_jsx_runtime2.jsx)(
        ToggleButton_default,
        {
          classes: { root: classes.button },
          disabled: readOnly,
          value: "header1",
          onClick: () => {
            editor.update(() => {
              const selection = (0, import_lexical.$getSelection)();
              if ((0, import_lexical.$isRangeSelection)(selection)) {
                LexicalSelectionExports.$wrapNodes(selection, () => LexicalRichText_1.$createHeadingNode("h1"));
              }
            });
          },
          children: (0, import_jsx_runtime2.jsx)(import_Title.default, { fontSize: "small" })
        },
        "header1"
      ),
      (0, import_jsx_runtime2.jsx)(
        ToggleButton_default,
        {
          classes: { root: classes.button },
          disabled: readOnly,
          value: "bullet-list",
          onClick: () => {
            if (blockType !== "bullet-list") {
              editor.dispatchCommand(LexicalList_1.INSERT_UNORDERED_LIST_COMMAND, void 0);
            } else {
              editor.dispatchCommand(LexicalList_1.REMOVE_LIST_COMMAND, void 0);
            }
          },
          children: (0, import_jsx_runtime2.jsx)(import_FormatListBulleted.default, { fontSize: "small" })
        },
        "bullet-list"
      ),
      (0, import_jsx_runtime2.jsx)(
        ToggleButton_default,
        {
          classes: { root: classes.button },
          disabled: readOnly,
          value: "number-list",
          onClick: () => {
            if (blockType !== "number-list") {
              editor.dispatchCommand(LexicalList_1.INSERT_ORDERED_LIST_COMMAND, void 0);
            } else {
              editor.dispatchCommand(LexicalList_1.REMOVE_LIST_COMMAND, void 0);
            }
          },
          children: (0, import_jsx_runtime2.jsx)(import_FormatListNumbered.default, { fontSize: "small" })
        },
        "number-list"
      )
    ] }),
    (0, import_jsx_runtime2.jsx)(Divider_default, { flexItem: true, orientation: "vertical", className: classes.divider }),
    (0, import_jsx_runtime2.jsxs)(StyledToggleButtonGroup, { size: "small", value: toggled, onChange: (_, newStyles) => updateButtons(newStyles), children: [
      (0, import_jsx_runtime2.jsx)(
        ToggleButton_default,
        {
          classes: { root: classes.button },
          disabled: readOnly,
          value: "bold",
          onClick: () => {
            editor.dispatchCommand(import_lexical.FORMAT_TEXT_COMMAND, "bold");
          },
          children: (0, import_jsx_runtime2.jsx)(import_FormatBold.default, { fontSize: "small" })
        },
        "bold"
      ),
      (0, import_jsx_runtime2.jsx)(
        ToggleButton_default,
        {
          classes: { root: classes.button },
          disabled: readOnly,
          value: "italic",
          onClick: () => {
            editor.dispatchCommand(import_lexical.FORMAT_TEXT_COMMAND, "italic");
          },
          children: (0, import_jsx_runtime2.jsx)(import_FormatItalic.default, { fontSize: "small" })
        },
        "italic"
      ),
      (0, import_jsx_runtime2.jsx)(
        ToggleButton_default,
        {
          classes: { root: classes.button },
          disabled: readOnly,
          value: "code",
          onClick: () => {
            editor.dispatchCommand(import_lexical.FORMAT_TEXT_COMMAND, "code");
          },
          children: (0, import_jsx_runtime2.jsx)(import_Code.default, { fontSize: "small" })
        },
        "code"
      ),
      (0, import_jsx_runtime2.jsx)(
        ToggleButton_default,
        {
          classes: { root: classes.button },
          disabled: readOnly,
          value: "strikethrough",
          onClick: () => {
            editor.dispatchCommand(import_lexical.FORMAT_TEXT_COMMAND, "strikethrough");
          },
          children: (0, import_jsx_runtime2.jsx)(import_StrikethroughS.default, { fontSize: "small" })
        },
        "strikethrough"
      )
    ] })
  ] });
};
var ContentEditable = ({ onFocus, readOnly }) => {
  const [editor] = (0, import_LexicalComposerContext.useLexicalComposerContext)();
  const ref = (0, import_react2.useCallback)(
    (rootElement) => {
      editor.setRootElement(rootElement);
    },
    [editor]
  );
  return (0, import_jsx_runtime2.jsx)("div", { ref, contentEditable: !readOnly, spellCheck: false, onFocus });
};
var UpdateValuePlugin = ({ markdownText }) => {
  const [editor] = (0, import_LexicalComposerContext.useLexicalComposerContext)();
  (0, import_react2.useEffect)(() => {
    editor.update(() => {
      LexicalMarkdown_1.$convertFromMarkdownString(markdownText, LexicalMarkdown_1.TRANSFORMERS);
      (0, import_lexical.$setSelection)(null);
    });
  }, [editor, markdownText]);
  return null;
};
var OnBlurPlugin = ({ onBlur, children }) => {
  const [editor] = (0, import_LexicalComposerContext.useLexicalComposerContext)();
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      onBlur: (event) => {
        if (!event.currentTarget.contains(event.relatedTarget)) {
          editor.getEditorState().read(() => {
            const markdown = LexicalMarkdown_1.$convertToMarkdownString(LexicalMarkdown_1.TRANSFORMERS);
            onBlur(markdown);
          });
        }
      },
      children
    }
  );
};
var useRichTextEditorStyles = makeStyles_default((theme) => ({
  editorContainer: {
    marginTop: theme.spacing(2),
    color: theme.palette.text.primary,
    position: "relative",
    fontWeight: Number(theme.typography.fontWeightRegular),
    textAlign: "left",
    borderBottom: `1px solid ${theme.palette.divider}`,
    "&:hover": {
      borderBottom: `2px solid ${theme.palette.divider}`
    },
    "&:focus-within": {
      transition: "transform 200ms cubic-bezier(0.0, 0, 0.2, 1) 0ms",
      borderBottom: `2px solid ${theme.palette.primary.main}`
    }
  },
  editorPlaceholder: {
    color: theme.palette.text.secondary,
    top: 0,
    overflow: "hidden",
    position: "absolute",
    textOverflow: "ellipsis",
    fontSize: theme.typography.fontSize,
    userSelect: "none",
    display: "inline-block",
    pointerEvents: "none"
  },
  editorParagraph: {
    margin: 0,
    marginBottom: theme.spacing(2),
    position: "relative"
  },
  editorTextBold: {
    fontWeight: "bold"
  },
  editorTextItalic: {
    fontStyle: "italic"
  },
  editorTextUnderline: {
    textDecoration: "underline"
  },
  editorTextStrikethrough: {
    textDecoration: "line-through"
  },
  editorTextUnderlineStrikethrough: {
    textDecoration: "underline line-through"
  },
  editorTextCode: {
    backgroundColor: theme.palette.background.default,
    padding: "1px 0.25rem",
    fontFamily: "Menlo, Consolas, Monaco, monospace",
    fontSize: "94%"
  },
  editorHeading1: {
    fontFamily: theme.typography.h4.fontFamily,
    fontSize: theme.typography.h4.fontSize,
    fontWeight: theme.typography.h4.fontWeight,
    lineHeight: theme.typography.h4.lineHeight,
    letterSpacing: theme.typography.h4.letterSpacing,
    color: theme.palette.text.primary,
    margin: 0,
    marginBottom: theme.spacing(3),
    padding: 0
  },
  editorHeading2: {
    fontFamily: theme.typography.h5.fontFamily,
    fontSize: theme.typography.h5.fontSize,
    fontWeight: theme.typography.h5.fontWeight,
    lineHeight: theme.typography.h5.lineHeight,
    letterSpacing: theme.typography.h5.letterSpacing,
    color: theme.palette.text.secondary,
    margin: 0,
    marginTop: theme.spacing(2),
    padding: 0
  },
  editorListOl: {
    padding: 0,
    margin: 0,
    marginLeft: theme.spacing(2),
    listStyle: "decimal"
  },
  editorListUl: {
    padding: 0,
    margin: 0,
    marginLeft: theme.spacing(2),
    listStyle: "circle"
  },
  editorListitem: {
    margin: `${theme.spacing(2)} ${theme.spacing(8)} ${theme.spacing(2)} ${theme.spacing(8)}`
  },
  editorNestedListitem: {
    listStyleType: "none"
  }
}));
var RichTextEditor = ({ value: value22, placeholder, readOnly, onFocus, onBlur }) => {
  const classes = useRichTextEditorStyles();
  const theme = {
    placeholder: classes.editorPlaceholder,
    paragraph: classes.editorParagraph,
    heading: {
      h1: classes.editorHeading1,
      h2: classes.editorHeading2
    },
    list: {
      nested: {
        listitem: classes.editorNestedListitem
      },
      ol: classes.editorListOl,
      ul: classes.editorListUl,
      listitem: classes.editorListitem
    },
    text: {
      bold: classes.editorTextBold,
      italic: classes.editorTextItalic,
      underline: classes.editorTextUnderline,
      strikethrough: classes.editorTextStrikethrough,
      underlineStrikethrough: classes.editorTextUnderlineStrikethrough,
      code: classes.editorTextCode
    }
  };
  const initialConfig = {
    namespace: "RichTextEditor",
    onError: console.error,
    theme,
    nodes: [LexicalRichText_1.HeadingNode, LexicalList_1.ListNode, LexicalList_1.ListItemNode, LexicalRichText_1.QuoteNode, import_LexicalHorizontalRuleNode.HorizontalRuleNode, import_lexical.TextNode, LexicalCode_1.CodeNode, LexicalLink_1.LinkNode]
  };
  return (0, import_jsx_runtime2.jsx)(import_LexicalComposer.LexicalComposer, { initialConfig, children: (0, import_jsx_runtime2.jsxs)(OnBlurPlugin, { onBlur, children: [
    (0, import_jsx_runtime2.jsx)(UpdateValuePlugin, { markdownText: value22 }),
    (0, import_jsx_runtime2.jsx)(ToolbarPlugin, { readOnly }),
    (0, import_jsx_runtime2.jsxs)("div", { className: classes.editorContainer, children: [
      (0, import_jsx_runtime2.jsx)(import_LexicalMarkdownShortcutPlugin.MarkdownShortcutPlugin, { transformers: LexicalMarkdown_1.TRANSFORMERS }),
      (0, import_jsx_runtime2.jsx)(ListPlugin, {}),
      (0, import_jsx_runtime2.jsx)(
        import_LexicalRichTextPlugin.RichTextPlugin,
        {
          contentEditable: (0, import_jsx_runtime2.jsx)(ContentEditable, { onFocus, readOnly }),
          placeholder: (0, import_jsx_runtime2.jsx)("div", { className: classes.editorPlaceholder, children: placeholder }),
          ErrorBoundary: import_LexicalErrorBoundary.default
        }
      ),
      (0, import_jsx_runtime2.jsx)(import_LexicalTabIndentationPlugin.TabIndentationPlugin, {})
    ] })
  ] }) });
};
var editRichTextMutation = gql`
  mutation editRichText($input: EditRichTextInput!) {
    editRichText(input: $input) {
      __typename
      ... on ErrorPayload {
        messages {
          body
          level
        }
      }
      ... on SuccessPayload {
        messages {
          body
          level
        }
      }
    }
  }
`;
var updateWidgetFocusMutation$3 = gql`
  mutation updateWidgetFocus($input: UpdateWidgetFocusInput!) {
    updateWidgetFocus(input: $input) {
      __typename
      ... on ErrorPayload {
        messages {
          body
          level
        }
      }
    }
  }
`;
var isErrorPayload$3 = (payload) => payload.__typename === "ErrorPayload";
var isSuccessPayload$3 = (payload) => payload.__typename === "SuccessPayload";
var RichTextPropertySection = ({
  editingContextId,
  formId,
  widget,
  subscribers,
  readOnly
}) => {
  const [editRichText, { loading: updateRichTextLoading, data: updateRichTextData, error: updateRichTextError }] = useMutation(editRichTextMutation);
  const sendEditedValue = (newValue) => {
    const input = {
      id: crypto.randomUUID(),
      editingContextId,
      representationId: formId,
      richTextId: widget.id,
      newValue
    };
    const variables = { input };
    editRichText({ variables });
  };
  const { addErrorMessage, addMessages } = useMultiToast();
  (0, import_react2.useEffect)(() => {
    if (!updateRichTextLoading) {
      if (updateRichTextError) {
        addErrorMessage("An unexpected error has occurred, please refresh the page");
      }
      if (updateRichTextData) {
        const { editRichText: editRichText2 } = updateRichTextData;
        if (isErrorPayload$3(editRichText2) || isSuccessPayload$3(editRichText2)) {
          addMessages(editRichText2.messages);
        }
      }
    }
  }, [updateRichTextLoading, updateRichTextData, updateRichTextError]);
  const [
    updateWidgetFocus,
    { loading: updateWidgetFocusLoading, data: updateWidgetFocusData, error: updateWidgetFocusError }
  ] = useMutation(updateWidgetFocusMutation$3);
  const sendUpdateWidgetFocus = (selected) => {
    const input = {
      id: crypto.randomUUID(),
      editingContextId,
      representationId: formId,
      widgetId: widget.id,
      selected
    };
    const variables = {
      input
    };
    updateWidgetFocus({ variables });
  };
  (0, import_react2.useEffect)(() => {
    if (!updateWidgetFocusLoading) {
      if (updateWidgetFocusError) {
        addErrorMessage("An unexpected error has occurred, please refresh the page");
      }
      if (updateWidgetFocusData) {
        const { updateWidgetFocus: updateWidgetFocus2 } = updateWidgetFocusData;
        if (isErrorPayload$3(updateWidgetFocus2)) {
          addMessages(updateWidgetFocus2.messages);
        }
      }
    }
  }, [updateWidgetFocusLoading, updateWidgetFocusData, updateWidgetFocusError]);
  const onFocus = () => sendUpdateWidgetFocus(true);
  const onBlur = (currentText) => {
    sendUpdateWidgetFocus(false);
    if (currentText !== widget.stringValue) {
      sendEditedValue(currentText);
    }
  };
  return (0, import_jsx_runtime2.jsxs)("div", { children: [
    (0, import_jsx_runtime2.jsx)(
      PropertySectionLabel,
      {
        editingContextId,
        formId,
        widget,
        subscribers
      }
    ),
    (0, import_jsx_runtime2.jsx)("div", { "data-testid": widget.label, children: (0, import_jsx_runtime2.jsx)(
      RichTextEditor,
      {
        value: widget.stringValue,
        placeholder: widget.label,
        onFocus,
        onBlur,
        readOnly: readOnly || widget.readOnly
      }
    ) })
  ] });
};
var useStyle$2 = makeStyles_default((theme) => ({
  style: {
    backgroundColor: ({ backgroundColor }) => backgroundColor ? getCSSColor(backgroundColor, theme) : null,
    color: ({ foregroundColor }) => foregroundColor ? getCSSColor(foregroundColor, theme) : null,
    fontSize: ({ fontSize }) => fontSize ? fontSize : null,
    fontStyle: ({ italic }) => italic ? "italic" : null,
    fontWeight: ({ bold }) => bold ? "bold" : null,
    textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough)
  },
  iconRoot: {
    minWidth: theme.spacing(3)
  }
}));
var editSelectMutation = gql`
  mutation editSelect($input: EditSelectInput!) {
    editSelect(input: $input) {
      __typename
      ... on ErrorPayload {
        messages {
          body
          level
        }
      }
      ... on SuccessPayload {
        messages {
          body
          level
        }
      }
    }
  }
`;
var updateWidgetFocusMutation$2 = gql`
  mutation updateWidgetFocus($input: UpdateWidgetFocusInput!) {
    updateWidgetFocus(input: $input) {
      __typename
      ... on ErrorPayload {
        messages {
          body
          level
        }
      }
    }
  }
`;
var isErrorPayload$2 = (payload) => payload.__typename === "ErrorPayload";
var isSuccessPayload$2 = (payload) => payload.__typename === "SuccessPayload";
var SelectPropertySection = ({
  editingContextId,
  formId,
  widget,
  subscribers,
  readOnly
}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const props = {
    backgroundColor: ((_a = widget.style) == null ? void 0 : _a.backgroundColor) ?? null,
    foregroundColor: ((_b = widget.style) == null ? void 0 : _b.foregroundColor) ?? null,
    fontSize: ((_c = widget.style) == null ? void 0 : _c.fontSize) ?? null,
    italic: ((_d = widget.style) == null ? void 0 : _d.italic) ?? null,
    bold: ((_e = widget.style) == null ? void 0 : _e.bold) ?? null,
    underline: ((_f = widget.style) == null ? void 0 : _f.underline) ?? null,
    strikeThrough: ((_g = widget.style) == null ? void 0 : _g.strikeThrough) ?? null
  };
  const classes = useStyle$2(props);
  const [isFocused, setFocus] = (0, import_react2.useState)(false);
  const [editSelect, { loading, error, data }] = useMutation(editSelectMutation);
  const onChange = (event) => {
    const newValue = event.target.value;
    const variables = {
      input: {
        id: crypto.randomUUID(),
        editingContextId,
        representationId: formId,
        selectId: widget.id,
        newValue
      }
    };
    editSelect({ variables });
  };
  const { addErrorMessage, addMessages } = useMultiToast();
  (0, import_react2.useEffect)(() => {
    if (!loading) {
      if (error) {
        addErrorMessage("An unexpected error has occurred, please refresh the page");
      }
      if (data) {
        const { editSelect: editSelect2 } = data;
        if (isErrorPayload$2(editSelect2) || isSuccessPayload$2(editSelect2)) {
          addMessages(editSelect2.messages);
        }
      }
    }
  }, [loading, error, data]);
  const [
    updateWidgetFocus,
    { loading: updateWidgetFocusLoading, data: updateWidgetFocusData, error: updateWidgetFocusError }
  ] = useMutation(updateWidgetFocusMutation$2);
  const sendUpdateWidgetFocus = (selected) => {
    const variables = {
      input: {
        id: crypto.randomUUID(),
        editingContextId,
        representationId: formId,
        widgetId: widget.id,
        selected
      }
    };
    updateWidgetFocus({ variables });
  };
  (0, import_react2.useEffect)(() => {
    if (!updateWidgetFocusLoading) {
      if (updateWidgetFocusError) {
        addErrorMessage("An unexpected error has occurred, please refresh the page");
      }
      if (updateWidgetFocusData) {
        const { updateWidgetFocus: updateWidgetFocus2 } = updateWidgetFocusData;
        if (isErrorPayload$2(updateWidgetFocus2)) {
          addMessages(updateWidgetFocus2.messages);
        }
      }
    }
  }, [updateWidgetFocusLoading, updateWidgetFocusData, updateWidgetFocusError]);
  const onFocus = () => {
    if (!isFocused) {
      setFocus(true);
      sendUpdateWidgetFocus(true);
    }
  };
  const onBlur = () => {
    setFocus(false);
    sendUpdateWidgetFocus(false);
  };
  return (0, import_jsx_runtime2.jsxs)(FormControl_default, { error: widget.diagnostics.length > 0, children: [
    (0, import_jsx_runtime2.jsx)(
      PropertySectionLabel,
      {
        editingContextId,
        formId,
        widget,
        subscribers
      }
    ),
    (0, import_jsx_runtime2.jsxs)(
      Select_default,
      {
        value: widget.value || "",
        onChange,
        displayEmpty: true,
        onFocus,
        onBlur,
        fullWidth: true,
        "data-testid": widget.label,
        disabled: readOnly || widget.readOnly,
        inputProps: widget.style ? {
          className: classes.style
        } : {},
        children: [
          (0, import_jsx_runtime2.jsx)(
            MenuItem_default,
            {
              value: "",
              classes: widget.style ? {
                root: classes.style
              } : {},
              children: (0, import_jsx_runtime2.jsx)("em", { children: "None" })
            }
          ),
          widget.options.map((option) => (0, import_jsx_runtime2.jsxs)(
            MenuItem_default,
            {
              value: option.id,
              classes: widget.style ? {
                root: classes.style
              } : {},
              children: [
                option.iconURL.length > 0 && (0, import_jsx_runtime2.jsx)(ListItemIcon_default, { className: classes.iconRoot, children: (0, import_jsx_runtime2.jsx)(IconOverlay, { iconURL: option.iconURL, alt: option.label }) }),
                option.label
              ]
            },
            option.id
          ))
        ]
      }
    ),
    (0, import_jsx_runtime2.jsx)(FormHelperText_default, { children: (_h = widget.diagnostics[0]) == null ? void 0 : _h.message })
  ] });
};
var ProposalsList = ({ anchorEl, proposals, onProposalSelected, onClose }) => {
  return (0, import_jsx_runtime2.jsx)(
    Popover_default,
    {
      open: true,
      onClose,
      anchorEl,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "left"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "left"
      },
      children: (0, import_jsx_runtime2.jsx)(MenuList_default, { id: "completion-proposals", "data-testid": "completion-proposals", children: proposals.map((proposal, index2) => (0, import_jsx_runtime2.jsx)(
        Tooltip_default,
        {
          "data-testid": `proposal-${proposal.textToInsert}-${proposal.charsToReplace}`,
          title: proposal.description,
          placement: "right",
          children: (0, import_jsx_runtime2.jsx)(MenuItem_default, { button: true, onClick: () => onProposalSelected(proposal), children: (0, import_jsx_runtime2.jsx)(ListItemText_default, { primary: proposal.textToInsert }) })
        },
        index2
      )) })
    }
  );
};
var textfieldPropertySectionMachine = Machine(
  {
    type: "parallel",
    context: {
      value: "",
      completionRequest: null,
      proposals: null
    },
    states: {
      textfieldPropertySection: {
        initial: "pristine",
        states: {
          pristine: {
            on: {
              INITIALIZE: {
                target: "pristine",
                actions: "updateValue"
              },
              CHANGE_VALUE: {
                target: "edited",
                actions: "updateValue"
              }
            }
          },
          edited: {
            on: {
              INITIALIZE: {
                target: "pristine",
                actions: "initializeValue"
              },
              CHANGE_VALUE: {
                target: "edited",
                actions: "updateValue"
              }
            }
          }
        }
      },
      completion: {
        initial: "idle",
        states: {
          idle: {
            on: {
              COMPLETION_REQUESTED: {
                target: "requested",
                actions: "setCompletionRequest"
              }
            }
          },
          requested: {
            on: {
              COMPLETION_RECEIVED: [
                {
                  cond: "noProposals",
                  target: "idle"
                },
                {
                  target: "received",
                  actions: "setReceivedProposals"
                }
              ]
            }
          },
          received: {
            on: {
              COMPLETION_DISMISSED: {
                target: "idle",
                actions: "resetCompletion"
              },
              COMPLETION_REQUESTED: {
                target: "requested",
                actions: ["resetCompletion", "setCompletionRequest"]
              }
            }
          }
        }
      }
    }
  },
  {
    guards: {
      noProposals: (_, event) => {
        const { proposals } = event;
        return proposals.length === 0;
      }
    },
    actions: {
      initializeValue: assign((context, event) => {
        const { value: value22 } = event;
        const { value: previousValue } = context;
        if (value22 !== previousValue) {
          console.trace(`The following content "${previousValue}" has been overwritten by "${value22}"`);
        }
        return { value: value22 };
      }),
      updateValue: assign((_, event) => {
        const { value: value22 } = event;
        return { value: value22 };
      }),
      setCompletionRequest: assign((_, event) => {
        const { currentText, cursorPosition } = event;
        return { completionRequest: { currentText, cursorPosition } };
      }),
      setReceivedProposals: assign((_, event) => {
        const { proposals } = event;
        return { proposals };
      }),
      resetCompletion: assign((_) => {
        return { completionRequest: null, proposals: null };
      })
    }
  }
);
var useStyle$1 = makeStyles_default((theme) => ({
  style: {
    backgroundColor: ({ backgroundColor }) => backgroundColor ? getCSSColor(backgroundColor, theme) : null,
    color: ({ foregroundColor }) => foregroundColor ? getCSSColor(foregroundColor, theme) : null,
    fontSize: ({ fontSize }) => fontSize ? fontSize : null,
    fontStyle: ({ italic }) => italic ? "italic" : null,
    fontWeight: ({ bold }) => bold ? "bold" : null,
    textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough)
  }
}));
var getCompletionProposalsQuery = gql`
  query completionProposals(
    $editingContextId: ID!
    $formId: ID!
    $widgetId: ID!
    $currentText: String!
    $cursorPosition: Int!
  ) {
    viewer {
      editingContext(editingContextId: $editingContextId) {
        representation(representationId: $formId) {
          description {
            ... on FormDescription {
              completionProposals(widgetId: $widgetId, currentText: $currentText, cursorPosition: $cursorPosition) {
                description
                textToInsert
                charsToReplace
              }
            }
          }
        }
      }
    }
  }
`;
var editTextfieldMutation = gql`
  mutation editTextfield($input: EditTextfieldInput!) {
    editTextfield(input: $input) {
      __typename
      ... on ErrorPayload {
        messages {
          body
          level
        }
      }
      ... on SuccessPayload {
        messages {
          body
          level
        }
      }
    }
  }
`;
var updateWidgetFocusMutation$1 = gql`
  mutation updateWidgetFocus($input: UpdateWidgetFocusInput!) {
    updateWidgetFocus(input: $input) {
      __typename
      ... on ErrorPayload {
        messages {
          body
          level
        }
      }
    }
  }
`;
var isTextarea$1 = (widget) => widget.__typename === "Textarea";
var isErrorPayload$1 = (payload) => payload.__typename === "ErrorPayload";
var isSuccessPayload$1 = (payload) => payload.__typename === "SuccessPayload";
var TextfieldPropertySection = ({
  editingContextId,
  formId,
  widget,
  subscribers,
  readOnly
}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const inputElt = (0, import_react2.useRef)();
  const props = {
    backgroundColor: ((_a = widget.style) == null ? void 0 : _a.backgroundColor) ?? null,
    foregroundColor: ((_b = widget.style) == null ? void 0 : _b.foregroundColor) ?? null,
    fontSize: ((_c = widget.style) == null ? void 0 : _c.fontSize) ?? null,
    italic: ((_d = widget.style) == null ? void 0 : _d.italic) ?? null,
    bold: ((_e = widget.style) == null ? void 0 : _e.bold) ?? null,
    underline: ((_f = widget.style) == null ? void 0 : _f.underline) ?? null,
    strikeThrough: ((_g = widget.style) == null ? void 0 : _g.strikeThrough) ?? null
  };
  const classes = useStyle$1(props);
  const [{ value: schemaValue, context }, dispatch] = useMachine(textfieldPropertySectionMachine);
  const { textfieldPropertySection } = schemaValue;
  const { value: value22, completionRequest, proposals } = context;
  (0, import_react2.useEffect)(() => {
    const initializeEvent = { type: "INITIALIZE", value: widget.stringValue };
    dispatch(initializeEvent);
  }, [dispatch, widget.stringValue]);
  const onChange = (event) => {
    const { value: value222 } = event.target;
    const changeValueEvent = { type: "CHANGE_VALUE", value: value222 };
    dispatch(changeValueEvent);
  };
  const [editTextfield, { loading: updateTextfieldLoading, data: updateTextfieldData, error: updateTextfieldError }] = useMutation(editTextfieldMutation);
  const sendEditedValue = () => {
    if (textfieldPropertySection === "edited") {
      const input = {
        id: crypto.randomUUID(),
        editingContextId,
        representationId: formId,
        textfieldId: widget.id,
        newValue: value22
      };
      const variables = { input };
      editTextfield({ variables });
    }
  };
  const { addErrorMessage, addMessages } = useMultiToast();
  (0, import_react2.useEffect)(() => {
    if (!updateTextfieldLoading) {
      let hasError = false;
      if (updateTextfieldError) {
        addErrorMessage("An unexpected error has occurred, please refresh the page");
        hasError = true;
      }
      if (updateTextfieldData) {
        const { editTextfield: editTextfield2 } = updateTextfieldData;
        if (isErrorPayload$1(editTextfield2)) {
          addMessages(editTextfield2.messages);
          hasError = true;
        }
        if (isSuccessPayload$1(editTextfield2)) {
          addMessages(editTextfield2.messages);
        }
      }
      if (hasError) {
        const initializeEvent = { type: "INITIALIZE", value: widget.stringValue };
        dispatch(initializeEvent);
      }
    }
  }, [updateTextfieldLoading, updateTextfieldData, updateTextfieldError, dispatch]);
  const [
    updateWidgetFocus,
    { loading: updateWidgetFocusLoading, data: updateWidgetFocusData, error: updateWidgetFocusError }
  ] = useMutation(updateWidgetFocusMutation$1);
  const sendUpdateWidgetFocus = (selected) => {
    const input = {
      id: crypto.randomUUID(),
      editingContextId,
      representationId: formId,
      widgetId: widget.id,
      selected
    };
    const variables = {
      input
    };
    updateWidgetFocus({ variables });
  };
  (0, import_react2.useEffect)(() => {
    if (!updateWidgetFocusLoading) {
      if (updateWidgetFocusError) {
        addErrorMessage("An unexpected error has occurred, please refresh the page");
      }
      if (updateWidgetFocusData) {
        const { updateWidgetFocus: updateWidgetFocus2 } = updateWidgetFocusData;
        if (isErrorPayload$1(updateWidgetFocus2)) {
          addMessages(updateWidgetFocus2.messages);
        }
      }
    }
  }, [updateWidgetFocusLoading, updateWidgetFocusData, updateWidgetFocusError, dispatch]);
  const onFocus = () => sendUpdateWidgetFocus(true);
  const onBlur = () => {
    sendUpdateWidgetFocus(false);
    sendEditedValue();
  };
  const [getCompletionProposals, { loading: proposalsLoading, data: proposalsData, error: proposalsError }] = useLazyQuery(getCompletionProposalsQuery);
  (0, import_react2.useEffect)(() => {
    if (!proposalsLoading) {
      if (proposalsError) {
        addErrorMessage(proposalsError.message);
      }
      if (proposalsData) {
        const proposalsReceivedEvent = {
          type: "COMPLETION_RECEIVED",
          proposals: proposalsData.viewer.editingContext.representation.description.completionProposals
        };
        dispatch(proposalsReceivedEvent);
      }
    }
  }, [proposalsLoading, proposalsData, proposalsError, dispatch]);
  const onKeyPress = (event) => {
    if ("Enter" === event.key && !event.shiftKey) {
      event.preventDefault();
      sendEditedValue();
    }
    const dismissCompletionEvent = { type: "COMPLETION_DISMISSED" };
    dispatch(dismissCompletionEvent);
  };
  const [controlDown, setControlDown] = (0, import_react2.useState)(false);
  const onKeyDown = (event) => {
    if (event.key === "ArrowLeft" || event.key === "ArrowRight") {
      const proposalsMenu = document.getElementById("completion-proposals");
      if (proposalsMenu && proposalsMenu.firstChild) {
        proposalsMenu.firstChild.focus();
      }
    } else if ("Control" === event.key) {
      setControlDown(true);
    } else if ("Escape" === event.key) {
      const dismissCompletionEvent = { type: "COMPLETION_DISMISSED" };
      dispatch(dismissCompletionEvent);
    }
    if (widget.supportsCompletion && controlDown && event.key === " ") {
      const cursorPosition = event.target.selectionStart;
      const variables = {
        editingContextId,
        formId,
        widgetId: widget.id,
        currentText: value22,
        cursorPosition
      };
      getCompletionProposals({ variables });
      const requestCompletionEvent = {
        type: "COMPLETION_REQUESTED",
        currentText: value22,
        cursorPosition
      };
      dispatch(requestCompletionEvent);
    }
  };
  const onKeyUp = (event) => {
    if ("Control" === event.key) {
      setControlDown(false);
    }
  };
  const [caretPos, setCaretPos] = (0, import_react2.useState)(null);
  (0, import_react2.useEffect)(() => {
    if (caretPos && inputElt.current) {
      inputElt.current.setSelectionRange(caretPos, caretPos);
      inputElt.current.focus();
      setCaretPos(null);
    }
  }, [caretPos, inputElt.current]);
  let proposalsList = null;
  if (proposals) {
    const dismissProposals = () => {
      const dismissCompletionEvent = { type: "COMPLETION_DISMISSED" };
      dispatch(dismissCompletionEvent);
    };
    const applyProposal = (proposal) => {
      const result = applyCompletionProposal(
        { textValue: value22, cursorPosition: completionRequest.cursorPosition },
        proposal
      );
      const changeValueEvent = { type: "CHANGE_VALUE", value: result.textValue };
      dispatch(changeValueEvent);
      setCaretPos(result.cursorPosition);
      dismissProposals();
    };
    proposalsList = (0, import_jsx_runtime2.jsx)(
      ProposalsList,
      {
        anchorEl: inputElt.current,
        proposals,
        onProposalSelected: applyProposal,
        onClose: dismissProposals
      }
    );
  }
  return (0, import_jsx_runtime2.jsxs)(
    "div",
    {
      onBlur: (event) => {
        if (!event.currentTarget.contains(event.relatedTarget)) {
          onBlur();
        }
      },
      children: [
        (0, import_jsx_runtime2.jsx)(
          PropertySectionLabel,
          {
            editingContextId,
            formId,
            widget,
            subscribers
          }
        ),
        (0, import_jsx_runtime2.jsx)(
          TextField_default,
          {
            name: widget.label,
            placeholder: widget.label,
            value: value22,
            spellCheck: false,
            margin: "dense",
            multiline: isTextarea$1(widget),
            maxRows: isTextarea$1(widget) ? 4 : 1,
            fullWidth: true,
            onKeyDown,
            onKeyUp,
            onChange,
            onFocus,
            onKeyPress,
            "data-testid": widget.label,
            disabled: readOnly || widget.readOnly,
            error: widget.diagnostics.length > 0,
            helperText: (_h = widget.diagnostics[0]) == null ? void 0 : _h.message,
            inputRef: inputElt,
            InputProps: widget.style ? {
              className: classes.style
            } : {},
            inputProps: {
              "data-testid": `input-${widget.label}`
            }
          }
        ),
        proposalsList
      ]
    }
  );
};
var applyCompletionProposal = (initialState, proposal) => {
  const prefix = initialState.textValue.substring(0, initialState.cursorPosition);
  const inserted = proposal.textToInsert.substring(proposal.charsToReplace);
  const suffix = initialState.textValue.substring(initialState.cursorPosition);
  const newValue = prefix + inserted + suffix;
  return { textValue: newValue, cursorPosition: (prefix + inserted).length };
};
var useTreeItemWidgetStyles = makeStyles_default((theme) => ({
  label: {
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    columnGap: theme.spacing(1)
  }
}));
var TreeItem = ({ node, nodes }) => {
  const styles = useTreeItemWidgetStyles();
  const { setSelection } = useSelection();
  const handleClick = () => {
    if (node.selectable) {
      const newSelection = {
        id: node.id,
        label: node.label,
        kind: node.kind
      };
      setSelection({ entries: [newSelection] });
    }
  };
  const label = (0, import_jsx_runtime2.jsxs)("div", { className: styles.label, onClick: handleClick, children: [
    (0, import_jsx_runtime2.jsx)(IconOverlay, { iconURL: node.iconURL, alt: node.label }),
    (0, import_jsx_runtime2.jsx)(Typography_default, { children: node.label })
  ] });
  const childNodes = nodes.filter((childNode) => childNode.parentId === node.id);
  return (0, import_jsx_runtime2.jsx)(TreeItem_default, { nodeId: node.id, label, children: childNodes.map((childNode) => (0, import_jsx_runtime2.jsx)(TreeItem, { node: childNode, nodes }, childNode.id)) });
};
var TreePropertySection = ({ editingContextId, formId, widget, subscribers }) => {
  let { nodes, expandedNodesIds } = widget;
  if (widget.nodes.length === 0) {
    expandedNodesIds = [];
    nodes = [
      {
        id: "none",
        parentId: null,
        label: "None",
        kind: "siriusComponents://unknown",
        iconURL: [],
        selectable: false
      }
    ];
  }
  const rootNodes = nodes.filter((node) => node.parentId === null);
  return (0, import_jsx_runtime2.jsxs)("div", { children: [
    (0, import_jsx_runtime2.jsx)(
      PropertySectionLabel,
      {
        editingContextId,
        formId,
        widget,
        subscribers
      }
    ),
    (0, import_jsx_runtime2.jsx)(
      TreeView_default,
      {
        defaultCollapseIcon: (0, import_jsx_runtime2.jsx)(import_ExpandMore.default, {}),
        defaultExpanded: expandedNodesIds,
        defaultExpandIcon: (0, import_jsx_runtime2.jsx)(import_ChevronRight.default, {}),
        children: rootNodes.map((rootNode) => (0, import_jsx_runtime2.jsx)(TreeItem, { node: rootNode, nodes }, rootNode.id))
      }
    )
  ] });
};
var isTextfield = (widget) => widget.__typename === "Textfield";
var isTextarea = (widget) => widget.__typename === "Textarea";
var isCheckbox = (widget) => widget.__typename === "Checkbox";
var isSelect = (widget) => widget.__typename === "Select";
var isMultiSelect = (widget) => widget.__typename === "MultiSelect";
var isRadio = (widget) => widget.__typename === "Radio";
var isList$1 = (widget) => widget.__typename === "List";
var isLink = (widget) => widget.__typename === "Link";
var isButton = (widget) => widget.__typename === "Button";
var isLabelWidget = (widget) => widget.__typename === "LabelWidget";
var isChartWidget = (widget) => widget.__typename === "ChartWidget";
var isFlexboxContainer = (widget) => widget.__typename === "FlexboxContainer";
var isTree = (widget) => widget.__typename === "TreeWidget";
var isImage = (widget) => widget.__typename === "Image";
var isRichText = (widget) => widget.__typename === "RichText";
var PropertySection = ({
  editingContextId,
  formId,
  widget,
  widgetSubscriptions,
  readOnly
}) => {
  let subscribers = [];
  const { propertySectionsRegistry: propertySectionsRegistry2 } = (0, import_react2.useContext)(PropertySectionContext);
  widgetSubscriptions.filter((subscription) => subscription.widgetId === widget.id).forEach((subscription) => subscribers.push(...subscription.subscribers));
  let propertySection = null;
  if (isTextfield(widget) || isTextarea(widget)) {
    propertySection = (0, import_jsx_runtime2.jsx)(
      TextfieldPropertySection,
      {
        editingContextId,
        formId,
        widget,
        subscribers,
        readOnly
      },
      widget.id
    );
  } else if (isCheckbox(widget)) {
    propertySection = (0, import_jsx_runtime2.jsx)(
      CheckboxPropertySection,
      {
        editingContextId,
        formId,
        widget,
        subscribers,
        readOnly
      },
      widget.id
    );
  } else if (isSelect(widget)) {
    propertySection = (0, import_jsx_runtime2.jsx)(
      SelectPropertySection,
      {
        editingContextId,
        formId,
        widget,
        subscribers,
        readOnly
      },
      widget.id
    );
  } else if (isMultiSelect(widget)) {
    propertySection = (0, import_jsx_runtime2.jsx)(
      MultiSelectPropertySection,
      {
        editingContextId,
        formId,
        widget,
        subscribers,
        readOnly
      },
      widget.id
    );
  } else if (isRadio(widget)) {
    propertySection = (0, import_jsx_runtime2.jsx)(
      RadioPropertySection,
      {
        editingContextId,
        formId,
        widget,
        subscribers,
        readOnly
      },
      widget.id
    );
  } else if (isList$1(widget)) {
    propertySection = (0, import_jsx_runtime2.jsx)(
      ListPropertySection,
      {
        editingContextId,
        formId,
        widget,
        subscribers,
        readOnly
      },
      widget.id
    );
  } else if (isLink(widget)) {
    propertySection = (0, import_jsx_runtime2.jsx)(LinkPropertySection, { editingContextId, formId, widget }, widget.id);
  } else if (isButton(widget)) {
    propertySection = (0, import_jsx_runtime2.jsx)(
      ButtonPropertySection,
      {
        editingContextId,
        formId,
        widget,
        subscribers,
        readOnly
      },
      widget.id
    );
  } else if (isLabelWidget(widget)) {
    propertySection = (0, import_jsx_runtime2.jsx)(
      LabelWidgetPropertySection,
      {
        editingContextId,
        formId,
        widget,
        subscribers
      },
      widget.id
    );
  } else if (isChartWidget(widget)) {
    propertySection = (0, import_jsx_runtime2.jsx)(
      ChartWidgetPropertySection,
      {
        editingContextId,
        formId,
        widget,
        subscribers
      },
      widget.id
    );
  } else if (isFlexboxContainer(widget)) {
    propertySection = (0, import_jsx_runtime2.jsx)(
      FlexboxContainerPropertySection,
      {
        editingContextId,
        formId,
        widget,
        widgetSubscriptions,
        readOnly
      },
      widget.id
    );
  } else if (isTree(widget)) {
    propertySection = (0, import_jsx_runtime2.jsx)(
      TreePropertySection,
      {
        editingContextId,
        formId,
        widget,
        subscribers
      },
      widget.id
    );
  } else if (isImage(widget)) {
    propertySection = (0, import_jsx_runtime2.jsx)(ImagePropertySection, { editingContextId, formId, widget }, widget.id);
  } else if (isRichText(widget)) {
    propertySection = (0, import_jsx_runtime2.jsx)(
      RichTextPropertySection,
      {
        editingContextId,
        formId,
        widget,
        subscribers,
        readOnly
      },
      widget.id
    );
  } else {
    const CustomWidgetComponent = propertySectionsRegistry2.getComponent(widget);
    if (CustomWidgetComponent) {
      propertySection = (0, import_jsx_runtime2.jsx)(
        CustomWidgetComponent,
        {
          editingContextId,
          formId,
          widget,
          subscribers,
          readOnly
        },
        widget.id
      );
    } else {
      console.error(`Unsupported widget type ${widget.__typename}`);
    }
  }
  return propertySection;
};
var useStyle = makeStyles_default((theme) => ({
  style: {
    minWidth: "32px",
    lineHeight: 1.25,
    backgroundColor: ({ backgroundColor }) => backgroundColor ? getCSSColor(backgroundColor, theme) : theme.palette.primary.light,
    color: ({ foregroundColor }) => foregroundColor ? getCSSColor(foregroundColor, theme) : "white",
    fontSize: ({ fontSize }) => fontSize ? fontSize : null,
    fontStyle: ({ italic }) => italic ? "italic" : null,
    fontWeight: ({ bold }) => bold ? "bold" : null,
    textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough),
    "&:hover": {
      backgroundColor: ({ backgroundColor }) => backgroundColor ? getCSSColor(backgroundColor, theme) : theme.palette.primary.main,
      color: ({ foregroundColor }) => foregroundColor ? getCSSColor(foregroundColor, theme) : "white",
      fontSize: ({ fontSize }) => fontSize ? fontSize : null,
      fontStyle: ({ italic }) => italic ? "italic" : null,
      fontWeight: ({ bold }) => bold ? "bold" : null,
      textDecorationLine: ({ underline, strikeThrough }) => getTextDecorationLineValue(underline, strikeThrough)
    }
  },
  icon: {
    marginRight: ({ iconOnly }) => iconOnly ? theme.spacing(0) : theme.spacing(2)
  }
}));
var pushButtonMutation = gql$1`
  mutation pushButton($input: PushButtonInput!) {
    pushButton(input: $input) {
      __typename
      ... on ErrorPayload {
        messages {
          body
          level
        }
      }
      ... on SuccessPayload {
        messages {
          body
          level
        }
      }
    }
  }
`;
var updateWidgetFocusMutation = gql$1`
  mutation updateWidgetFocus($input: UpdateWidgetFocusInput!) {
    updateWidgetFocus(input: $input) {
      __typename
      ... on ErrorPayload {
        messages {
          body
          level
        }
      }
    }
  }
`;
var isErrorPayload = (payload) => payload.__typename === "ErrorPayload";
var isSuccessPayload = (payload) => payload.__typename === "SuccessPayload";
var ToolbarAction = ({ editingContextId, formId, widget, readOnly }) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const props = {
    backgroundColor: ((_a = widget.style) == null ? void 0 : _a.backgroundColor) ?? null,
    foregroundColor: ((_b = widget.style) == null ? void 0 : _b.foregroundColor) ?? null,
    fontSize: ((_c = widget.style) == null ? void 0 : _c.fontSize) ?? null,
    italic: ((_d = widget.style) == null ? void 0 : _d.italic) ?? null,
    bold: ((_e = widget.style) == null ? void 0 : _e.bold) ?? null,
    underline: ((_f = widget.style) == null ? void 0 : _f.underline) ?? null,
    strikeThrough: ((_g = widget.style) == null ? void 0 : _g.strikeThrough) ?? null,
    iconOnly: widget.buttonLabel ? false : true
  };
  const classes = useStyle(props);
  const { httpOrigin } = (0, import_react2.useContext)(ServerContext);
  const [pushButton, { loading, data, error }] = useMutation(
    pushButtonMutation
  );
  const { addErrorMessage, addMessages } = useMultiToast();
  (0, import_react2.useEffect)(() => {
    if (!loading) {
      if (error) {
        addErrorMessage("An unexpected error has occurred, please refresh the page");
      }
      if (data) {
        const { pushButton: pushButton2 } = data;
        if (isErrorPayload(pushButton2) || isSuccessPayload(pushButton2)) {
          addMessages(pushButton2.messages);
        }
      }
    }
  }, [loading, error, data]);
  const [
    updateWidgetFocus,
    { loading: updateWidgetFocusLoading, data: updateWidgetFocusData, error: updateWidgetFocusError }
  ] = useMutation(updateWidgetFocusMutation);
  const sendUpdateWidgetFocus = (selected) => {
    const input = {
      id: crypto.randomUUID(),
      editingContextId,
      representationId: formId,
      widgetId: widget.id,
      selected
    };
    const variables = {
      input
    };
    updateWidgetFocus({ variables });
  };
  (0, import_react2.useEffect)(() => {
    if (!updateWidgetFocusLoading) {
      if (updateWidgetFocusError) {
        addErrorMessage("An unexpected error has occurred, please refresh the page");
      }
      if (updateWidgetFocusData) {
        const { updateWidgetFocus: updateWidgetFocus2 } = updateWidgetFocusData;
        if (isErrorPayload(updateWidgetFocus2)) {
          addMessages(updateWidgetFocus2.messages);
        }
      }
    }
  }, [updateWidgetFocusLoading, updateWidgetFocusData, updateWidgetFocusError]);
  const onFocus = () => sendUpdateWidgetFocus(true);
  const onBlur = () => {
    sendUpdateWidgetFocus(false);
  };
  const onClick = () => {
    const input = {
      id: crypto.randomUUID(),
      editingContextId,
      representationId: formId,
      buttonId: widget.id
    };
    const variables = { input };
    pushButton({ variables });
  };
  const getImageURL = (widget2) => {
    if (widget2.imageURL.startsWith("http://") || widget2.imageURL.startsWith("https://")) {
      return widget2.imageURL;
    }
    return httpOrigin + widget2.imageURL;
  };
  return (0, import_jsx_runtime2.jsx)("div", { children: (0, import_jsx_runtime2.jsx)(HelpTooltip, { editingContextId, formId, widgetId: widget.id, children: (0, import_jsx_runtime2.jsxs)(
    Button_default,
    {
      "data-testid": widget.buttonLabel,
      size: "small",
      variant: "contained",
      color: "primary",
      onClick,
      onBlur,
      onFocus,
      disabled: readOnly || widget.readOnly,
      classes: { root: classes.style },
      children: [
        ((_h = widget.imageURL) == null ? void 0 : _h.length) > 0 ? (0, import_jsx_runtime2.jsx)("img", { className: classes.icon, width: "16", height: "16", alt: widget.label, src: getImageURL(widget) }) : null,
        widget.buttonLabel
      ]
    }
  ) }) });
};
var useGroupStyles = makeStyles_default((theme) => ({
  group: {
    display: "flex",
    flexDirection: "column",
    margin: ({ borderStyle }) => borderStyle ? theme.spacing(0.5) : 0,
    padding: ({ borderStyle }) => borderStyle ? theme.spacing(0.5) : 0,
    borderWidth: ({ borderStyle }) => (borderStyle == null ? void 0 : borderStyle.size) || 0,
    borderColor: ({ borderStyle }) => getCSSColor(borderStyle == null ? void 0 : borderStyle.color, theme) || "transparent",
    borderStyle: ({ borderStyle }) => (borderStyle == null ? void 0 : borderStyle.lineStyle) || "solid",
    borderRadius: ({ borderStyle }) => (borderStyle == null ? void 0 : borderStyle.radius) || 0
  },
  groupLabelAndToolbar: {
    display: "flex",
    flexDirection: "row",
    justifyContent: "space-between"
  },
  toolbar: {
    display: "flex",
    flexDirection: "row",
    justifyContent: "flex-end"
  },
  toolbarAction: {
    paddingRight: theme.spacing(1),
    whiteSpace: "nowrap"
  },
  title: {
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis"
  },
  verticalSections: {
    display: "flex",
    flexDirection: "column",
    "& > *": {
      marginBottom: theme.spacing(2)
    }
  },
  adaptableSections: {
    display: "grid",
    gridTemplateColumns: "repeat(auto-fit, minmax(250px, 1fr))",
    gap: theme.spacing(2),
    "& > *": {
      marginBottom: theme.spacing(2)
    }
  },
  button: {
    paddingTop: "1px",
    paddingBottom: "0px"
  }
}));
var Group = ({ editingContextId, formId, group: group2, widgetSubscriptions, readOnly }) => {
  var _a;
  const props = {
    borderStyle: group2.borderStyle
  };
  const classes = useGroupStyles(props);
  const theme = useTheme();
  const [visibleWidgetIds, setVisibleWidgetIds] = (0, import_react2.useState)([]);
  (0, import_react2.useEffect)(() => {
    setVisibleWidgetIds(group2.widgets.map((widget) => widget.id));
  }, [group2]);
  let widgetSelector = void 0;
  if (group2.displayMode === "TOGGLEABLE_AREAS") {
    widgetSelector = (0, import_jsx_runtime2.jsx)(ToggleButtonGroup_default, { value: visibleWidgetIds, onChange: (_, newVisibleIds) => setVisibleWidgetIds(newVisibleIds), children: group2.widgets.map((widget) => {
      return (0, import_jsx_runtime2.jsxs)(ToggleButton_default, { className: classes.button, value: widget.id, children: [
        (0, import_jsx_runtime2.jsx)(
          IconOverlay,
          {
            iconURL: widget.iconURL,
            alt: widget.label,
            customIconStyle: { marginRight: theme.spacing(1) }
          }
        ),
        widget.label
      ] }, widget.id);
    }) });
  }
  let toolbar = null;
  if (((_a = group2.toolbarActions) == null ? void 0 : _a.length) > 0) {
    toolbar = (0, import_jsx_runtime2.jsx)("div", { className: classes.toolbar, children: group2.toolbarActions.map((toolbarAction) => (0, import_jsx_runtime2.jsx)("div", { className: classes.toolbarAction, children: (0, import_jsx_runtime2.jsx)(
      ToolbarAction,
      {
        editingContextId,
        formId,
        readOnly,
        widget: toolbarAction
      }
    ) }, toolbarAction.id)) });
  }
  return (0, import_jsx_runtime2.jsxs)("div", { className: classes.group, "data-testid": `group-${group2.label}`, children: [
    (0, import_jsx_runtime2.jsxs)("div", { className: classes.groupLabelAndToolbar, children: [
      group2.displayMode === "TOGGLEABLE_AREAS" ? widgetSelector : (0, import_jsx_runtime2.jsx)(Typography_default, { variant: "subtitle1", className: classes.title, gutterBottom: true, children: group2.label }),
      toolbar
    ] }),
    (0, import_jsx_runtime2.jsx)("div", { className: group2.displayMode === "LIST" ? classes.verticalSections : classes.adaptableSections, children: group2.widgets.filter((widget) => visibleWidgetIds.includes(widget.id)).map((widget) => (0, import_jsx_runtime2.jsx)(
      PropertySection,
      {
        editingContextId,
        formId,
        widget,
        widgetSubscriptions,
        readOnly
      },
      widget.id
    )) })
  ] });
};
var usePageStyles = makeStyles_default((theme) => ({
  page: {
    display: "flex",
    flexDirection: "column",
    "& > *": {
      marginBottom: theme.spacing(2)
    },
    overflowY: "auto"
  }
}));
var Page = ({ editingContextId, formId, page, widgetSubscriptions, readOnly }) => {
  const classes = usePageStyles();
  return (0, import_jsx_runtime2.jsx)("div", { className: classes.page, children: page.groups.map((group2) => {
    return (0, import_jsx_runtime2.jsx)(
      Group,
      {
        editingContextId,
        formId,
        group: group2,
        widgetSubscriptions,
        readOnly
      },
      group2.id
    );
  }) });
};
var useFormStyles = makeStyles_default((theme) => ({
  form: {
    display: "flex",
    flexDirection: "column",
    paddingLeft: theme.spacing(1),
    paddingRight: theme.spacing(1),
    gap: theme.spacing(1)
  },
  tabsRoot: {
    minHeight: theme.spacing(4),
    borderBottomColor: theme.palette.divider,
    borderBottomWidth: "1px",
    borderBottomStyle: "solid"
  },
  tabRoot: {
    minHeight: theme.spacing(4),
    textTransform: "none"
  },
  tabLabel: {
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    width: "inherit"
  },
  tabLabelText: {
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  },
  toolbar: {
    display: "flex",
    flexDirection: "row",
    justifyContent: "flex-end",
    alignItems: "center"
  },
  toolbarAction: {
    paddingRight: theme.spacing(1),
    whiteSpace: "nowrap"
  },
  pagesListAndToolbar: {
    display: "flex",
    justifyContent: "space-between",
    paddingLeft: theme.spacing(1)
  }
}));
var a11yProps = (id) => {
  return {
    id: `simple-tab-${id}`,
    "aria-controls": `simple-tabpanel-${id}`
  };
};
var Form = ({ editingContextId, form, widgetSubscriptions, readOnly }) => {
  var _a, _b;
  const classes = useFormStyles();
  const { id, pages } = form;
  const [state, setState] = (0, import_react2.useState)({ selectedPage: pages[0], pages });
  (0, import_react2.useEffect)(() => {
    setState(() => {
      const selectedPage = pages.find((page2) => {
        var _a2;
        return page2.id === ((_a2 = state.selectedPage) == null ? void 0 : _a2.id);
      });
      if (selectedPage) {
        return { selectedPage, pages };
      }
      return { selectedPage: pages[0], pages };
    });
  }, [pages, state.selectedPage.id]);
  const onChangeTab = (_, value22) => {
    const selectedPage = pages.find((page2) => page2.id === value22);
    setState((prevState) => {
      return { ...prevState, selectedPage };
    });
  };
  let selectedPageToolbar = null;
  if (((_b = (_a = state.selectedPage) == null ? void 0 : _a.toolbarActions) == null ? void 0 : _b.length) > 0) {
    selectedPageToolbar = (0, import_jsx_runtime2.jsx)("div", { className: classes.toolbar, children: state.selectedPage.toolbarActions.map((toolbarAction) => (0, import_jsx_runtime2.jsx)("div", { className: classes.toolbarAction, children: (0, import_jsx_runtime2.jsx)(ToolbarAction, { editingContextId, formId: id, readOnly, widget: toolbarAction }) }, toolbarAction.id)) });
  }
  let page = null;
  if (state.selectedPage) {
    page = (0, import_jsx_runtime2.jsx)(
      Page,
      {
        editingContextId,
        formId: id,
        page: state.selectedPage,
        widgetSubscriptions,
        readOnly
      }
    );
  }
  const maxWidth = state.pages.length > 1 ? 100 : 390;
  const variant = state.pages.length > 1 ? "scrollable" : "standard";
  return (0, import_jsx_runtime2.jsxs)("div", { "data-testid": "form", className: classes.form, children: [
    (0, import_jsx_runtime2.jsxs)("div", { className: classes.pagesListAndToolbar, children: [
      (0, import_jsx_runtime2.jsx)(
        Tabs_default,
        {
          classes: { root: classes.tabsRoot },
          value: state.selectedPage.id,
          onChange: onChangeTab,
          variant,
          scrollButtons: "on",
          textColor: "primary",
          indicatorColor: "primary",
          children: state.pages.map((page2) => {
            return (0, import_react2.createElement)(
              Tab_default,
              {
                ...a11yProps(page2.id),
                classes: { root: classes.tabRoot },
                style: { minWidth: 1, maxWidth },
                value: page2.id,
                title: page2.label,
                label: (0, import_jsx_runtime2.jsx)("div", { className: classes.tabLabel, children: (0, import_jsx_runtime2.jsx)("div", { className: classes.tabLabelText, children: page2.label }) }),
                key: page2.id,
                "data-testid": `page-tab-${page2.label}`
              }
            );
          })
        }
      ),
      selectedPageToolbar
    ] }),
    page
  ] });
};
var isFormRefreshedEventPayload$1 = (payload) => payload.__typename === "FormRefreshedEventPayload";
var isSubscribersUpdatedEventPayload$1 = (payload) => payload.__typename === "SubscribersUpdatedEventPayload";
var isWidgetSubscriptionsUpdatedEventPayload$1 = (payload) => payload.__typename == "WidgetSubscriptionsUpdatedEventPayload";
var formRepresentationMachine = Machine(
  {
    type: "parallel",
    context: {
      id: crypto.randomUUID(),
      formId: null,
      form: null,
      subscribers: [],
      widgetSubscriptions: [],
      message: null
    },
    states: {
      toast: {
        initial: "hidden",
        states: {
          hidden: {
            on: {
              SHOW_TOAST: {
                target: "visible",
                actions: "setMessage"
              }
            }
          },
          visible: {
            on: {
              HIDE_TOAST: {
                target: "hidden",
                actions: "clearMessage"
              }
            }
          }
        }
      },
      formRepresentation: {
        initial: "idle",
        states: {
          idle: {
            on: {
              SWITCH_FORM: {
                target: "idle",
                actions: "switchForm"
              },
              HANDLE_SUBSCRIPTION_RESULT: [
                {
                  cond: "isFormRefreshedEventPayload",
                  target: "ready",
                  actions: "handleSubscriptionResult"
                },
                {
                  target: "idle",
                  actions: "handleSubscriptionResult"
                }
              ]
            }
          },
          ready: {
            on: {
              SWITCH_FORM: {
                target: "idle",
                actions: "switchForm"
              },
              HANDLE_SUBSCRIPTION_RESULT: {
                target: "ready",
                actions: "handleSubscriptionResult"
              },
              HANDLE_COMPLETE: {
                target: "complete"
              }
            }
          },
          complete: {
            on: {
              SWITCH_FORM: {
                target: "idle",
                actions: "switchForm"
              }
            }
          }
        }
      }
    }
  },
  {
    guards: {
      isFormRefreshedEventPayload: (_, event) => {
        const { result } = event;
        const { data } = result;
        return isFormRefreshedEventPayload$1(data.formEvent);
      }
    },
    actions: {
      switchForm: assign((_, event) => {
        const { formId } = event;
        return {
          id: crypto.randomUUID(),
          formId
        };
      }),
      handleSubscriptionResult: assign((_, event) => {
        const { result } = event;
        const { data } = result;
        if (isFormRefreshedEventPayload$1(data.formEvent)) {
          const { form } = data.formEvent;
          return { form };
        } else if (isSubscribersUpdatedEventPayload$1(data.formEvent)) {
          const { subscribers } = data.formEvent;
          return { subscribers };
        } else if (isWidgetSubscriptionsUpdatedEventPayload$1(data.formEvent)) {
          const { widgetSubscriptions } = data.formEvent;
          return { widgetSubscriptions };
        }
        return {};
      }),
      setMessage: assign((_, event) => {
        const { message } = event;
        return { message };
      }),
      clearMessage: assign((_) => {
        return { message: null };
      })
    }
  }
);
var formEventSubscription = (contributions) => gql(`
  subscription formEvent($input: FormEventInput!) {
    formEvent(input: $input) {
      __typename
      ... on SubscribersUpdatedEventPayload {
        ...subscribersUpdatedEventPayloadFragment
      }
      ... on WidgetSubscriptionsUpdatedEventPayload {
        ...widgetSubscriptionsUpdatedEventPayloadFragment
      }
      ... on FormRefreshedEventPayload {
        ...formRefreshedEventPayloadFragment
      }
    }
  }
  ${subscribersUpdatedEventPayloadFragment}
  ${widgetSubscriptionsUpdatedEventPayloadFragment}
  ${formRefreshedEventPayloadFragment(contributions)}
`);
var useFormRepresentationStyles = makeStyles_default((theme) => ({
  page: {
    display: "flex",
    flexDirection: "column",
    gap: theme.spacing(1),
    paddingTop: theme.spacing(1),
    paddingLeft: theme.spacing(1),
    paddingRight: theme.spacing(1),
    overflowY: "scroll"
  },
  complete: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  toolbar: {
    display: "flex",
    flexDirection: "row",
    justifyContent: "flex-end",
    alignItems: "center",
    maxHeight: theme.spacing(4),
    textTransform: "none"
  },
  toolbarAction: {
    paddingRight: theme.spacing(1),
    whiteSpace: "nowrap"
  }
}));
var FormRepresentation = ({ editingContextId, representationId, readOnly }) => {
  var _a;
  const classes = useFormRepresentationStyles();
  const [{ value: value22, context }, dispatch] = useMachine(
    formRepresentationMachine,
    {
      context: {
        formId: representationId
      }
    }
  );
  const { toast, formRepresentation } = value22;
  const { id, formId, form, widgetSubscriptions, message } = context;
  (0, import_react2.useEffect)(() => {
    if (formId !== representationId) {
      const switchFormEvent = { type: "SWITCH_FORM", formId: representationId };
      dispatch(switchFormEvent);
    }
  }, [representationId, formId, dispatch]);
  const { propertySectionsRegistry: propertySectionsRegistry2 } = (0, import_react2.useContext)(PropertySectionContext);
  const { error } = useSubscription(
    formEventSubscription(propertySectionsRegistry2.getWidgetContributions()),
    {
      variables: {
        input: {
          id,
          editingContextId,
          formId: representationId
        }
      },
      fetchPolicy: "no-cache",
      onData: ({ data }) => {
        const handleDataEvent = {
          type: "HANDLE_SUBSCRIPTION_RESULT",
          result: data
        };
        dispatch(handleDataEvent);
      },
      onComplete: () => {
        const completeEvent = { type: "HANDLE_COMPLETE" };
        dispatch(completeEvent);
      }
    }
  );
  (0, import_react2.useEffect)(() => {
    if (error) {
      const { message: message2 } = error;
      const showToastEvent = { type: "SHOW_TOAST", message: message2 };
      dispatch(showToastEvent);
    }
  }, [error, dispatch]);
  let content = null;
  if (formRepresentation === "ready") {
    if (form.pages.length > 1) {
      content = (0, import_jsx_runtime2.jsx)(
        Form,
        {
          editingContextId,
          form,
          widgetSubscriptions,
          readOnly
        }
      );
    } else if (form.pages.length === 1) {
      let selectedPageToolbar = null;
      if (((_a = form.pages[0].toolbarActions) == null ? void 0 : _a.length) > 0) {
        selectedPageToolbar = (0, import_jsx_runtime2.jsx)("div", { className: classes.toolbar, children: form.pages[0].toolbarActions.map((toolbarAction) => (0, import_jsx_runtime2.jsx)("div", { className: classes.toolbarAction, children: (0, import_jsx_runtime2.jsx)(
          ToolbarAction,
          {
            editingContextId,
            formId: form.id,
            readOnly,
            widget: toolbarAction
          }
        ) }, toolbarAction.id)) });
      }
      content = (0, import_jsx_runtime2.jsxs)("div", { "data-testid": "page", className: classes.page, children: [
        selectedPageToolbar,
        (0, import_jsx_runtime2.jsx)(
          Page,
          {
            editingContextId,
            formId: form.id,
            page: form.pages[0],
            widgetSubscriptions,
            readOnly
          }
        )
      ] });
    }
  } else if (formRepresentation === "complete") {
    content = (0, import_jsx_runtime2.jsx)("div", { className: classes.complete, children: (0, import_jsx_runtime2.jsx)(Typography_default, { variant: "h5", align: "center", children: "The form does not exist anymore" }) });
  }
  return (0, import_jsx_runtime2.jsxs)("div", { "data-representation-kind": "form", children: [
    content,
    (0, import_jsx_runtime2.jsx)(
      Toast,
      {
        message,
        open: toast === "visible",
        onClose: () => dispatch({ type: "HIDE_TOAST" })
      }
    )
  ] });
};
var converter = {
  convert: (form) => form
};
var defaultContext = {
  converter
};
var DetailsViewContext = import_react2.default.createContext(defaultContext);
var DetailsViewConfiguration = ({ children, converter: converter2 }) => {
  return (0, import_jsx_runtime2.jsx)(DetailsViewContext.Provider, { value: { converter: converter2 }, children });
};
var useDetailsViewConfiguration = () => {
  const { converter: converter2 } = import_react2.default.useContext(DetailsViewContext);
  return {
    converter: converter2
  };
};
var isFormRefreshedEventPayload = (payload) => payload.__typename === "FormRefreshedEventPayload";
var isSubscribersUpdatedEventPayload = (payload) => payload.__typename === "SubscribersUpdatedEventPayload";
var isWidgetSubscriptionsUpdatedEventPayload = (payload) => payload.__typename == "WidgetSubscriptionsUpdatedEventPayload";
var formBasedViewMachine = Machine(
  {
    type: "parallel",
    context: {
      id: crypto.randomUUID(),
      currentSelection: null,
      form: null,
      subscribers: [],
      widgetSubscriptions: [],
      message: null
    },
    states: {
      toast: {
        initial: "hidden",
        states: {
          hidden: {
            on: {
              SHOW_TOAST: {
                target: "visible",
                actions: "setMessage"
              }
            }
          },
          visible: {
            on: {
              HIDE_TOAST: {
                target: "hidden",
                actions: "clearMessage"
              }
            }
          }
        }
      },
      formBasedView: {
        initial: "empty",
        states: {
          empty: {
            on: {
              SWITCH_SELECTION: [
                {
                  cond: "isSelectionUnsupported",
                  target: "unsupportedSelection",
                  actions: ["switchSelection", "clearForm"]
                },
                {
                  target: "idle",
                  actions: "switchSelection"
                }
              ]
            }
          },
          unsupportedSelection: {
            on: {
              SWITCH_SELECTION: [
                {
                  cond: "isSelectionUnsupported",
                  target: "unsupportedSelection",
                  actions: ["switchSelection", "clearForm"]
                },
                {
                  target: "idle",
                  actions: "switchSelection"
                }
              ]
            }
          },
          idle: {
            on: {
              SWITCH_SELECTION: [
                {
                  cond: "isSelectionUnsupported",
                  target: "unsupportedSelection",
                  actions: ["switchSelection", "clearForm"]
                },
                {
                  target: "idle",
                  actions: "switchSelection"
                }
              ],
              HANDLE_SUBSCRIPTION_RESULT: [
                {
                  cond: "isFormRefreshedEventPayload",
                  target: "ready",
                  actions: "handleSubscriptionResult"
                },
                {
                  target: "idle",
                  actions: "handleSubscriptionResult"
                }
              ],
              HANDLE_COMPLETE: {
                target: "complete"
              }
            }
          },
          ready: {
            on: {
              SWITCH_SELECTION: [
                {
                  cond: "isSelectionUnsupported",
                  target: "unsupportedSelection",
                  actions: ["switchSelection", "clearForm"]
                },
                {
                  target: "idle",
                  actions: "switchSelection"
                }
              ],
              HANDLE_SUBSCRIPTION_RESULT: {
                target: "ready",
                actions: "handleSubscriptionResult"
              },
              HANDLE_COMPLETE: {
                target: "complete"
              }
            }
          },
          complete: {
            on: {
              SWITCH_SELECTION: [
                {
                  cond: "isSelectionUnsupported",
                  target: "unsupportedSelection",
                  actions: ["switchSelection", "clearForm"]
                },
                {
                  target: "idle",
                  actions: "switchSelection"
                }
              ]
            }
          }
        }
      }
    }
  },
  {
    guards: {
      isFormRefreshedEventPayload: (_, event) => {
        const { result } = event;
        return isFormRefreshedEventPayload(result);
      },
      isSelectionUnsupported: (_, event) => {
        const { selection } = event;
        return !selection;
      }
    },
    actions: {
      switchSelection: assign((_, event) => {
        const { selection } = event;
        return {
          id: crypto.randomUUID(),
          currentSelection: selection
        };
      }),
      clearForm: assign((_, _event) => {
        return { form: null };
      }),
      handleSubscriptionResult: assign((_, event) => {
        const { result } = event;
        if (isFormRefreshedEventPayload(result)) {
          const { form } = result;
          return { form };
        } else if (isSubscribersUpdatedEventPayload(result)) {
          const { subscribers } = result;
          return { subscribers };
        } else if (isWidgetSubscriptionsUpdatedEventPayload(result)) {
          const { widgetSubscriptions } = result;
          return { widgetSubscriptions };
        }
        return {};
      }),
      setMessage: assign((_, event) => {
        const { message } = event;
        return { message };
      }),
      clearMessage: assign((_) => {
        return { message: null };
      })
    }
  }
);
var getFormEventSubscription = (subscriptionName, contributions) => {
  return `
  subscription ${subscriptionName}($input: PropertiesEventInput!) {
    ${subscriptionName}(input: $input) {
      __typename
      ... on SubscribersUpdatedEventPayload {
        ...subscribersUpdatedEventPayloadFragment
      }
      ... on WidgetSubscriptionsUpdatedEventPayload {
        ...widgetSubscriptionsUpdatedEventPayloadFragment
      }
      ... on FormRefreshedEventPayload {
        ...formRefreshedEventPayloadFragment
      }
    }
  }
  ${subscribersUpdatedEventPayloadFragment}
  ${widgetSubscriptionsUpdatedEventPayloadFragment}
  ${formRefreshedEventPayloadFragment(contributions)}
`;
};
var useFormBasedViewStyles = makeStyles_default((theme) => ({
  idle: {
    padding: theme.spacing(1)
  }
}));
var FormBasedView = ({
  editingContextId,
  readOnly,
  subscriptionName,
  converter: converter2,
  postProcessor
}) => {
  const classes = useFormBasedViewStyles();
  const [{ value: value22, context }, dispatch] = useMachine(formBasedViewMachine);
  const { toast, formBasedView } = value22;
  const { id, currentSelection, form, widgetSubscriptions, message } = context;
  const { selection } = useSelection();
  const currentSelectionKey = currentSelection == null ? void 0 : currentSelection.entries.map((entry) => entry.id).sort().join(":");
  const newSelectionKey = selection == null ? void 0 : selection.entries.map((entry) => entry.id).sort().join(":");
  (0, import_react2.useEffect)(() => {
    if (selection.entries.length > 0 && currentSelectionKey !== newSelectionKey) {
      const switchSelectionEvent = {
        type: "SWITCH_SELECTION",
        selection
      };
      dispatch(switchSelectionEvent);
    } else if (selection.entries.length === 0) {
      const switchSelectionEvent = {
        type: "SWITCH_SELECTION",
        selection: null
      };
      dispatch(switchSelectionEvent);
    }
  }, [currentSelectionKey, newSelectionKey, dispatch]);
  const input = {
    id,
    editingContextId,
    objectIds: currentSelection == null ? void 0 : currentSelection.entries.map((entry) => entry.id)
  };
  const variables = { input };
  const { propertySectionsRegistry: propertySectionsRegistry2 } = (0, import_react2.useContext)(PropertySectionContext);
  const formSubscription = getFormEventSubscription(
    subscriptionName,
    propertySectionsRegistry2.getWidgetContributions()
  );
  const { error } = useSubscription(
    gql(formSubscription),
    {
      variables,
      fetchPolicy: "no-cache",
      skip: formBasedView === "empty" || formBasedView === "unsupportedSelection",
      onData: ({ data }) => {
        const handleDataEvent = {
          type: "HANDLE_SUBSCRIPTION_RESULT",
          result: data.data[subscriptionName]
        };
        dispatch(handleDataEvent);
      },
      onComplete: () => {
        const completeEvent = { type: "HANDLE_COMPLETE" };
        dispatch(completeEvent);
      }
    }
  );
  (0, import_react2.useEffect)(() => {
    if (error) {
      const { message: message2 } = error;
      const showToastEvent = { type: "SHOW_TOAST", message: message2 };
      dispatch(showToastEvent);
    }
  }, [error, dispatch]);
  const formConverter = converter2 ? converter2 : { convert: (gqlForm) => gqlForm };
  let content = null;
  if (formBasedView === "empty" || formBasedView === "unsupportedSelection" || formBasedView === "complete") {
    content = (0, import_jsx_runtime2.jsx)("div", { className: classes.idle, children: (0, import_jsx_runtime2.jsx)(Typography_default, { variant: "subtitle2", children: "No object selected" }) });
  }
  if (formBasedView === "idle" && form || formBasedView === "ready") {
    if (postProcessor) {
      content = postProcessor({ editingContextId, readOnly }, formConverter.convert(form), widgetSubscriptions);
    } else {
      content = (0, import_jsx_runtime2.jsx)(
        Form,
        {
          editingContextId,
          form: formConverter.convert(form),
          widgetSubscriptions,
          readOnly
        }
      );
    }
  }
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    content,
    (0, import_jsx_runtime2.jsx)(
      Toast,
      {
        message,
        open: toast === "visible",
        onClose: () => dispatch({ type: "HIDE_TOAST" })
      }
    )
  ] });
};
var DetailsView = (props) => {
  const { converter: converter2 } = useDetailsViewConfiguration();
  return (0, import_jsx_runtime2.jsx)(FormBasedView, { ...props, subscriptionName: "propertiesEvent", converter: converter2 });
};
var useRelatedElementsViewStyles = makeStyles_default((theme) => ({
  content: {
    padding: theme.spacing(1)
  }
}));
var RelatedElementsView = (props) => {
  const classes = useRelatedElementsViewStyles();
  const extractFirstGroup = (props2, form, widgetSubscriptions) => {
    var _a;
    const group2 = (_a = form.pages[0]) == null ? void 0 : _a.groups[0];
    if (group2) {
      return (0, import_jsx_runtime2.jsx)("div", { className: classes.content, children: (0, import_jsx_runtime2.jsx)(
        Group,
        {
          editingContextId: props2.editingContextId,
          formId: form.id,
          readOnly: props2.readOnly,
          group: group2,
          widgetSubscriptions
        }
      ) });
    } else {
      return (0, import_jsx_runtime2.jsx)("div", { className: classes.content });
    }
  };
  return (0, import_jsx_runtime2.jsx)(FormBasedView, { ...props, subscriptionName: "relatedElementsEvent", postProcessor: extractFirstGroup });
};
var useRepresentationsViewStyles = makeStyles_default((theme) => ({
  content: {
    padding: theme.spacing(1)
  }
}));
var isList = (widget) => widget.__typename === "List";
var RepresentationsView = (props) => {
  const classes = useRepresentationsViewStyles();
  const extractPlainList = (props2, form, widgetSubscriptions) => {
    var _a, _b;
    const widget = (_b = (_a = form.pages[0]) == null ? void 0 : _a.groups[0]) == null ? void 0 : _b.widgets[0];
    if (isList(widget)) {
      const uniqueSubscribers = /* @__PURE__ */ new Set();
      widgetSubscriptions.forEach(
        (subscription) => subscription.subscribers.forEach((subscriber) => uniqueSubscribers.add(subscriber))
      );
      return (0, import_jsx_runtime2.jsx)("div", { className: classes.content, children: (0, import_jsx_runtime2.jsx)(
        ListPropertySection,
        {
          editingContextId: props2.editingContextId,
          formId: form.id,
          readOnly: props2.readOnly,
          widget,
          subscribers: [...uniqueSubscribers.values()]
        }
      ) });
    } else {
      return (0, import_jsx_runtime2.jsx)("div", { className: classes.content });
    }
  };
  return (0, import_jsx_runtime2.jsx)(FormBasedView, { ...props, subscriptionName: "representationsEvent", postProcessor: extractPlainList });
};

export {
  BarChart,
  PieChart,
  require_Code,
  require_FormatBold,
  require_FormatItalic,
  require_FormatListNumbered,
  require_StrikethroughS,
  require_Subject,
  require_Title,
  PropertySectionContext,
  subscribersUpdatedEventPayloadFragment,
  widgetSubscriptionsUpdatedEventPayloadFragment,
  commonFields,
  widgetFields,
  flexboxContainerFields,
  formRefreshedEventPayloadFragment,
  PropertySectionLabel,
  getTextDecorationLineValue,
  useClickHandler,
  FormRepresentation,
  DetailsViewConfiguration,
  useDetailsViewConfiguration,
  DetailsView,
  RelatedElementsView,
  RepresentationsView
};
/*! Bundled license information:

prismjs/prism.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)

@eclipse-sirius/sirius-components-forms/dist/sirius-components-forms.es.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)
*/
//# sourceMappingURL=chunk-SNRJU3PN.js.map
